<!--XSLT Processor: Saxonica SAXON HE 9.4.0.3--><!-- 
   Version with maps etc (1 Dec 2010) is draft G.
   Version with separate compilation, new XPath operators (Jan? 2011) is draft H.
   Version post-Prague-2011 is draft I
   Version post-Toronto-2011 is draft J
   New Streaming Spec is draft K
   Edits after 11 May 2012 are draft L
   Version post-July-2012 publication is draft M
--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" xmlns:t="http://www.w3.org/2008/XSL/Spec/TreeDiagram" xmlns:g="http://www.martin-loetzsch.de/DOTML" w3c-doctype="wd" status="int-review"><header><title>XSL Transformations (XSLT)</title><version>Version 3.0</version><w3c-designation>WD-****</w3c-designation><w3c-doctype>W3C Working Draft</w3c-doctype><pubdate><!-- The value from the stylesheet xslt.xsl is used in preference --><day>15</day><month>March</month><year>2012</year></pubdate><publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/yyyy/WD-xslt-30-yyyymmdd/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/yyyy/WD-xslt-30-yyyymmdd/</loc>
      </publoc><!--<altlocs>
		    <loc href="Overview-diff.html">HTML with revision markings</loc>
		    <loc href="http://www.w3.org/2007/schema-for-xslt20.xsd">Schema for XSLT 2.0 stylesheets</loc>
		</altlocs>--><latestloc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xslt-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
      </latestloc><prevlocs>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2012/WD-xslt-30-20120710/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2012/WD-xslt-30-20120710/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xslt-21-20100511/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2010/WD-xslt-21-20100511/</loc>
      </prevlocs><authlist><author><name>Michael Kay</name><affiliation>Saxonica</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.saxonica.com/</email></author></authlist><errataloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2010/qt-errata/xslt-30-errata.html" xlink:type="simple"/><translationloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30" xlink:type="simple"/><status diff="chg" at="L"><p><emph>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document. A list of current W3C publications and
               the latest revision of this technical report can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index.</loc></emph></p><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsWD" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Draft</loc> 
            as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> process document. It has
            been developed by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C XSL Working
               Group</loc>, which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML
               Activity</loc>. The Working Group expects to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p><p>This specification has been developed in conjunction with <bibref ref="xpath-30"/> and
            other documents that underpin both XSLT and XQuery. Although the development of this
            family of documents is coordinated, it has not been possible on this occasion to publish
            them simultaneously, and there may therefore be imperfect technical alignment between
            them. This will be corrected in later drafts.</p><p><emph>In particular, this document proposes changes to the XDM data model and to XPath
         language syntax to underpin the introduction of maps, which have been found necessary to
         support some XSLT streaming use cases and make many other processing tasks easier. These
         changes have not yet been accepted by other Working Groups with an interest in XPath and the
         XDM data model.</emph></p><p>There are a number open issues in this draft, flagged in the text and summarized
            at <specref ref="open-issues"/>. 
            Feedback from readers on these issues will be especially welcome.</p><p>Please report errors in this document using W3C's <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc> (instructions can
            be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>). If access to that
            system is not feasible, you may send your comments to the W3C XSLT/XPath/XQuery public
            comments mailing list, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. It will be very helpful if you include the string
            "[XSLT30]" in the subject line of your report, whether made in Bugzilla or in email.
            Please use multiple Bugzilla entries (or, if necessary, multiple email messages) if you
            have more than one comment to make. Archives of the comments and responses are available
            at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p><p> Publication as a Working Draft does not imply endorsement by the W3C Membership. This
            is a draft document and may be updated, replaced or obsoleted by other documents at any
            time. It is inappropriate to cite this document as other than work in progress. </p><p>This document was produced by a group operating under the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004 W3C
               Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any
               patent disclosures</loc> made in connection with the deliverables of the XSL Working
            Group; those pages also include instructions for disclosing a patent. An individual who
            has actual knowledge of a patent which the individual believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential
               Claim(s)</loc> must disclose the information in accordance with <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6
               of the W3C Patent Policy</loc>. </p><p>For a list of changes, see <specref ref="changes-since-2.0"/> 
            and <specref ref="changes-since-july-2012"/>.</p></status><abstract diff="chg" at="D"><p>This specification defines the syntax and semantics of XSLT <phrase diff="chg" at="A">3.0</phrase>, a language for transforming XML documents into other XML
            documents.</p><p>XSLT 3.0 is a revised version of the XSLT 2.0 Recommendation <bibref ref="xslt20"/>
            published on 23 January 2007.</p><p>The primary purpose of the changes in this version of the language is to enable
            transformations to be performed in streaming mode, where neither the source document nor
            the result document is ever held in memory in its entirety. Another important aim
            is to improve the modularity of large stylesheets, allowing stylesheets to be developed
            from independently-developed components with a high level of software engineering robustness.
         </p><p>XSLT 3.0 is designed to be used in conjunction with XPath 3.0, which is defined in
               <bibref ref="xpath-30"/>. XSLT shares the same data model as XPath 3.0, which is
            defined in <bibref ref="xpath-datamodel-30"/>, and it uses the library of functions and
            operators defined in <bibref ref="xpath-functions-30"/>. XPath 3.0 and the underlying
            function library introduce a number of enhancements, for example the availability of
            higher-order functions. Some of the functions that were previously defined in <phrase diff="chg" at="F">the XSLT 2.0</phrase> specification, such as the
               <xfunction>format-date</xfunction> and <xfunction>format-number</xfunction> functions, are now defined in
            the standard function library to make them available to other host languages.</p><p>XSLT 3.0 also includes optional facilities to serialize the results of a transformation,
            by means of an interface to the serialization component described in <bibref ref="xslt-xquery-serialization-30"/>.</p><p>
            <emph>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP30 for XPath 3.0, DM30 for
               the XDM data model version 3.0, FO30 for Functions and Operators version 3.0.</emph>
         </p></abstract><langusage><language id="EN">English</language></langusage><revisiondesc><slist><sitem>((not used)).</sitem></slist></revisiondesc></header><body><div1 id="introduction"><head>Introduction</head><div2 id="what-is-xslt"><head>What is XSLT?</head><p>This specification defines the syntax and semantics of the XSLT <phrase diff="chg" at="A">3.0</phrase> language.</p><p>
               <termdef id="dt-stylesheet" term="stylesheet">A transformation in the XSLT language
                  is expressed in the form of a <term>stylesheet</term>, whose syntax is well-formed
                  XML <bibref ref="REC-xml"/> conforming to the Namespaces in XML Recommendation
                     <bibref ref="xml-names"/>.</termdef>
            </p><p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <specref ref="xslt-namespace"/>), which is referred to in this specification as the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p><p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <bibref ref="xsl11"/>), or into another presentation-oriented format such as HTML,
               XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks, not
               exclusively for formatting and presentation applications.</p><p>A transformation expressed in XSLT describes rules for transforming zero or more
               source trees into one or more result trees. The structure of these trees is described
               in <bibref ref="xpath-datamodel-30"/>. The transformation is achieved by a set of
                  <termref def="dt-template-rule">template rules</termref>. A template rule
               associates a <termref def="dt-pattern">pattern</termref>, which matches nodes in the
               source document, with a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>. In many cases, evaluating the sequence constructor will
               cause new nodes to be constructed, which can be used to produce part of a result
               tree. The structure of the result trees can be completely different from the
               structure of the source trees. In constructing a result tree, nodes from the source
               trees can be filtered and reordered, and arbitrary structure can be added. This
               mechanism allows a <termref def="dt-stylesheet">stylesheet</termref> to be applicable
               to a wide class of documents that have similar source tree structures.</p><note diff="add" at="L"><p>The use of the term <term>tree</term> in this document
            does not imply the use of a data structure in memory that holds the entire contents
            of the document at one time. It implies rather a logical view of the XML input and output in which
            elements have a hierarchic relationship to each other. When a source document is being
            processed in a streaming manner, access to the nodes in this tree is constrained, but it
            is still viewed and described as a tree.</p></note><p diff="add" at="L">A <termref def="dt-stylesheet"/> has a modular structure. It may consist of one
            or more <termref def="dt-package">packages</termref> developed independently of each other;
            each package defines the services (functions, templates, etc) that it exposes to its clients.
            Internally, a package may consist of a number of <termref def="dt-stylesheet-module">stylesheet modules</termref>.</p><p>
               <termdef id="dt-principal-stylesheet-module" term="principal stylesheet module">For 
                  a given transformation, one <termref def="dt-stylesheet-module"/> functions as the
                     <term>principal stylesheet module</term>. The complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by finding the <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced directly or
                  indirectly from the principal stylesheet module using <elcode>xsl:include</elcode>
                  and <elcode>xsl:import</elcode> elements: see <specref ref="include"/> and
                     <specref ref="import"/>.</termdef>
            </p></div2><div2 id="whats-new-in-xslt3" diff="add" at="D"><head>What's New in XSLT 3.0?</head><p>A major focus for enhancements in XSLT 3.0 is the requirement to enable streaming
               of source documents. This is needed when source documents become too large
               to hold in main memory, and also for applications where it is important to start
               delivering results before the entire source document is available.</p><p>While implementations of XSLT that use streaming have always been theoretically possible, the
               nature of the language has made it very difficult to achieve this in practice. The
               approach adopted in this specification is twofold: it identifies a set of
               restrictions which, if followed by stylesheet authors, will enable implementations to
               adopt a streaming mode of operation without placing excessive demands on the
               optimization capabilities of the processor; and it provides new constructs to
               indicate that streaming is required, or to express transformations in a way
               that makes it easier for the processor to adopt a streaming execution plan.</p><p>Capabilities provided in this category include:</p><ulist><item><p>A new <elcode>xsl:stream</elcode> instruction, which reads and processes a
                     source document in streaming mode;</p></item><item><p>The ability to declare that a <termref def="dt-mode">mode</termref> is a
                     streaming mode, in which case all the template rules using that mode must be
                     streamable;</p></item><item><p>A new <elcode>xsl:iterate</elcode> instruction, which iterates over the items
                     in a sequence, allowing parameters for the processing of one item to be set
                     during the processing of the previous item;</p></item><item><p>A new <elcode>xsl:merge</elcode> instruction, allowing multiple input streams
                     to be merged into a single output stream;</p></item><item><p>A new <elcode>xsl:fork</elcode> instruction, allowing multiple computations to
                     be performed in parallel during a single pass through an input document.</p></item><item diff="add" at="L"><p><termref def="dt-accumulator-function">Accumulators</termref>, which allow a value to be
                  computed progressively during streamed processing of a document, and accessed as a function
                  of a node in the document, without compromise to the functional nature of the XSLT language.</p></item></ulist><p>A second focus for enhancements in XSLT 3.0 is the introduction of a new mechanism
            for stylesheet modularity, called the package. Unlike the stylesheet modules of XSLT 1.0 and
            2.0 (which remain available), a package defines an interface that regulates which functions,
            variables, templates and other components are visible outside the package, and which can
            be overridden. There are two main goals for this facility: it is designed to deliver
            software engineering benefits by improving the reusability and maintainability of code, 
            and it is intended to streamline stylesheet deployment by allowing packages to be compiled
            independently of each other, and compiled instances of packages to be shared between
            multiple applications.</p><p>Other significant features in XSLT 3.0 include:</p><ulist><item><p>An <elcode>xsl:evaluate</elcode> instruction allowing evaluation of XPath
                     expressions that are dynamically constructed as strings, or that are read from
                     a source document;</p></item><item><p>Enhancements to the syntax of <termref def="dt-pattern">patterns</termref>, in
                     particular enabling the matching of atomic values as well as nodes;</p></item><item><p>An <elcode>xsl:try</elcode> instruction to allow recovery from dynamic
                     errors;</p></item><item><p>The element <elcode>xsl:context-item</elcode>, used to declare the stylesheet's
                     expectations of the initial context item (notably, its type), given the initial
                     mode.</p></item><item diff="add" at="L"><p>A new instruction <elcode>xsl:assert</elcode> to assist developers in producing
                  correct and robust code.</p></item></ulist><p>XSLT 3.0 also delivers enhancements made to the XPath language and to the standard
               function library, including the following:</p><ulist><item><p>Variables can now be bound in XPath using the <code>let</code> expression.</p></item><item><p>Functions are now first class values, and can be passed as arguments to other
                     (higher-order) functions, making XSLT a fully-fledged functional programming
                     language.</p></item><item><p>A number of new functions are available, for example trigonometric functions,
                     and the functions <xfunction>parse-xml</xfunction> and
                        <xfunction>serialize</xfunction> to convert between lexical and tree
                     representations of XML.</p></item></ulist><p diff="add" at="L">This Working Draft includes support for maps (a data structure consisting
               of key/value pairs, sometimes referred to in other programming languages as dictionaries, hashes, or associative
               arrays). This feature extends the data model, provides
            new syntax in XPath, and adds a number of new functions and operators. The XSL Working Group intends
            that these changes should eventually become part of XPath: however, this has not yet been agreed
            with all interested parties.</p><p>The XSL Working Group is designing other new features which it hopes to include in
               the final XSLT 3.0 Recommendation, but which are not yet advanced enough to include
               in this Working Draft.</p><p diff="add" at="E">A full list of changes is at <specref ref="changes-since-2.0"/>.</p></div2></div1><div1 id="concepts"><head>Concepts</head><div2 id="terminology"><head>Terminology</head><p>For a full glossary of terms, see <specref ref="glossary"/>.</p><p>
               <termdef id="dt-processor" term="processor">The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <term>processor</term>. This is sometimes expanded to <emph>XSLT
                     processor</emph> to avoid any confusion with other processors, for example an
                  XML processor.</termdef>
            </p><p>
               <termdef id="dt-implementation" term="implementation">A specific product that
                  performs the functions of an <termref def="dt-processor">XSLT processor</termref>
                  is referred to as an <term>implementation</term>.
               </termdef></p><p>
               <termdef id="dt-result-tree" term="result tree">The term <term>result tree</term> is
                  used to refer to any tree constructed by <termref def="dt-instruction">instructions</termref> in the stylesheet. A result tree is either a <termref def="dt-final-result-tree">final result tree</termref> or a <termref def="dt-temporary-tree">temporary tree</termref>.</termdef>
            </p><p>
               <termdef id="dt-final-result-tree" term="final result tree">A <term>final result
                     tree</term> is a <termref def="dt-result-tree">result tree</termref> that forms
                  part of the final output of a transformation. Once created, the contents of a
                  final result tree are not accessible within the stylesheet itself.</termdef> The
                  <elcode>xsl:result-document</elcode> instruction always creates a final result
               tree, and a final result tree may also be created implicitly by the <termref def="dt-initial-template">initial template</termref>. The conditions under which
               this happens are described in <specref ref="executing-a-transformation"/>. A final
               result tree <rfc2119>may</rfc2119> be serialized as described in <specref ref="serialization"/>.</p><p>
               <termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> if any, documents containing nodes supplied as the values of
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
                  documents obtained from the results of functions such as
                     <function>document</function>, <xfunction>doc</xfunction>, and
                     <xfunction>collection</xfunction>, <phrase diff="add" at="C">documents read
                     using the <elcode>xsl:stream</elcode> instruction,</phrase> and documents
                  returned by extension functions or extension instructions. In the context of a
                  particular XSLT instruction, the term <term>source tree</term> means any tree
                  provided as input to that instruction; this may be a source tree of the
                  transformation as a whole, or it may be a <termref def="dt-temporary-tree">temporary tree</termref> produced during the course of the
                  transformation.</termdef>
            </p><p>
               <termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary
                     tree</term> means any tree that is neither a <termref def="dt-source-tree">source tree</termref> nor a <termref def="dt-final-result-tree">final result
                     tree</termref>.</termdef> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p><p diff="add" at="C">The use of the term "tree" in phrases such as <term>source
                  tree</term>, <term>result tree</term>, and <term>temporary tree</term> is not
               confined to documents that the processor materializes in memory in their entirety.
               The processor <rfc2119>may</rfc2119>, and in some cases <rfc2119>must</rfc2119>, use
               streaming techniques to limit the amount of memory used to hold source and result
               documents. When streaming is used, the nodes of the tree may never all be in memory
               at the same time, but at an abstract level the information is still modeled as a tree
               of nodes, and the document is therefore still described as a tree.</p><p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, 
               <phrase diff="add" at="F">when used in normative text and rendered in capitals,</phrase>
               are to be interpreted as described in <bibref ref="rfc2119"/>.</p><p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <specref ref="conformance"/>. </p><p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to a stylesheet then the processor
                  <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an
               error if the constraint is not satisfied.</p><p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, or
                  <rfc2119>recommended</rfc2119> relates to a stylesheet then a processor
                  <rfc2119>may</rfc2119> produce warning messages if the constraint is not
               satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p><p>
               <termdef id="dt-implementation-defined" term="implementation-defined">In this
                  specification, the term <term>implementation-defined</term> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <rfc2119>must</rfc2119> be described in documentation that
                  accompanies any conformance claim.</termdef>
            </p><p>
               <termdef id="dt-implementation-dependent" term="implementation-dependent">The term
                     <term>implementation-dependent</term> refers to a feature where the behavior
                     <rfc2119>may</rfc2119> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</termdef>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p><p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p><p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
               non-normative.</p><p>Many terms used in this document are defined in the XPath specification <bibref ref="xpath-30"/> or the XDM specification <bibref ref="xpath-datamodel-30"/>.
               Particular attention is drawn to the following:</p><ulist><item><p>
                     <termdef id="dt-atomization" term="atomize">The term <term>atomization</term>
                        is defined in <!--<bibref ref="xpath-30"/>--><xspecref spec="XP30" ref="id-atomization"/>. It is a process that takes as input a sequence of
                           <phrase diff="chg" at="C">items</phrase>, and returns a sequence of
                        atomic values, in which the nodes are replaced by their typed values as
                        defined in <bibref ref="xpath-datamodel-30"/>.</termdef> For some <phrase diff="chg" at="C">items</phrase> (for example, elements with element-only
                     content, <phrase diff="add" at="C">and function items</phrase>), atomization
                     generates a <termref def="dt-dynamic-error">dynamic error</termref>.</p></item><item><p>
                     <termdef id="dt-typed-value" term="typed value">The term <term>typed
                           value</term> is defined in <xspecref spec="DM30" ref="dm-typed-value"/>.
                        Every node except an element defined in the schema with element-only content
                        has a <termref def="dt-string-value">typed value</termref>. For example, the
                           <termref def="dt-typed-value">typed value</termref> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</termdef>
                  </p></item><item><p>
                     <termdef id="dt-string-value" term="string value">The term <term>string
                           value</term> is defined in
                           <!--<bibref ref="xpath-datamodel-30"/>--><xspecref spec="DM30" ref="dm-string-value"/>. Every node has a <termref def="dt-string-value">string value</termref>. For example, the <termref def="dt-string-value">string value</termref> of an element is the concatenation of the
                           <termref def="dt-string-value">string values</termref> of all its
                        descendant text nodes.</termdef>
                  </p></item><item><p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode">The term
                           <term>XPath 1.0 compatibility mode</term> is defined in <xspecref spec="XP30" ref="static_context"/>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to true, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between <phrase diff="chg" at="D">XPath
                           3.0</phrase> and XPath 1.0.</termdef>
                  </p></item></ulist><p>
               <termdef id="dt-core-function" term="core function">The term <term>core
                     function</term> means a function that is specified in <bibref ref="xpath-functions-30"/> and that is in the <termref def="dt-standard-function-namespace">standard function
                  namespace</termref>.</termdef>
            </p></div2><div2 id="notation"><head>Notation</head><p>
               <termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an
                  element in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose
                  syntax and semantics are defined in this specification.</termdef> For a
               non-normative list of XSLT elements, see <specref ref="element-syntax-summary"/>.</p><p>In this document the specification of each <termref def="dt-xslt-element">XSLT
                  element</termref> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <specref ref="element-syntax-summary"/>. The meaning of syntax summary
               notation is as follows:</p><ulist><item><p>An attribute that is <rfc2119>required</rfc2119> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p></item><item><p>An attribute that is <termref def="dt-deprecated">deprecated</termref> is shown
                     in a grayed font within square brackets.</p></item><item><p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <termref def="dt-attribute-value-template">attribute value template</termref>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p><p diff="add" at="K">The types used are as follows:</p><table diff="add" at="K" summary="Types used in element syntax summaries, and their meaning"><thead><tr><th rowspan="1" colspan="1">Type name</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">string</td><td rowspan="1" colspan="1">Any string</td></tr><tr><td rowspan="1" colspan="1">expression</td><td rowspan="1" colspan="1">An XPath <termref def="dt-expression">expression</termref></td></tr><tr><td rowspan="1" colspan="1">pattern</td><td rowspan="1" colspan="1">A <termref def="dt-pattern">pattern</termref> as described in
                           <specref ref="patterns"/>.</td></tr><tr><td rowspan="1" colspan="1">sequence-type</td><td rowspan="1" colspan="1">A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt>
                           as defined in the XPath specification</td></tr><tr><td rowspan="1" colspan="1">uri; uris</td><td rowspan="1" colspan="1">A URI, for example a namespace URI or a collation URI; a whitespace-separated
                           list of URIs</td></tr><tr><td rowspan="1" colspan="1">qname</td><td rowspan="1" colspan="1">A <termref def="dt-lexical-qname">lexical QName</termref> as defined in
                              <specref ref="qname"/></td></tr><tr><td rowspan="1" colspan="1">eqname; eqnames</td><td rowspan="1" colspan="1">An <termref def="dt-eqname">EQName</termref> as defined in
                           <specref ref="qname"/>; a whitespace-separated list of EQNames</td></tr><tr><td rowspan="1" colspan="1">token; tokens</td><td rowspan="1" colspan="1">A string containing no significant whitespace; a whitespace-separated list
                           of such strings</td></tr><tr><td rowspan="1" colspan="1">nmtoken; nmtokens</td><td rowspan="1" colspan="1">A string conforming to the XML schema rules for the type
                           <code>xs:NMTOKEN</code>; a whitespace-separated list of such
                              strings.</td></tr><tr><td rowspan="1" colspan="1">char</td><td rowspan="1" colspan="1">A string comprising a single Unicode character</td></tr><tr><td rowspan="1" colspan="1">integer</td><td rowspan="1" colspan="1">An integer, that is a string in the lexical space of 
                              the schema type <code>xs:integer</code></td></tr><tr><td rowspan="1" colspan="1">decimal</td><td rowspan="1" colspan="1">A decimal value, that is a string in the lexical space 
                              of the schema type <code>xs:decimal</code></td></tr><tr><td rowspan="1" colspan="1">ncname</td><td rowspan="1" colspan="1">An unprefixed name: a string in the value space of the schema
                           type <code>xs:NCName</code></td></tr><tr><td rowspan="1" colspan="1">prefix</td><td rowspan="1" colspan="1">An <code>xs:NCName</code> representing a namespace prefix, which
                           must be in scope for the element on which it appears</td></tr><tr><td rowspan="1" colspan="1">id</td><td rowspan="1" colspan="1">An <code>xs:NCName</code> used as a unique identifier for an
                           element in the containing XML document</td></tr></tbody></table><!--Text replaced by erratum E2 change 1"--><p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <emph>string</emph> or <emph>char</emph>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <termref def="dt-attribute-value-template">attribute value template</termref>, this
                     applies to the <termref def="dt-effective-value">effective value</termref>
                     obtained when the attribute value template is expanded.</p><!--End of text replaced by erratum E2--></item><item><p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a similar way to an element type declaration in XML;
                        <emph>sequence constructor</emph> means that any mixture of text nodes,
                        <termref def="dt-literal-result-element">literal result elements</termref>,
                        <termref def="dt-extension-instruction">extension instructions</termref>,
                     and <termref def="dt-xslt-element">XSLT elements</termref> from the <termref def="dt-instruction">instruction</termref> category is allowed;
                        <emph>other-declarations</emph> means that any mixture of XSLT elements from
                     the <termref def="dt-declaration">declaration</termref> category, other than
                        <elcode>xsl:import</elcode>, is allowed, together with <termref def="dt-data-element">user-defined data elements</termref>.</p></item><item><p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element only affects whether it is allowed in the
                     content of elements that allow a <termref def="dt-sequence-constructor">sequence constructor</termref> or <emph>other-declarations</emph>.</p></item></ulist><example><head>Syntax Notation</head><p>This example illustrates the notation used to describe <termref def="dt-xslt-element">XSLT elements</termref>.</p><e:element-syntax name="example-element"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="debug"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:sequence><e:choice repeat="zero-or-more"><e:element name="variable"/><e:element name="param"/></e:choice><e:element name="sequence"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes a mandatory
                     <code>select</code> attribute, whose value is an XPath <termref def="dt-expression">expression</termref>, and an optional <code>debug</code>
                  attribute, whose value <rfc2119>must</rfc2119> be either <code>yes</code> or
                     <code>no</code>; the curly brackets indicate that the value can be defined as
                  an <termref def="dt-attribute-value-template">attribute value template</termref>,
                  allowing a value such as <code>debug="{$debug}"</code>, where the <termref def="dt-variable">variable</termref>
                  <code>debug</code> is evaluated to yield <code>"yes"</code> or <code>"no"</code>
                  at run-time.</p><p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> elements, followed by an
                     <elcode>xsl:sequence</elcode> element.</p></example><p>
               <error spec="XT" type="static" class="SE" code="0010"><p>It is a <termref def="dt-static-error">static error</termref> if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <rfc2119>required</rfc2119> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.</p></error>
            </p><p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p><ulist><item><p>
                     <error spec="XT" type="static" class="SE" code="0020"><p>It is a <termref def="dt-static-error">static error</termref> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted) contains a value that is not
                           one of the permitted values for that attribute.</p></error>
                  </p></item><item><p>
                     <error spec="XT" type="dynamic" class="DE" code="0030"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                              error</termref> if the <termref def="dt-effective-value">effective
                              value</termref> of an attribute written using curly brackets, in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted, is a value that is not one of
                           the permitted values for that attribute. If the processor is able to
                           detect the error statically (for example, when any XPath expressions
                           within the curly brackets can be evaluated statically), then the
                           processor may optionally signal this as a static error.</p></error>
                  </p></item></ulist><p>Special rules apply if the construct appears in part of the <termref def="dt-stylesheet">stylesheet</termref> that is processed with <termref def="dt-forwards-compatible-behavior"/>: see
                  <specref ref="forwards"/>.</p><p>
               <termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
                  specification are described as being <term>deprecated</term>. The use of this term
                  implies that stylesheet authors <rfc2119>should not</rfc2119> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</termdef><phrase diff="del" at="M">All constructs that are <termref def="dt-deprecated">deprecated</termref> in this specification are also (as it happens) optional
               features that <termref def="dt-implementation">implementations</termref> are
                  <rfc2119>not required</rfc2119> to provide.</phrase></p><note><p>This working draft includes a non-normative XML Schema for XSLT <termref def="dt-stylesheet-module">stylesheet modules</termref> (see <specref ref="schema-for-xslt"/>). The syntax summaries described in this section are
                  normative.</p></note><p>XSLT defines a set of standard functions which are additional to those defined in
                  <bibref ref="xpath-functions-30"/>. <phrase diff="add" at="L">A list of these functions appears in
               <specref ref="XSLT-defined-functions"/>.</phrase> The signatures of these functions are described
               using the same notation as used in <bibref ref="xpath-functions-30"/>. The names of
               <phrase diff="add" at="L">many of</phrase>
               these functions are in the <termref def="dt-standard-function-namespace">standard
                  function namespace</termref>.</p></div2><div2 id="initiating"><head>Initiating a Transformation</head><p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <rfc2119>required</rfc2119>.</p><p diff="add" at="M">The execution of a stylesheet necessarily involves two activities:
            static analysis and dynamic evaluation. Static analysis consists of those tasks that can be
            performed by inspection of the stylesheet alone, including the evaluation of 
            <code>[xsl:]use-when</code> expressions (see <specref ref="conditional-inclusion"/>), 
               and detection of <termref def="dt-static-error">static errors</termref>. Dynamic evaluation
               consists of tasks which in general cannot be carried out until a source document is available.</p><p diff="chg" at="M">Implementations <rfc2119>may</rfc2119> allow static analysis and dynamic evaluation to
               be initiated independently, so that the cost of static analysis can be amortized over multiple
               transformations using the same stylesheet. Such a separation is not <rfc2119>required</rfc2119> by this
               specification. However, this section distinguishes information that is needed before
               static analysis can proceed from information that is not needed until dynamic evaluation
               commences.</p><p diff="chg" at="M">The following information is needed prior to static analysis:</p><ulist><item><p>The <termref def="dt-stylesheet-module">stylesheet module</termref> that is to
                     act as the <termref def="dt-principal-stylesheet-module">principal stylesheet
                        module</termref> for the transformation. The complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by recursively
                     expanding the <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode>
                     declarations in the principal stylesheet module, as described in <specref ref="include"/> and <specref ref="import"/>. </p><ednote diff="add" at="2012-07-21"><edtext>We need to say something here about packages.</edtext></ednote></item><item><p diff="add" at="M">A set (possibly empty) of values for <termref def="dt-static-parameter">static parameters</termref> (see <specref ref="global-variables"/>).
                     These values are available for use within <termref def="dt-static-expression">static expressions</termref> (notably <code>[xsl:]use-when</code> expressions)
                     as well as non-static expressions in the <termref def="dt-stylesheet">stylesheet</termref>. As a minimum, values <rfc2119>must</rfc2119>
                  be supplied for any static parameters declared with the attribute <code>required="yes"</code>.</p></item></ulist><p diff="chg" at="M">The information needed prior to dynamic evaluation depends on whether
            the stylesheet is to be invoked starting with a <termref def="dt-named-template"/> or with a
            <termref def="dt-template-rule"/>. The following information is relevant in both cases:</p><ulist><item><p>A set (possibly empty) of values for <phrase diff="add" at="M">non-static</phrase> 
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see <specref ref="global-variables"/>).
                     These values are available for use within <termref def="dt-expression">expressions</termref> in the <termref def="dt-stylesheet">stylesheet</termref>.
                     As a minimum, values <rfc2119>must</rfc2119>
                     be supplied for any parameters declared with the attribute <code>required="yes"</code>.</p></item><item><p diff="chg" at="E">
                     <termdef id="dt-initial-context-item" term="initial context item">An item that
                        acts as the <term>initial context item</term> for the transformation. This
                        item is accessible within the <termref def="dt-stylesheet">stylesheet</termref> as the initial value of the XPath <termref def="dt-expression">expressions</termref>
                        <code>.</code> (dot) and <code>self::node()</code>, as described in <specref ref="focus"/>
                     </termdef>. </p><p diff="add" at="M">The <termref def="dt-initial-context-item"/> is required if dynamic evaluation
                     is to start with a <termref def="dt-template-rule"/>, and is optional if it is to start with a
                  <termref def="dt-named-template"/>.</p><p diff="add" at="D">The value that can be supplied as the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> is constrained by
                     the <elcode>xsl:context-item</elcode> element, if defined for the chosen
                     <termref def="dt-initial-mode"/>.</p><p>If no initial context item is supplied, then the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context
                        position</termref>, and <termref def="dt-context-size">context
                           size</termref> will initially be <termref def="dt-absent">absent</termref>, and the evaluation of any
                     expression that references these values will result in a dynamic error. (Note
                     that the initial context size and context position will always be 1 (one) when
                     an <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>
                     is supplied, and will be <termref def="dt-absent">absent</termref> if no initial context item is supplied).</p></item><item><p>A base output URI. <termdef id="dt-base-output-uri" term="base output URI"> The
                     <term>base output URI</term> is a URI to be used as the base URI when
                     resolving a relative URI <phrase diff="add" at="F">reference</phrase> allocated to a <termref def="dt-final-result-tree">final result tree</termref>. If the transformation generates more than
                     one final result tree, then typically each one will be allocated a URI
                     relative to this base URI. </termdef> The way in which a base output URI is
                     established is <termref def="dt-implementation-defined">implementation-defined</termref>. </p><imp-def-feature>The way in which a <termref def="dt-base-output-uri"/> is
                     established is <termref def="dt-implementation-defined">implementation-defined</termref></imp-def-feature></item><item><p>A mechanism for obtaining a document node and a media type, given an absolute
                     URI. The total set of available documents (modeled as a mapping from URIs to
                     document nodes) forms part of the context for evaluating XPath expressions,
                     specifically the <xfunction>doc</xfunction> function. The XSLT
                     <function>document</function> function additionally requires the media type
                     of the resource representation, for use in interpreting any fragment identifier
                     present within a URI Reference.</p><note><p>The set of documents that are available to the stylesheet is <termref def="dt-implementation-dependent">implementation-dependent</termref>, as
                        is the processing that is carried out to construct a tree representing the
                        resource retrieved using a given URI. Some possible ways of constructing a
                        document (specifically, rules for constructing a document from an Infoset or
                        from a PSVI) are described in <bibref ref="xpath-datamodel-30"/>.</p></note></item></ulist><p diff="add" at="M">The following additional information is needed when 
               dynamic evaluation is to start with a <termref def="dt-template-rule"/></p><ulist><item><p>Optionally, an initial <termref def="dt-mode">mode</termref>.</p><p><termdef id="dt-initial-mode" term="initial mode">The initial mode, if
                        specified, <rfc2119>must</rfc2119> either be the default mode, or a mode
                        that is explicitly named in the <code>mode</code> attribute of an
                        <elcode>xsl:template</elcode> declaration within the stylesheet. If an
                        initial mode is supplied, then in searching for the <termref def="dt-template-rule">template rule</termref> that best matches the
                        <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, the processor considers only those rules that apply to the
                        initial mode. If no initial mode is supplied, then the mode named in the
                        <code>default-mode</code> attribute of the
                        <elcode>xsl:stylesheet</elcode> element of the <termref def="dt-principal-stylesheet-module"/> is used; or in the absence of such
                        an attribute, the <termref def="dt-unnamed-mode"/>.</termdef></p><note diff="chg" at="C"><p>If the initial mode is a <termref def="dt-streamable-mode">streamable
                           mode,</termref> then streaming will only be possible if the
                           initial context item is a node that is supplied in a form that allows such
                           processing: for example, as a reference to a stream of parsing events.</p></note><note diff="add" at="E"><p>The design of the API for invoking a transformation
                           <rfc2119>should</rfc2119> provide some means for users to designate the
                           <termref def="dt-unnamed-mode"/> as the <termref def="dt-initial-mode"/>
                           in cases where it is not the default mode.</p></note></item></ulist><p diff="add" at="M">The following additional information is needed when 
               dynamic evaluation is to start with a <termref def="dt-named-template"/></p><ulist><item><p>Optionally, the name of a <termref def="dt-named-template">named
                        template</termref> which is to be executed as the entry point to the
                     transformation. <phrase diff="add" at="M">If no template name is supplied,
                     the default template name is <code>xsl:initial-template</code>.</phrase>
                     The selected template <rfc2119>must</rfc2119> exist within the <termref def="dt-stylesheet">stylesheet</termref>. </p></item></ulist><p>
               <error spec="XT" type="dynamic" class="DE" code="0040"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies a template name that does not match the
                        <termref def="dt-expanded-qname">expanded QName</termref> of a named
                     template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0045"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies an initial <termref def="dt-mode">mode</termref> (other than the default mode) that does not match the
                        <termref def="dt-expanded-qname">expanded QName</termref> in the
                        <code>mode</code> attribute of any template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0047"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies both an initial <termref def="dt-mode">mode</termref> and an initial template.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0050"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the stylesheet that is invoked declares a visible
                        <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied
                     during the invocation of the stylesheet. A stylesheet parameter is visible if
                     it is not masked by another global variable or parameter with the same name and
                     higher <termref def="dt-import-precedence">import precedence</termref>.
                  <phrase diff="add" at="M">If the parameter is a <termref def="dt-static-parameter"/> then
                  the value <rfc2119>must</rfc2119> be supplied prior to the static analysis phase.</phrase></p></error>
            </p><p>
               <termdef id="dt-initial-template" term="initial template">The transformation is
                  performed by evaluating an <term>initial template</term>. If a <termref def="dt-named-template">named template</termref> is supplied when the
                  transformation is initiated, then this is the initial template; otherwise, the
                  initial template is the <termref def="dt-template-rule">template rule</termref>
                  selected according to the rules of the <elcode>xsl:apply-templates</elcode>
                  instruction for processing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> in the initial <termref def="dt-mode">mode</termref>.</termdef>
            </p><p>Parameters passed to the transformation by the client application are matched against
                  <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                  <specref ref="global-variables"/>), not against the <termref def="dt-template-parameter">template parameters</termref> declared within the
                  <termref def="dt-initial-template">initial template</termref>. All <termref def="dt-template-parameter">template parameters</termref> within the initial
               template to be executed will take their default values.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0060"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-initial-template">initial
                        template</termref> defines a <termref def="dt-template-parameter">template
                        parameter</termref> that specifies <code>required="yes"</code>.</p></error>
            </p><imp-def-feature>The way in which an XSLT processor is invoked, and the way in which
               values are supplied for the source document, starting node, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and <termref def="dt-base-output-uri">base output URI</termref>, are
               implementation-defined.</imp-def-feature><p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source
               documents in addition to those supplied when the transformation is invoked. These
               additional documents can be loaded using the functions <function>document</function>
               (see <specref ref="func-document"/>) or <xfunction>doc</xfunction> or
                  <xfunction>collection</xfunction> (see <bibref ref="xpath-functions-30"/>), 
               <phrase diff="add" at="F">or using the <elcode>xsl:stream</elcode> instruction</phrase>;
               alternatively, they
               can be supplied as <termref def="dt-stylesheet-parameter">stylesheet
                  parameters</termref> (see <specref ref="global-variables"/>), or returned as the result of
               an <termref def="dt-extension-function">extension function</termref> (see <specref ref="extension-functions"/>).</p></div2><div2 id="executing-a-transformation"><head>Executing a Transformation</head><p>
               <termdef id="dt-template-rule" term="template rule">A stylesheet contains a set of
                     <term>template rules</term> (see <specref ref="rules"/>). A template rule has
                  three parts: a <termref def="dt-pattern">pattern</termref> that is matched against
                  nodes, a (possibly empty) set of <termref def="dt-template-parameter">template
                     parameters</termref>, and a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that is evaluated to produce a sequence of
                  items.</termdef> In many cases these items are newly constructed nodes, which are
               then written to a <termref def="dt-result-tree">result tree</termref>.</p><p>A transformation as a whole is executed by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> of the <termref def="dt-initial-template">initial template</termref> as described in <specref ref="sequence-constructors"/>. </p><!--Text replaced by erratum E11 change 1"--><p>The result sequence produced by evaluating the initial template is handled as
               follows:</p><olist><item><p>If the initial template has an <code>as</code> attribute, then the result
                     sequence of the initial template is checked against the required type in the
                     same way as for any other template.</p></item><item><p>If the result sequence is non-empty, then it is used to construct an implicit
                        <termref def="dt-final-result-tree">final result tree</termref>, following
                     the rules described in <specref ref="constructing-complex-content"/>: the
                     effect is as if the initial template <var>T</var> were called by an implicit
                     template of the form:</p><eg xml:space="preserve">
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;</eg></item></olist><!--End of text replaced by erratum E11--><p>An implicit result tree is also created when the result sequence is empty, provided
               that no <elcode>xsl:result-document</elcode> instruction has been evaluated during
               the course of the transformation. In this situation the implicit result tree will
               consist of a document node with no children.</p><note><p>This means that there is always at least one result tree. It also means that if
                  the content of the initial template is a single
                     <elcode>xsl:result-document</elcode> instruction, as in the example above, then
                  only one result tree is produced, not two. It is useful to make the result
                  document explicit as this is the only way of invoking document-level
                  validation.</p><p>If the result of the initial template is non-empty, and an explicit
                     <elcode>xsl:result-document</elcode> instruction has been evaluated with the
                  empty attribute <code>href=""</code>, then an error will occur <errorref spec="XT" class="DE" code="1490"/>, since it is not possible to create two final result
                  trees with the same URI.</p></note><p>A <termref def="dt-sequence-constructor"/> is a sequence
               of sibling nodes in the stylesheet, each of which is either an <termref def="dt-xslt-instruction">XSLT instruction</termref>, a <termref def="dt-literal-result-element">literal result element</termref>, a text node, or
               an <termref def="dt-extension-instruction">extension instruction</termref>.</p><p>
               <termdef id="dt-instruction" term="instruction">An <term>instruction</term> is either
                  an <termref def="dt-xslt-instruction">XSLT instruction</termref> or an <termref def="dt-extension-instruction">extension instruction</termref>.</termdef>
            </p><p>
               <termdef id="dt-xslt-instruction" term="XSLT instruction">An <term>XSLT
                     instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</termdef>
            </p><p>
               <termref def="dt-extension-instruction">Extension instructions</termref> are
               described in <specref ref="extension-instruction"/>.</p><p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref>
               are as follows:</p><ulist><item><p>instructions that create new nodes: <elcode>xsl:document</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:comment</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>,
                        <elcode>xsl:namespace</elcode>;</p></item><item><p>an instruction that returns an arbitrary sequence by evaluating an XPath
                     expression: <elcode>xsl:sequence</elcode>;</p></item><item><p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode>,
                        <phrase diff="add" at="F"><elcode>xsl:try</elcode>,</phrase>
                        <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
                     <phrase diff="add" at="F"><elcode>xsl:fork</elcode>,
                        <elcode>xsl:iterate</elcode> and its subordinate instructions
                     <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode></phrase>;</p></item><item><p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
                        <elcode>xsl:next-match</elcode>;</p></item><item><p>Instructions that declare variables: <elcode>xsl:variable</elcode>,
                        <elcode>xsl:param</elcode>;</p></item><item><p>other specialized instructions: <elcode>xsl:number</elcode>,
                     <elcode>xsl:analyze-string</elcode>, <phrase diff="add" at="L"><elcode>xsl:assert</elcode>,</phrase>
                     <elcode>xsl:message</elcode>,
                        <elcode>xsl:result-document</elcode>, 
                     <phrase diff="add" at="F"><elcode>xsl:stream</elcode>, <elcode>xsl:perform-sort</elcode>, <elcode>xsl:merge</elcode></phrase>.</p></item></ulist><p>Often, a <termref def="dt-sequence-constructor"/> will
               include an <elcode>xsl:apply-templates</elcode> instruction, which selects a sequence
               of nodes to be processed. Each of the selected nodes is processed by searching the
               stylesheet for a matching <termref def="dt-template-rule">template rule</termref> and
               evaluating the <termref def="dt-sequence-constructor"/>
               of that template rule. The resulting sequences of items are concatenated, in order,
               to give the result of the <elcode>xsl:apply-templates</elcode> instruction, as
               described in <specref ref="applying-templates"/>; this sequence is often added to a
                  <termref def="dt-result-tree">result tree</termref>. Since the <termref def="dt-sequence-constructor">sequence constructors</termref> of the selected
                  <termref def="dt-template-rule">template rules</termref> may themselves contain
                  <elcode>xsl:apply-templates</elcode> instructions, this results in a cycle of
               selecting nodes, identifying <termref def="dt-template-rule">template
               rules</termref>, constructing sequences, and constructing <termref def="dt-result-tree">result trees</termref>, that recurses through a <termref def="dt-source-tree">source tree</termref>. </p></div2><div2 id="context"><head>The Evaluation Context</head><p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p><p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p><p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. The <phrase diff="chg" at="D">XPath 3.0</phrase> specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <elcode>xsl:sort</elcode>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <function>key</function> and <function>current-group</function>) that are
               available for use in XPath expressions appearing within a stylesheet.</p><p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p><p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p><p>The most commonly used component of the dynamic context is the <termref def="dt-context-item">context item</termref>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic value,
                  <phrase diff="add" at="C">or a function item</phrase>). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p><p>Full details of the static and dynamic context are provided in <specref ref="static-and-dynamic-context"/>.</p></div2><div2 id="parsing-and-serialization"><head>Parsing and Serialization</head><p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> describes a process that
               constructs a set of <termref def="dt-final-result-tree">final result trees</termref>
               from a set of <termref def="dt-source-tree">source trees</termref>.</p><p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
                  <termref def="dt-source-tree">source tree</termref> is constructed. Some possible
               ways of constructing source trees are described in <bibref ref="xpath-datamodel-30"/>.
               Frequently an <termref def="dt-implementation">implementation</termref> will operate
               in conjunction with an XML parser (or more strictly, in the terminology of <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source tree from an
               input XML document. An implementation <rfc2119>may</rfc2119> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <bibref ref="DOM-Level-2-Core"/>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <bibref ref="xpath-datamodel-30"/>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <termref def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p><p>
               <termdef id="dt-serialization" term="serialization">A frequent requirement is to
                  output a <termref def="dt-final-result-tree">final result tree</termref> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <term>serialization</term>.</termdef>
            </p><p>Like parsing, serialization is not part of the transformation process, and it is not
                  <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <elcode>xsl:output</elcode> element and the
                  <elcode>xsl:character-map</elcode> declarations, see <specref ref="serialization"/>), and attributes on the <elcode>xsl:result-document</elcode> instruction, that
               allow a <termref def="dt-stylesheet">stylesheet</termref> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <elcode>xsl:output</elcode> and
                  <elcode>xsl:character-map</elcode> declarations has no effect. Under these
               circumstances the processor <rfc2119>may</rfc2119> report any errors in an
                  <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode> declaration, or
               in the serialization attributes of <elcode>xsl:result-document</elcode>, but is not
                  <rfc2119>required</rfc2119> to do so.</p></div2><div2 id="packages-and-modules" diff="add" at="I"><head>Packages and Modules</head><p>In previous versions of the XSLT language, it has been possible to structure a stylesheet
            as a collection of modules, using the <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
            declarations to express the dependency of on module on others.</p><p>In XSLT 3.0 an additional layer of modularization of stylesheet code is enabled through the
            introduction of <termref def="dt-package">packages</termref>. A package is a collection of
            stylesheet modules with a controlled interface to the packages that use it: for example, it
            defines which functions and templates defined in the package are visible to callers, which are
            purely internal, and which are not only public but capable of being overridden by other functions
            and templates supplied by the using package.</p><p>Packages are introduced with several motivations, which broadly divide into two categories:</p><olist><item><p>Software engineering benefits: greater re-use of code, greater robustness
            through ease of testing, controlled evolution of code in response to new requirements,
            ability to deliver code that users cannot see or modify.</p></item><item><p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when
            they are used in multiple stylesheets, and to avoid holding multiple copies of the same
            library in memory simultaneously.</p></item></olist><p>Packages are designed to allow separate compilation: that is, a package can be compiled independently
               of the packages that use it. This specification does not define a process model for
               compilation, or expand on what it means to compile different packages independently. Nor does it
               mandate that implementations offer any feature along these lines. It merely defines language
               features that are designed to make separate compilation of packages possible.</p><p>To achieve this, packages (unlike modules):</p><ulist><item><p>Must not contain unresolved references to functions, templates, or variables declared
               in other packages;</p></item><item><p>Have strict rules governing the ability to override declarations in a library package
               with declarations in a package that uses the library;</p></item><item><p>Constrain the visibility of component names and of context declarations such as the
               declarations of keys and decimal formats;</p></item><item><p>Can declare a mode (a collection of template rules) as final, which disallows the
               addition of new overriding template rules in a using package;</p></item><item><p>Require explicit disambiguation where naming conflicts arise, for example when
               a package uses two other packages that both export like-named components;</p></item><item><p>Allow multiple specializations of library components to coexist in the same application.</p></item></ulist><p>A package is defined by means of an XML document whose outermost element is an <elcode>xsl:package</elcode>
               element. This is referred to as the <term>package manifest</term>. The <elcode>xsl:package</elcode> element has child
               elements describing properties of the package, as well as an <elcode>xsl:stylesheet</elcode> or
               <elcode>xsl:transform</elcode> child element that defines the content of the package, either directly
               or by reference through one or more <elcode>xsl:import</elcode> or <elcode>xsl:include</elcode>
               declarations.</p><p>When no packages are explicitly defined, the entire stylesheet is treated as a single package;
            the effect is as if the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>
            were wrapped in an <elcode>xsl:package</elcode> element with no other information in the package
            manifest.</p></div2><div2 id="extensibility"><head>Extensibility</head><p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p><p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p><p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as <termref def="dt-extension-function">extension functions</termref>, and are described in
                  <specref ref="extension-functions"/>.</p><p>It is also permissible to extend the language by providing new <termref def="dt-instruction">instructions</termref>. These are referred to as <termref def="dt-extension-instruction">extension instructions</termref>, and are described
               in <specref ref="extension-instruction"/>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p><p>Extension instructions and extension functions defined according to these rules
                  <rfc2119>may</rfc2119> be provided by the implementer of the XSLT processor, and
               the implementer <rfc2119>may</rfc2119> also provide facilities to allow users to
               create further extension instructions and extension functions.</p><p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <termref def="dt-implementation-defined">implementation-defined</termref>. For further details, see <specref ref="extension"/>.</p><imp-def-feature>The mechanisms for creating new <termref def="dt-extension-instruction">extension instructions</termref> and <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-implementation-defined"/>.</imp-def-feature><p>The XSLT language can also be extended by the use of <termref def="dt-extension-attribute">extension attributes</termref> (see <specref ref="extension-attributes"/>), and by means of <termref def="dt-data-element">user-defined data elements</termref> (see <specref ref="user-defined-top-level"/>).</p></div2><div2 id="stylesheets-and-schemas"><head>Stylesheets and XML Schemas</head><p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p><p>Information from a schema can be used both statically (when the <termref def="dt-stylesheet">stylesheet</termref> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p><p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, and
               within XPath <termref def="dt-expression">expressions</termref> and <termref def="dt-pattern">patterns</termref> in a <termref def="dt-stylesheet">stylesheet</termref>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using the
                  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt> syntax defined
               in <bibref ref="xpath-30"/>.</p><p>
               <termdef id="dt-schema-component" term="schema component">Type definitions and
                  element and attribute declarations are referred to collectively as <term>schema
                     components</term>.</termdef>
            </p><p>
               <termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
                     <termref def="dt-schema-component">schema components</termref> that may be
                  referenced by name in a <termref def="dt-stylesheet">stylesheet</termref> are
                  referred to as the <term>in-scope schema components</term>. This set is the same
                  throughout all the modules of a stylesheet.</termdef>
            </p><p>The conformance rules for XSLT <phrase diff="chg" at="A">3.0</phrase>, defined in
                  <specref ref="conformance"/>, distinguish between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <termref def="dt-stylesheet">stylesheet</termref> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <xfunction>substring</xfunction> function) and other constructs may produce
               different results depending on the datatype (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return true if the attributes have type
                  <code>xs:decimal</code>, but will return false if they are untyped).</p><p>There is a standard set of type definitions that are always available as <termref def="dt-in-scope-schema-component">in-scope schema components</termref> in every
               stylesheet. These are defined in <specref ref="built-in-types"/>. <phrase diff="del" at="E">The set of built-in types varies between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</phrase></p><p>The remainder of this section describes facilities that are available only with a
                  <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</p><p>Additional <termref def="dt-schema-component">schema components</termref> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
               by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p><p>The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p><p>It is only necessary to import a schema explicitly if one or more of its <termref def="dt-schema-component">schema components</termref> are referenced explicitly by
               name in the <termref def="dt-stylesheet">stylesheet</termref>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p><p>Importing a schema does not of itself say anything about the type of the source
               document that the <termref def="dt-stylesheet">stylesheet</termref> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <termref def="dt-stylesheet">stylesheet</termref>. For example:</p><example diff="chg" at="C"><head>Asserting the Required Type of the Source Document</head><eg xml:space="preserve">&lt;xsl:mode initial="yes" typed="lax"&gt;
  &lt;xsl:context-item use="required"
                    as="document-node(schema-element(my:invoice))"/&gt;
&lt;/xsl:mode&gt;
</eg><p>This example will cause the transformation to fail with an error message when the
                     <termref def="dt-initial-mode"/> is the unnamed mode, unless the document
                  element of the source document is valid against the top-level element declaration
                     <code>my:invoice</code>, and has been annotated as such.</p><p diff="chg" at="I">The setting <code>typed="lax"</code> further ensures that 
               in any match pattern for a template rule in this mode, an element name that corresponds
               to the name of an element declaration in the schema is taken as referring to elements
               validated against that declaration: for example, <code>match="employee"</code> will
               only match a validated <code>employee</code> element. Selecting this option enables
               the XSLT processor to do more compile-time type-checking against the schema, for
               example it allows the processor to produce warning or error messages when path expressions
               contain misspelt element names, or confuse an element with an attribute.</p></example><p diff="add" at="D">It is also true that importing a schema does not of itself say anything about
               the structure of the result tree. It is possible to request validation of a result
               tree against the schema by using the <elcode>xsl:result-document</elcode>
               instruction, for example:</p><example diff="add" at="D"><head>Requesting Validation of the Result Document</head><eg xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               </eg><p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p></example><p>It is possible that a source document may contain nodes whose <termref def="dt-annotation">type annotation</termref> is not one of the types imported by
               the stylesheet. This creates a potential problem because in the case of an expression
               such as <code>data(.) instance of xs:integer</code> the system needs to know whether
               the type named in the type annotation of the context node is derived by restriction
               from the type <code>xs:integer</code>. This information is not explicitly available
               in an XDM tree, as defined in <bibref ref="xpath-datamodel-30"/>. The implementation may
               choose one of several strategies for dealing with this situation:</p><olist><item><p>The processor may signal a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if a source document is found to
                     contain a <termref def="dt-annotation">type annotation</termref> that is not
                     known to the processor.</p></item><item><p>The processor may maintain additional metadata, beyond that described in
                        <bibref ref="xpath-datamodel-30"/>, that allows the source document to be
                     processed as if all the necessary schema information had been imported using
                        <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data
                     structure representing the source document itself, or it might be held in a
                     system catalog or repository.</p></item><item><p>The processor may be configured to use a fixed set of schemas, which are
                     automatically used to validate all source documents before they can be supplied
                     as input to a transformation. In this case it is impossible for a source
                     document to have a <termref def="dt-annotation">type annotation</termref> that
                     the processor is not aware of.</p></item><item><p>The processor may be configured to treat the source document as if no schema
                     processing had been performed, that is, effectively to strip all type
                     annotations from elements and attributes on input, marking them instead as
                     having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.</p></item></olist><p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <termref def="dt-variable">variables</termref> and <termref def="dt-parameter">parameters</termref>, it is possible for an XSLT processor to perform static
               analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis
               in the absence of any source document). Such analysis <rfc2119>may</rfc2119> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static
               type-checking. Under some circumstances (see <specref ref="errors"/>) type errors
               that are detected early <rfc2119>may</rfc2119> be reported as static errors. In
               addition an implementation <rfc2119>may</rfc2119> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p><p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref def="dt-annotation">type annotations</termref> of nodes that it constructs in a
                  <termref def="dt-final-result-tree">final result tree</termref>, or in <termref def="dt-temporary-tree">temporary trees</termref>. This can be done in a number of
               ways.</p><ulist><item><p>It is possible to request explicit validation of a complete document, that is,
                     a tree rooted at a document node. This applies both to temporary trees
                     constructed using the <elcode>xsl:document</elcode> (or
                        <elcode>xsl:copy</elcode>) instruction and also to <termref def="dt-final-result-tree">final result trees</termref> constructed using
                        <elcode>xsl:result-document</elcode>. Validation is either strict or lax, as
                     described in <bibref ref="xmlschema-1"/>. If validation of a <termref def="dt-result-tree">result tree</termref> fails (strictly speaking, if the
                     outcome of the validity assessment is <code>invalid</code>), then the
                     transformation fails, but in all other cases, the element and attribute nodes
                     of the tree will be annotated with the names of the types to which these nodes
                     conform. These <termref def="dt-annotation">type annotations</termref> will be
                     discarded if the result tree is serialized as an XML document, but they remain
                     available when the result tree is passed to an application (perhaps another
                        <termref def="dt-stylesheet">stylesheet</termref>) for further
                     processing.</p></item><item><p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <elcode>xsl:element</elcode>,
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p></item><item><p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <termref def="dt-annotation">type annotations</termref> are to be
                     retained or not.</p></item></ulist><p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p><p>For details of how validation of element and attribute nodes works, see <specref ref="validation"/>.</p></div2><div2 id="streaming-concepts" diff="add" at="A"><head>Streaming</head><p><termdef id="dt-streaming" term="streaming">The term <term>streaming</term> refers to
                  a manner of processing in which documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed "on the fly" as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.</termdef></p><p><termdef id="dt-streamed-document" term="streamed document">A <term>streamed
                     document</term> is a <termref def="dt-source-tree">source tree</termref> that
                  is processed using streaming, that is, without constructing a complete tree
                  of nodes in memory.</termdef></p><p><termdef id="dt-streamed-document-node" term="streamed node">A <term>streamed
                     node</term> is a node in a <termref def="dt-streamed-document">streamed
                     document</termref>.</termdef></p><p>Many processors implementing earlier versions of this specification have adopted an
               architecture that allows streaming of the <termref def="dt-result-tree">result
                  tree</termref> directly to a serializer, without first materializing the complete
               result tree in memory. Streaming of the <termref def="dt-source-tree">source
                  tree</termref>, however, has proved to be more difficult without subsetting the
               language. This has created a situation where documents exceeding the capacity of
               virtual memory could not be transformed. XSLT 3.0 therefore introduces facilities
               allowing stylesheets to be written in a way that makes streaming of source documents
               possible, without excessive reliance on processor-specific optimization
               techniques.</p><p>Streaming achieves two important objectives: it allows large documents to be
               transformed without requiring correspondingly large amounts of memory; and it allows
               the processor to start producing output before it has finished receiving its input,
               thus reducing latency.</p><p>This specification does not attempt to legislate precisely which implementation
               techniques fall under the definition of streaming, and which do not. A number of
               techniques are available that reduce memory requirements, while still requiring a
               degree of buffering, or allocation of memory to partial results. A stylesheet that
               requests streaming of a source document is indicating that the processor should avoid
               assuming that the entire source document will fit in memory; in return, the
               stylesheet must be written in a way that makes streaming possible. This
               specification does not attempt to describe the algorithms that the processor should
               actually use, or to impose quantitative constraints on the resources that these
               algorithms should consume.</p><p>Nothing in this specification, nor in its predecessors <bibref ref="xslt"/> and <bibref ref="xslt20"/>,
               prevents a processor using streaming whenever it sees an opportunity to do
               so. However, experience has shown that in order to achieve streaming, it is often
               necessary to write stylesheet code in such a way as to make this possible. Therefore,
               XSLT 3.0 provides explicit constructs allowing the stylesheet author to request
               streaming, and defines explicit static constraints on the structure of the
               code which are designed to make streaming possible.</p><p>A processor that claims conformance with the streaming option offers a guarantee that
               when streaming is requested for a source document, and when the stylesheet conforms
               to the rules that make the processing <termref def="dt-guaranteed-streamable"/>, 
               then an algorithm will be adopted in which
               memory consumption is either completely independent of document size, or increases
               only very slowly as document size increases, allowing documents to be processed that
               are orders-of-magnitude larger than the physical memory available. A processor that
               does not claim conformance with the streaming option must still process a stylesheet
               and deliver the correct results, but is not required to use streaming algorithms, and
               may therefore fail with out-of-memory errors when presented with large source
               documents.</p><p>Apart from the fact that there are constructs to request streaming, and rules that
               must be followed to guarantee that streaming is possible, the language has been designed
               so there are as few differences as possible between streaming and non-streaming
               evaluation. The semantics of the language continue to be expressed in terms of the
               XDM data model, which is substantively unchanged; but readers must take care to
               observe that when terms like "node" and "axis" are used, the concepts are completely
               abstract and may have no direct representation in the run-time execution
               environment.</p><p>Streamed processing of a document can be initiated in one of two ways:</p><ulist><item><p>The <termref def="dt-initial-mode">initial mode</termref> can be declared as a
                        <termref def="dt-streamable-mode">streamable mode</termref>. In this case
                     the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>
                     will generally be a document node, and it will be supplied by the calling
                     application in a form that allows streaming (that is, in some form
                     other than a tree in memory; for example, as a reference to a push or pull XML
                     parser primed to deliver a stream of events). <phrase diff="chg" at="E">The
                        type of the <termref def="dt-initial-context-item"/> can be constrained
                        using the <elcode>xsl:context-item</elcode> element.</phrase> In this case
                     the <termref def="dt-template-rule">template rule</termref> that matches the
                     document node (in this mode) must be a <termref def="dt-guaranteed-streamable-template">guaranteed-streamable template</termref>, which means that it (as well as all other
                     template rules using this <termref def="dt-mode">mode</termref>) must satisfy
                     certain statically checkable constraints to ensure that streaming is
                     possible.</p></item><item><p>Streamed processing of any document can be initiated using the
                        <elcode>xsl:stream</elcode> instruction. This has an attribute
                        <code>href</code> whose value is the URI of a document to be processed using
                     streaming, and the actual processing to be applied is defined by the
                     instructions written as children of the <elcode>xsl:stream</elcode>
                     instruction. These instructions must satisfy the same rules as for a <termref def="dt-guaranteed-streamable-template">guaranteed-streamable template</termref>.</p></item></ulist><p>The rules for streamability, which are defined in detail in <specref ref="streamability"/>, impose two main constraints:</p><ulist><item><p>The only nodes reachable from the node that is currently being processed are
                     its attributes and namespaces, its ancestors and their attributes and
                     namespaces, and its descendants and their attributes and namespaces. The
                     siblings of the node, and the siblings of its ancestors, are not reachable in
                     the tree, and any attempt to use their values is a <termref def="dt-static-error">static error</termref>. However, constructs (for
                     example, simple forms of <elcode>xsl:number</elcode>, and simple positional
                        <termref def="dt-pattern">patterns</termref>) that require knowledge of the
                     number of preceding elements by name are permitted.</p></item><item><p>When processing a given node in the tree, each descendant node can only be
                     visited once. Essentially this allows two styles of processing: either visit
                     each of the children once, and then process that child with the same
                     restrictions applied; or process all the descendants in a single pass, in which
                     case it is not possible while processing a descendant to make any further
                     downward selection.</p></item></ulist><p diff="chg" at="F">The second restriction, that only one visit to the children is allowed, means that
               XSLT code that was not designed with streaming in mind will often need to be
               rewritten to make it streamable. In many cases it is possible to do this using a
               technique sometimes called <emph>windowing</emph> or <emph>burst-mode
                  streaming</emph> (note this is not
               quite the same meaning as <emph>windowing</emph> in XQuery 3.0). 
               Many XML documents consist of a large number of
               elements, each of manageable size, representing transactions or business objects
               where each such element can be processed independently: in such cases, an effective
               design pattern is to write a streaming transformation that takes a snapshot of each
               element in turn, processing the snapshot using the full power of the XSLT language.
               Each snapshot is a tree built in memory and is therefore fully navigable.  For details
               see the <function>snapshot</function> and <function>copy-of</function> functions.</p><p diff="add" at="K">The new facility of <emph>accumulators</emph> allows applications
            complete control over how much information is retained (and by implication, how much memory
            is required) in the course of a pass over a streamed document. An accumulator computes
            a value for every node in a streamed document: or more accurately, two values, one for the
            first visit to a node (before visiting its descendants), and a second value for the second
            visit to the node (after visiting the descendants). The computation is structured in such
            a way that the value for a given node can depend only on the value for the previous node
            in document order together with the data available when positioned at the current node
            (for example, the attribute values). Based on the well-established fold operation
            of functional programming languages, accumulators provide the convenience and economy
            of mutable variables while remaining within the constraints of a purely declarative 
            processing model.</p><p>Streaming applications often fall into one of the following categories:</p><ulist><item><p>Aggregation applications, where a single aggregation operation (perhaps
                        <xfunction>count</xfunction>, <xfunction>sum</xfunction>,
                        <xfunction>exists</xfunction>, or <xfunction>distinct-values</xfunction>) is
                     applied to a set of elements selected from the streamed source document by
                     means of a path expression.</p></item><item><p>Record-at-a-time applications, where the source document consists of a long
                     sequence of elements with similar structure ("records"), and each "record" is
                     processed using the same logic, independently of any other "records". This kind
                     of processing is facilitated using the <function>snapshot</function> and
                        <function>copy-of</function> function mentioned earlier.</p></item><item><p>Grouping applications, where the output follows the structure of the input,
                     except that an extra layer of hierarchy is added. For example, the input might
                     be a flat series of banking transactions in date/time order, and the output
                     might contain the same transactions grouped by date.</p></item><item><p>Accumulator applications, which are the same as record-at-a-time applications,
                     except that the processing of one "record" might depend on data encountered
                     earlier in the document. A classical example is processing a sequence of
                     banking transactions in which the input transaction contains a debit or credit
                     amount, and the output adds a running total (the account balance). The
                        <elcode>xsl:iterate</elcode> instruction has been introduced to facilitate
                     this style of processing.</p></item><item><p>Isomorphic transformations, in which there is an ordered (often largely
                     one-to-one) relationship between the nodes of the source tree and the nodes of
                     the result tree: for example, transformations that involve only the renaming or
                     selective deletion of nodes, or scalar manipulations of the values held in the
                     leaf nodes. Such transformations are most conveniently expressed using
                     recursive application of template rules. This is possible with a streamed input
                     document only if all the template rules adhere to the constraints required for
                     streamability. To enforce these rules, while still allowing unrestricted
                     processing of other documents within the same transformation, all streaming
                     evaluation must be carried out using a specific <termref def="dt-mode">mode</termref>, which is declared to be a streaming mode by means of an
                        <elcode>xsl:mode</elcode> declaration in the stylesheet.</p></item></ulist><p>There are important classes of application in which streaming is possible only if
               multiple streams can be processed in parallel. This specification therefore provides
               facilities:</p><olist><item><p>allowing multiple sorted input sequences to be merged into one sorted output
                     sequence (the <elcode>xsl:merge</elcode> instruction)</p></item><item><p>allowing multiple output sequences to be generated during a single pass of an
                     input sequence (the <elcode>xsl:fork</elcode> instruction).</p></item></olist><p>These facilities have been designed in such a way that they can readily be
               implemented using streaming, that is, without materializing the input or output
               sequences in memory.</p><!--<issue id="issue-streaming-pessimism">
               <p>The design adopted in this specification works on the basis that decisions about
                  streamability should be made statically (at compile time). Sometimes this means
                  taking a pessimistic approach, that is, rejecting a construct as non-streamable
                  based on worst-case assumptions. Two examples of this are (a) disallowing
                     <code>&lt;xsl:with-param name="p" select="@code"/></code> when calling a
                  streamable template, on the grounds that the called template might perform
                  disallowed navigation from the attribute node; (b) disallowing use of the
                  descendant axis in cases where it might select two elements, one of which is an
                  ancestor of the other. An alternative design approach would allow optimistic
                  assumptions to be made in such cases, creating the risk of dynamic errors: for
                  example it might be a dynamic error in the first case if the called template
                  performs disallowed navigation from the attribute node, and in the second case if
                  the descendant axis actually selects a node that is a descendant of another
                  selected node. The decision to make the analysis pessimistic interacts with the
                  strategy for fallback if streaming is not possible; a non-streaming fallback is
                  feasible if decisions are made statically, but is not realistically possible if
                  the problems are only detected at execution time. The Working Group welcomes
                  discussion of this decision.</p>
            </issue>--></div2><div2 id="errors"><head>Error Handling</head><!--Text replaced by erratum E5 change 1"--><p>
               <termdef id="dt-static-error" term="static error">An error that can be detected by
                  examining a <termref def="dt-stylesheet">stylesheet</termref> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <term>static error</term>.</termdef>
            </p><p>Errors classified in this specification as static errors <rfc2119>must</rfc2119> be
               signaled by all implementations: that is, the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> indicate that the error is present. A static error
                  <rfc2119>must</rfc2119> be signaled even if it occurs in a part of the <termref def="dt-stylesheet">stylesheet</termref> that is never evaluated. Static errors
               are never recoverable. After signaling a static error, a processor
                  <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors,
               but it <rfc2119>must</rfc2119> eventually terminate abnormally without producing any
                  <termref def="dt-final-result-tree">final result tree</termref>.</p><p>There is an exception to this rule when the stylesheet specifies <termref def="dt-forwards-compatible-behavior"/> (see
                  <specref ref="forwards"/>).</p><p>Generally, errors in the structure of the <termref def="dt-stylesheet">stylesheet</termref>, or in the syntax of XPath <termref def="dt-expression">expressions</termref> contained in the stylesheet, are classified as <termref def="dt-static-error">static errors</termref>. Where this specification states
               that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must
                  not</rfc2119> appear in a certain position, or that it <rfc2119>must</rfc2119> or
                  <rfc2119>must not</rfc2119> have a particular attribute, or that an attribute
                  <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p><p>
               <termdef id="dt-dynamic-error" term="dynamic error">An error that is not detected
                  until a source document is being transformed is referred to as a <term>dynamic
                     error</term>.</termdef>
            </p><p>
               <termdef id="dt-recoverable-error" term="recoverable error">Some dynamic errors are
                  classed as <term>recoverable errors</term>. When a recoverable error occurs, this
                  specification allows the processor either to signal the error (by reporting the
                  error condition and terminating execution) or to take a defined recovery action
                  and continue processing.</termdef> It is <termref def="dt-implementation-defined">implementation-defined</termref> whether the error is signaled or the recovery
               action is taken. If the processor chooses to signal the error rather than taking the
               recovery action, the error is then treated in the same way as a <termref def="dt-nonrec-dynamic-error"/> and is therefore eligible to be caught using
                  <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode>.</p><p>
               <termdef id="dt-optional-recovery-action" term="optional recovery action">If an
                  implementation chooses to recover from a <termref def="dt-recoverable-error">recoverable dynamic error</termref>, it <rfc2119>must</rfc2119> take the
                     <term>optional recovery action</term> defined for that error condition in this
                  specification.</termdef>
            </p><imp-def-feature>Where the specification provides a choice between signaling a dynamic
               error or recovering, the decision that is made (but not the recovery action itself)
               is <termref def="dt-implementation-defined"/>.</imp-def-feature><p>When the implementation makes the choice between signaling a dynamic error or
               recovering, it is not restricted in how it makes the choice; for example, it
                  <rfc2119>may</rfc2119> provide options that can be set by the user. When an
               implementation chooses to recover from a dynamic error, it <rfc2119>may</rfc2119>
               also take other action, such as logging a warning message.</p><p>
               <termdef id="dt-nonrec-dynamic-error" term="non-recoverable dynamic error">A <termref def="dt-dynamic-error">dynamic error</termref> that is not recoverable is
                  referred to as a <term>non-recoverable dynamic error</term>. When a
                  non-recoverable dynamic error occurs, the <termref def="dt-processor">processor</termref>
                  <rfc2119>must</rfc2119> signal the error, and <phrase diff="add" at="B">(unless
                     the error is caught using <elcode>xsl:catch</elcode>)</phrase> the
                  transformation fails.</termdef>
            </p><note diff="add" at="B"><p>The term <term>non-recoverable</term> is retained from earlier XSLT versions, and
                  implies that the processor will not recover from the error on its own initiative.
                  However, the introduction of <elcode>xsl:try</elcode> and
                     <elcode>xsl:catch</elcode> in XSLT 3.0 means that such errors can now be
                  recovered by means of application logic.</p></note><p>Because different implementations may optimize execution of the <termref def="dt-stylesheet">stylesheet</termref> in different ways, the detection of
               dynamic errors is to some degree <termref def="dt-implementation-dependent">implementation-dependent</termref>. In cases where an implementation is able to
               produce the <termref def="dt-final-result-tree">final result trees</termref> without
               evaluating a particular construct, the implementation is never
                  <rfc2119>required</rfc2119> to evaluate that construct solely in order to
               determine whether doing so causes a dynamic error. For example, if a <termref def="dt-variable">variable</termref> is declared but never referenced, an
               implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will signal this error and others will not.</p><p>There are some cases where this specification requires that a construct <rfc2119>must
                  not</rfc2119> be evaluated: for example, the content of an <elcode>xsl:if</elcode>
               instruction <rfc2119>must not</rfc2119> be evaluated if the test condition is false.
               This means that an implementation <rfc2119>must not</rfc2119> signal any dynamic
               errors that would arise if the construct were evaluated.</p><p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error">dynamic error</termref> before any source document is available, but only if it
               can determine that the error would be signaled for every possible source document and
               every possible set of parameter values. For example, some <termref def="circularity">circularity</termref> errors fall into this category: see <specref ref="circularity"/>.</p><p diff="add" at="B">There are also some <termref def="dt-dynamic-error">dynamic
                  errors</termref> where the specification gives a processor license to signal the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <function>key</function>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <elcode>xsl:analyze-string</elcode>
                  instruction.</p><p diff="add" at="M">A <termref def="dt-dynamic-error"/> may also be signaled during the
            static analysis phase if the error occurs during evaluation of a <termref def="dt-static-expression"/>.</p><p>The XPath specification states (see <xspecref spec="XP30" ref="id-kinds-of-errors"/>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <rfc2119>may</rfc2119>
               be reported as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <rfc2119>must not</rfc2119> be reported as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be signaled as dynamic errors, and signaled only if
               the XPath expression is actually evaluated.</p><example><head>Errors in Constant Subexpressions</head><p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a "divide by zero" error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p><eg xml:space="preserve">&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</eg><p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 2.0
                     <phrase diff="chg" at="A">or 3.0</phrase> processor. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p></example><p>
               <termdef id="dt-type-error" term="type error">Certain errors are classified as
                     <term>type errors</term>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</termdef> If a type error
               occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
               be signaled in the same way as a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>. Alternatively, an implementation
                  <rfc2119>may</rfc2119> signal a type error during the analysis phase in the same
               way as a <termref def="dt-static-error">static error</termref>, even if it occurs in
               part of the stylesheet that is never evaluated, provided it can establish that
               execution of a particular construct would never succeed.</p><p>It is <termref def="dt-implementation-defined"/>
               whether type errors are signaled statically.</p><imp-def-feature>It is <termref def="dt-implementation-defined"/> whether type errors
               are signaled statically.</imp-def-feature><example><head>A Type Error</head><p diff="chg" at="D">The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <elcode>xsl:number</elcode> instruction (it must be a node). An
                  implementation <rfc2119>may</rfc2119> optionally signal this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be signaled as a dynamic error.</p><eg role="error" xml:space="preserve" diff="chg" at="D">&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</eg><p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <phrase diff="chg" at="D"><elcode>xsl:number</elcode></phrase> will have a suitable dynamic type. An
                  implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it
                     <rfc2119>must not</rfc2119> treat it as an error.</p><eg xml:space="preserve" diff="chg" at="D">&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</eg></example><p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119>
               to signal any errors other than the first one that it detects. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> which of the
               several errors is signaled. This applies both to static errors and to dynamic errors.
               An implementation is allowed to signal more than one error, but if any errors have
               been signaled, it <rfc2119>must not</rfc2119> finish as if the transformation were
               successful.</p><p>When a transformation signals one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <termref def="dt-implementation-dependent">implementation-dependent</termref>.
               Implementations are not <rfc2119>required</rfc2119> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <rfc2119>may</rfc2119> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p><p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <termref def="dt-expression">expressions</termref>. Static errors and dynamic errors may occur in both
               cases.</p><p>
               <termdef id="dt-serialization-error" term="serialization error">If a transformation
                  has successfully produced a <termref def="dt-final-result-tree">final result
                     tree</termref>, it is still possible that errors may occur in serializing the
                  result tree. For example, it may be impossible to serialize the result tree using
                  the encoding selected by the user. Such an error is referred to as a
                     <term>serialization error</term>.</termdef> If the processor performs
               serialization, then it <rfc2119>must</rfc2119> do so as specified in <specref ref="serialization"/>, and in particular it <rfc2119>must</rfc2119> signal any
               serialization errors that occur.</p><p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error), <code>RE</code> (recoverable dynamic error), or <code>TE</code>
               (type error). Note that the allocation of an error to one of these categories is
               purely for convenience and carries no normative implications about the way the error
               is handled. Many errors, for example, can be reported either dynamically or
               statically. These error codes are used to label error conditions in this
               specification, and are summarized in <specref ref="error-summary"/>. <phrase diff="del" at="B">They are provided primarily for ease of reference.
                  Implementations <rfc2119>may</rfc2119> use these error codes when signaling
                  errors, but they are not <rfc2119>required</rfc2119> to do so. An API
                  specification, however, <rfc2119>may</rfc2119> require the use of error codes
                  based on these QNames.</phrase></p><p>Errors defined in related specifications (<bibref ref="xpath-30"/>, <bibref ref="xpath-functions-30"/>
               <bibref ref="xslt-xquery-serialization-30"/>) use QNames with a similar structure, in the same
               namespace. When errors occur in processing XPath expressions, an XSLT processor
                  <rfc2119>should</rfc2119> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p><p><phrase diff="add" at="B">Implementations <rfc2119>must</rfc2119> use the codes
                  defined in these specifications when signaling errors, to ensure that
                     <elcode>xsl:catch</elcode> behaves in an interoperable way across
                  implementations. Stylesheet authors should note, however, that there are many
                  examples of errors where more than one rule in this specification is violated, and
                  where the processor therefore has discretion in deciding which error code to
                  associate with the condition: there is therefore no guarantee that different
                  processors will always use the same error code for the same erroneous
                  input.</phrase></p><p>Additional errors defined by an implementation (or by an application)
                  <rfc2119>may</rfc2119> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p></div2></div1><div1 id="stylesheet-structure"><head>Stylesheet Structure</head><p>This section describes the overall structure of a stylesheet as a collection
         of XML documents.</p><div2 id="xslt-namespace"><head>XSLT Namespace</head><p>
               <termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
                  has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                  identify elements, attributes, and other names that have a special meaning defined
                  in this specification.</termdef>
            </p><note><p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                  by the W3C. It does not indicate the version of XSLT being used, which is
                  specified by attributes (see <specref ref="stylesheet-element"/> and <specref ref="simplified-stylesheet"/>).</p></note><p>XSLT <termref def="dt-processor">processors</termref>
               <rfc2119>must</rfc2119> use the XML namespaces mechanism <bibref ref="xml-names"/> to recognize elements and attributes from this namespace. Elements from the XSLT
               namespace are recognized only in the <termref def="dt-stylesheet">stylesheet</termref> and not in the source document. The complete list of
               XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
                  <termref def="dt-implementation">Implementations</termref>
               <rfc2119>must not</rfc2119> extend the XSLT namespace with additional elements or
               attributes. Instead, any extension <rfc2119>must</rfc2119> be in a separate
               namespace. Any namespace that is used for additional instruction elements
                  <rfc2119>must</rfc2119> be identified by means of the <termref def="dt-extension-instruction">extension instruction</termref> mechanism specified
               in <specref ref="extension-instruction"/>.</p><p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
               the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
               that there is a namespace declaration that binds the prefix to the URI of the XSLT
               namespace.</p><note><p>Throughout this specification, an element or attribute that is in no namespace, or
                  an <termref def="dt-expanded-qname">expanded QName</termref> whose namespace part
                  is an empty sequence, is referred to as having a <term>null namespace
                  URI</term>.</p></note><note><p>The conventions used for the names of <termref def="dt-xslt-element">XSLT
                     elements</termref>, attributes and functions are that names are all lower-case,
                  use hyphens to separate words, and use abbreviations only if they already appear
                  in the syntax of a related language such as XML or HTML. Names of types defined in
                  XML Schema are regarded as single words and are capitalized exactly as in XML
                  Schema. This sometimes leads to composite function names such as
                     <xfunction>current-dateTime</xfunction>.</p></note></div2><div2 id="reserved-namespaces"><head>Reserved Namespaces</head><p>
               <termdef id="dt-reserved-namespace" term="reserved namespace">The XSLT namespace,
                  together with certain other namespaces recognized by an XSLT processor, are
                  classified as <term>reserved namespaces</term> and <rfc2119>must</rfc2119> be used
                  only as specified in this and related specifications.</termdef> The reserved
               namespaces are those listed below.</p><ulist><item><p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in
                        <specref ref="xslt-namespace"/>, is reserved.</p></item><item><p>
                     <termdef id="dt-standard-function-namespace" term="standard function namespace">The <term>standard function namespace</term>
                        <code>http://www.w3.org/2005/xpath-functions</code> is used for functions in
                        the function library defined in <bibref ref="xpath-functions-30"/> and for
                        standard functions defined in this specification.</termdef>
                  </p></item><item><p diff="add" at="E"> The namespace
                        <code>http://www.w3.org/2005/xpath-functions/math</code> is used for
                     mathematical functions in the function library defined in <bibref ref="xpath-functions-30"/>. </p></item><item><p diff="add" at="I"> The namespace
                     <code>http://www.w3.org/2005/xpath-functions/map</code> is used for
                     functions defined in this specification relating to the manipulation
                     of <termref def="dt-map">maps</termref>. </p></item><item><p>
                     <termdef id="xml-namespace" term="XML namespace">The <term>XML
                        namespace</term>, defined in <bibref ref="xml-names"/> as
                           <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes
                        such as <code>xml:lang</code>, <code>xml:space</code>, and
                           <code>xml:id</code>.</termdef>
                  </p></item><item><p><termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
                           namespace</term>
                        <code>http://www.w3.org/2001/XMLSchema</code> is used as defined in <bibref ref="xmlschema-1"/></termdef>. In a <termref def="dt-stylesheet">stylesheet</termref> this namespace may be used to refer to built-in schema
                     datatypes and to the constructor functions associated with those datatypes.</p></item><item><p><termdef id="dt-schema-instance-namespace" term="schema instance namespace">The
                           <term>schema instance namespace</term>
                        <code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined in
                           <bibref ref="xmlschema-1"/></termdef>. Attributes in this namespace, if
                     they appear in a <termref def="dt-stylesheet">stylesheet</termref>, are treated
                     by the XSLT processor in the same way as any other attributes.</p></item><item><p diff="add" at="B"><termdef id="dt-standard-error-namespace" term="standard error namespace">The <term>standard error namespace</term>
                        <code>http://www.w3.org/2005/xqt-errors</code> is used for error codes
                        defined in this specification and related specifications. It is also used
                        for the names of certain predefined variables accessible within the scope of
                        an <elcode>xsl:catch</elcode> element.</termdef></p></item><item><p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use as
                     described in <bibref ref="xml-names"/>. No element or attribute node can
                     have a name in this namespace, and although the prefix <code>xmlns</code> is
                     implicitly bound to this namespace, no namespace node will ever define this
                     binding.</p></item></ulist><p>Reserved namespaces may be used without restriction to refer to the names of elements
               and attributes in source documents and result documents. As far as the XSLT processor
               is concerned, reserved namespaces other than the XSLT namespace may be used without
               restriction in the names of <termref def="dt-literal-result-element">literal result
                  elements</termref> and <termref def="dt-data-element">user-defined data
                  elements</termref>, and in the names of attributes of literal result elements or
               of <termref def="dt-xslt-element">XSLT elements</termref>: but other processors
                  <rfc2119>may</rfc2119> impose restrictions or attach special meaning to them.
               Reserved namespaces <rfc2119>must not</rfc2119> be used, however, in the names of
               stylesheet-defined objects such as <termref def="dt-variable">variables</termref> and
                  <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p><note><p>With the exception of the XML namespace, any of the above namespaces that are used
                  in a stylesheet must be explicitly declared with a namespace declaration. Although
                  conventional prefixes are used for these namespaces in this specification, any
                  prefix may be used in a user stylesheet.</p></note><p>
               <error spec="XT" type="static" class="SE" code="0080"><p>It is a <termref def="dt-static-error">static error</termref> to use a <termref def="dt-reserved-namespace">reserved namespace</termref> in the name of a
                        <termref def="dt-named-template">named template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute
                        set</termref>, a <termref def="dt-key">key</termref>, a <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet
                        function</termref>, a named <termref def="dt-output-definition">output
                        definition</termref>, or a <termref def="dt-character-map">character
                        map</termref>.</p></error>
            </p></div2><div2 id="extension-attributes"><head>Extension Attributes</head><p>
               <termdef id="dt-extension-attribute" term="extension attribute">An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <termref def="dt-expanded-qname">expanded QName</termref> (see <bibref ref="xpath-30"/>) of the attribute has a non-null namespace URI. These
                  attributes are referred to as <term>extension attributes</term>.</termdef> The
               presence of an extension attribute <rfc2119>must not</rfc2119> cause the <termref def="dt-final-result-tree">final result trees</termref> produced by the
               transformation to be different from the result trees that a conformant XSLT <phrase diff="chg" at="A">3.0</phrase> processor might produce. They <rfc2119>must
                  not</rfc2119> cause the processor to fail to signal an error that a conformant
               processor is required to signal. This means that an extension attribute <rfc2119>must
                  not</rfc2119> change the effect of any <termref def="dt-instruction">instruction</termref> except to the extent that the effect is <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p><p>Furthermore, if serialization is performed using one of the serialization methods
                  <code>xml</code>, <code>xhtml</code>, <code>html</code>, or <code>text</code>
               described in <bibref ref="xslt-xquery-serialization-30"/>, the presence of an extension attribute
               must not cause the serializer to behave in a way that is inconsistent with the
               mandatory provisions of that specification.</p><note><p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may be used
                  to modify the behavior of <termref def="dt-extension-function">extension
                     functions</termref> and <termref def="dt-extension-instruction">extension
                     instructions</termref>. They may be used to select processing options in cases
                  where the specification leaves the behavior <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p><p>
                  <termref def="dt-extension-attribute">Extension attributes</termref>
                  <rfc2119>may</rfc2119> also be used to influence the behavior of the serialization
                  methods <code>xml</code>, <code>xhtml</code>, <code>html</code>, or
                     <code>text</code>, to the extent that the behavior of the serialization method
                  is <termref def="dt-implementation-defined"/> or
                     <termref def="dt-implementation-dependent">implementation-dependent</termref>.
                  For example, an extension attribute might be used to define the amount of
                  indentation to be used when <code>indent="yes"</code> is specified. If a
                  serialization method other than one of these four is requested (using a prefixed
                  QName in the method parameter) then extension attributes may influence its
                  behavior in arbitrary ways. Extension attributes <rfc2119>must not</rfc2119> be
                  used to cause the four standard serialization methods to behave in a
                  non-conformant way, for example by failing to report serialization errors that a
                  serializer is <rfc2119>required</rfc2119> to report. An implementation that wishes
                  to provide such options must create a new serialization method for the
                  purpose.</p><p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, <rfc2119>must</rfc2119> perform the
                  transformation as if the extension attribute were not present. As always, it is
                  permissible to produce warning messages.</p><p>The namespace used for an extension attribute will be copied to the <termref def="dt-result-tree">result tree</termref> in the normal way if it is in scope
                  for a <termref def="dt-literal-result-element">literal result element</termref>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p></note><example><head>An Extension Attribute for <code>xsl:message</code>
               </head><p>The following code might be used to indicate to a particular implementation that
                  the <elcode>xsl:message</elcode> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p><eg xml:space="preserve">&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</eg><p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
                  normal way.</p></example><p>
               <error spec="XT" type="static" class="SE" code="0090"><p>It is a <termref def="dt-static-error">static error</termref> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.</p></error>
            </p></div2><div2 id="xslt-media-type"><head>XSLT Media Type</head><p>The media type <code>application/xslt+xml</code>
               <phrase diff="chg" at="A">has been</phrase> registered for XSLT stylesheet
               modules.</p><p>The definition of the media type is at <bibref ref="XSLT-Mime-Type"/>.</p><p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a
                  <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
               at its top level, and it <rfc2119>may</rfc2119> also be used for a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
                  <rfc2119>should not</rfc2119> be used for an XML document containing an <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p></div2><div2 id="standard-attributes"><head>Standard Attributes</head><p>
               <termdef id="dt-standard-attributes" term="standard attributes">There are a number of
                     <term>standard attributes</term> that may appear on any <termref def="dt-xslt-element">XSLT element</termref>: specifically
                  <code>version</code>, <code>exclude-result-prefixes</code>,
                     <code>extension-element-prefixes</code>, <code>xpath-default-namespace</code>,
                     <code>default-collation</code>, and <code>use-when</code>.</termdef>
            </p><p>These attributes may also appear on a <termref def="dt-literal-result-element">literal result element</termref>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. They are thus typically written
               as <code>xsl:version</code>, <code>xsl:exclude-result-prefixes</code>,
                  <code>xsl:extension-element-prefixes</code>,
                  <code>xsl:xpath-default-namespace</code>, <code>xsl:default-collation</code>, or
                  <code>xsl:use-when</code>.</p><p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be
               permitted on <termref def="dt-extension-instruction">extension
               instructions</termref>, but this is at the discretion of the implementer of each
               extension instruction. They <rfc2119>may</rfc2119> also be permitted on <termref def="dt-data-element">user-defined data elements</termref>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p><p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p><p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p><p>In the case of <code>[xsl:]version</code>,
               <code>[xsl:]xpath-default-namespace</code>, and <code>[xsl:]default-collation</code>,
               the value can be overridden by a different value for the same attribute appearing on
               a descendant element. The effective value of the attribute for a particular
               stylesheet element is determined by the innermost ancestor-or-self element on which
               the attribute appears.</p><p>In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet
                  module</termref>, <termref def="dt-standard-attributes">standard
                  attributes</termref> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p><p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the effective value for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p><p>The effect of the <code>[xsl:]use-when</code> attribute is described in <specref ref="conditional-inclusion"/>.</p><p>Because these attributes may appear on any <termref def="dt-xslt-element">XSLT
                  element</termref>, they are not listed in the syntax summary of each individual
               element. Instead
               <!--<phrase diff="add" at="T">(with the exception of <code>[xsl:]use-when</code>)</phrase>-->
               they are listed and described in the entry for the <elcode>xsl:stylesheet</elcode>
               and <elcode>xsl:transform</elcode> elements only. This reflects the fact that these
               attributes are often used on the <elcode>xsl:stylesheet</elcode> element only, in
               which case they apply to the entire <termref def="dt-stylesheet-module">stylesheet
                  module</termref>.</p><p>Note that the effect of these attributes does <emph>not</emph> extend to <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced by
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations.</p><p>For the detailed effect of each attribute, see the following sections:</p><glist><gitem><label>
                     <code>[xsl:]version</code>
                  </label><def><p>see <specref ref="backwards"/> and <specref ref="forwards"/>
                     </p></def></gitem><gitem><label>
                     <code>[xsl:]xpath-default-namespace</code>
                  </label><def><p>see <specref ref="unprefixed-qnames"/>
                     </p></def></gitem><gitem><label>
                     <code>[xsl:]exclude-result-prefixes</code>
                  </label><def><p>see <specref ref="lre-namespaces"/>
                     </p></def></gitem><gitem><label>
                     <code>[xsl:]extension-element-prefixes</code>
                  </label><def><p>see <specref ref="extension-instruction"/>
                     </p></def></gitem><gitem><label>
                     <code>[xsl:]use-when</code>
                  </label><def><p>see <specref ref="conditional-inclusion"/>
                     </p></def></gitem><gitem><label>
                     <code>[xsl:]default-collation</code>
                  </label><def><p>see <specref ref="default-collation-attribute"/>
                     </p></def></gitem></glist></div2><div2 id="packages" at="I" diff="chg"><head>Packages</head><p><termdef id="dt-package" term="package">A <term>package</term> is represented by
               an <elcode>xsl:package</elcode> element, which will generally be the outermost element
               of an XML document.</termdef> (This specification does not preclude the <elcode>xsl:package</elcode> being embedded
               in another XML document, but it will never have any other XSLT element as an ancestor).</p><e:element-syntax name="package"><e:attribute name="xsl:version"><e:data-type name="decimal"/></e:attribute><e:attribute name="name"><e:data-type name="uri"/></e:attribute><e:attribute name="package-version"><e:data-type name="string"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="use-package"/><e:choice><e:element name="stylesheet"/><e:element name="transform"/></e:choice><e:element repeat="zero-or-more" name="expose"/></e:sequence><e:allowed-parents/></e:element-syntax><p><termdef id="dt-package-manifest" term="package manifest">The content of the <elcode>xsl:package</elcode> element is
               referred to as the <term>package manifest</term></termdef>.</p><p>The <code>xsl:version</code> attribute indicates the version of the XSLT language specification to which the
            package manifest conforms. The value <rfc2119>should</rfc2119> be <code>3.0</code>.</p><issue id="issue-package-xslt-version" status="open"><p>Need to define forwards and backwards compatibility rules for package/@xsl:version</p></issue><p>Every package has a name, given in its <code>name</code> attribute, which <rfc2119>must</rfc2119> be an 
               absolute URI.</p><p>Every package has a version identifier, given in its <code>package-version</code> attribute. This is used
               to distinguish different packages that have the same package name, perhaps successive versions of a package,
               or perhaps variants of a package for use in different environments. The version identifier can be
               any string.</p><p>The package manifest is in three parts:</p><olist><item><p>It starts with zero-or-more <elcode>xsl:use-package</elcode> elements
               which identify the packages used by this package, including subsidiary elements that constrain the way
               in which the components contained in those packages are used.</p></item><item><p>This is followed by an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
               (the two names are synonyms) which is an embedded <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>.
               This can contain references to other stylesheet modules using <elcode>xsl:include</elcode> and/or
               <elcode>xsl:import</elcode> <termref def="dt-declaration">declarations</termref>, and it can contain
               other declarations such as <elcode>xsl:function</elcode> and <elcode>xsl:template</elcode>.</p><p>The modules making up a package are this module, plus all modules that are transitively reachable from it using
               <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode> declarations. It is permissible for the same module to appear in more than
               one package, or indeed more than once in the same package; this situation is no different 
               from having two modules with identical content but different URIs.</p></item><item><p>Finally, the manifest contains zero or more <elcode>xsl:expose</elcode> declarations that define
            the interface offered by this package to the outside world.</p></item></olist><!--<p><termdef id="dt-main-package" term="main package">The <term>main package</term>
               of a <termref def="dt-stylesheet">stylesheet</termref> is the <termref def="dt-package">package</termref>
               that contains the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref> 
               of the stylesheet.</termdef></p>
               <p><termdef id="dt-library-package" term="library package">A <term>library package</term>
               within a <termref def="dt-stylesheet">stylesheet</termref> is a <termref def="dt-package">package</termref>
               that is incorporated within the stylesheet by virtue of an <elcode>xsl:use-package</elcode>
               declaration</termdef></p>
               
               <p>The chief module of a package <rfc2119>may</rfc2119> be identified using the attribute <code>package="yes"</code>
               on its <elcode>xsl:stylesheet</elcode> element. A module labeled with this attribute, as well as any module
               that is the object of an <elcode>xsl:use-package</elcode> declaration whether or not it is so labeled,
               must conform to additional static constraints described [where??].</p>
               
               
               <note><p>XSLT 3.0 is designed to enable a package to be compiled independently of
               other packages. This specification does not attempt to formalize a description of
               how packages are compiled. The term <term>assembled package</term>, however, may be
               interpreted as representing the results of such compilation.</p>
               <p>The specification acknowledges that a compiled package may
               be deployed at a location whose URL is different from that of the source modules
               from which it was created.</p>
               </note>--><p diff="add" at="L">A package that does not itself expose any components (in effect, a stylesheet that makes
            use of library packages but is not itself intended to act as a library package) may be written using a simplified
            syntax: the <elcode>xsl:package</elcode> element is omitted, and the <elcode>xsl:use-package</elcode> children
            are moved to the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, which is now the outermost
            element of the stylesheet module. More formally, an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
            element having one or more <elcode>xsl:use-package</elcode> children is equivalent to the package represented by
               the output of the following transformation, preserving the base URI of the source:</p><eg diff="add" at="L" xml:space="preserve">
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    &lt;xsl:mode on-no-match="shallow-copy"/&gt;
    &lt;xsl:template match="(xsl:stylesheet|xsl:transform)[xsl:use-package]"&gt;
      &lt;t:package t:version="{@version}"&gt;
        &lt;xsl:copy-of select="xsl:use-package"/&gt;
        &lt;xsl:copy&gt;
          &lt;xsl:copy-of select="@*"/&gt;
          &lt;xsl:copy-of select="* except xsl:use-package"/&gt;
        &lt;/xsl:copy&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;   
       </eg><div3 id="package-dependencies"><head>Dependencies between Packages</head><p>When components in one package reference components in another, the dependency
               of the first package on the second must be represented by an <elcode>xsl:use-package</elcode>
               element in the <termref def="dt-package-manifest">package manifest</termref> of the first
               package.</p><p><termdef id="dt-use" term="use">If a package <var>Q</var> 
                  contains an <elcode>xsl:use-package</elcode> element that references package <var>P</var>, 
                  then package <var>Q</var> is said to <term>use</term>
                  package <var>P</var>. In this relationship package <var>Q</var> is referred to as the
                  <term>using</term> package, package <var>P</var> as the <term>used</term> package.</termdef></p><p>The phrase <term>directly uses</term> is synonymous with <term>uses</term> as defined above,
               while <term>directly or indirectly uses</term> refers to the transitive closure of this relationship.</p><e:element-syntax name="use-package"><e:attribute name="name"><e:data-type name="uri"/></e:attribute><e:attribute name="package-version" required="no"><e:data-type name="token"/></e:attribute><e:choice repeat="zero-or-more"><e:element name="accept"/><e:element name="override"/></e:choice><e:allowed-parents><e:parent name="package"/></e:allowed-parents></e:element-syntax><p>A <termref def="dt-package">package</termref> may be <termref def="dt-use">used</termref>
                  by more than one other package, 
                  but the relationship must not be cyclic. It is possible, but by no means inevitable, that
                  using the same package in more than one place within a stylesheet will cause static errors
                  due to the presence of conflicting components according to the above rules. Where a package
                  is successfully used by more than one other package, its components may be overridden in different
                  ways by different using packages.</p><!--<issue id="issue-cyclic-package-dependencies"><p>The restriction that prevents cyclic package dependencies is unfortunate, it would be nice
                  if we can find a way of dispensing with it. It's a consequence of the decision that each use of a package
                  effectively creates a new occurrence of all its components.</p></issue>--><p>The <code>name</code> and <code>package-version</code> attributes together identify the used
               package. The used package must have a name that is an exact match for the name in the <code>name</code>
               attribute, and it may have a package-version that matches the pattern given in the <code>package-version</code>
               attribute. Omitting this attribute is equivalent to specifying the value as <code>package-version="#"</code>,
               which matches any version.</p><p>The value of the <code>package-version</code> attribute consists of a prefix and a suffix separated by a hash sign (#); 
               if there is no hash sign, the entire string is used as the prefix, and the suffix is empty; if there is more than one
               hash sign, the first one is taken as the separator and others as part of the suffix; if the hash sign is the
               last character in the string then a suffix of ".*" is assumed. The pattern matches 
               a package version if the package version can be divided into two substrings such that the first substring matches
               the prefix literally (using codepoint comparison), and the second substring matches the suffix considered as a regular
               expression (matched according to the rules of the <xfunction>matches</xfunction> function with the <code>$flags</code>
               argument set to a zero length string). Thus the version pattern <code>3.1</code> matches version <code>3.1</code>
               only; the pattern <code>3.1#</code> matches <code>3.1</code>, <code>3.1.2</code>, and <code>3.17</code>; the pattern
                  <code>3.1#(\.\d+)?</code> matches <code>3.1</code> and <code>3.1.5</code>; and the pattern 
                  <code>3.1#(\.\d+)*</code> matches <code>3.1</code>, <code>3.1.5</code>, and <code>3.1.5.2</code>.</p><p>This specification does not define how the implementation locates a package given its name and version.
               Nor does it define whether this process locates source code or some other representation of the package
               contents. Such mechanisms are <termref def="dt-implementation-defined"/>. Use of the package name as a dereferencable
               URI is <rfc2119>not recommended</rfc2119>, because the intent of the packaging feature is to allow a package to be
               distributed as reusable code and to therefore to exist in many different locations.</p><imp-def-feature>Mechanisms to locate the source or executable code of a <termref def="dt-package"/>
               are implementation-defined.</imp-def-feature><p>The <elcode>xsl:accept</elcode> and <elcode>xsl:override</elcode> elements are used to modify the
               visibility or behavior of components acquired from the used package; they are described in 
               <specref ref="accepting-components"/> below.</p><issue id="issue-use-package-xquery" status="open"><p>The WG intends to add an option to xsl:use-package to allow
               an XQuery library module to be used in the same way as a package written in XSLT. This requires
               defining a mapping of XQuery concepts to XSLT concepts (for example, XQuery external variables equate
               to XSLT stylesheet parameters). This is likely to be an optional conformance feature.</p></issue></div3><div3 id="named-components"><head>Named Components in Packages</head><p>This section discusses the use of named components in packages: specifically
               functions, named templates, attribute sets, and global variables and parameters.
               Some of the provisions in this section also apply to named modes, but there are
               differences noted in <specref ref="modes-and-packages"/>. The section is largely concerned
               with details of the rules that affect references from one component to another by name, whether
               the components are in the same package or in different packages. The rules are designed to
               meet a number of requirements:</p><ulist><item><p>A component defined in one package can be overridden by a component
                     in another package, provided the signatures are type-compatible.</p></item><item><p>The author of a package can declare whether the components in 
                  the package are public or private (that is, whether or not they can be used
                  from outside the package) and whether they are final, overridable, or abstract (that
                  is whether they can or must be overridden by the using package).</p></item><item><p>Within an application, two packages can make use of a common library
                  and override its components in different ways.</p></item><item><p>Visibility of components can be defined either as part of the declaration
                  of the component, or in the package manifest.</p></item><item><p>An application that wishes to make use of a library package can be
                     selective about which components from the library it acquires, perhaps
                     to avoid name clashes between components acquired from different libraries.</p></item></ulist><p><termdef id="dt-component" term="component">The term 
               <term>component</term> is used to refer to any of the following:
            a <termref def="dt-stylesheet-function">stylesheet function</termref>, a 
               <termref def="dt-named-template">named template</termref>, a <termref def="dt-mode">mode</termref>,
            a <termref def="dt-attribute-set">attribute set</termref>, a 
               <termref def="dt-global-variable">global variable</termref>, or a 
               <termref def="dt-mode">mode</termref>.</termdef></p><p><termdef id="dt-symbolic-identifier" term="symbolic identifier">The <term>symbolic identifier</term>
            of a <termref def="dt-component">component</termref> is a composite name used to identify the component uniquely within a package.
            The symbolic identifier comprises the kind of component (stylesheet function, named template, 
            attribute set, global variable, or mode), the <termref def="dt-expanded-qname">expanded QName</termref>
               of the component (namespace URI plus local name), and in the case of stylesheet functions,
               the <termref def="dt-arity">arity</termref>.</termdef></p><p><termdef id="dt-homonymous" term="homonymous">Two <termref def="dt-component">components</termref> are said to be
                  <term>homonymous</term> if they have the same <termref def="dt-symbolic-identifier">symbolic identifier</termref>.</termdef></p><p>Every <termref def="dt-component">component</termref> has a <termref def="dt-declaration">declaration</termref>
               in some <termref def="dt-stylesheet-module"/> and therefore within some 
                  <termref def="dt-package">package</termref>. The declaration is an element in an XDM tree representing
                  the stylesheet module. Declarations therefore have identity, based on XDM node identity.</p><p>Not all <termref def="dt-declaration">declarations</termref> result in <termref def="dt-component">components</termref>:</p><ulist><item><p>Some declarations, such as <elcode>xsl:decimal-format</elcode> and <elcode>xsl:strip-space</elcode>,
                     declare aspects of the processing context which are not considered to be components as defined here.</p></item><item><p><termref def="dt-template-rule">Template rules</termref>
                        (<elcode>xsl:template</elcode> with a <code>match</code> attribute) are
                        also not considered to be components for the purposes of this section, which is concerned
                        only with components that are bound by name. However, when an <elcode>xsl:template</elcode>
                        has both a <code>match</code> attribute and a <code>name</code> attribute, then it establishes
                        both a template rule and a <termref def="dt-named-template">named template</termref>, and
                        in its role as a named template it comes within the scope of this discussion.</p></item><item><p>A named declaration, for example a named template, a function, an attribute set, or a global
                        variable, may be overridden within the same package by another like-named declaration
                        having higher <termref def="dt-import-precedence">import precedence</termref>. When a
                        declaration is overridden in this way it can never be referenced or invoked either from
                        within its containing package or from outside that package; it is effectively dead code,
                        and it therefore does not result in the creation of any component, which means that it
                        plays no part in the component binding process.</p></item></ulist><!--<p><termdef id="dt-original-identity" term="original identity">The <term>original identity</term>
            of a <termref def="dt-component">component</termref> is the XDM node identity of the element
               acting as the <termref def="dt-declaration">declaration</termref> of the component.</termdef></p>--><!--<p>A component is originally declared within one package, and this declaration determines the original
            identity of the component. Each package that directly or indirectly uses this package contains 
            information about the component called a <termref def="dt-component-occurrence">component occurrence</termref>.
            </p>--><p><termdef id="dt-declaring-package" term="declaring package">The <term>declaring package</term>
            of a <termref def="dt-component">component</termref> is the package that contains the declaration
            of the component.</termdef></p><p>When a <termref def="dt-component">component</termref> declared in one 
                  <termref def="dt-package">package</termref> is made available in another, the using package will
            contain a separate component that can be regarded as a modified copy of the original. The new
            component shares the same <termref def="dt-symbolic-identifier">symbolic identifier</termref> as the original, and it has
            the same <termref def="dt-declaration">declaration</termref>, but it has other properties
            such as its <termref def="dt-visibility">visibility</termref> that may differ from the original.</p><!--<p><termdef id="dt-component-occurrence" term="component occurrence">A <term>component occurrence</term>
            represents the availability of a particular <termref def="dt-component">component</termref> within a 
            particular <termref def="dt-package">package</termref>; for every component, there is a <term>component occurrence</term>
            of the component in its <termref def="dt-declaring-package">declaring package</termref>, 
               and one in each package that directly or indirectly
            <termref def="dt-use">uses</termref> its declaring package.</termdef></p>--><p>The properties of a <termref def="dt-component">component</termref> are
            as follows:</p><ulist><item><p>The original <termref def="dt-declaration">declaration</termref> of the component.</p></item><item><p>The <termref def="dt-package">package</termref> to which the component belongs (called its <term>containing</term> package,
                  not to be confused with the <termref def="dt-declaring-package">declaring package</termref>).</p></item><item><p>The <termref def="dt-symbolic-identifier">symbolic identifier</termref> of the component.</p></item><!--<item><p>The <termref def="dt-internal-visibility">internal visibility</termref> of the component occurrence, which
                  determines the way in which the component is seen by other components within the same package.
                  This is one of <code>public</code>, <code>private</code>, <code>abstract</code>, <code>final</code>,
                  or <code>hidden</code>.</p></item>
               <item><p>The <termref def="dt-external-visibility">external visibility</termref> of the component occurrence, which
                  determines the way in which the component is seen within a using package.
                  This is one of <code>public</code>, <code>private</code>, <code>abstract</code>, <code>final</code>,
                  or <code>hidden</code>.</p></item>--><item><p>The <termref def="dt-visibility">visibility</termref> of the component, which
                  determines the way in which the component is seen by other components within the same package
                  and within using packages.
                  This is one of <code>public</code>, <code>private</code>, <code>abstract</code>, <code>final</code>,
                  or <code>hidden</code>. The visibility of components is discussed further in
                  <specref ref="visibility"/>.</p></item><item><p>A set of bindings for the <termref def="dt-symbolic-reference">symbolic references</termref> in 
                  the component. The way in which these bindings are established is discussed further in
                  <specref ref="component-references"/>.</p></item></ulist><note><p>When a function <var>F</var> defined in a package <var>P</var> is acquired by two using packages 
                  <var>Q</var> and <var>R</var>, we may think
                  of <var>P</var>, <var>Q</var>, and <var>R</var> as all providing access to the "same" function. 
                  The detailed semantics, however, demand
               an understanding that there is one function declaration, but three components. The three components
               representing the function <var>F</var> within packages <var>P</var>, <var>Q</var>, 
                  and <var>R</var> have some properties in common (the same
               symbolic identifier, the same declaration), but other properties
               (the visibility and the bindings of symbolic references) that may vary from one of these components to 
               another.</p></note><p><termdef id="dt-symbolic-reference" term="symbolic reference">The 
               <termref def="dt-declaration">declaration</termref>
               of a component includes constructs that can be interpreted as references to 
               other <termref def="dt-component">components</termref> by means of their
               <termref def="dt-symbolic-identifier">symbolic identifiers</termref>. These constructs are generically
               referred to as <term>symbolic references</term>. Examples of constructs that give rise to symbolic references
            are the <code>name</code> attribute of <elcode>xsl:call-template</elcode>; 
               the <code>[xsl:]use-attribute-sets</code>
            attribute of <elcode>xsl:copy</elcode>, <code>xsl:element</code>, and 
               <termref def="dt-literal-result-element">literal result elements</termref>;
            the <code>mode</code> attribute of <elcode>xsl:template</elcode> and <elcode>xsl:apply-templates</elcode>;               
            XPath variable references referring to global variables; and XPath function calls
            referring to <termref def="dt-stylesheet-function">stylesheet functions</termref>.</termdef></p><p>Symbolic references exist as properties of the <termref def="dt-declaration">declaration</termref>
               of a <termref def="dt-component">component</termref>. The 
               <termref def="dt-symbolic-identifier">symbolic identifier</termref> being referred to can
               be determined straightforwardly from the syntactic form and context of the reference: for example,
               the instruction <code>&lt;xsl:value-of select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains
               a symbolic reference to a function with expanded name <code>{http://f.com/}price</code> and with arity=1.
               However, because there may be several (homonymous) function components with this symbolic identifier,
               translating this symbolic reference into a reference to a specific component (a process called "binding")
               is less straightforward, and is described in the text that follows.
            </p><p>The process of assembling a stylesheet from its constituent packages is primarily a process of binding
               these symbolic references to actual components. Within any 
               <termref def="dt-component">component</termref> whose <termref def="dt-declaration">declaration</termref>
               is <var>D</var>, there is a set of bindings; each binding is an association between an
               <termref def="dt-symbolic-reference">symbolic reference</termref> in <var>D</var> and
               a <termref def="dt-component">component</termref> whose <termref def="dt-symbolic-identifier">symbolic identifier</termref>
               matches the outward reference. Outward references for which a component <var>C</var> contains
               a binding are said to be <term>bound</term> in <var>C</var>; those for which <var>C</var>
               contains no binding are said to be <term>unbound</term>.</p><p>For example, suppose that in some package <var>P</var>, function <var>A</var> calls <var>B</var>, which in turn
               calls <var>C</var>, and that <var>B</var> is <code>private</code>. Now suppose that in some package 
               <var>Q</var> which uses <var>P</var>, <var>C</var> is overridden. The effect of the binding process
               is that <var>Q</var> will contain three components corresponding to <var>A</var>, <var>B</var>, and 
               <var>C</var>, which we might call <var>A(Q)</var>, <var>B(Q)</var>, and 
               <var>C(Q)</var>. The <termref def="dt-declaration">declarations</termref> of <var>A(Q)</var> and
               <var>B(Q)</var> are in package <var>P</var>, but the declaration of <var>C(Q)</var> is in <var>Q</var>.
               The internal visibility of <var>B(Q)</var> will be <code>hidden</code>
               (meaning that it cannot be referenced from within <var>Q</var>), and <var>B(Q)</var> will contain
               a binding for the component <var>C(Q)</var> that corresponds to the outward reference from <var>B</var> to <var>C</var>.
               The effect is that when <var>A</var> calls <var>B</var> and <var>B</var> calls <var>C</var>, it is the
               overriding version of <var>C</var> that is executed.
               In another package <var>R</var> that uses <var>P</var> without overriding
               <var>C</var>, there will be three different components <var>A(R)</var>, <var>B(R)</var>, and 
               <var>C(R)</var>. This time the declaration of all three components is in the original package <var>P</var>.
               Component <var>B(R)</var> will contain a binding to <var>C(R)</var>, so in this package, the original
               version of <var>C</var> is executed. The fact that one package <var>Q</var> overrides <var>C</var>
               thus has no effect on <var>R</var>, which does not override it.</p><div4 id="visibility"><head>Visibility of Components</head><p><termdef id="dt-visibility" term="visibility">The <term>visibility</term> of a 
                  <termref def="dt-component">component</termref>
                  is one of: <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>,
                  or <code>hidden</code>.</termdef></p><p>The meanings of these visibility values is as follows:</p><table border="1" cellpadding="2" summary="Values of the visibility attribute, and their meaning"><thead><tr><th rowspan="1" colspan="1">Visibility</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">public</td><td rowspan="1" colspan="1">The component can be referenced from other components in this package
                        or in any using package; it can be overridden by a different component in 
                        any using package.</td></tr><tr><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">The component can be referenced from other components in this package;
                        it cannot be referenced or overridden within a using package.</td></tr><tr><td rowspan="1" colspan="1">abstract</td><td rowspan="1" colspan="1">The component can be referenced from other components in this package
                           or in any using package; in a using package it can either remain abstract
                           or be overridden by a different component. (In the top-level package of
                           a stylesheet, it must be overridden by a non-abstract component.)</td></tr><tr><td rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">The component can be referenced from other components in this package
                           or in any using package; it cannot be overridden by a different component in 
                           any using package.</td></tr><tr><td rowspan="1" colspan="1">hidden</td><td rowspan="1" colspan="1">The component cannot be referenced from other components in this package;
                           it cannot be referenced or overridden within a using package.</td></tr></tbody></table><p>The <termref def="dt-visibility">visibility</termref> (sometimes called the
                  <term>actual visibility</term>) of a component depends on two factors: 
                  its <termref def="dt-potential-visibility">potential visibility</termref>
                  and its <termref def="dt-exposed-visibility">exposed visibility</termref>.</p><p><termdef id="dt-potential-visibility" term="potential visibility">The 
                  <term>potential visibility</term> of a component is established when the
                  component is declared or accepted into a package.</termdef></p><p><termdef id="dt-exposed-visibility" term="exposed visibility">The 
                  <term>exposed visibility</term> of a component is established by an 
                  <elcode>xsl:expose</elcode> element in the package manifest.</termdef></p><p>For a component within its <termref def="dt-declaring-package"/> the
               <termref def="dt-potential-visibility">potential visibility</termref> 
               is the value of the <code>visibility</code> attribute on the
               component's <termref def="dt-declaration">declaration</termref>, or
               <code>private</code> if the attribute is absent.</p><p>For a component accepted from another package, the 
                  <termref def="dt-potential-visibility">potential visibility</termref> depends on 
               the visibility declared in the relevant <elcode>xsl:accept</elcode> or
                  <elcode>xsl:override</elcode> element that
               makes the component available within the using package; this in turn has a default
               that depends on the (actual) visibility of the corresponding component in the used package.</p><p>These rules are described more fully in the sections that follow.</p></div4><div4 id="declared-visibility"><head>Visibility of Declarations</head><p>The <elcode>xsl:function</elcode>, <elcode>xsl:template</elcode>,
                     <elcode>xsl:attribute-set</elcode>, <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
                     and <elcode>xsl:mode</elcode> <termref def="dt-declaration">declarations</termref> each have an optional <code>visibility</code>
                     attribute that determines the 
                     <termref def="dt-potential-visibility">potential visibility</termref> of the component corresponding
                     to this declaration in its <termref def="dt-declaring-package">declaring package</termref>.
                     The value is one of 
                     <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>
                     (never <code>hidden</code>), with the default being <code>private</code>.</p><p>Whatever the value of this attribute, and whatever the 
                     <termref def="dt-exposed-visibility">exposed visiblity</termref>
                     of the component, other declarations within the same package may contain 
                     <termref def="dt-symbolic-reference">symbolic references</termref> to this
                     declaration: informally, the name of the component is always "in scope" within the package
                     containing its declaration. The way in which these symbolic references are bound
                     to an actual component, however, depends on the component's visibility, as
                     defined in <specref ref="component-references"/>. For example,
                     a symbolic reference will never be bound to a component whose visibility is
                     <code>abstract</code>.
                  </p></div4><!--<p><termdef id="dt-internal-visibility" term="internal visibility">The <term>internal visibility</term>
                  of a <termref def="dt-component">component</termref> within its 
                  <termref def="dt-declaring-package">declaring
               package</termref> depends on the value of the <code>visibility</code> attribute on its
               <termref def="dt-declaration">declaration</termref>, which defaults to <code>private</code>.
               The internal visibility determines how other components within the same package see the component.</termdef></p>
               
               <p>The internal visibility of a component within its <termref def="dt-declaring-package">declaring
               package</termref> will never be <code>hidden</code>: this value only ever applies to a
               component that results from accepting a <code>private</code> component from a used package.</p>
               --><div4 id="exposing-components"><head>Exposing Components</head><p>The <termref def="dt-visibility">visibility</termref> 
                  of a component within a package may be modified by means of an
               <elcode>xsl:expose</elcode> element in the package manifest.</p><e:element-syntax name="expose"><e:attribute name="component" required="yes"><e:constant value="template"/><e:constant value="function"/><e:constant value="attribute-set"/><e:constant value="variable"/><e:constant value="mode"/></e:attribute><e:attribute name="names" required="yes"><e:data-type name="tokens"/></e:attribute><e:attribute name="visibility" required="yes"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/><!--<e:constant value="hidden"/>--></e:attribute><e:empty/><e:allowed-parents><e:parent name="package"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:expose</elcode> element allows selected components within a package
               to have an <termref def="dt-exposed-visibility">exposed visibility</termref> 
                  different from their <termref def="dt-potential-visibility">potential visibility</termref> .</p><p>The components in question are identified
                  using their <termref def="dt-symbolic-identifier">symbolic identifiers</termref>.
                  The <code>component</code> attribute defines the kind
                  of component that is selected (<code>variable</code> 
                  embraces <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>). 
                  The <code>names</code> attribute selects a subset of those components
                  by name (and in the case of functions, arity); its value is a whitespace-separated sequence 
                  of tokens each of which is either a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> or 
                  a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NamedFunctionRef" xlink:type="simple">NamedFunctionRef</xnt>. (Examples are
                  <code>*</code>, <code>p:*</code>, <code>*:local</code>, <code>p:local</code>, and <code>p:local#2</code>.)</p><p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet functions, 
                  and distinguishes functions with the same name and different arity.</p><p>The <code>visibility</code> attribute defines the exposed visibility of the 
                  selected components.</p><p>If a <termref def="dt-component">component</termref> is matched by more
                  than one <elcode>xsl:expose</elcode> element in the package manifest, 
                  then its exposed visibility is determined by the best matching <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> or 
                  <code>LiteralFunctionItem</code>. The rules are similar to those for
                  <termref def="dt-template-rule">template rules</termref>:</p><ulist><item><p>A token in the form of a LiteralFunctionItem (for example,
                        <code>f:price#1</code>) has higher priority
                        than any NameTest.</p></item><item><p>Next, any match that has a lower <termref def="dt-default-priority">default
                        priority</termref> than the <termref def="dt-default-priority">default
                           priority</termref> of another match is ignored.</p></item><item><p diff="chg" at="G">If several matches have the same <termref def="dt-default-priority">default
                     priority</termref> (which can happen if the same value is repeated, or if 
                        one of the NameTests takes the form
                        <code>*:local</code> and the other takes the form <code>prefix:*</code>),
                        then the <elcode>xsl:expose</elcode> element that appears last in 
                        document order within the package manifest is used.</p></item></ulist><p>If no <elcode>xsl:expose</elcode> element matches a component, then the 
                  <termref def="dt-visibility">visibility</termref> of the component is its
               <termref def="dt-potential-visibility">potential visibility</termref>.</p><p>Otherwise, the <termref def="dt-visibility">visibility</termref> of the component depends on its
               potential visibility and its exposed visibility as defined by the following table. In this
               table, the value N/P means "not permitted".</p><table border="1" cellpadding="2" summary="relationship of exposed visibility to potential visibility"><thead><tr><th rowspan="2" colspan="1">Exposed visibility</th><th colspan="4" rowspan="1">Potential visibility</th></tr><tr><th rowspan="1" colspan="1">public</th><th rowspan="1" colspan="1">private</th><th rowspan="1" colspan="1">final</th><th rowspan="1" colspan="1">abstract</th></tr></thead><tbody><tr><th rowspan="1" colspan="1">public</th><td rowspan="1" colspan="1">public</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">private</th><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">final</th><td rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">abstract</th><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">abstract</td></tr><!--<tr>
                        <th>hidden</th>
                        <td>private</td>
                        <td>private</td>
                        <td>private</td>
                        <td>N/P</td>
                     </tr>--></tbody></table><p>
                  <error spec="XT" type="static" class="SE" code="3010"><p>It is a <termref def="dt-static-error">static error</termref> if the exposed visibility of a component is inconsistent
                        with its potential visibility, as defined in the above table, unless the token that
                        matches the component is a wildcard, in which case it is treated as not matching that component.</p></error> 
               </p><p>
                  <error spec="XT" type="static" class="SE" code="3020"><p>It is a <termref def="dt-static-error">static error</termref> if an <elcode>xsl:expose</elcode> element matches no
                        components in the containing package, unless the tokens in the <code>names</code>
                        attribute are all wildcards.</p></error>
               </p><!--<p><termdef id="dt-external-visibility" term="external visibility">The <term>external visibility</term> of
               a component occurrence within a package <var>P</var> determines how the component may be used in a 
                  package that uses <var>P</var>.</termdef></p>--><!--<p>A package contains a set of <termref def="dt-component">components</termref>, 
                  as described in the previous
               section. It exposes the same set of components, except that each component may be exposed
               with a reduced visibility. Specifically, the table below relates the 
               <termref def="dt-internal-visibility">internal visibility</termref> of the component
                  occurrence within the package to the default value for its 
                  <termref def="dt-external-visibility">external visibility</termref>,
               and to the permitted values of its external visibility that may be selected using the
               <elcode>xsl:expose</elcode> element.</p>
               
                              
               <table border="1" cellpadding="2">
                  <thead>
                     <tr>
                        <th>Internal Visibility within Package</th>
                        <th>Default External Visibility</th>
                        <th>External Visibility (allowed values)</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>public</td>
                        <td>private</td>
                        <td>public, private, final, hidden</td>
                     </tr>
                     <tr>
                        <td>private</td>
                        <td>hidden</td>
                        <td>hidden</td>
                     </tr>
                     <tr>
                        <td>final</td>
                        <td>private</td>
                        <td>final, private, hidden</td>
                     </tr>
                     <tr>
                        <td>abstract</td>
                        <td>abstract</td>
                        <td>abstract</td>
                     </tr>
                     <tr>
                        <td>hidden</td>
                        <td>hidden</td>
                        <td>hidden</td>
                     </tr>
                  </tbody>
               </table>--></div4><div4 id="accepting-components"><head>Accepting Components</head><p>When a package <var>Q</var> uses a package <var>P</var>, by virtue of
                  an <elcode>xsl:use-package</elcode> element in the 
                  <termref def="dt-package-manifest">package manifest</termref> of <var>Q</var>,
                  then <var>Q</var> will contain
               a <termref def="dt-component">component</termref> corresponding to every component
               in <var>P</var>. The <termref def="dt-potential-visibility">potential visibility</termref>
                  of the component within <var>Q</var>
                  depends on the <termref def="dt-visibility">visibility</termref> of the component
                  in <var>P</var>, optionally modified by two elements that may
               appear as children of the <elcode>xsl:use-package</elcode> element, 
                  namely <elcode>xsl:accept</elcode> and
               <elcode>xsl:override</elcode>.</p><p>For every component <var>C(P)</var> in package <var>P</var> that is not matched
                  by any <elcode>xsl:override</elcode> or <elcode>xsl:accept</elcode>
               element in the package manifest of <var>Q</var>, there will be a corresponding
                  component <var>C(Q)</var> in package <var>Q</var> that has the same
                  <termref def="dt-symbolic-identifier">symbolic identifier</termref>
                  and <termref def="dt-declaration">declaration</termref> as <var>C(P)</var>.
                  The <termref def="dt-potential-visibility">potential visibility</termref> of <var>C(Q)</var> 
                  will be the same as the (actual)
                  <termref def="dt-visibility">visibility</termref> of <var>C(P)</var>, except that
                  where the <termref def="dt-visibility">visibility</termref> of <var>C(P)</var> is <code>private</code>,
                  the <termref def="dt-potential-visibility">potential visibility</termref> of <var>C(Q)</var> will
                  be <code>hidden</code>. The (actual) visibility
                  of <var>C(Q)</var> depends both on its <termref def="dt-potential-visibility">potential visibility</termref>
                  and its <termref def="dt-exposed-visibility">exposed visibility</termref>, as described
                  in <specref ref="exposing-components"/>.</p><p>A component <var>C(P)</var> in package <var>P</var> whose 
                  <termref def="dt-visibility">visibility</termref> is <code>hidden</code>
                  will never be matched by an <elcode>xsl:override</elcode> or <elcode>xsl:accept</elcode>
                  element in the package manifest of <var>Q</var>, and therefore <var>Q</var>
                  will contain a <code>hidden</code> component <var>C(Q)</var> corresponding to <var>C(P)</var>.</p><!--<p>If there is a declaration of a component within <elcode>xsl:override</elcode>, then the 
                  component that is overridden remains in the using package with internal visibility 
                  <code>hidden</code> and this is supplemented by the overriding component which appears with the
                  visibility given in its declaration.
                  In this case any <elcode>xsl:accept</elcode> element that matches the component is ignored.
                  For more details of <elcode>xsl:override</elcode> see <specref ref="package-overriding-components"/>.</p>
                --><e:element-syntax name="accept"><e:attribute name="component" required="yes"><e:constant value="template"/><e:constant value="function"/><e:constant value="attribute-set"/><e:constant value="variable"/><e:constant value="mode"/></e:attribute><e:attribute name="names" required="yes"><e:data-type name="tokens"/></e:attribute><e:attribute name="visibility" required="yes"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/><e:constant value="hidden"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="use-package"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:accept</elcode> element has the same syntax as <elcode>xsl:expose</elcode>, and very similar
               semantics. Whereas <elcode>xsl:expose</elcode> allows a package to restrict the visibility of its own
               components to other (using) packages, <elcode>xsl:accept</elcode> allows a package to restrict the
               visibility of components exposed by a package that it uses. This may be necessary if, for example,
               it uses two different packages whose component names conflict. It may also simply be good practice if
               the package author knows that only a small subset of the functionality of a used package is required.</p><p>The rules for determining whether an <elcode>xsl:accept</elcode> element matches a particular
                  component, and for which element to use if there are several matches, are the same as the
                  rules for the <elcode>xsl:expose</elcode> element.</p><p>
                  <error spec="XT" type="static" class="SE" code="3030"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if an <elcode>xsl:accept</elcode> element matches no
                        components in the used package, unless the tokens in its <code>names</code> attribute
                        are all wildcards.</p></error>
               </p><p>In the absence of a matching <elcode>xsl:override</elcode> element 
                  (see <specref ref="package-overriding-components"/>),
                   the <termref def="dt-potential-visibility">potential visibility</termref> of
               a component that matches an <elcode>xsl:accept</elcode> element depends both on the
                  <code>visibility</code> attribute of the best-matching <elcode>xsl:accept</elcode> element
               and on the (actual) <termref def="dt-visibility">visibility</termref> of the corresponding
               component in the used package, according to the following table. In this table the entry
               "N/P" means "not permitted".</p><table border="1" cellpadding="2" summary="relationship of the visibility given in xsl:accept to visibility in the used package"><thead><tr><th rowspan="2" colspan="1">Visibility in <elcode>xsl:accept</elcode> element</th><th colspan="4" rowspan="1">Visibility in used package</th></tr><tr><th rowspan="1" colspan="1">public</th><th rowspan="1" colspan="1">private</th><th rowspan="1" colspan="1">final</th><th rowspan="1" colspan="1">abstract</th></tr></thead><tbody><tr><th rowspan="1" colspan="1">public</th><td rowspan="1" colspan="1">public</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">private</th><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">final</th><td rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">N/P</td></tr><tr><th rowspan="1" colspan="1">abstract</th><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">abstract</td></tr><tr><th rowspan="1" colspan="1">hidden</th><td rowspan="1" colspan="1">hidden</td><td rowspan="1" colspan="1">N/P</td><td rowspan="1" colspan="1">hidden</td><td rowspan="1" colspan="1">N/P</td></tr></tbody></table><p>
                  <error spec="XT" type="static" class="SE" code="3040"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if the visibility assigned to a component
                        by an <elcode>xsl:accept</elcode> element is incompatible with the
                        visibility of the corresponding component in the used package, as defined
                        by the above table, unless the token that matches the component name is a wildcard,
                        in which case the <elcode>xsl:accept</elcode> element is treated as not matching
                        that component.</p></error>
               </p><p>
                  <error spec="XT" type="static" class="SE" code="3050"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if the <elcode>xsl:use-package</elcode> elements in a
                        <termref def="dt-package-manifest">package manifest</termref> cause two or more 
                        <termref def="dt-homonymous">homonymous</termref> 
                        components to be accepted with a visibility other than <code>hidden</code>.</p></error>
               </p><p>Conflicts between the components accepted from used packages and those declared within
               the package itself are handled as follows:</p><olist><item><p>If the conflict is between two components both declared within the package
                     itself, then it is resolved by the rules relating to 
                     <termref def="dt-import-precedence">import precedence</termref> defined for each kind
                     of component.</p></item><item><p>If the conflict is between two components both accepted from used packages, 
                     or between a component declared within the package and an
                     accepted component, then a static error occurs.</p></item></olist><note><p>To override a component accepted from a used package, the overriding declaration
               must appear as a child of the <elcode>xsl:override</elcode> element.</p></note><note><p>There is no rule that prevents a function (say) being declared in the using
               package with the same name as a <code>private</code> function in the used package. This
               does not create a conflict, since all references in the used package are bound to one
               function and all those in the using package are bound to another.</p></note></div4><div4 id="package-overriding-components"><head>Overriding Named Components from a Used Package</head><p><termdef id="dt-override" term="override">A component in a using package 
                  may <term>override</term> a component in a used package, provided that the 
               <termref def="dt-visibility">visibility</termref> of the component in the used
                  package is either <code>abstract</code> or <code>public</code>. The overriding
               declaration is written as a child of the <elcode>xsl:override</elcode> element, which in turn
               appears as a child of <elcode>xsl:use-package</elcode>.</termdef></p><note><p>This mechanism is distinct from the mechanism for overriding declarations within
                  the same package by relying on 
                  <termref def="dt-import-precedence">import precedence</termref>. 
                  It imposes stricter rules: the
                  overriding component is required to be type-compatible with the component that
                  it overrides.</p></note><p>If the used package <var>P</var> contains a <termref def="dt-component">component</termref>
               <var>C(P)</var> and the <elcode>xsl:use-package</elcode> element contains an <elcode>xsl:override</elcode>
               element which contains a declaration <var>D</var> whose 
                  <termref def="dt-symbolic-identifier">symbolic identifier</termref> matches the symbolic
                  identifier of <var>C(P)</var>, then the using package <var>Q</var> will contain
               a component whose declaration is D, whose symbolic identifier is that of D, and whose
               <termref def="dt-potential-visibility">potential visibility</termref> is equal to the value of 
               the <code>visibility</code> attribute of <var>D</var>, or <code>private</code> if this is
               absent.</p><p>If the overridden component <var>C(P)</var> has visibility <code>public</code>
                  then the using package <var>Q</var> will also contain a component <var>C′(Q)</var>
                  whose declaration is the same as the declaration of <var>C(P)</var> and whose 
                  <termref def="dt-visibility">visibility</termref>
               is <code>hidden</code>. This component is used as the target of a binding for the
               symbolic reference <code>xsl:original</code> described below.</p><p>Other than its appearance as a child of <elcode>xsl:override</elcode>, the overriding declaration
               is a normal <elcode>xsl:function</elcode>, <elcode>xsl:template</elcode>, <elcode>xsl:variable</elcode>,
               <elcode>xsl:param</elcode>, <elcode>xsl:attribute-set</elcode>, or <elcode>xsl:mode</elcode> element.
                  In the case of <elcode>xsl:variable</elcode> and,
                  <elcode>xsl:param</elcode>, the variable that is declared is a 
                  <termref def="dt-global-variable">global variable</termref>.</p><p>The <termref def="dt-potential-visibility">potential visibility</termref> of the 
                  overriding component in the using package is defined by the <code>visibility</code>
               attribute appearing on the overriding declaration.</p><p>The overriding declaration must not be <termref def="dt-homonymous">homonymous</termref> with
               any other declaration in the using package, regardless of 
                  <termref def="dt-import-precedence">import precedence</termref>, including any other
                  overriding declaration in the package manifest of the using package.</p><e:element-syntax name="override"><e:choice repeat="zero-or-more"><e:element name="template"/><e:element name="function"/><e:element name="variable"/><e:element name="param"/><e:element name="attribute-set"/><!--<e:element name="mode"/>--></e:choice><e:allowed-parents><e:parent name="use-package"/></e:allowed-parents></e:element-syntax><p>
                  <error spec="XT" type="static" class="SE" code="3060"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if the component referenced by an <elcode>xsl:override</elcode>
                        declaration has <termref def="dt-visibility">visibility</termref>
                        other than <code>public</code> or <code>abstract</code></p></error>
               </p><p>A package is executable if and only if it contains no <termref def="dt-component">component</termref> whose <termref def="dt-visibility">visibility</termref> is <code>abstract</code>.
               A package that is not executable is not a <termref def="dt-stylesheet">stylesheet</termref>, and therefore
               cannot be nominated as the stylesheet to be used when initiating a transformation.</p><note><p>In other words, if a component is declared as abstract, then some package that uses the declaring
                  package of that component directly or indirectly
                  must override that component with one that is not abstract. It is not necessary for the
                  override to happen in the immediately using package.</p></note><p>
                  <error spec="XT" type="static" class="SE" code="3070"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if the signature of an overriding component is not 
                        <termref def="dt-compatible">compatible</termref> with the 
                        signature of the component that
                        it is overriding.</p></error>
               </p><p><termdef id="dt-compatible" term="compatible">The signatures of two <termref def="dt-component">components</termref>
               are <term>compatible</term> if they present the same interface to the user of the component. The
               rules depend on the kind of component.</termdef></p><p>The compatibility rules for each kind of component are as follows:</p><ulist><item><p>Two attribute sets are compatible if they have the same name.</p></item><item><p>Two functions are compatible if they have the same name, 
                     if the types of the arguments are pairwise identical and
                     if the return types are identical.</p></item><item><p>Two named templates are compatible if they have the same name, 
                     if the return types are identical, and if the declared
                     parameters on the overriding template include one parameter matching each parameter 
                     on the overridden template by having identical effective values for its <code>name</code>,
                     <code>as</code>, <code>required</code>, and <code>tunnel</code> attributes; in addition
                     the overriding template may define additional parameters provided they specify 
                     <code>required="no"</code>.</p></item><item><p>Two variables are compatible if they have the same name and their types are identical.
                     A variable may override
                     a parameter or vice-versa, and the value of the <code>required</code> attribute may differ.</p></item></ulist><p>Modes are not overridable, so the <elcode>xsl:mode</elcode> declaration cannot appear as a child
               of <elcode>xsl:override</elcode>.</p><p>Within the declaration of an overriding component (that is, a component whose declaration 
                  is a child of <elcode>xsl:override</elcode>), where the overridden component has
                  <code>public</code> visibility, it is possible to use the name 
                  <code>xsl:original</code> as a <termref def="dt-symbolic-reference">symbolic reference</termref>
                  to the overridden component:
               </p><ulist><item><p>Within an overriding named template, <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>
                  may be used to call the overridden named template.</p></item><item><p>Within an overriding stylesheet function, <code>xsl:original()</code> may be used
                     to call the overridden stylesheet function.</p></item><item><p>Within an overriding global variable or parameter, <code>$xsl:original</code> may be used
                     to reference the overridden global variable or parameter.</p></item><item><p>Within an overriding attribute set, <code>[xsl:]use-attribute-set="xsl:original"</code> may be used
                     to reference the overridden attribute set.</p></item></ulist><p>Within the overriding component <var>C(Q)</var>, this symbolic reference is bound to the hidden
                  component <var>C′(Q)</var> described earlier, whose declaration is that of the component
                  <var>C(P)</var> in the used package. The static context for the overriding declaration is
                  augmented to include a component of the relevant kind (function, named template, attribute set, 
                  or variable) with the name <code>xsl:original</code>.</p></div4><div4 id="component-references"><head>Binding References to Components</head><p><termdef id="dt-reference-resolution" term="reference resolution">The process of 
                  identifying the <termref def="dt-component">component</termref> to which a 
                  <termref def="dt-symbolic-reference">symbolic reference</termref> applies 
                  (possibly chosen from several 
                  <termref def="dt-homonymous">homonymous</termref> alternatives) is called
                  <term>reference binding</term>.</termdef> A reference is called <term>bound</term> if the
                  component to which it applies has been identified and fixed, 
                  and is <term>unbound</term> otherwise (that is, if it exists only in the form of a
                  <termref def="dt-symbolic-identifier">symbolic identifier</termref>).</p><p>Reference resolution for the components in a package occurs conceptually 
                  after a package has been fully defined and before the processing of
                  any other package that uses it.</p><note><p>If packages are separately compiled, then reference resolution is likely
               to form part of the compilation process.</p></note><p>When reference resolution is performed for a <termref def="dt-component">component</termref> <var>C</var>,
               each symbolic reference <var>R</var> that is present in the 
                  <termref def="dt-declaration">declaration</termref> of <var>C</var>
                  is processed as follows:</p><olist><item><p>If <var>C</var> already contains a binding for <var>R</var> then this
                  binding is retained.</p></item><item><p>If <var>C</var> contains no binding for <var>R</var>
                  then the processor attempts to locate a component in the containing package
                  of <var>C</var> whose visibility is not <code>hidden</code> and whose symbolic name 
                     matches <var>R</var>. If there is no such
                  component, then a static error is reported as described elsewhere in this specification.
                  There can never be more than one. Call the located component <var>D</var>. If
                     <var>D</var> has <termref def="dt-visibility">visibility</termref>
                  <code>private</code> or <code>final</code>, then <var>C</var> acquires a binding
                  that associates the symbolic reference <var>R</var> with the component <var>D</var>.
                  Otherwise, the reference remains unbound.</p></item></olist><p>When a package <var>P</var> is used by another package <var>Q</var>, then
               <var>Q</var> will accept components corresponding to the components in <var>P</var>,
               as described in previous sections. Until reference resolution is performed for <var>Q</var>,
               these components will have the same bindings as their corresponding components from <var>P</var>:
                  a symbolic reference that was bound for a component in <var>P</var> will retain the same binding,
                  and a symbolic reference that was unbound in <var>P</var> will remain unbound in the corresponding
               component in <var>Q</var>. Subsequently, when reference resolution is performed for package
               <var>Q</var>, these symbolic references may become bound, perhaps to components whose declaration
               is in <var>Q</var> or in some other package.</p><p>When reference resolution is performed on a package that is intended to be used as a 
                  <termref def="dt-stylesheet">stylesheet</termref>
                  (that is, for the top-level package), symbolic references to 
                  components whose visibility is <code>public</code> are bound in the same way as
                  references to components whose visibility is <code>private</code> or <code>final</code>.
                  At this stage there must be no symbolic references
                  referring to components whose visibility is <code>abstract</code> (that is, an 
                  implementation must be provided for every abstract component).
                  </p><p>
                  <error spec="XT" type="static" class="SE" code="3080"><p>It is a <termref def="dt-static-error">static error</termref> 
                        if a top-level package intended for execution (as distinct from a library
                        package) contains symbolic references
                        referring to components whose visibility is <code>abstract</code>.</p></error>
               </p><note><p>Unresolved references are allowed at the module level but not at the package level. A stylesheet module can contain references to
               components that are satisfied only when the module is imported into another module that declares
               the missing component.</p></note><note><p>The process of resolving references (or linking) is critical to an implementation that uses separate
                  compilation. One of the aims of these rules
                  is to ensure that when compiling a package, it is always possible to determine the signature
                  of called functions, templates, and other components. A further aim is to establish
                  unambiguously in what circumstances components can be overridden, so that compilers know
                  when it is possible to perform optimizations such as inlining of function and variable
                  references.</p><p>Suppose a public template <var>T</var> calls a private function <var>F</var>. When the package
               containing these two components is referenced by a using package, the template remains public, while
               the function becomes hidden. Because the function becomes hidden, it can no longer conflict with
               any other function of the same name, or be overridden by any other function; at this stage the compiler knows exactly
               which function <var>T</var> will be calling, and can perform optimizations based on this knowledge.</p></note></div4></div3><div3 id="modes-and-packages"><head>Overriding Template Rules from a Used Package</head><p>The rules in the previous section apply to named components including 
               functions, named templates, global variables, and named attribute sets.
               The rules for <termref def="dt-mode">modes</termref>, and the 
               <termref def="dt-template-rule">template rules</termref> appearing within a mode, are slightly different.</p><p>The unnamed mode is local to a package: in effect, each package has its own private unnamed mode, and the
            unnamed mode of one package does not interact with the unnamed mode of any other package.</p><p>A named mode may be
            declared in an <elcode>xsl:mode</elcode> declaration as being either <code>public</code>, <code>private</code>,
               or <code>final</code>. The values of the <code>visibility</code> attribute are interpreted as follows:</p><table border="1" cellspacing="2" summary="visibility values for named modes, and their meaning"><thead><tr><th rowspan="1" colspan="1">Value</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">public</td><td rowspan="1" colspan="1">A <term>using</term> package may use <elcode>xsl:apply-templates</elcode>
                  to invoke templates in this mode; it may also declare additional template rules in this mode,
                  which are selected in preference to template rules in the used package. These may appear only
               as children of the <elcode>xsl:override</elcode> element within the <elcode>xsl:use-package</elcode> element.</td></tr><tr><td valign="top" rowspan="1" colspan="1">private</td><td rowspan="1" colspan="1">A <term>using</term> package may neither reference the mode nor provide additional templates
                  in this mode; the
                  name of the mode is not even visible in the using package, so no such attempt is possible.
                  The using package can use the same name for its own modes without risk of conflict. </td></tr><tr><td valign="top" rowspan="1" colspan="1">final</td><td rowspan="1" colspan="1">A <term>using</term> package may  use <elcode>xsl:apply-templates</elcode>
                  to invoke templates in this mode, but it must not provide additional template rules in this mode.
                  </td></tr></tbody></table><p>As with other named components, an <elcode>xsl:use-package</elcode> declaration may contain 
               an <elcode>xsl:expose</elcode> element to control the visibility of a mode acquired from the
<term>used</term> package. The allowed values of its <code>visibility</code> attribute are <code>public</code>,
<code>private</code>, <code>final</code>, and <code>hidden</code>.</p><p>The <elcode>xsl:mode</elcode> declaration itself must not be overridden. A using package must not contain
            an <elcode>xsl:mode</elcode> declaration whose name matches that of a <code>public</code>
            or <code>final</code> <elcode>xsl:mode</elcode> component accepted from a used package.</p><p>The <elcode>xsl:expose</elcode> and <elcode>xsl:accept</elcode> elements may be used to
            reduce the visibility of a mode in a using package; the same rules apply in general, though
            some of the rules are not applicable because, for example, modes cannot be <code>abstract</code>.</p><p>It is not possible for a package to combine the template rules from
               two other packages into a single mode. When <elcode>xsl:apply-templates</elcode> is used without specifying
               a mode, the chosen template rules will always come from the same package; when it is used with a named mode,
               then they will come from the package where the mode is defined, or any package that uses that package and adds
               template rules to the mode. If two template rules defined in different packages match the same node, then 
               the rule in the using package wins over any rule in the used package; this decision is made before taking
               other factors such as import precedence and priority into account.</p><p>A static error occurs if two modes with the same name are visible within a package, either because they
            are both declared within the package, or because one is declared within the package and the other is acquired
            from a used package, or because both are accepted from different used packages.</p><p>The rules for matching template rules by precedence and priority operate as normal, with the addition
               that template rules declared within an <elcode>xsl:use-package</elcode> element have higher precedence
               than any template rule declared in the used package.</p><p>When a template rule specifies <code>match="#all"</code> this is interpreted as meaning all modes declared
            implicitly or explicitly within the <termref def="dt-declaring-package">declaring package</termref>
               of the <elcode>xsl:template</elcode> element. </p><note><p>If existing XSLT code has been written to use template rules in the unnamed mode,
             a convenient way to incorporate this code into a library package is to add a stub module that defines
             a new named <code>public</code> or <code>final</code> mode, in which there is a single
                template rule whose content is the single instruction
                <code>&lt;xsl:apply-templates/&gt;</code>. This in effect redirects <elcode>xsl:apply-templates</elcode>
             instructions using the named mode to the rules defined in the unnamed mode.</p></note></div3><div3 id="package-local-declarations"><head>Declarations Local to a Package</head><p>Declarations of <termref def="dt-key">keys</termref>, 
                  <termref def="dt-decimal-format">decimal formats</termref>, 
                  namespace aliases (see <specref ref="namespace-aliasing"/>), 
                  <termref def="dt-output-definition">output definitions</termref>, and 
                  <termref def="dt-character-map">character maps</termref>
                  within a package have local scope within that package — they are all effectively private.
                  The elements that declare these constructs do not have a <code>visibility</code> attribute.
                  The unnamed decimal format and the unnamed output format are also local to a package.</p><p>If <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode> declarations appear
                  within a library package, they only affect calls to the <xfunction>doc</xfunction> or 
                  <function>document</function> functions appearing within that package. Such a declaration
                  within the main package additionally affects 
                  stripping of whitespace in the principal source document.</p><p>An <elcode>xsl:decimal-format</elcode> declaration within a package applies only to calls
                  on <xfunction>format-number</xfunction>
                  appearing within that package.</p><p>An <elcode>xsl:namespace-alias</elcode> declarations within a package applies only
               to literal result elements within the same package.</p><p>An <elcode>xsl:import-schema</elcode> declaration within a package adds the names of the imported
                  schema components to the static context for that package only; these names are effectively private, 
                  in the sense that they do not become available for use in any other packages. However, the names of
                  schema components must be consistent across the stylesheet as a whole: it is not possible for two
                  different packages within a stylesheet to use a type-name such as "part-number" to refer to different
                  schema-defined simple or complex types.</p><p>Type names used in the interface of public components in a package (for example, in the arguments of
                  a function) must be respected by callers of those components, in the sense that the caller must supply
                  values of the correct type. Often this will mean that the using component, if it contains calls on such
                  interfaces, must itself import the necessary schema components. However, the requirement for an explicit
                  schema import applies only where the package contains explicit use of the names of schema components required
                  to call such interfaces.</p><note><p>For example, suppose a library package contains a function which requires an argument of type
                  <code>mfg:part-number</code>. The caller of this function must supply an argument of the correct
                  type, but does not need to import the schema unless it explicitly uses the schema type name 
                  <code>mfg:part-number</code>. If it obtains an instance of this type from outside the package,
                  for example as the result of another function call, then it can supply this instance to the acquired
                  function even though it has not imported a schema that defines this type.</p></note><p>At execution time, the schema available for validating
                  instance documents contains (at least) the union of the schema components imported into all constituent
                  packages of the stylesheet.</p></div3><div3 id="xquery-packages"><head>Using an XQuery Library Package</head><p><emph>This section is a stub: it describes work in progress.</emph></p><p>It is intended to provide a variant of <elcode>xsl:use-package</elcode>
               that allows an XQuery library module to be used in exactly the same way as
               a package written in XSLT.</p><p>The syntax for doing this is to be defined.</p><p>Such a package will contain functions and global variables/parameters only (no
               attribute sets or templates). These may be public or private, depending on their
               XQuery annotations (they cannot be final or abstract). The effect of using functions
               that are updating, or nondeterministic is implementation-defined.</p><p>The same rules for consistency of imported schema components apply as when 
               using an XSLT package.</p></div3></div2><div2 id="stylesheet-modules"><head>Stylesheet Modules</head><p>
               <termdef id="dt-stylesheet-module" term="stylesheet module">A <phrase diff="chg" at="I"><termref def="dt-package">package</termref></phrase> consists of one or more <term>stylesheet
                     modules</term>, each one forming all or part of an XML document.</termdef>
            </p><note><p>A stylesheet module is represented by an XDM element node (see <bibref ref="xpath-datamodel-30"/>). In the case of a standard stylesheet module, this will
                  be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element. In
                  the case of a simplified stylesheet module, it can be any element (not in the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has an
                  <code>xsl:version</code> attribute.</p><p>Although stylesheet modules will commonly be maintained in the form of documents
                  conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
                  representation. As with <termref def="dt-source-tree">source trees</termref>, the way
                  in which stylesheet modules are constructed, from textual XML or otherwise, is
                  outside the scope of this specification.</p></note><p>A stylesheet module is either a standard stylesheet module or a simplified stylesheet
               module:</p><ulist><item><p>
                     <termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
                        <term>standard stylesheet module</term> is a tree, or part of a tree,
                        consisting of an <elcode>xsl:stylesheet</elcode> or
                        <elcode>xsl:transform</elcode> element (see <specref ref="stylesheet-element"/>) together with its descendant nodes and
                        associated attributes and namespaces.</termdef>
                  </p></item><item><p>
                     <termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet module">A <term>simplified stylesheet module</term> is a tree, or part of a tree,
                        consisting of a <termref def="dt-literal-result-element">literal result
                           element</termref> together with its descendant nodes and associated
                        attributes and namespaces. This element is not itself in the XSLT namespace,
                        but it <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute,
                        which implies that it <rfc2119>must</rfc2119> have a namespace node that
                        declares a binding for the XSLT namespace. For further details see <specref ref="simplified-stylesheet"/>. </termdef>
                  </p></item></ulist><p>Both forms of stylesheet module (standard and simplified) can exist either as an entire
               XML document, or embedded as part of another XML document, typically but not necessarily
               a source document that is to be processed using the stylesheet.</p><p>
               <termdef id="dt-standalone-stylesheet-module" term="standalone stylesheet module">A
                  <term>standalone stylesheet module</term> is a stylesheet module that comprises
                  the whole of an XML document.</termdef>
            </p><p>
               <termdef id="dt-embedded-stylesheet-module" term="embedded stylesheet module">An
                  <term>embedded stylesheet module</term> is a stylesheet module that is embedded
                  within another XML document, typically the source document that is being
                  transformed.</termdef> (see <specref ref="embedded"/>).</p><p>There are thus four kinds of stylesheet module:</p><slist><sitem>standalone standard stylesheet modules</sitem><sitem>standalone simplified stylesheet modules</sitem><sitem>embedded standard stylesheet modules</sitem><sitem>embedded simplified stylesheet modules</sitem></slist></div2><div2 id="stylesheet-element"><head>Stylesheet Element</head><e:element-syntax name="stylesheet"><e:attribute name="id"><e:data-type name="id"/></e:attribute><e:attribute name="extension-element-prefixes"><e:data-type name="prefixes"/></e:attribute><e:attribute name="exclude-result-prefixes"><e:data-type name="prefixes"/></e:attribute><e:attribute name="version" required="yes"><e:data-type name="decimal"/></e:attribute><e:attribute name="xpath-default-namespace"><e:data-type name="uri"/></e:attribute><e:attribute name="default-validation"><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="default-collation"><e:data-type name="uris"/></e:attribute><e:attribute name="default-mode"><e:data-type name="eqname"/><e:constant value="#unnamed"/></e:attribute><e:attribute name="input-type-annotations"><e:constant value="preserve"/><e:constant value="strip"/><e:constant value="unspecified"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="use-package"/><e:element repeat="zero-or-more" name="import"/><e:model name="other-declarations"/></e:sequence><e:allowed-parents/></e:element-syntax><e:element-syntax name="transform"><e:attribute name="id"><e:data-type name="id"/></e:attribute><e:attribute name="extension-element-prefixes"><e:data-type name="prefixes"/></e:attribute><e:attribute name="exclude-result-prefixes"><e:data-type name="prefixes"/></e:attribute><e:attribute name="version" required="yes"><e:data-type name="decimal"/></e:attribute><e:attribute name="xpath-default-namespace"><e:data-type name="uri"/></e:attribute><e:attribute name="default-validation"><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="default-collation"><e:data-type name="uris"/></e:attribute><e:attribute name="default-mode"><e:data-type name="eqname"/><e:constant value="#unnamed"/></e:attribute><e:attribute name="input-type-annotations"><e:constant value="preserve"/><e:constant value="strip"/><e:constant value="unspecified"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="use-package"/><e:element repeat="zero-or-more" name="import"/><e:model name="other-declarations"/></e:sequence><e:allowed-parents/></e:element-syntax><p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode> element in
               an XML document. <elcode>xsl:transform</elcode> is allowed as a synonym for
                  <elcode>xsl:stylesheet</elcode>; everything this specification says about the
                  <elcode>xsl:stylesheet</elcode> element applies equally to
                  <elcode>xsl:transform</elcode>.</p><p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must</rfc2119> have a
                  <code>version</code> attribute, indicating the version of XSLT that the stylesheet
               module requires.</p><p>
               <error spec="XT" type="static" class="SE" code="0110"><p>The value of the <code>version</code> attribute <rfc2119>must</rfc2119> be a
                     number: specifically, it <rfc2119>must</rfc2119> be a valid instance of the
                     type <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p></error>
            </p><p diff="chg" at="D">The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 3.0, the value <rfc2119>should</rfc2119> normally be
               set to <code>3.0</code>. If the value is numerically less than <code>3.0</code>, the
               stylesheet is processed using the rules for <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
               (see <specref ref="backwards"/>). If the value is numerically greater than
                  <code>3.0</code>, the stylesheet is processed using the rules for <termref def="dt-forwards-compatible-behavior"/> (see
                  <specref ref="forwards"/>).</p><!--For this version of XSLT, the value <rfc2119>should</rfc2119> normally
be <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code>.  A value of <code>1.0</code> indicates that the stylesheet module
was written with the intention that it <rfc2119>should</rfc2119> be processed using an XSLT 1.0 processor,
               <phrase diff="add" at="D">while a value of <code>2.0</code> indicates that the module
                  was intended to be processed using an XSLT 2.0 processor</phrase>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref>
that specifies <code>[xsl:]version="1.0"</code> in the
outermost element of the <termref def="dt-principal-stylesheet-module">principal
stylesheet module</termref> (that is, <code>version="1.0"</code> in the case of a 
<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>, or
<code>xsl:version="1.0"</code> in the case of a <termref def="dt-simplified-stylesheet-module">simplified
stylesheet module</termref>) is submitted to an XSLT <phrase diff="chg" at="A">3.0</phrase> processor, the processor <rfc2119>should</rfc2119> output
a warning advising the user of possible incompatibilities, unless the user has requested otherwise. 
The processor <rfc2119>must</rfc2119> then process the stylesheet
using the rules for <termref def="dt-backwards-compatible-behavior"/>.
These rules require that if the processor does not support 
<termref def="dt-backwards-compatible-behavior"/>, it <rfc2119>must</rfc2119>
signal an error and <rfc2119>must not</rfc2119> execute the transformation.</p>
            <p>When the value of the <code>version</code> attribute is greater than <phrase diff="chg" at="A">3.0</phrase>, 
<termref def="dt-forwards-compatible-behavior">forwards compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>
            <note>
               <p>XSLT 1.0 allowed the <code>[xsl:]version</code> attribute to take any numeric value,
and specified that if the value was not equal to 1.0, the <termref def="dt-stylesheet">stylesheet</termref> would be executed in
forwards compatible mode. XSLT 2.0 <phrase diff="chg" at="A">and 3.0</phrase>continue to allow the attribute to take any unsigned decimal value.
A software product that includes both an XSLT <phrase diff="chg" at="A">3.0</phrase> processor and
<phrase diff="chg" at="A">a processor supporting a different XSLT version</phrase> (or that can execute as either) may use the <code>[xsl:]version</code> attribute to 
decide which processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT <phrase diff="chg" at="A">3.0</phrase> processor, the value
<code>1.0</code> is taken to indicate that the stylesheet module
was written with XSLT 1.0
in mind: if this value appears on the outermost element of the principal stylesheet module then
an XSLT <phrase diff="chg" at="A">3.0</phrase> processor will either reject the stylesheet or execute it in backwards compatible
mode, as described above. 
Setting <code>version="<phrase diff="chg" at="A">3.0</phrase>"</code> indicates that the <termref def="dt-stylesheet">stylesheet</termref> is to be
executed with neither backwards nor forwards compatible behavior enabled. Any other value less than
<code>2.0</code> enables backwards compatible behavior, while any value greater than <code>
                     <phrase diff="chg" at="A">3.0</phrase>
                  </code>
enables forwards compatible behavior.</p>
               
               <p>When developing a <termref def="dt-stylesheet">stylesheet</termref> that is designed to execute under either XSLT 1.0 or XSLT 2.0,
the recommended practice is to create two alternative <termref def="dt-stylesheet-module">stylesheet modules</termref>, 
one specifying
<code>version="1.0"</code>, and the other specifying <code>version="2.0"</code>; these
modules can use <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> to incorporate 
the common code. When running under an XSLT 1.0 processor, the <code>version="1.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>;
when running under an XSLT 2.0 processor, the <code>version="2.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>.
Stylesheet modules that are included or imported should specify <code>version="2.0"</code> if they make use of XSLT 2.0 facilities,
and <code>version="1.0"</code> otherwise.</p>
            </note>--><p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <specref ref="stripping-annotations"/>.</p><p>The <code>default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all <elcode>xsl:document</elcode>,
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, and
                  <elcode>xsl:result-document</elcode> instructions, and of the
                  <code>xsl:validation</code> attribute of all <termref def="dt-literal-result-element">literal result elements</termref>. It also
               determines the validation applied to the implicit <termref def="dt-final-result-tree">final result tree</termref> created in the absence of an
                  <elcode>xsl:result-document</elcode> instruction. This default applies within the
                  <termref def="dt-stylesheet-module">stylesheet module</termref>: it does not
               extend to included or imported stylesheet modules. If the attribute is omitted, the
               default is <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>. For details of the effect of this attribute, see <specref ref="validation"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0120"><p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must not</rfc2119> have any
                     text node children.</p></error> (This rule applies after stripping of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> as described in <specref ref="stylesheet-stripping"/>.)</p><p>
               <termdef id="dt-top-level" term="top-level">An element occurring as a child of an
                     <elcode>xsl:stylesheet</elcode><phrase diff="add" at="M">, <elcode>xsl:transform</elcode>,
                     or <elcode>xsl:override</elcode></phrase> element is called a <term>top-level</term>
                  element.</termdef>
            </p><p>
               <termdef id="dt-declaration" term="declaration">Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <termref def="dt-xslt-namespace">XSLT namespace</termref> are
                     <term>declarations</term>. Top-level elements in any other namespace are
                     <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>)</termdef>.</p><p>The <termref def="dt-declaration">declaration</termref> elements permitted in the
                  <elcode>xsl:stylesheet</elcode> element are:</p><slist><sitem>
                  <elcode>xsl:use-package</elcode>
               </sitem><sitem>
                  <elcode>xsl:import</elcode>
               </sitem><sitem>
                  <elcode>xsl:include</elcode>
               </sitem><sitem>
                  <elcode>xsl:accumulator</elcode>
               </sitem><sitem>
                  <elcode>xsl:attribute-set</elcode>
               </sitem><sitem>
                  <elcode>xsl:character-map</elcode>
               </sitem><sitem>
                  <elcode>xsl:decimal-format</elcode>
               </sitem><sitem>
                  <elcode>xsl:function</elcode>
               </sitem><sitem>
                  <elcode>xsl:import-schema</elcode>
               </sitem><sitem>
                  <elcode>xsl:key</elcode>
               </sitem><sitem>
                  <phrase diff="add" at="A">
                     <elcode>xsl:mode</elcode>
                  </phrase>
               </sitem><sitem>
                  <elcode>xsl:namespace-alias</elcode>
               </sitem><sitem>
                  <elcode>xsl:output</elcode>
               </sitem><sitem>
                  <elcode>xsl:param</elcode>
               </sitem><sitem>
                  <elcode>xsl:preserve-space</elcode>
               </sitem><sitem>
                  <elcode>xsl:strip-space</elcode>
               </sitem><sitem>
                  <elcode>xsl:template</elcode>
               </sitem><sitem>
                  <elcode>xsl:variable</elcode>
               </sitem></slist><p>Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements
               can act either as <termref def="dt-declaration">declarations</termref> or as <termref def="dt-instruction">instructions</termref>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p><p><phrase diff="chg" at="L">If there are <elcode>xsl:use-package</elcode> elements, these <rfc2119>must</rfc2119> come
               before any other elements. If there are <elcode>xsl:import</elcode> elements, these <rfc2119>must</rfc2119> come
               after any <elcode>xsl:use-package</elcode> elements but before any other elements.</phrase> 
               Apart from this, the child elements of the
                  <elcode>xsl:stylesheet</elcode> element may appear in any order. <phrase diff="chg" at="D">In most cases, the ordering of these elements does not affect
                  the results of the transformation; however, as described in <specref ref="conflict"/>, when two template rules with the same <termref def="dt-priority">priority</termref> match the same nodes, there are situations
                     where the order of the template rules will affect which is chosen.</phrase></p><p diff="add" at="L">For the meaning of the <elcode>xsl:use-package</elcode> element, see <specref ref="packages"/>.</p><div3 id="default-collation-attribute"><head>The <code>default-collation</code> Attribute</head><p>The <code>default-collation</code> attribute is a <termref def="dt-standard-attributes">standard attribute</termref> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p><p>The attribute is used to specify the default collation used by all XPath
                  expressions appearing in the attributes of this element, or attributes of
                  descendant elements, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <elcode>xsl:key</elcode> and
                     <elcode>xsl:for-each-group</elcode>) within its scope.</p><p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI <phrase diff="add" at="F">reference</phrase>, then it is resolved relative to the base URI
                  of the attribute's parent element. If the implementation recognizes one or more of
                  the resulting absolute collation URIs, then it uses the first one that it
                  recognizes as the default collation.</p><p>
                  <error spec="XT" type="static" class="SE" code="0125"><p>It is a <termref def="dt-static-error">static error</termref> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.</p></error>
               </p><note><p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to specify the Unicode
                     Codepoint Collation as the last collation URI in the list.</p></note><p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <code>xsl:sort</code>.</p></div3><div3 id="default-mode" diff="add" at="A"><head>The <code>default-mode</code> Attribute</head><p>The <code>default-mode</code> attribute defines the default value for the <termref def="dt-mode">mode</termref> attribute of all <elcode>xsl:template</elcode> and
                     <elcode>xsl:apply-templates</elcode> elements within the stylesheet module. It
                  also determines which mode is referred to when the token <code>#default</code> is
                  used in either of these attributes.</p><p>The value <rfc2119>must</rfc2119> either be <phrase diff="chg" at="K">an <termref def="dt-eqname">EQName</termref></phrase>, or the token <code>#unnamed</code> which refers to
                  the <termref def="dt-unnamed-mode">unnamed mode</termref>. It is not necessary for 
                  the referenced mode to be explicitly declared in an <elcode>xsl:mode</elcode>
                  declaration. </p><p>If the <code>default-mode</code> attribute is omitted, then the default mode for
                  the stylesheet module is the <termref def="dt-unnamed-mode">unnamed
                  mode</termref>. This is equivalent to specifying <code>#unnamed</code>.</p><note><p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <termref def="dt-mode">mode</termref> are
                     collected together into a single <termref def="dt-stylesheet-module">stylesheet
                        module</termref>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p></note></div3><div3 id="user-defined-top-level"><head>User-defined Data Elements</head><p>
                  <termdef id="dt-data-element" term="user-defined data element">In addition to
                        <termref def="dt-declaration">declarations</termref>, the
                        <elcode>xsl:stylesheet</elcode> element may contain among its children any
                     element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
                     provided that the <termref def="dt-expanded-qname">expanded QName</termref> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <term>user-defined data elements</term>.</termdef>
               </p><p>
                  <error spec="XT" type="static" class="SE" code="0130"><p>It is a <termref def="dt-static-error">static error</termref> if the
                           <elcode>xsl:stylesheet</elcode> element has a child element whose name
                        has a null namespace URI.</p></error>
               </p><p>An implementation <rfc2119>may</rfc2119> attach an <termref def="dt-implementation-defined">implementation-defined</termref> meaning to
                  user-defined data elements that appear in particular namespaces. The set of
                  namespaces that are recognized for such data elements is <termref def="dt-implementation-defined">implementation-defined</termref>. The presence
                  of a user-defined data element <rfc2119>must not</rfc2119> change the behavior of
                     <termref def="dt-xslt-element">XSLT elements</termref> and functions defined in
                  this document; for example, it is not permitted for a user-defined data element to
                  specify that <elcode>xsl:apply-templates</elcode> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <termref def="dt-extension-attribute">extension attributes</termref>, described in
                     <specref ref="extension-attributes"/>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <rfc2119>must</rfc2119> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p><imp-def-feature>The set of namespaces that are specially recognized by the
                  implementation (for example, for user-defined data elements, and <termref def="dt-extension-attribute">extension attributes</termref>) is <termref def="dt-implementation-defined"/>.</imp-def-feature><imp-def-feature>The effect of user-defined data elements whose name is in a
                  namespace recognized by the implementation is <termref def="dt-implementation-defined"/>.</imp-def-feature><p>User-defined data elements can provide, for example,</p><ulist><item><p>information used by <termref def="dt-extension-instruction">extension
                           instructions</termref> or <termref def="dt-extension-function">extension
                           functions</termref> (see <specref ref="extension"/>),</p></item><item><p>information about what to do with any <termref def="dt-final-result-tree">final result tree</termref>,</p></item><item><p>information about how to construct <termref def="dt-source-tree">source
                           trees</termref>,</p></item><item><p>optimization hints for the <termref def="dt-processor">processor</termref>,</p></item><item><p>metadata about the stylesheet,</p></item><item><p>structured documentation for the stylesheet.</p></item></ulist><p>A <termref def="dt-data-element">user-defined data element</termref>
                  <rfc2119>must not</rfc2119> precede an <elcode>xsl:import</elcode> element within
                  a <termref def="dt-stylesheet-module">stylesheet module</termref>
                  <errorref spec="XT" class="SE" code="0200"/>
               </p></div3></div2><div2 id="simplified-stylesheet"><head>Simplified Stylesheet Modules</head><p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that defines only a single template rule for the document node.
               The stylesheet module may consist of just a <termref def="dt-literal-result-element">literal result element</termref> (see <specref ref="literal-result-element"/>)
               together with its contents. The literal result element must have an
                  <code>xsl:version</code> attribute (and it must therefore also declare the XSLT
               namespace). Such a stylesheet module is equivalent to a standard stylesheet module
               whose <elcode>xsl:stylesheet</elcode> element contains a <termref def="dt-template-rule">template rule</termref> containing the literal result
               element, minus its <code>xsl:version</code> attribute; the template rule has a match
                  <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p><example><head>A Simplified Stylesheet</head><p>For example:</p><eg xml:space="preserve">&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</eg><p>has the same meaning as</p><eg xml:space="preserve">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg><p>Note that it is not possible, using a simplified stylesheet, to request that the
                  serialized output contains a <code>DOCTYPE</code> declaration. This can only be
                  done by using a standard stylesheet module, and using the
                     <elcode>xsl:output</elcode> element.</p></example><p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <termref def="dt-named-template">named template</termref>
               <code>expand</code>, with the containing literal result element as the <termref def="dt-context-node">context node</termref>: </p><eg xml:space="preserve">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</eg><p>
               <error spec="XT" type="static" class="SE" code="0150"><p>A <termref def="dt-literal-result-element">literal result element</termref>
                     that is used as the outermost element of a simplified stylesheet module
                        <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute.</p></error> This indicates the version of XSLT that the stylesheet requires. For this
               version of XSLT, the value will normally be <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code>; the value <rfc2119>must</rfc2119> be a valid instance of the type
                  <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p><p diff="del" at="D">Other <termref def="dt-literal-result-element">literal result
                  elements</termref> may also have an <code>xsl:version</code> attribute. When the
                  <code>xsl:version</code> attribute is numerically less than <code>2.0</code>,
               <termref def="dt-backwards-compatible-behavior"/> is enabled (see <specref ref="backwards"/>).
               When the <code>xsl:version</code> attribute is numerically greater than
                  <code>2.0</code>, <termref def="dt-forwards-compatible-behavior"/> is enabled (see <specref ref="forwards"/>).</p><p>The allowed content of a literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <termref def="dt-sequence-constructor">sequence constructor</termref>. Thus, a literal result element used as the
               document element of a simplified stylesheet cannot contain <termref def="dt-declaration">declarations</termref>. Simplified stylesheets therefore
               cannot use <termref def="dt-template-rule">template rules</termref>, <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, <termref def="dt-stylesheet-function">stylesheet functions</termref>, <termref def="dt-key">keys</termref>, <termref def="dt-attribute-set">attribute-sets</termref>, or
                  <termref def="dt-output-definition">output definitions</termref>. In turn this
               means that the only useful way to initiate the transformation is to supply a document
               node as the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, to be matched by the implicit <code>match="/"</code> template rule
               using the <termref def="dt-unnamed-mode">unnamed mode</termref>. </p></div2><div2 id="backwards" diff="chg" at="D"><head>Backwards Compatible Processing</head><p><termdef id="dt-effective-version" term="effective version">The <term>effective
                     version</term> of an element in the stylesheet is the decimal value of the
                     <code>[xsl:]version</code> attribute (see <specref ref="standard-attributes"/>)
                  on that element or on the innermost ancestor element that has such an attribute,
                  excluding the <code>version</code> attribute on an <elcode>xsl:output</elcode>
                  element.</termdef></p><p>
               <termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior">An element is processed with <term>backwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is less than
                     <code diff="chg" at="D">3.0</code>.</termdef>
            </p><p>Specifically:</p><ulist><item><p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <specref ref="backwards-1.0"/>.</p></item><item><p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <specref ref="backwards-2.0"/>.</p></item><item><p>If the <termref def="dt-effective-version">effective version</termref> is any
                     other value less than 3.0, the <rfc2119>recommended</rfc2119> action is to
                     report a static error; however, processors <rfc2119>may</rfc2119> recognize
                     such values and process the element in an <termref def="dt-implementation-defined"/> way.</p><imp-def-feature>If the <termref def="dt-effective-version">effective
                        version</termref> of any element in the stylesheet is not 1.0 or 2.0 but is
                     less than 3.0, the <rfc2119>recommended</rfc2119> action is to report a static
                     error; however, processors <rfc2119>may</rfc2119> recognize such values and
                     process the element in an <termref def="dt-implementation-defined"/>
                     way.</imp-def-feature><note><p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p></note></item></ulist><p>These rules do not apply to the <elcode>xsl:output</elcode> element, whose
                  <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.</p><p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is greater than or equal to <code>2.0</code> disables backwards compatible
               behavior for itself, its attributes, its descendants and their attributes. The
               compatibility behavior established by an element overrides any compatibility behavior
               established by an ancestor element.</p><p>It is <termref def="dt-implementation-defined"/>
               whether a particular XSLT 3.0 implementation supports backwards compatible behavior
               for any XSLT version earlier than XSLT 3.0.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0160"><p diff="chg" at="D">It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an element has an <termref def="dt-effective-version">effective version</termref> of <var>V</var> (with
                        <var>V</var> &lt; 3.0) when the implementation does not support
                     backwards compatible behavior for XSLT version <var>V</var>.</p></error>
            </p><imp-def-feature>It is implementation-defined whether an <phrase diff="chg" at="D">XSLT
                  3.0</phrase> processor supports backwards compatible behavior for any XSLT version
               earlier than XSLT 3.0.</imp-def-feature><note><p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 3.0
                  processor are identical to the effects of processing the same stylesheet using
                     <phrase diff="chg" at="D">a processor for an earlier version of XSLT</phrase>.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p><p>All data values manipulated by an <phrase diff="chg" at="D">XSLT 3.0</phrase>
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the <phrase diff="chg" at="D">XSLT 3.0</phrase> and <phrase diff="chg" at="D">XPath 3.0</phrase> specifications, it is not defined by reference to <phrase diff="chg" at="D">earlier versions of the XSLT and XPath
                     specifications</phrase>. </p><p>To write a stylesheet that makes use of <phrase diff="chg" at="D">features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>)</phrase>, it is
                  necessary to understand both the rules for backwards compatible behavior in
                     <phrase diff="chg" at="D">XSLT version <var>N</var></phrase>, and the rules for
                  forwards compatible behavior in <phrase diff="chg" at="D">XSLT version
                        <var>M</var></phrase>. If the <elcode>xsl:stylesheet</elcode> element
                  specifies <code>version="2.0"</code>
                  <phrase diff="add" at="D">or <code>version="3.0"</code></phrase>, then an XSLT 1.0
                  processor will ignore XSLT 2.0 <phrase diff="add" at="D">and XSLT
                     3.0</phrase><termref def="dt-declaration">declarations</termref> that were not
                  defined in XSLT 1.0, for example <elcode>xsl:function</elcode> and
                     <elcode>xsl:import-schema</elcode>. If any new <phrase diff="chg" at="D">XSLT
                     3.0</phrase> instructions are used (for example <elcode>xsl:evaluate</elcode>
                  or <elcode>xsl:stream</elcode>), or if new <phrase diff="chg" at="D">XPath
                     3.0</phrase> features are used (for example, new functions, or <phrase diff="chg" at="D">let</phrase> expressions), then the stylesheet must provide
                  fallback behavior that relies only on facilities <phrase diff="chg" at="D">available in the earliest XSLT version supported</phrase>. The fallback
                  behavior can be invoked by using the <elcode>xsl:fallback</elcode> instruction, or
                  by testing the results of the <function>function-available</function> or
                     <function>element-available</function> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <function>system-property</function> function.</p></note><div3 id="backwards-1.0" diff="add" at="D"><head>XSLT 1.0 Compatibility Mode</head><p><termdef id="dt-xslt-10-behavior" term="XSLT 1.0 behavior">An element in the stylesheet is processed
                     with <term>XSLT 1.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 1.0.</termdef></p><p>In this mode, if any attribute contains an XPath <termref def="dt-expression">expression</termref>, then the expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
                     <code>true</code>. For details of this mode, see <xspecref spec="XP30" ref="static_context"/>.</p><p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <termref def="dt-standard-function-namespace">standard function namespace</termref>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <errorref spec="XT" class="DE" code="1425"/> . The effect is that with backwards compatible
                  behavior enabled, calls on <termref def="dt-extension-function">extension
                     functions</termref> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <specref ref="extension-functions"/>.</p><note><p>This might appear to contradict the specification of XPath <phrase diff="chg" at="D">3.0</phrase>, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <termref def="dt-standard-function-namespace">standard function
                        namespace</termref>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p></note><p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p></div3><div3 id="backwards-2.0" diff="add" at="D"><head>XSLT 2.0 Compatibility Mode</head><p><termdef id="dt-xslt-20-behavior" term="XSLT 2.0 behavior">An element is processed
                     with <term>XSLT 2.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 2.0.</termdef></p><p>In this working draft, no differences are defined for XSLT 2.0 behavior. An XSLT
                  3.0 processor will therefore produce the same results whether the <termref def="dt-effective-version">effective version</termref> of an element is set to
                  2.0 or 3.0.</p><note><p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <elcode>xsl:iterate</elcode> instruction with an
                        <elcode>xsl:fallback</elcode> child, an XSLT 3.0 processor will process the
                        <elcode>xsl:iterate</elcode> instruction regardless whether the effective
                     version is 2.0 or 3.0, while an XSLT 2.0 processor will report a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 3.0.</p></note></div3></div2><div2 id="forwards"><head>Forwards Compatible Processing</head><p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to <phrase diff="chg" at="D">XSLT 3.0</phrase>, while retaining the
               ability to execute the stylesheet with an <phrase diff="chg" at="D">XSLT 3.0</phrase>
               processor using appropriate fallback behavior.</p><p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <specref ref="conditional-inclusion"/>. The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p><ulist><item><p>certain constructs in the stylesheet that mean nothing to an <phrase diff="chg" at="D">XSLT 3.0</phrase> processor are ignored, rather than being treated as
                     errors.</p></item><item><p>explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <elcode>xsl:fallback</elcode> instruction.</p></item></ulist><p>The detailed rules follow.</p><p diff="chg" at="D">
               <termdef id="dt-forwards-compatible-behavior" term="forwards compatible behavior">An
                  element is processed with <term>forwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is greater than
                     <code diff="chg" at="D">3.0</code>.</termdef>
            </p><p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is less than or equal to <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code> disables forwards compatible behavior for itself, its attributes, its
               descendants and their attributes. The compatibility behavior established by an
               element overrides any compatibility behavior established by an ancestor element.</p><p>These rules do not apply to the <code>version</code> attribute of the
                  <elcode>xsl:output</elcode> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p><p diff="chg" at="D">When an element is processed with forwards compatible behavior:</p><ulist><item><p>if the element is in the XSLT namespace and appears as a child of the
                        <elcode>xsl:stylesheet</elcode> element, and XSLT <phrase diff="chg" at="A">3.0</phrase> does not allow the element to appear as a child of the
                        <elcode>xsl:stylesheet</elcode> element, then the element and its content
                        <rfc2119>must</rfc2119> be ignored.</p></item><item><p>if the element has an attribute that XSLT <phrase diff="chg" at="A">3.0</phrase> does not allow the element to have, then the attribute
                        <rfc2119>must</rfc2119> be ignored.</p></item><item><p>if the element is in the XSLT namespace and appears as part of a <termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT
                        <phrase diff="chg" at="A">3.0</phrase> does not allow such elements to
                     appear as part of a sequence constructor, then:</p><olist><item><p>If the element has one or more <elcode>xsl:fallback</elcode> children,
                           then no error is reported either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <elcode>xsl:fallback</elcode> children, in document order. Siblings of
                           the <elcode>xsl:fallback</elcode> elements are ignored, even if they are
                           valid XSLT <phrase diff="chg" at="A">3.0</phrase> instructions.</p></item><item><p>If the element has no <elcode>xsl:fallback</elcode> children, then a
                           static error is reported in the same way as if forwards compatible
                           behavior were not enabled.</p></item></olist></item></ulist><example><head>Forwards Compatible Behavior</head><p>For example, an XSLT <phrase diff="chg" at="A">3.0</phrase>
                  <termref def="dt-processor">processor</termref> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not defined
                  in this specification:</p><eg xml:space="preserve">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg></example><note><p>If a stylesheet depends crucially on a <termref def="dt-declaration">declaration</termref> introduced by a version of XSLT after <phrase diff="chg" at="A">3.0</phrase>, then the stylesheet can use an
                     <elcode>xsl:message</elcode> element with <code>terminate="yes"</code> (see
                     <specref ref="message"/>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <termref def="dt-declaration">declaration</termref>.</p></note><example><head>Testing the XSLT Version</head><p>For example,</p><eg xml:space="preserve">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</eg></example></div2><div2 id="combining-modules"><head>Combining Stylesheet Modules</head><p>XSLT provides two mechanisms to construct a <termref def="dt-stylesheet">stylesheet</termref> from multiple <termref def="dt-stylesheet-module">stylesheet
                  modules</termref>:</p><ulist><item><p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p></item><item><p>an import mechanism that allows stylesheet modules to override each other.</p></item></ulist><div3 id="locating-modules"><head>Locating Stylesheet Modules</head><p>The include and import mechanisms use two declarations,
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>, which are defined
                  in the sections that follow.</p><p>These declarations use an <code>href</code> attribute, whose value is a <termref def="dt-uri-reference">URI reference</termref>, to identify the <termref def="dt-stylesheet-module">stylesheet module</termref> to be included or
                  imported. If the value of this attribute is a relative URI <phrase diff="add" at="F">reference</phrase>, 
                  it is resolved as
                  described in <specref ref="uri-references"/>.</p><p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <termref def="dt-stylesheet-module">stylesheet
                     module</termref>, and the way in which the stylesheet module is constructed
                  from that representation, are <termref def="dt-implementation-defined">implementation-defined</termref>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p><p>The referenced <termref def="dt-stylesheet-module">stylesheet module</termref> may
                  be any of the four kinds of stylesheet module: that is, it may be <termref def="dt-standalone-stylesheet-module">standalone</termref> or <termref def="dt-embedded-stylesheet-module">embedded</termref>, and it may be <termref def="dt-standard-stylesheet-module">standard</termref> or <termref def="dt-simplified-stylesheet-module">simplified</termref>. If it is a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>
                  then it is transformed into the equivalent <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref> by
                  applying the transformation described in <specref ref="simplified-stylesheet"/>.</p><p>Implementations <rfc2119>may</rfc2119> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <bibref ref="xptr-framework"/>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <termref def="dt-embedded-stylesheet-module">embedded
                     stylesheet module</termref>.</p><imp-def-feature>It is implementation-defined what forms of URI reference are
                  acceptable in the <code>href</code> attribute of the <elcode>xsl:include</elcode>
                  and <elcode>xsl:import</elcode> elements, for example, the URI schemes that may be
                  used, the forms of fragment identifier that may be used, and the media types that
                  are supported.</imp-def-feature><p>
                  <error spec="XT" type="static" class="SE" code="0165"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference<error.extra> in the <code>href</code> attribute of
                              <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode>
                        </error.extra>, or if the resource that is retrieved does not contain a
                        stylesheet module<phrase diff="del" at="I"> conforming to this specification</phrase>.</p></error>
               </p><note><p diff="add" at="I"><!--bug 9992-->
                  It is appropriate to use this error code when the resource
                  cannot be retrieved, or when the retrieved resource is not well formed XML. If
                  the resource contains XML than can be parsed but that violates the rules for
                  stylesheet modules, then a more specific error code may be more appropriate.</p></note></div3><div3 id="include"><head>Stylesheet Inclusion</head><e:element-syntax name="include"><e:in-category name="declaration"/><e:attribute name="href" required="yes"><e:data-type name="uri"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>A stylesheet module may include another stylesheet module using an
                     <elcode>xsl:include</elcode> declaration.</p><p>The <elcode>xsl:include</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p><p>
                  <error spec="XT" type="static" class="SE" code="0170"><p>An <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
                           <termref def="dt-top-level">top-level</termref> element.</p></error>
               </p><p>
                  <termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet
                        level</term> is a collection of <termref def="dt-stylesheet-module">stylesheet modules</termref> connected using <elcode>xsl:include</elcode>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <elcode>xsl:include</elcode> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</termdef>
               </p><p>
                  <termdef id="dt-declaration-order" term="declaration order">The <termref def="dt-declaration">declarations</termref> within a <termref def="dt-stylesheet-level">stylesheet level</termref> have a total ordering
                     known as <term>declaration order</term>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <elcode>xsl:include</elcode> element that references it.</termdef> In other
                  respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p><p>
                  <error spec="XT" type="static" class="SE" code="0180"><p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly includes itself.</p></error>
               </p><note><p>It is not intrinsically an error for a <termref def="dt-stylesheet">stylesheet</termref> to include the same module more than once. However,
                     doing so can cause errors because of duplicate definitions. Such multiple
                     inclusions are less obvious when they are indirect. For example, if stylesheet
                        <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
                     includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both
                     stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
                     included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var>
                     and <var>D</var> are used as independent stylesheets, then the error can be
                     avoided by separating everything in <var>B</var> other than the inclusion of
                        <var>A</var> into a separate stylesheet <var>B'</var> and changing
                        <var>B</var> to contain just inclusions of <var>B'</var> and <var>A</var>,
                     similarly for <var>C</var>, and then changing <var>D</var> to include
                        <var>A</var>, <var>B'</var>, <var>C'</var>.</p></note></div3><div3 id="import"><head>Stylesheet Import</head><e:element-syntax name="import"><e:in-category name="declaration"/><e:attribute name="href" required="yes"><e:data-type name="uri"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>A stylesheet module may import another <termref def="dt-stylesheet-module">stylesheet module</termref> using an <elcode>xsl:import</elcode>
                  <termref def="dt-declaration">declaration</termref>. Importing a stylesheet module
                  is the same as including it (see <specref ref="include"/>) except that <termref def="dt-template-rule">template rules</termref> and other <termref def="dt-declaration">declarations</termref> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p><p>The <elcode>xsl:import</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p><p>
                  <error spec="XT" type="static" class="SE" code="0190"><p>An <elcode>xsl:import</elcode> element <rfc2119>must</rfc2119> be a <termref def="dt-top-level">top-level</termref> element.</p></error>
               </p><p diff="del" at="M">
                  <error spec="XT" type="static" class="SE" code="0200"><p>The <elcode>xsl:import</elcode> element children <rfc2119>must</rfc2119>
                        precede all other element children of an <elcode>xsl:stylesheet</elcode>
                        element, including any <elcode>xsl:include</elcode> element children and any
                           <termref def="dt-data-element">user-defined data elements</termref>.</p></error>
               </p><example><head>Using <elcode>xsl:import</elcode>
                  </head><p>For example,</p><eg xml:space="preserve">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</eg></example><p>
                  <termdef id="dt-import-tree" term="import tree">The <termref def="dt-stylesheet-level">stylesheet levels</termref> making up a <termref def="dt-stylesheet">stylesheet</termref> are treated as forming an
                        <term>import tree</term>. In the import tree, each stylesheet level has one
                     child for each <elcode>xsl:import</elcode> declaration that it
                     contains.</termdef> The ordering of the children is the <termref def="dt-declaration-order">declaration order</termref> of the
                     <elcode>xsl:import</elcode> declarations within their stylesheet level.</p><p>
                  <termdef id="dt-import-precedence" term="import precedence">A <termref def="dt-declaration">declaration</termref>
                     <var>D</var> in the stylesheet is defined to have lower <term>import
                        precedence</term> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</termdef>
               </p><p>For example, suppose</p><ulist><item><p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p></item><item><p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p></item><item><p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p></item></ulist><p>Then the import tree has the following structure:</p><g:graph rankdir="LR"><g:node label="A" shape="box"><g:node label="B" shape="box"><g:node label="D" shape="box"/></g:node><g:node label="C" shape="box"><g:node label="E" shape="box"/></g:node></g:node></g:graph><p><emph>Here you should see a diagram. If it does not appear correctly in your
                     browser, you need to install an SVG Plugin.</emph></p><p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p><p>In general, a <termref def="dt-declaration">declaration</termref> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p><p>
                  <error spec="XT" type="static" class="SE" code="0210"><p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly imports itself.</p></error>
               </p><note><p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p></note></div3></div2><div2 id="embedded"><head>Embedded Stylesheet Modules</head><p>An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
               is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing
               element is not the outermost element of the containing XML document. Both <termref def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
                  <termref def="dt-simplified-stylesheet-module">simplified stylesheet
                  modules</termref> may be embedded in this way.</p><p>Two situations where embedded stylesheets may be useful are:</p><ulist><item><p>The stylesheet may be embedded in the source document to be transformed.</p></item><item><p>The stylesheet may be embedded in an XML document that describes a sequence of
                     processing of which the XSLT transformation forms just one part.</p></item></ulist><p>The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an
                  <code>id</code> attribute to facilitate reference to the stylesheet module within
               the containing document.</p><note><p>In order for such an attribute value to be used as a fragment identifier in a URI,
                  the XDM attribute node must generally have the <code>is-id</code> property: see
                     <xspecref spec="DM30" ref="dm-is-id"/>. This property will typically be set if
                  the attribute is defined in a DTD as being of type <code>ID</code>, or if is
                  defined in a schema as being of type <code>xs:ID</code>. It is also necessary that
                  the media type of the containing document should support the use of ID values as
                  fragment identifiers. <phrase diff="del" at="F">Such support is widespread in existing products, and is
                  expected to be endorsed in respect of the media type <code>application/xml</code>
                  by a future revision of <bibref ref="RFC3023"/></phrase>
                  <phrase diff="add" at="F">Such support is widespread in existing products, and is
                     endorsed in respect of the media type <code>application/xml</code> by <bibref ref="xptr-framework"/></phrase>.</p><p>An alternative, if the implementation supports it, is to use an
                     <code>xml:id</code> attribute. XSLT allows this attribute (like other
                  namespaced attributes) to appear on any <termref def="dt-xslt-element">XSLT
                     element</termref>.</p></note><example><head>The <code>xml-stylesheet</code> Processing Instruction</head><p>The following example shows how the <code>xml-stylesheet</code> processing
                  instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a source
                  document to contain its own stylesheet. The URI reference uses <phrase diff="del" at="F">a relative URI with</phrase>
                  a fragment identifier to locate the <elcode>xsl:stylesheet</elcode> element:</p><eg xml:space="preserve">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</eg></example><note><p>A stylesheet module that is embedded in the document to which it is to be applied
                  typically needs to contain a <termref def="dt-template-rule">template
                     rule</termref> that specifies that <elcode>xsl:stylesheet</elcode> elements are
                  to be ignored.</p></note><note><p diff="chg" at="C">The above example uses the pseudo-attribute
                     <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code>
                  processing instruction to denote an XSLT stylesheet. This is the officially
                  registered media type for XSLT: see <specref ref="xslt-media-type"/>. However,
                  browsers developed before this media type was registered are more likely to accept
                  the unofficial designation <code>type="text/xsl"</code>.</p></note><note><p>Support for the <code>xml-stylesheet</code> processing instruction is not required
                  for conformance with this Recommendation. Implementations are not constrained in
                  the mechanisms they use to identify a stylesheet when a transformation is
                  initiated: see <specref ref="initiating"/>.</p></note></div2><div2 id="conditional-inclusion"><head>Conditional Element Inclusion</head><p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
               value is an XPath expression that can be evaluated statically. If the attribute is
               present and the <xtermref spec="XP30" ref="dt-ebv">effective boolean value</xtermref>
               of the expression is false, then the element, together with all the nodes having that
               element as an ancestor, is effectively excluded from the <termref def="dt-stylesheet-module">stylesheet module</termref>. When a node is effectively
               excluded from a stylesheet module the stylesheet module has the same effect as if the
               node were not there. Among other things this means that no static or dynamic errors
               will be reported in respect of the element and its contents, other than errors in the
                  <code>use-when</code> attribute itself.</p><note><p>This does not apply to XML parsing or validation errors, which will be reported in
                  the usual way. It also does not apply to attributes that are necessarily processed
                  before <code>[xsl:]use-when</code>, examples being <code>xml:space</code> and
                     <code>[xsl:]xpath-default-namespace</code>.</p></note><p>A <termref def="dt-literal-result-element">literal result element</termref>, or any
               other element within a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that is not in the XSLT namespace, may similarly carry an
                  <code>xsl:use-when</code> attribute.</p><p>If the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
               itself is effectively excluded, the effect is to exclude all the children of the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, but not
               the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element or its
               attributes.</p><note><p>This allows all the declarations that depend on the same condition to be included
                  in one stylesheet module, and for their inclusion or exclusion to be controlled by
                  a single <code>use-when</code> attribute at the level of the module.</p></note><p>Conditional element exclusion happens after stripping of whitespace text nodes from
               the stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p><p diff="chg" at="M">The XPath expression used as the value of the <code>xsl:use-when</code>
            attribute follows the rules for <termref def="dt-static-expression">static expressions</termref>.</p><p>The use of <code>[xsl:]use-when</code> is illustrated in the following examples.</p><example><head>Using Conditional Exclusion to Achieve Portability</head><p>This example demonstrates the use of the <code>use-when</code> attribute to
                  achieve portability of a stylesheet across schema-aware and non-schema-aware
                  processors.</p><eg xml:space="preserve">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg><p>The effect of these declarations is that a non-schema-aware processor ignores the
                     <elcode>xsl:import-schema</elcode> declaration and the first template rule, and
                  therefore generates no errors in respect of the schema-related constructs in these
                  declarations.</p></example><example><head>Including Variant Stylesheet Modules</head><p>This example includes different stylesheet modules depending on which XSLT
                  processor is in use.</p><eg xml:space="preserve">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</eg></example></div2><div2 id="built-in-types"><head>Built-in Types</head><p>Every XSLT <phrase diff="chg" at="A">3.0</phrase> processor includes the following
               named type definitions in the <termref def="dt-in-scope-schema-component">in-scope
                  schema components</termref>:</p><ulist><item><p><phrase diff="del" at="C">All the primitive atomic types defined in <bibref ref="xmlschema-2"/>
                     with the exception of
                     <code>xs:NOTATION</code>. That is: <code>xs:string</code>,
                     <code>xs:boolean</code>, <code>xs:decimal</code>, <code>xs:double</code>,
                     <code>xs:float</code>, <code>xs:date</code>, <code>xs:time</code>,
                     <code>xs:dateTime</code>, <code>xs:duration</code>, <code>xs:QName</code>,
                     <code>xs:anyURI</code>, <code>xs:gDay</code>, <code>xs:gMonthDay</code>,
                     <code>xs:gMonth</code>, <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                     <code>xs:base64Binary</code>, and <code>xs:hexBinary</code>.</phrase>
                     <phrase diff="add" at="F">All built-in types defined in <bibref ref="xmlschema-2"/>,
                        including <code>xs:anyType</code> and <code>xs:anySimpleType</code>.</phrase></p></item><item><p>The following types defined in <bibref ref="xpath-30"/>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p></item></ulist><p diff="add" at="I">XSLT 3.0 processors <rfc2119>may</rfc2119> optionally include 
               types defined in XSD 1.1 (see <bibref ref="xmlschema11-1"/>). 
               XSD 1.1 adopts the types <code>xs:yearMonthDuration</code>, 
               <code>xs:dayTimeDuration</code>, and <code>xs:anyAtomicType</code> previously defined
               in XPath 2.0, and adds one new type: <code>xs:dateTimeStamp</code>. XSD 1.1 also
               allows implementors to define additional primitive types, and XSLT 3.0 permits
               such types to be supported by an XSLT processor.</p><p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>
               additionally supports:</p><ulist><item diff="del" at="C"><p>All other built-in types defined in <bibref ref="xmlschema-2"/>
                  </p></item><item><p>User-defined types, and element and attribute declarations, that are imported
                     using an <elcode>xsl:import-schema</elcode> declaration as described in
                        <specref ref="import-schema"/>. These may include both simple and complex
                     types.</p></item></ulist><note><p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schema Documents or the Schema
                  for Schema Documents (Datatypes). The Schema for Schema Documents, as well as defining built-in types such
                  as <code>xs:integer</code> and <code>xs:double</code>, also defines types that are
                  intended for use only within that schema, such as
                     <code>xs:derivationControl</code>. A <termref def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema documents as its
                  input or output may import the Schema for Schema Documents.</p></note><p>An implementation may define mechanisms that allow additional <termref def="dt-schema-component">schema components</termref> to be added to the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
               stylesheet. For example, the mechanisms used to define <termref def="dt-extension-function">extension functions</termref> (see <specref ref="extension-functions"/>) may also be used to import the types used in the
               interface to such functions.</p><imp-def-feature>An implementation may define mechanisms, above and beyond
                  <elcode>xsl:import-schema</elcode> that allow <termref def="dt-schema-component">schema components</termref> such as type definitions to be made available within
               a stylesheet.</imp-def-feature><p>These <termref def="dt-schema-component">schema components</termref> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p><p diff="del" at="C">For a Basic XSLT Processor, schema built-in types that are not
               included in the static context (for example, <code>xs:NCName</code>) are "unknown
               types" in the sense of  <xspecref spec="XP30" ref="id-sequencetype-matching"/>. In the
               language of that section, a Basic XSLT Processor <rfc2119>must</rfc2119> be able to
               determine whether these unknown types are derived from known schema types such as
                  <code>xs:string</code>. The purpose of this rule is to ensure that system
               functions such as <xfunction>local-name-from-QName</xfunction>, which is defined to
               return an <code>xs:NCName</code>, behave correctly. A stylesheet that uses a Basic
               XSLT Processor will not be able to test whether the returned value is an
                  <code>xs:NCName</code>, but it will be able to use it as if it were an
                  <code>xs:string</code>. </p></div2><div2 id="import-schema"><head>Importing Schema Components</head><note><p>The facilities described in this section are not available with a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>. They require a
                     <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref>, as described in <specref ref="conformance"/>.</p></note><e:element-syntax name="import-schema"><e:in-category name="declaration"/><e:attribute name="namespace"><e:data-type name="uri"/></e:attribute><e:attribute name="schema-location"><e:data-type name="uri"/></e:attribute><e:element repeat="zero-or-one" name="xs:schema"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:import-schema</elcode> declaration is used to identify <termref def="dt-schema-component">schema components</termref> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <termref def="dt-stylesheet">stylesheet</termref> must refer to an <termref def="dt-in-scope-schema-component">in-scope schema component</termref>, which means they must either be built-in
               types as defined in <specref ref="built-in-types"/>, or they must be imported using
               an <elcode>xsl:import-schema</elcode> declaration.</p><p>The <elcode>xsl:import-schema</elcode> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the
               <phrase diff="chg" at="I"><termref def="dt-package">package</termref></phrase>, and within other stylesheet constructs
               such as the <code>type</code> and <code>as</code> attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p><p diff="chg" at="I">The same schema components are available in all stylesheet modules
               <phrase diff="chg" at="I">within the <termref def="dt-declaring-package">declaring package</termref></phrase>; importing
               components in one stylesheet module makes them available throughout the <termref def="dt-package">package</termref>.</p><p diff="add" at="I">The schema components imported into different <termref def="dt-package">packages</termref> 
               within a <termref def="dt-stylesheet">stylesheet</termref> must be consistent. Specifically, it is
            not permitted to use the same name in the same XSD symbol space to refer to different schema components within
            different packages; and the union of the schema components imported into the packages of a stylesheet must
            constitute a valid schema (as well as the set of schema components imported into each package forming a
            valid schema in its own right).</p><p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p><!--Text replaced by erratum E9 change 1"--><p>If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <rfc2119>must</rfc2119> be
               absent, and one of the following <rfc2119>must</rfc2119> be true:</p><ulist><item><p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p></item><item><p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p></item><item><p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p></item></ulist><!--End of text replaced by erratum E9--><p>
               <error spec="XT" type="static" class="SE" code="0215"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:import-schema</elcode> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p></error>
            </p><p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, or
               if both specify no namespace, then only the one with highest <termref def="dt-import-precedence">import precedence</termref> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p><p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above
               rule, the effect of the remaining <elcode>xsl:import-schema</elcode> declarations is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <elcode>xsl:import-schema</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p><ulist><item><p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p></item><item><p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p></item><item><p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <elcode>xsl:import-schema</elcode> declaration.</p></item></ulist><p>The schema components included in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> (that is, the components whose names are
               available for use within the stylesheet) are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document. See <bibref ref="xmlschema-1"/> (section 4.2.3,
                  <emph>References to schema components across namespaces</emph>).</p><p>
               <error spec="XT" type="static" class="SE" code="0220"><p>It is a <termref def="dt-static-error">static error</termref> if the synthetic
                     schema document does not satisfy the constraints described in <bibref ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and
                        Structure</emph>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p></error>
            </p><note><p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <elcode>xsl:import-schema</elcode> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
                  mutually consistent.</p><p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document A does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document A. (See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p><p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <termref def="dt-stylesheet">stylesheet</termref>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p><p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference">URI Reference</termref> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref> will be able to process a schema document found at this
                  location.</p><p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p><p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <elcode>xsl:import-schema</elcode> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p><p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p></note><p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p><example><head>An Inline Schema Document</head><p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p><p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p><eg xml:space="preserve">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:simpleType name="local:yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xs:variable name="condition" select="'yes'" as="local:yes-no"/&gt;
</eg></example></div2></div1><div1 id="data-model"><head>Data Model</head><p>The data model used by XSLT is the <phrase diff="chg" at="F">XPath 3.0 and XQuery 3.0</phrase> data model (XDM), as defined
            in <bibref ref="xpath-datamodel-30"/>. XSLT operates on source, result and stylesheet
            documents using the same data model.</p><p>This section elaborates on some particular features of XDM as it is used by XSLT:</p><p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/> make use
            of the concept of a whitespace text node.</p><p>
            <termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace
                  text node</term> is a text node whose content consists entirely of whitespace
               characters (that is, #x09, #x0A, #x0D, or #x20).</termdef>
         </p><note><p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p></note><div2 id="xml-versions"><head>XML Versions</head><p>The XDM data model defined in <bibref ref="xpath-datamodel-30"/> is capable of
               representing either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and
                  <bibref ref="xml-names"/>) or an XML 1.1 document (conforming to <bibref ref="xml11"/> and <bibref ref="xml-names11"/>), and it makes no distinction
               between the two. In principle, therefore, XSLT <phrase diff="chg" at="A">3.0</phrase>
               can be used with either of these XML versions.</p><p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  <phrase diff="chg" at="A">3.0</phrase> places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <specref ref="serialization"/>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p><p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p><p>Some of the syntactic constructs in XSLT <phrase diff="chg" at="A">3.0</phrase> and
               <phrase diff="chg" at="F">XPath 3.0</phrase>, for example the productions <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="Char" xlink:type="simple">Char</xnt> and <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, are defined by reference to the XML and
               XML Namespaces specifications. There are slight variations between the XML 1.0 and
               XML 1.1 versions of these productions <phrase diff="add" at="D">(and, indeed, between
                  different editions of XML 1.0)</phrase>. Implementations <rfc2119>may</rfc2119>
               support <phrase diff="chg" at="D">any</phrase> version; it is
                  <rfc2119>recommended</rfc2119> that an XSLT <phrase diff="chg" at="A">3.0</phrase>
               processor that implements the 1.1 versions <rfc2119>should</rfc2119> also provide a
               mode that supports the 1.0 versions. It is thus <termref def="dt-implementation-defined">implementation-defined</termref> whether the XSLT
               processor supports XML 1.0 with XML Namespaces 1.0, or XML 1.1 with XML Namespaces
               1.1, or supports both versions at user option.</p><note><p>The specification referenced as <bibref ref="xml-names"/> was actually
                  published without a version number.</p></note><imp-def-feature>It is implementation-defined which versions of XML and XML Namespaces
               (1.0 and/or 1.1) are supported.</imp-def-feature><p><phrase diff="chg" at="D">The current version of <bibref ref="xmlschema-2"/> (that
                  is, XSD 1.0) does not reference the XML 1.1 specifications.</phrase> This means
               that datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> are constrained
               by the XML 1.0 rules, and do not allow the full range of values permitted by XML 1.1.
               This situation will not be resolved until a new version of <bibref ref="xmlschema-2"/> becomes available; in the meantime, it is <rfc2119>recommended</rfc2119> that
               implementers wishing to support XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance. An XSLT <phrase diff="chg" at="A">3.0</phrase> processor that supports XML 1.1 <rfc2119>should</rfc2119> implement
               the rules in later versions of <bibref ref="xmlschema-2"/> as they become
               available.</p></div2><div2 id="stylesheet-stripping"><head>Stripping Whitespace from the Stylesheet</head><p>The tree representing the stylesheet is preprocessed as follows:</p><olist><item><p>All comments and processing instructions are removed.</p></item><item><p>Any text nodes that are now adjacent to each other are merged.</p></item><item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> that
                     satisfies both the following conditions is removed from the tree:</p><ulist><item><p>The parent of the text node is not an <elcode>xsl:text</elcode>
                           element</p></item><item><p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                           <code>preserve</code>, unless there is a closer ancestor element having
                           an <code>xml:space</code> attribute with a value of
                           <code>default</code>.</p></item></ulist></item><item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     parent is one of the following elements is removed from the tree, regardless of
                     any <code>xml:space</code> attributes:</p><slist><sitem>
                        <phrase diff="add" at="L">
                           <elcode>xsl:accumulator</elcode>
                        </phrase>
                     </sitem><sitem>
                        <elcode>xsl:analyze-string</elcode>
                     </sitem><sitem>
                        <elcode>xsl:apply-imports</elcode>
                     </sitem><sitem>
                        <elcode>xsl:apply-templates</elcode>
                     </sitem><sitem>
                        <elcode>xsl:attribute-set</elcode>
                     </sitem><sitem>
                        <elcode>xsl:call-template</elcode>
                     </sitem><sitem>
                        <elcode>xsl:character-map</elcode>
                     </sitem><sitem>
                        <elcode>xsl:choose</elcode>
                     </sitem><sitem>
                        <phrase diff="add" at="B">
                           <elcode>xsl:evaluate</elcode>
                        </phrase>
                     </sitem><sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge</elcode>
                        </phrase>
                     </sitem><sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge-source</elcode>
                        </phrase>
                     </sitem><sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:next-iteration</elcode>
                        </phrase>
                     </sitem><sitem>
                        <elcode>xsl:next-match</elcode>
                     </sitem><sitem>
                        <elcode>xsl:stylesheet</elcode>
                     </sitem><sitem>
                        <elcode>xsl:transform</elcode>
                     </sitem></slist></item><item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     immediate following-sibling node is an 
                     <elcode>xsl:param</elcode> or <elcode>xsl:sort</elcode> element is removed
                     from the tree, regardless of any <code>xml:space</code> attributes.</p></item><item><p diff="add" at="B">Any <termref def="dt-whitespace-text-node">whitespace text
                        node</termref> whose immediate preceding-sibling node is an
                        <elcode>xsl:catch</elcode> or <elcode>xsl:on-completion</elcode> element is
                     removed from the tree, regardless of any <code>xml:space</code> attributes.</p></item></olist><p>
               <error spec="XT" type="static" class="SE" code="0260"><p>Within an <termref def="dt-xslt-element">XSLT element</termref> that is
                        <rfc2119>required</rfc2119> to be empty, any content other than comments or
                     processing instructions, including any <termref def="dt-whitespace-text-node">whitespace text node</termref> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <termref def="dt-static-error">static error</termref>.</p></error>
            </p><note><p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <termref def="dt-sequence-constructor">sequence constructors</termref> will
                  cause all text nodes in that part of the stylesheet, including those that contain
                  whitespace only, to be copied to the result of the sequence constructor. When the
                  result of the sequence constructor is used to form the content of an element, this
                  can cause errors if such text nodes are followed by attribute nodes generated
                  using <elcode>xsl:attribute</elcode>.</p></note><note><p>If an <code>xml:space</code> attribute is specified on a <termref def="dt-literal-result-element">literal result element</termref>, it will be
                  copied to the result tree in the same way as any other attribute.</p></note></div2><div2 id="stripping-annotations"><head>Stripping Type Annotations from a Source Tree</head><p>
               <termdef id="dt-annotation" term="type annotation">The term <term>type
                     annotation</term> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <xspecref spec="DM30" ref="dm-type-name"/>.</termdef>
            </p><p>There is sometimes a requirement to write stylesheets that produce the same results
               whether or not the source documents have been validated against a schema. To achieve
               this, an option is provided to remove any <termref def="dt-annotation">type
                  annotations</termref> on element and attribute nodes in a <termref def="dt-source-tree">source tree</termref>, replacing them with an annotation of
                  <code>xs:untyped</code> in the case of element nodes, and
                  <code>xs:untypedAtomic</code> in the case of attribute nodes.</p><p>Such stripping of <termref def="dt-annotation">type annotations</termref> can be
               requested by specifying <code>input-type-annotations="strip"</code> on the
                  <elcode>xsl:stylesheet</elcode> element. This attribute has three permitted
               values: <code>strip</code>, <code>preserve</code>, and <code>unspecified</code>. The
               default value is <code>unspecified</code>. Stripping of type annotations takes place
               if at least one <termref def="dt-stylesheet-module">stylesheet module</termref> in
               the <termref def="dt-stylesheet">stylesheet</termref> specifies
                  <code>input-type-annotations="strip"</code>.</p><p>
               <error spec="XT" type="static" class="SE" code="0265"><p> It is a <termref def="dt-static-error">static error</termref> if there is a
                        <termref def="dt-stylesheet-module">stylesheet module</termref> in the
                        <termref def="dt-stylesheet">stylesheet</termref> that specifies
                        <code>input-type-annotations="strip"</code> and another <termref def="dt-stylesheet-module">stylesheet module</termref> that specifies
                        <code>input-type-annotations="preserve"</code>.</p></error>
            </p><p>The <termref def="dt-source-tree">source trees</termref> to which this applies are
               the same as those affected by <elcode>xsl:strip-space</elcode> and
                  <elcode>xsl:preserve-space</elcode>: see <specref ref="strip"/>.</p><p>When type annotations are stripped, the following changes are made to the source
               tree:</p><ulist><item><p>The type annotation of every element node is changed to <code>xs:untyped</code>
                  </p></item><item><p>The type annotation of every attribute node is changed to
                        <code>xs:untypedAtomic</code>
                  </p></item><item><p>The typed value of every element and attribute node is set to be the same as
                     its string value, as an instance of <code>xs:untypedAtomic</code>.</p></item><item><p>The <code>is-nilled</code> property of every element node is set to
                        <code>false</code>.</p></item></ulist><p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
               changed.</p><note><p>Stripping type annotations does not necessarily return the document to the state
                  it would be in had validation not taken place. In particular, any defaulted
                  elements and attributes that were added to the tree by the validation process will
                  still be present , and elements and attributes validated as IDs will still be
                  accessible using the <xfunction>id</xfunction> function.</p></note></div2><div2 id="strip"><head>Stripping Whitespace from a Source Tree</head><p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the
               transformation process may contain <termref def="dt-whitespace-text-node">whitespace
                  text nodes</termref> that are of no interest, and that do not need to be retained
               by the transformation. Conceptually, an XSLT <termref def="dt-processor">processor</termref> makes a copy of the source tree from which unwanted <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been removed.
               This process is referred to as whitespace stripping. </p><p>For the purposes of this section, the term <term>source tree</term> means the
               document containing the <termref def="dt-initial-context-item">initial context
                  item</termref>
               <phrase diff="chg" at="E">if it is a node</phrase>, and any document returned by the
               functions <function>document</function>, <xfunction>doc</xfunction>, or
                  <xfunction>collection</xfunction>. It does not include documents passed as the
               values of <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> or
               returned from <termref def="dt-extension-function">extension functions</termref>.</p><p>The stripping process takes as input a set of element names whose child <termref def="dt-whitespace-text-node">whitespace text nodes</termref> are to be preserved.
               The way in which this set of element names is established using the
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               declarations is described later in this section.</p><p>A <termref def="dt-whitespace-text-node">whitespace text node</termref> is preserved
               if either of the following apply:</p><ulist><item><p>The element name of the parent of the text node is in the set of
                     whitespace-preserving element names.</p></item><item><p>An ancestor element of the text node has an <code>xml:space</code> attribute
                     with a value of <code>preserve</code>, and no closer ancestor element has
                        <code>xml:space</code> with a value of <code>default</code>.</p></item></ulist><p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text node</termref>
               is stripped.</p><p>The <code>xml:space</code> attributes are not removed from the tree.</p><e:element-syntax name="strip-space"><e:in-category name="declaration"/><e:attribute name="elements" required="yes"><e:data-type name="tokens"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><e:element-syntax name="preserve-space"><e:in-category name="declaration"/><e:attribute name="elements" required="yes"><e:data-type name="tokens"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The set of whitespace-preserving element names is specified by
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               <termref def="dt-declaration">declarations</termref>. Whether an element name is
               included in the set of whitespace-preserving names is determined by the best match
               among all the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
               declarations: it is included if and only if there is no match or the best match is an
                  <elcode>xsl:preserve-space</elcode> element. The <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> elements each have an <code>elements</code>
               attribute whose value is a whitespace-separated list of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTests</xnt>; an element name matches an
                  <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode> element if
               it matches one of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTests</xnt>.
               An element matches a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> if
               and only if the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> would be
               true for the element as an XPath node test.</p><p diff="add" at="I">The effect of <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
            is local to the <termref def="dt-package">package</termref> in which they appear. Declarations within a
            library package only affect the handling of documents loaded using a call on the <function>document</function>,
            <xfunction>doc</xfunction>, or <xfunction>collection</xfunction> functions appearing lexically within the same
            package. Declarations within the top-level package also affect the processing of the main input document.</p><p diff="add" at="G"><!--bug 10097--><error spec="XT" type="static" class="SE" code="0270"><p>It 
               is a <termref def="dt-static-error">static error</termref> if 
               <phrase diff="add" at="I">within any <termref def="dt-package">package</termref></phrase>
               the same <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt>
            appears in both an <elcode>xsl:strip-space</elcode> and an <elcode>xsl:preserve-space</elcode>
               declaration if both have the same <termref def="dt-import-precedence">import
               precedence</termref>. Two NameTests are considered the same if they match the same set of names
               (which can be determined by comparing them after expanding namespace prefixes to URIs).</p></error></p><p><phrase diff="add" at="G">Otherwise,</phrase> when more than one
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> element
               <phrase diff="add" at="I">within the relevant <termref def="dt-package">package</termref></phrase>
               matches, the best matching element is determined by the best matching <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt>. 
               <phrase diff="del" at="G"><!--bug 10097-->This is determined in the
               same way as with</phrase>
               <phrase diff="add" at="G"><!--bug 10097-->The rules are similar to those for</phrase>
               <termref def="dt-template-rule">template rules</termref>:</p><ulist><item><p>First, any match with lower <termref def="dt-import-precedence">import
                        precedence</termref> than another match is ignored.</p></item><item><p>Next, any match that has a lower <termref def="dt-default-priority">default
                        priority</termref> than the <termref def="dt-default-priority">default
                        priority</termref> of another match is ignored.</p></item><item><p diff="chg" at="G">If several matches have the same <termref def="dt-default-priority">default
                  priority</termref> (which can only happen if one of the NameTests takes the form
                     <code>*:local</code> and the other takes the form <code>prefix:*</code>),
                     then the declaration that appears last in 
                     <termref def="dt-declaration-order">declaration order</termref> is used.</p></item></ulist><p diff="del" at="G"><!--bug 10097-->
               <error spec="XT" type="dynamic" class="RE" code="0270"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if this <error.extra>the process of finding an <elcode>xsl:strip-space</elcode>
                        or <elcode>xsl:preserve-space</elcode> declaration to match an element in
                        the source document</error.extra> leaves more than one match, unless all the
                     matched declarations are equivalent (that is, they are all
                        <elcode>xsl:strip-space</elcode> or they are all
                        <elcode>xsl:preserve-space</elcode>). <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
                        to select, from the matches that are left, the one that occurs last in
                           <termref def="dt-declaration-order">declaration order</termref>.
                     </error.action>
                  </p></error>
            </p><p>If an element in a source document has a <termref def="dt-annotation">type
                  annotation</termref> that is a simple type or a complex type with simple content,
               then any whitespace text nodes among its children are preserved, regardless of any
                  <elcode>xsl:strip-space</elcode> declarations. The reason for this is that
               stripping a whitespace text node from an element with simple content could make the
               element invalid: for example, it could cause the <code>minLength</code> facet to be
               violated.</p><p>Stripping of <termref def="dt-annotation">type annotations</termref> happens before
               stripping of whitespace text nodes, so this situation will not occur if
                  <code>input-type-annotations="strip"</code> is specified.</p><note><p>In <bibref ref="xpath-datamodel-30"/>, processes are described for constructing an
                  XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace
                  according to their own rules, and the provisions in this section apply to the
                  resulting tree. In practice this means that elements that are defined in a DTD or
                  a Schema to contain element-only content will have <termref def="dt-whitespace-text-node">whitespace text nodes</termref> stripped,
                  regardless of the <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p><p>However, source trees are not necessarily constructed using those processes;
                  indeed, they are not necessarily constructed by parsing XML documents. Nothing in
                  the XSLT specification constrains how the source tree is constructed, or what
                  happens to <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
                  during its construction. The provisions in this section relate only to whitespace
                  text nodes that are present in the tree supplied as input to the XSLT processor.
                  The XSLT processor cannot preserve whitespace text nodes unless they were actually
                  present in the supplied tree.</p></note></div2><div2 id="id-in-data-model"><head>Attribute Types and DTD Validation</head><p>The mapping from the Infoset to the XDM data model, described in <bibref ref="xpath-datamodel-30"/>, does not retain attribute types. This means, for example,
               that an attribute described in the DTD as having attribute type <code>NMTOKENS</code>
               will be annotated in the XDM tree as <code>xs:untypedAtomic</code> rather than
                  <code>xs:NMTOKENS</code>, and its typed value will consist of a single
                  <code>xs:untypedAtomic</code> value rather than a sequence of
                  <code>xs:NMTOKEN</code> values.</p><p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <termref def="dt-annotation">type
                  annotation</termref>, that are examined by the functions <xfunction>id</xfunction>
               and <xfunction>idref</xfunction> described in <bibref ref="xpath-functions-30"/>.</p></div2><div2 id="model-for-streaming" diff="add" at="C"><head>Data Model for Streaming</head><p>The data model for nodes in a document that is being streamed is no different from
               the standard XDM data model, in that it contains the same objects (nodes) with the
               same properties and relationships. The facilities for streaming do not change the
               data model; instead they impose rules that limit the ability of stylesheets to
               navigate the data model.</p><p>A useful way to visualize streaming is to suppose that at any point in
               time, there is a current position in the streamed input document which may be the
               start or end of the document, the start or end tag of an element, or a text, comment,
               or processing instruction node. From this position, the stylesheet has access to the
               following information: </p><ulist><item><p>Properties intrinsic to the node, such as its name, its base URI, its type
                     annotation, and its <code>is-id</code> and <code>is-idref</code>
                     properties.</p></item><item><p>The ancestors of the node (but navigation downwards from the ancestors is not
                     permitted).</p></item><item><p>The attributes of the node, and the attributes of its ancestors. For each such
                     attribute, all the properties of the node including its string value and typed
                     value are available, but there are limitations that restrict navigation from
                     the attribute node to other nodes in the document.</p></item><item><p>The in-scope namespace bindings of the node.</p></item><item><p>In the case of attributes, text nodes, comments, and processing instructions,
                     the string value and typed value of the node.</p></item><item><p>Summary data about the preceding siblings of the node, and of each of its
                     ancestor nodes: specifically, for each distinct combination of node kind, node
                     name, and type annotation, a count of the number of preceding siblings that
                     have that combination of properties. This information allows patterns such as
                        <code>match="para[1]"</code> to be used, and it permits some limited use of
                     the <elcode>xsl:number</elcode> instruction.</p></item></ulist><p>The children and other descendants of a node are not accessible except as a
               by-product of changing the current position in the document. The same applies to
               properties of an element or document node that require examination of the node's
               descendants, that is, the string value and typed value. This is enforced by means of
               a rule that only one expression requiring downward navigation from a node is
               permitted.</p><p diff="add" at="I">There is an assumption that information about unparsed entities is available at
            all times during the processing of a document. This has two implications: firstly, the processor
            may need to read ahead at the start of the document to determine this information so that it is 
            available while processing the document root node; and secondly, the information then needs to
            be retained for the duration of the processing.</p><p diff="add" at="I">Expressions such as <code>(/) instance of document-node(element(invoice))</code> also
            require look-ahead as far as the start-tag of the first element.</p><p diff="add" at="I">A streaming processor is required to read only as much of the source document as is needed
            to generate correct stylesheet output. It is not required to read the full source document
            merely in order to satisfy the requirement imposed by the XML Recommendation that an XML Processor
            must report violations of well-formedness in the input.</p><p>More detailed rules are defined in <specref ref="streamability"/>.</p></div2><div2 id="limits"><head>Limits</head><p>The XDM data model (see <bibref ref="xpath-datamodel-30"/>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p><p>Limits on some primitive datatypes are defined in <bibref ref="xmlschema-2"/>. Other
               limits, listed below, are <termref def="dt-implementation-defined">implementation-defined</termref>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p><imp-def-feature>Limits on the value space of primitive datatypes, where not fixed by
                  <bibref ref="xmlschema-2"/>, are implementation-defined.</imp-def-feature><p>The following limits are <termref def="dt-implementation-defined">implementation-defined</termref>:</p><olist><item><p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p></item><item><p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p></item><item><p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p></item><item><p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p></item><item><p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p></item><item><p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p></item><item><p>For sequences, the maximum number of items in a sequence.</p></item></olist></div2><div2 id="d-o-e-in-data-model"><head>Disable Output Escaping</head><p>For backwards compatibility reasons, XSLT <phrase diff="chg" at="A">3.0</phrase>
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <rfc2119>required</rfc2119> to support it. A new facility, that of named <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) <phrase diff="chg" at="A">was</phrase> introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p><p>If an <termref def="dt-implementation">implementation</termref> supports the
                  <code>disable-output-escaping</code> attribute of <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode>, (see <specref ref="disable-output-escaping"/>),
               then the data model for trees constructed by the <termref def="dt-processor">processor</termref> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <termref def="dt-final-result-tree">final result tree</termref> that is being passed to the
               serializer.</p><p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character<phrase diff="del" at="L"> or attribute node</phrase>.</p><note><p>In practice, the nodes in a <termref def="dt-final-result-tree">final result
                     tree</termref> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p></note></div2></div1><div1 id="constructs"><head>Features of the XSLT Language</head><div2 id="qname" diff="chg" at="K"><head>Qualified Names</head><p>The name of a stylesheet-defined object, specifically a <termref def="dt-named-template">named template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a
                  <termref def="dt-key">key</termref>, a <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or
                  <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet function</termref>, a named <termref def="dt-output-definition">output definition</termref>, or a <termref def="dt-character-map">character map</termref> is a qualified name:
                  that is, it consists of a local name and an optional namespace URI.</p><p>In most cases where such names are written in a 
               <termref def="dt-stylesheet">stylesheet</termref>, the syntax for expressing
               the name is given by the production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-EQName" xlink:type="simple">EQName</xnt>
               in the XPath specification. In practice, this means that three forms are permitted:</p><ulist><item><p>A simple <code>NCName</code> appearing on its own (without any prefix). 
                  This represents
               the local name of the object. The interpretation of unprefixed names is described below.</p></item><item><p>A <termref def="dt-lexical-qname">lexical QName</termref>
                  written in the form <code>NCName ":" NCName</code> where the first
               part is a namespace prefix and the second part is the local name. The namespace
               part of the object's name is then derived from the prefix by examining the
               in-scope namespace bindings of the element node in the stylesheet where the
               name appears.</p></item><item><p>A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-URIQualifiedName" xlink:type="simple">URIQualifiedName</xnt>
               in the form <code>"Q{" URI? "}" NCName</code> where the two parts of the name,
               that is the namespace part and the local part, both appear explicitly. If the URI
               part is omitted (for example <code>Q{}local</code>), the 
               resulting expanded QName is a QName whose namespace part is absent.</p></item></ulist><note><p>There are a few places where the third form, a URIQualifiedName, is not permitted.
               These include the <code>name</code> attribute of <elcode>xsl:element</elcode>
               and <elcode>xsl:attribute</elcode> (which have a separate <code>namespace</code>
               attribute for the purpose), and constructs defined by other specifications. For
               example, names appearing within an embedded <code>xs:schema</code> element
               must follow the XSD rules.</p></note><p>
               <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded QName</term>
                  is a value in the value space of the <code>xs:QName</code> datatype as defined in the
                  XDM data model (see <bibref ref="xpath-datamodel-30"/>): that is, a triple containing
                  namespace prefix (optional), namespace URI (optional), and local name. 
                  Two expanded QNames are equal if the
                  namespace URIs are the same (or both absent) and the local names are the same. The
                  prefix plays no part in the comparison, but is used only if the expanded QName
                  needs to be converted back to a string.</termdef>
            </p><p><termdef id="dt-eqname" term="EQName">An <term>EQName</term> is a string
               representing a <termref def="dt-expanded-qname">expanded QName</termref>
               where the string, after removing leading and trailing whitespace, 
               is in the form defined by the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-EQName" xlink:type="simple">EQName</xnt> production
               in the XPath specification.</termdef></p><note><p>At the time of publication, the most recent public working draft of XPath 3.0
            uses the syntax <code>"uri":local</code> for an EQName. However, the next public working
            draft is expected to use the syntax <code>Q{uri}local</code>.</p></note><p>
               <termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term> is a
                  string representing a <termref def="dt-expanded-qname">expanded QName</termref>
                  where the string, after removing leading and trailing whitespace, 
                  is within the lexical space of the <code>xs:QName</code>
                  datatype as defined in XML Schema (see <bibref ref="xmlschema-2"/>): 
                  that is, a local name optionally preceded by
                  a namespace prefix and a colon.</termdef>
            </p><p>Note that every <termref def="dt-lexical-qname">lexical QName</termref> is
            an <termref def="dt-eqname">EQName</termref>, but the converse is not true.</p><p>The following rules are used when interpreting a 
               <termref def="dt-lexical-qname">lexical QName</termref>:</p><olist><item><p>
               <termdef id="dt-defining-element" term="defining element">A string in the form of a
                  lexical QName may occur as the value of an attribute node in a stylesheet module,
                  or within an XPath <termref def="dt-expression">expression</termref> contained in
                  such an attribute node, or as the result of evaluating an XPath expression
                  contained in such an attribute node. The element containing this attribute node is
                  referred to as the <term>defining element</term> of the lexical QName.</termdef>
            </p></item><item><p>If the lexical QName has a prefix, then the prefix is expanded into a URI reference using the
               namespace declarations in effect on its <termref def="dt-defining-element">defining
                  element</termref>. The <termref def="dt-expanded-qname">expanded QName</termref>
               consisting of the local part of the name and the possibly null URI reference is used
               as the name of the object. The default namespace of the defining element (see
                  <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used for unprefixed
                  names.</p><p>
                  <error spec="XT" type="static" class="SE" code="0280"><p>In the case of a prefixed <termref def="dt-lexical-qname">lexical QName</termref> used as the
                        value <phrase diff="add" at="G">(or as part of the value)</phrase> 
                        of an attribute in the <termref def="dt-stylesheet">stylesheet</termref>,
                        or appearing within an XPath <termref def="dt-expression">expression</termref>
                        in the stylesheet, it is a <termref def="dt-static-error">static
                           error</termref> if the <termref def="dt-defining-element">defining
                              element</termref> has no namespace node whose name matches the prefix of the
                        <termref def="dt-lexical-qname">lexical QName</termref>.</p></error>
               </p><p>
                  <error spec="XT" type="dynamic" class="DE" code="0290"><p>Where the result of evaluating an XPath expression (or an attribute value
                        template) is required to be a <termref def="dt-lexical-qname">lexical
                           QName</termref>, or if it is permitted to be a
                        <termref def="dt-lexical-qname">lexical QName</termref> and the actual value
                        takes the form of a <termref def="dt-lexical-qname">lexical QName</termref>,
                        then unless otherwise specified it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        value has a prefix and the
                        <termref def="dt-defining-element">defining element</termref> has no
                        namespace node whose name matches that prefix. This error
                        <rfc2119>may</rfc2119> be signaled as a <termref def="dt-static-error">static error</termref> if the value of the expression can be determined
                        statically.</p></error>
               </p></item><item><p>If the lexical QName has no prefix, then:</p><olist><item><p>In the case of an unprefixed QName used as a <code>NameTest</code> within an XPath
                     <termref def="dt-expression">expression</termref> (see <specref ref="expressions"/>) , and in certain other contexts, the namespace to be used in expanding the QName
                     may be specified by means of the <code>[xsl:]xpath-default-namespace</code>
                     attribute, as specified in <specref ref="unprefixed-qnames"/>.</p></item><item><p>If the name is in one of the following categories, 
                  then the default namespace of the <termref def="dt-defining-element">defining element</termref>
                  is used:</p><olist><item><p>Where a QName is used to define the name of an element being constructed. This
                              applies both to cases where the name is known statically (that is, the name of
                              a literal result element) and to cases where it is computed dynamically (the
                              value of the <code>name</code> attribute of the <elcode>xsl:element</elcode>
                              instruction).</p></item><item><p>The default namespace is used when expanding the first argument of the function
                                 <function>element-available</function>.</p></item><item><p>The default namespace applies to any unqualified element names appearing in the
                                 <code>cdata-section-elements</code> attribute of <elcode>xsl:output</elcode>
                              or <elcode>xsl:result-document</elcode>
                           </p></item></olist></item><item><p>In all other cases, a <termref def="dt-lexical-qname">lexical QName</termref>
                  with no prefix represents an <termref def="dt-expanded-qname">expanded QName</termref>
                  in no namespace (that is, an <code>xs:QName</code> value in which both the prefix
                  and the namespace URI are absent).</p></item></olist></item></olist></div2><div2 id="unprefixed-qnames"><head>Unprefixed Lexical QNames in Expressions and Patterns</head><p>The attribute <code>[xsl:]xpath-default-namespace</code> (see <specref ref="standard-attributes"/>) may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the namespace that will be used
               for an unprefixed element name or type name within an XPath expression, and in
               certain other contexts listed below.</p><p>The value of the attribute is the namespace URI to be used.</p><p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, this
               attribute has an effective value, which is the value of the
                  <code>[xsl:]xpath-default-namespace</code> on that element or on the innermost
               containing element that specifies such an attribute, or the zero-length string if no
               containing element specifies such an attribute.</p><p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
               effective value of this attribute determines the value of the <emph>default namespace
                  for element and type names</emph> in the static context of any XPath expression
               contained in an attribute of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>). The effect
               of this is specified in <bibref ref="xpath-30"/>; in summary, it determines the
               namespace used for any unprefixed type name in the SequenceType production, and for
               any element name appearing in a path expression or in the SequenceType
               production.</p><p>The effective value of this attribute similarly applies to any of the following
               constructs appearing within its scope:</p><ulist><item><p>any unprefixed element name or type name used in a <termref def="dt-pattern">pattern</termref>
                  </p></item><item><p>any unprefixed element name used in the <code>elements</code> attribute of the
                        <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                     instructions</p></item><item><p>any unprefixed element name or type name used in the <code>as</code> attribute
                     of an <termref def="dt-xslt-element">XSLT element</termref>
                  </p></item><item><p>any unprefixed type name used in the <code>type</code> attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                  </p></item><item><p>any unprefixed type name used in the <code>xsl:type</code> attribute of a
                        <termref def="dt-literal-result-element">literal result
                     element</termref>.</p></item></ulist><p>The <code>[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119> be
               in the <termref def="dt-xslt-namespace">XSLT namespace</termref> if and only if its
               parent element is <emph>not</emph> in the XSLT namespace.</p><p>If the effective value of the attribute is a zero-length string, which will be the
               case if it is explicitly set to a zero-length string or if it is not specified at
               all, then an unprefixed element name or type name refers to a name that is in no
               namespace. The default namespace of the parent element (see <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used.</p><p>The attribute does not affect other names, for example function names, variable
               names, or template names, or strings that are interpreted as <termref def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation, such
               as the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute of <elcode>xsl:element</elcode> or the string supplied
               as the first argument to the <function>key</function> function.</p></div2><div2 id="expressions"><head>Expressions</head><p>XSLT uses the expression language defined by <phrase>XPath 3.0</phrase>
               <bibref ref="xpath-30"/>. Expressions are used in XSLT for a variety of purposes
               including:</p><ulist><item><p>selecting nodes for processing;</p></item><item><p>specifying conditions for different ways of processing a node;</p></item><item><p>generating text to be inserted in a <termref def="dt-result-tree">result
                        tree</termref>.</p></item></ulist><p>
               <termdef id="dt-expression" term="expression">Within this specification, the term
                     <term>XPath expression</term>, or simply <term>expression</term>, means a
                  string that matches the production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Expr" xlink:type="simple">Expr</xnt> defined in <bibref ref="xpath-30"/>.</termdef>
            </p><p>An XPath expression may occur as the value of certain attributes on XSLT-defined
               elements, and also within curly brackets in <termref def="dt-attribute-value-template">attribute value templates</termref>.</p><p>Except where <termref def="dt-forwards-compatible-behavior"/> is enabled 
               (see <specref ref="forwards"/>), it is a <termref def="dt-static-error">static error</termref> if the value of such an attribute,
                  <error.extra>an attribute defined as containing an XPath <termref def="dt-expression">expression</termref>
               </error.extra> or the text between curly brackets in an attribute value template,
               does not match the XPath production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Expr" xlink:type="simple">Expr</xnt>, or if it fails to satisfy other static constraints defined in the
               XPath specification, for example that all variable references <rfc2119>must</rfc2119>
               refer to <termref def="dt-variable">variables</termref> that are in scope. Error
               codes are defined in <bibref ref="xpath-30"/>.</p><p>The transformation fails with a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if any XPath <termref def="dt-expression">expression</termref> is evaluated and raises a dynamic error. Error codes are
               defined in <bibref ref="xpath-30"/>.</p><p>The transformation fails with a <termref def="dt-type-error">type error</termref> if
               an XPath <termref def="dt-expression">expression</termref> raises a type error, or if
               the result of evaluating the XPath <termref def="dt-expression">expression</termref>
               is evaluated and raises a type error, or if the XPath processor signals a type error
               during static analysis of an <termref def="dt-expression">expression</termref>. Error
               codes are defined in <bibref ref="xpath-30"/>.</p><p>
               <termdef id="dt-required-type" term="required type">The context within a <termref def="dt-stylesheet">stylesheet</termref> where an XPath <termref def="dt-expression">expression</termref> appears may specify the <term>required
                     type</term> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</termdef> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p><p>
               <termdef id="dt-function-conversion-rules" term="function conversion rules">Except
                  where otherwise indicated, the actual value of an <termref def="dt-expression">expression</termref> is converted to the <termref def="dt-required-type">required type</termref> using the <term>function conversion rules</term>.
                  These are the rules defined in <bibref ref="xpath-30"/> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The relevant rules are those that apply when
                     <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is
                  set to <code>false</code>.</termdef>
            </p><p>This specification also invokes the <phrase diff="chg" at="D">XPath 3.0</phrase>
               <termref def="dt-function-conversion-rules">function conversion rules</termref> to
               convert the result of evaluating an XSLT <termref def="dt-sequence-constructor">sequence constructor</termref> to a required type (for example, the sequence
               constructor enclosed in an <elcode>xsl:variable</elcode>,
                  <elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p><p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs when applying the <termref def="dt-function-conversion-rules">function conversion rules</termref> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p><note><p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be reported statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the string <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are reported only if the instructions or expressions that
                  cause them are actually evaluated.</p></note></div2><div2 id="static-and-dynamic-context"><head>The Static and Dynamic Context</head><p>XPath defines the concept of an <xtermref spec="XP30" ref="dt-expression-context">expression context</xtermref> which contains all the information that can affect
               the result of evaluating an <termref def="dt-expression">expression</termref>. The
               expression context has two parts, the <xtermref spec="XP30" ref="dt-static-context">static context</xtermref>, and the <xtermref spec="XP30" ref="dt-dynamic-context">dynamic context</xtermref>. The components that make up the expression context
               are defined in the XPath specification (see <xspecref spec="XP30" ref="context"/>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p><p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>), and also
               by the functions in the extended function library described in this
               specification.</p><p>The following four sections describe:</p><slist><sitem>
                  <specref ref="static-context"/>
               </sitem><sitem>
                  <specref ref="additional-static-context"/>
               </sitem><sitem>
                  <specref ref="xpath-dynamic-context"/>
               </sitem><sitem>
                  <specref ref="additional-dynamic-context"/>
               </sitem></slist><div3 id="static-context"><head>Initializing the Static Context</head><p>The <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <term>containing element</term> means the element within the
                  stylesheet that is the parent of the attribute whose value contains the XPath
                  expression in question, and the term <term>enclosing element</term> means the
                  containing element or any of its ancestors.</p><ulist><item><p diff="chg" at="D">
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                        is set to true if and only if the containing element is processed with
                           <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref> (see
                           <specref ref="backwards"/>).</p></item><item><p>The <xtermref spec="XP30" ref="dt-static-namespaces">statically known
                           namespaces</xtermref> are the namespace declarations that are in scope
                        for the containing element.</p></item><item><p>The <xtermref spec="XP30" ref="dt-def-elemtype-ns">default element/type
                           namespace</xtermref> is the namespace defined by the
                           <code>[xsl:]xpath-default-namespace</code> attribute on the innermost
                        enclosing element that has such an attribute, as described in <specref ref="unprefixed-qnames"/>. The value of this attribute is a namespace
                        URI. If there is no <code>[xsl:]xpath-default-namespace</code> attribute on
                        an enclosing element, the default namespace for element names and type names
                        is the null namespace.</p></item><item><p>The <xtermref spec="XP30" ref="dt-def-fn-ns">default function
                           namespace</xtermref> is the <termref def="dt-standard-function-namespace">standard function namespace</termref>, defined in <bibref ref="xpath-functions-30"/>. This means that it is not necessary to declare
                        this namespace in the <termref def="dt-stylesheet">stylesheet</termref>, nor
                        is it necessary to use the prefix <code>fn</code> (or any other prefix) in
                        calls to the <termref def="dt-core-function">core functions</termref>.</p></item><item><p>The <xtermref spec="XP30" ref="dt-issd">in-scope schema
                           definitions</xtermref> for the XPath expression are the same as the
                           <termref def="dt-in-scope-schema-component">in-scope schema
                           components</termref> for the <termref def="dt-stylesheet">stylesheet</termref>, and are as specified in <specref ref="built-in-types"/>.</p></item><item><p>The <xtermref spec="XP30" ref="dt-in-scope-variables">in-scope
                           variables</xtermref> are defined by the <termref def="dt-variable-binding-element">variable binding elements</termref>
                        that are in scope for the containing element (see <specref ref="variables-and-parameters"/>).</p></item><item diff="add" at="D"><p>The <xtermref spec="XP30" ref="dt-context-item-static-type">context item
                           static type</xtermref> may be determined by an XSLT processor that
                        performs static type inferencing, using rules that are outside the scope of
                        this specification; if no static type inferencing is done, then the context
                        item static type for every XPath expression is <code>item()</code>. </p></item><item><p>The <xtermref spec="XP30" ref="dt-known-func-signatures">Statically known function
                           signatures</xtermref> are the <termref def="dt-core-function">core
                           functions</termref> defined in <bibref ref="xpath-functions-30"/>, the
                        constructor functions for all the atomic types in the <xtermref spec="XP30" ref="dt-issd">in-scope schema definitions</xtermref>, the additional
                        functions defined in this specification, the <termref def="dt-stylesheet-function">stylesheet functions</termref> defined in
                        the stylesheet, plus any <termref def="dt-extension-function">extension
                           functions</termref> bound using <termref def="dt-implementation-defined">implementation-defined</termref> mechanisms (see <specref ref="extension"/>).</p><note><p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of <termref def="dt-core-function">core
                              functions</termref> defined in <bibref ref="xpath-functions-30"/>.</p></note></item><item><p>The <xtermref spec="XP30" ref="dt-static-collations">statically known
                           collations</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>. However, the set of in-scope
                        collations <rfc2119>must</rfc2119> always include the Unicode codepoint
                        collation, defined in <xspecref spec="FO30" ref="string-compare"/>.</p></item><item><p>The <xtermref spec="XP30" ref="dt-def-collation">default
                           collation</xtermref> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                        element that has such an attribute. For details, see <specref ref="default-collation-attribute"/>.</p><p>
                        <termdef id="dt-default-collation" term="default collation">In this
                           specification the term <term>default collation</term> means the collation
                           that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                           stylesheet.</termdef>
                     </p><p>This collation is also used by default when comparing strings in the
                        evaluation of the <elcode>xsl:key</elcode> and
                           <elcode>xsl:for-each-group</elcode> elements. This <rfc2119>may</rfc2119>
                        also (but need not necessarily) be the same as the default collation used
                        for <elcode>xsl:sort</elcode> elements within the stylesheet. Collations
                        used by <elcode>xsl:sort</elcode> are described in <specref ref="collating-sequences"/>.</p></item><item><p>The <xtermref spec="DM30" ref="dt-base-uri">base URI</xtermref> is the base
                        URI of the containing element in the stylesheet. The concept of the base URI
                        of a node is defined in <xspecref spec="DM30" ref="dm-base-uri"/>
                     </p></item><item diff="add" at="D"><p>The set of <xtermref spec="XP30" ref="dt-known-docs">statically known
                           documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref><phrase diff="del" at="I">, and by default is empty</phrase>. </p><imp-def-feature>The set of <xtermref spec="XP30" ref="dt-known-docs">statically known documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature></item><item diff="add" at="D"><p>The set of <xtermref spec="XP30" ref="dt-known-collections">statically known
                           collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref><phrase diff="del" at="I">, and by default is empty</phrase>. </p><imp-def-feature>The set of <xtermref spec="XP30" ref="dt-known-collections">statically known collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature></item><item diff="add" at="D"><p>The <xtermref spec="XP30" ref="dt-known-default-collection">statically known
                           default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref><phrase diff="del" at="I">, and by
                        default is <code>node()*</code></phrase>. </p><imp-def-feature>The <xtermref spec="XP30" ref="dt-known-default-collection">statically known default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature></item><item diff="add" at="D"><p>The set of <xtermref spec="XP30" ref="dt-static-decimal-formats">statically
                           known decimal formats</xtermref> is the set of decimal formats defined by
                           <elcode>xsl:decimal-format</elcode> declarations in the stylesheet. </p></item></ulist></div3><div3 id="additional-static-context"><head>Additional Static Context Components used by XSLT</head><p>Some of the components of the XPath static context are used also by <termref def="dt-xslt-element">XSLT elements</termref>. For example, the
                     <elcode>xsl:sort</elcode> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p><p>Many top-level declarations in a stylesheet, and attributes on the
                     <elcode>xsl:stylesheet</elcode> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p><p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p><ulist><item><p>The set of named keys, used by the <function>key</function> function</p></item><item diff="del" at="D"><p>The set of named decimal formats, used by the
                           <xfunction>format-number</xfunction> function</p></item><item><p>The values of system properties, used by the
                           <function>system-property</function> function</p></item><item><p>The set of available instructions, used by the
                           <function>element-available</function> function</p></item></ulist></div3><div3 id="xpath-dynamic-context"><head>Initializing the Dynamic Context</head><p>For convenience, the dynamic context is described in two parts: the <termref def="dt-focus">focus</termref>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p><p>A number of functions specified in <bibref ref="xpath-functions-30"/> are defined to
                  be <xtermref spec="FO30" ref="dt-deterministic">deterministic</xtermref>, meaning that if they are
                  called twice during the same <xtermref spec="FO30" ref="execution-scope">execution
                     scope</xtermref>, with the same arguments, then they return the same results
                  (see <xspecref spec="FO30" ref="terminology"/>). In XSLT, the execution of a
                  stylesheet defines the execution scope. This means, for example, that if the
                  function <xfunction>current-dateTime</xfunction> is called repeatedly during a
                  transformation, it produces the same result each time. By implication, the
                  components of the dynamic context on which these functions depend are also stable
                  for the duration of the transformation. Specifically, the following components
                  defined in <xspecref spec="XP30" ref="eval_context"/> must be stable:
                     <emph>function implementations</emph>, <emph>current dateTime</emph>,
                     <emph>implicit timezone</emph>, <emph>available documents</emph>,
                     <emph>available collections</emph>, and <emph>default collection</emph>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <emph>not</emph> stable; the additional
                  dynamic context components defined in <specref ref="additional-dynamic-context"/>
                  are also <emph>not</emph> stable.</p><p>As specified in <bibref ref="xpath-functions-30"/>, implementations may provide user
                  options that relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><imp-def-feature>Implementations may provide user options that relax the requirement
                  for the <xfunction>doc</xfunction> and <xfunction>collection</xfunction> functions
                  (and therefore, by implication, the <function>document</function> function) to
                  return stable results. The manner in which such user options are provided, if at
                  all, is <termref def="dt-implementation-defined"/>. </imp-def-feature><p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated "during the transformation" as defined above. For
                  details see <specref ref="conditional-inclusion"/>.</p><p diff="add" at="K"><termdef id="dt-absent" term="absent">A component
               of the context that has no value is said to be <term>absent</term>.</termdef> This
               is a distinguishable state, and is not the same as having the empty sequence
               as its value.</p><div4 id="focus"><head>Maintaining Position: the Focus</head><p>
                     <termdef id="dt-focus" term="focus">When a <termref def="dt-sequence-constructor">sequence constructor</termref> is
                        evaluated, the <termref def="dt-processor">processor</termref> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <term>focus</term>.</termdef> More
                     specifically, the focus consists of the following three values:</p><ulist><item><p><termdef id="dt-context-item" term="context item">The <term>context
                                 item</term> is the item currently being processed. An item (see
                                 <bibref ref="xpath-datamodel-30"/>) is either an atomic value (such as
                              an integer, date, or string), a node, <phrase diff="add" at="C">or a
                                 function item</phrase>. The context item is initially set to the
                                 <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> supplied when the transformation is invoked (see
                                 <specref ref="initiating"/>). It changes whenever instructions such
                              as <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</termdef> The context item is returned
                           by the XPath <termref def="dt-expression">expression</termref>
                           <code>.</code> (dot).</p></item><item><p><termdef id="dt-context-position" term="context position">The
                                 <term>context position</term> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <elcode>xsl:apply-templates</elcode> or
                                 <elcode>xsl:for-each</elcode> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</termdef> The context position is returned by the XPath <termref def="dt-expression">expression</termref>
                           <code>position()</code>.</p></item><item><p><termdef id="dt-context-size" term="context size">The <term>context
                                 size</term> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</termdef> The context size is returned by the XPath
                              <termref def="dt-expression">expression</termref>
                           <code>last()</code>.</p></item></ulist><p>
                     <termdef id="dt-context-node" term="context node">If the <termref def="dt-context-item">context item</termref> is a node (as distinct from
                        an atomic value such as an integer), then it is also referred to as the
                           <term>context node</term>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, there is no context node.</termdef> The context node is
                     returned by the XPath <termref def="dt-expression">expression</termref>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p><p>Where the containing element of an XPath expression is an <termref def="dt-instruction">instruction</termref> or a <termref def="dt-literal-result-element">literal result element</termref>, the
                     initial context item, context position, and context size for the XPath <termref def="dt-expression">expression</termref> are the same as the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing instruction or literal result element.</p><p>In other cases (for example, where the containing element is
                        <elcode>xsl:sort</elcode>, <elcode>xsl:with-param</elcode>, or
                        <elcode>xsl:key</elcode>), the rules are given in the specification of the
                     containing element.</p><p>The <function>current</function> function can be used within any XPath <termref def="dt-expression">expression</termref> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <function>current</function>
                     function is described in <specref ref="func-current"/>.</p><p>On completion of an instruction that changes the <termref def="dt-focus">focus</termref> (such as <elcode>xsl:apply-templates</elcode> or
                        <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p><p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is
                     called, the focus within the body of the function is initially <termref def="dt-absent">absent</termref>. The
                     focus is also <termref def="dt-absent">absent</termref> on initial entry to the <termref def="dt-stylesheet">stylesheet</termref> if no <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> is supplied.</p><p>When the focus is <termref def="dt-absent">absent</termref>, evaluation of any <termref def="dt-expression">expression</termref> that references the context item, context position, or
                     context size results in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
                     <xerrorref spec="XP" class="DY" code="0002"/></p><p>The description above gives an outline of the way the <termref def="dt-focus">focus</termref> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction. </p><p>
                     <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton
                           focus</term> based on an item <var>J</var> has the <phrase diff="chg" at="F"><termref def="dt-context-item">context item</termref> (and therefore the <termref def="dt-context-node">context node</termref>, if <var>J</var> is a node)</phrase> set to <var>J</var>, and
                        the <termref def="dt-context-position">context position</termref> and
                           <termref def="dt-context-size">context size</termref> both set to 1
                        (one).</termdef>
                  </p></div4><div4 id="evaluation-context"><head>Other Components of the XPath Dynamic Context</head><p>The previous section explained how the <termref def="dt-focus">focus</termref>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <xtermref spec="XP30" ref="dt-dynamic-context">dynamic context</xtermref> of an XPath expression
                     are initialized.</p><ulist><item><p>The <xtermref spec="XP30" ref="dt-variable-values">dynamic
                              variables</xtermref> are the current values of the in-scope <termref def="dt-variable-binding-element">variable binding
                           elements</termref>.</p></item><item><p>The <emph>current date and time</emph> represents an <termref def="dt-implementation-dependent">implementation-dependent</termref>
                           point in time during processing of the transformation; it does not change
                           during the course of the transformation.</p></item><item><p>The <xtermref spec="XP30" ref="dt-timezone">implicit timezone</xtermref>
                           is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><imp-def-feature>The implicit timezone for a transformation is
                           implementation-defined.</imp-def-feature></item><item><p>The <xtermref spec="XP30" ref="dt-known-docs">available
                              documents</xtermref>, and the <xtermref spec="XP30" ref="dt-known-collections">available collections</xtermref> are
                           determined as part of the process for initiating a transformation (see
                              <specref ref="initiating"/>).</p><p>The <xtermref spec="XP30" ref="dt-known-docs">available
                           documents</xtermref> are defined as part of the <phrase diff="chg" at="F">XPath 3.0</phrase> dynamic
                           context to support the <xfunction>doc</xfunction> function, but this
                           component is also referenced by the similar XSLT
                              <function>document</function> function: see <specref ref="func-document"/>.
                           This variable defines a mapping between URIs passed to the
                              <xfunction>doc</xfunction> or <function>document</function> function
                           and the document nodes that are returned.</p><note><p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p></note><p>The XSLT-defined <function>document</function> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in <xtermref spec="XP30" ref="dt-known-docs">available documents</xtermref> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p></item><item><p>The <xtermref spec="XP30" ref="dt-default-collection">default
                              collection</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. This allows options such as setting
                           the default collection to be an empty sequence, or to be <termref def="dt-absent">absent</termref>.</p><imp-def-feature>The <xtermref spec="XP30" ref="dt-default-collection">default collection</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature></item></ulist></div4></div3><div3 id="additional-dynamic-context"><head>Additional Dynamic Context Components used by XSLT</head><p>In addition to the values that make up the <termref def="dt-focus">focus</termref>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p><ulist><item><p>The <termref def="dt-current-template-rule">current template rule</termref>,
                        which is the <termref def="dt-template-rule">template rule</termref> most
                        recently invoked by an <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>
                        instruction: see <specref ref="apply-imports"/>; </p></item><item><p>The <termref def="dt-current-mode">current mode</termref>, which is the
                           <termref def="dt-mode">mode</termref> set by the most recent call of
                           <elcode>xsl:apply-templates</elcode> (for a full definition see <specref ref="modes"/>);</p></item><item><p>The <termref def="dt-current-group">current group</termref> and <termref def="dt-current-grouping-key">current grouping key</termref>, which
                        provide information about the collection of items currently being processed
                        by an <elcode>xsl:for-each-group</elcode> 
                        <phrase diff="add" at="I">or <elcode>xsl:merge</elcode></phrase> instruction: see <specref ref="func-current-group"/>, <specref ref="func-current-grouping-key"/>,
                        and <specref ref="merging"/>;</p><note><p>In XSLT 3.0 the initial value of these two properties is "absent",
                     which means that any reference to their values causes a dynamic error. Previously,
                     the initial value was an empty sequence. The value is also set to "absent"
                     by an <elcode>xsl:for-each-group</elcode> instruction that binds variables to the
                     current group and/or grouping-key using the <code>bind-group</code> or
                     <code>bind-grouping-key</code> attributes.</p></note></item><item><p>The <termref def="dt-current-captured-substrings">current captured
                           substrings</termref>: this is a sequence of strings, which is maintained
                        when a string is matched against a regular expression using the
                           <elcode>xsl:analyze-string</elcode> instruction, and which is accessible
                        using the <function>regex-group</function> function: see <specref ref="func-regex-group"/>.</p></item><item><p>The <termref def="dt-output-state">output state</termref>: this is a flag
                        whose two possible values are <termref def="dt-final-output-state">final
                           output state</termref> and <termref def="dt-temporary-output-state">temporary output state</termref>. This flag indicates whether
                        instructions are currently writing to a <termref def="dt-final-result-tree">final result tree</termref> or to an internal data structure. The
                        initial setting is <termref def="dt-final-output-state">final output
                           state</termref>, and it is switched to <termref def="dt-temporary-output-state">temporary output state</termref> by
                        instructions such as <elcode>xsl:variable</elcode>. For more details, see
                           <specref ref="creating-result-trees"/>.</p></item></ulist><p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p><table border="1" cellpadding="5" summary="Components of the dynamic evaluation context"><thead><tr><th align="left" rowspan="1" colspan="1">Component</th><th align="left" rowspan="1" colspan="1">Initial Setting</th><th align="left" rowspan="1" colspan="1">Set by</th><th align="left" rowspan="1" colspan="1">Cleared by</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-focus">focus</termref>
                        </td><td valign="top" rowspan="1" colspan="1">singleton focus based on the
                              <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> if supplied</td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                              <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>,
                           <phrase diff="add" at="M">evaluation of <termref def="dt-pattern">patterns</termref></phrase>
                        </td><td valign="top" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>
                        </td></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-template-rule">current template rule</termref>
                        </td><td valign="top" rowspan="1" colspan="1">If a <termref def="dt-named-template">named template</termref> is supplied as the
                           entry point to the transformation, then <phrase diff="chg" at="M"><termref def="dt-absent"/></phrase>; otherwise the <termref def="dt-initial-template">initial template</termref>
                        </td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                              <elcode>xsl:next-match</elcode>
                        </td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, 
                              <elcode>xsl:analyze-string</elcode>, <phrase diff="add" at="F"><elcode>xsl:iterate</elcode>,
                           <elcode>xsl:stream</elcode>, <elcode>xsl:merge</elcode>, <elcode>xsl:evaluate</elcode>, </phrase>
                           and <termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>. Also cleared while evaluating global variables or
                           default values of stylesheet parameters, 
                           <phrase diff="add" at="M"><termref def="dt-pattern">patterns</termref></phrase>,
                           and the sequence constructors
                           contained in <elcode>xsl:key</elcode> and <elcode>xsl:sort</elcode>.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-mode">current mode</termref>
                        </td><td valign="top" rowspan="1" colspan="1">the initial <termref def="dt-mode">mode</termref>
                        </td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>
                        </td><!--Text replaced by erratum E19 change 1"--><td valign="top" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>. Also cleared while evaluating global variables and stylesheet
                           parameters,  
                           <phrase diff="add" at="M"><termref def="dt-pattern">patterns</termref></phrase>,
                           and the sequence constructor contained in
                              <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>. Clearing the
                           current mode causes the current mode to be set to the default (unnamed)
                           mode.</td><!--End of text replaced by erratum E19--></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-group">current group</termref>
                        </td><td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="K">absent</phrase></td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>, <phrase diff="add" at="I"><elcode>xsl:merge</elcode></phrase>
                        </td><td valign="top" diff="add" at="D" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                           calls</termref>, <phrase diff="add" at="M">evaluation of global variables, stylesheet parameters, and <termref def="dt-pattern">patterns</termref>,
                              calls on <elcode>xsl:for-each-group</elcode> with a <code>bind-group</code>
                              attribute.</phrase>
                        </td></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-grouping-key">current grouping key</termref>
                        </td><td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="K">absent</phrase></td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>, <phrase diff="add" at="I"><elcode>xsl:merge</elcode></phrase>
                        </td><td valign="top" diff="add" at="D" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>, <phrase diff="add" at="M">evaluation of global variables, stylesheet parameters,
                                 and <termref def="dt-pattern">patterns</termref>,
                              calls on <elcode>xsl:for-each-group</elcode> with a <code>bind-grouping-key</code>
                              attribute or with a <code>group-starting-with</code> or <code>group-ending-with</code> attribute.</phrase>
                        </td></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-captured-substrings">current captured
                              substrings</termref>
                        </td><td valign="top" rowspan="1" colspan="1">empty sequence</td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:matching-substring</elcode>
                        </td><td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:non-matching-substring</elcode>; <phrase diff="add" at="D"><termref def="dt-non-contextual-function-call">non-contextual
                                    function calls</termref></phrase>, <phrase diff="add" at="M">evaluation of global variables, stylesheet parameters,
                                       and <termref def="dt-pattern">patterns</termref></phrase>
                        </td></tr><tr><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-output-state">output state</termref>
                        </td><td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-final-output-state">final output state</termref>
                        </td><td valign="top" rowspan="1" colspan="1">Set to <termref def="dt-temporary-output-state">temporary output state</termref> by
                           instructions such as <elcode>xsl:variable</elcode>,
                              <elcode>xsl:attribute</elcode>, etc., and by calls on <termref def="dt-stylesheet-function">stylesheet functions</termref>
                        </td><td valign="top" rowspan="1" colspan="1">None</td></tr></tbody></table><p diff="add" at="D"><termdef id="dt-non-contextual-function-call" term="non-contextual function call">The term <term>non-contextual function
                        call</term> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <termref def="dt-stylesheet-function">stylesheet functions</termref> and all
                  <xtermref spec="XP30" ref="dt-dynamic-function-invocation">dynamic function
                        invocations</xtermref>, (that is calls to function items as permitted by
                     XPath 3.0). It does not include calls to all <termref def="dt-core-function">core functions</termref> in particular those that explicitly depend on the
                     context, such as the <function>current-group</function> and
                        <function>regex-group</function> functions. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether,
                     and under what circumstances, calls to <termref def="dt-extension-function">extension functions</termref> are non-contextual.</termdef></p><imp-def-feature>It is <termref def="dt-implementation-defined">implementation-defined</termref> whether, and under what circumstances, calls
                  to <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-non-contextual-function-call">non-contextual</termref>.</imp-def-feature><note diff="del" at="M"><p>A contextual function call such as
                        <code>current-group()</code> cannot be used in a dynamic function
                     invocation: it is not possible to form a function item such as
                     <code>current-group#0</code>.</p></note></div3></div2><div2 id="patterns"><head>Patterns</head><p diff="add" at="C">In XSLT 3.0, patterns can match any kind of item: atomic values and
               function items as well as nodes.</p><p>A <termref def="dt-template-rule">template rule</termref> identifies the <phrase diff="chg" at="C">items</phrase> to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <specref ref="number"/>), for grouping (see <specref ref="grouping"/>), and for declaring
                  <termref def="key">keys</termref> (see <specref ref="key"/>).</p><p><termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies a set of
                  conditions on an <phrase diff="chg" at="C">item</phrase>. An <phrase diff="chg" at="C">item</phrase> that satisfies the conditions matches the pattern; an
                     <phrase diff="chg" at="C">item</phrase> that does not satisfy the conditions
                  does not match the pattern.</termdef></p><p diff="add" at="C">There are two basic kinds of pattern: type patterns, and path
               patterns. Patterns may also be formed by combining other patterns using union,
               intersection, and difference operators.</p><p diff="add" at="C">A type pattern is written with a leading <code>~</code> (tilde)
               followed by an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> and an
               optional list of predicates: for example, <code>~xs:anyAtomicValue</code> matches any
               atomic value, <code>~xs:integer[. mod 2 = 0]</code> matches any even integer,
                  <code>~node()</code> matches any node, and
                  <code>~function(*)[empty(function-name(.))]</code> matches any function item that
               refers to an anonymous function. An item matches a type pattern if and only if the
               item is an instance of the specified type and satisfies all the predicates. </p><p>The syntax for <phrase diff="add" at="C">path</phrase> patterns is a subset of the
               syntax for <termref def="dt-expression">expressions</termref>. <phrase diff="add" at="C">Path patterns are used only for matching nodes; an item other than a node
                  will never match a path pattern.</phrase> As explained in detail below, a node
               matches a <phrase diff="add" at="C">path</phrase> pattern if the node can be selected
               by deriving an equivalent expression, and evaluating this expression with respect to
               some possible context.</p><note><p>The specification uses the phrases <emph>an item matches a pattern</emph>
            and <emph>a pattern matches an item</emph> interchangeably. They are equivalent: an
            item matches a pattern if and only if the pattern matches the item.</p></note><div3 id="pattern-examples"><head>Examples of Patterns</head><example><head>Patterns</head><p>Here are some examples of patterns:</p><ulist><item><p><code>para</code> matches any <code>para</code> element.</p></item><item><p><code>*</code> matches any element.</p></item><item><p><code>chapter|appendix</code> matches any <code>chapter</code> element
                           and any <code>appendix</code> element.</p></item><item><p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p></item><item><p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p></item><item><p><code>schema-element(us:address)</code> matches any element that is
                           annotated as an instance of the type defined by the schema element
                           declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                           substitution group. </p></item><item><p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                           being of type <code>xs:date</code>.</p></item><item><p><code>/</code> matches a document node.</p></item><item><p><code>document-node()</code> matches a document node.</p></item><item><p><code>document-node(schema-element(my:invoice))</code> matches the
                           document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                           element declaration <code>my:invoice</code>.</p></item><item><p><code>text()</code> matches any text node.</p></item><item><p diff="add" at="C"><code>namespace-node()</code> matches any namespace
                           node.</p></item><item><p><code>node()</code> matches any node other than an attribute node,
                           namespace node, or document node.</p></item><item><p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p></item><item><p><code>para[1]</code> matches any <code>para</code> element that is the
                           first <code>para</code> child element of its parent. It also matches a
                           parentless <code>para</code> element.</p></item><item><p><code>//para</code> matches any <code>para</code> element that has a
                           parent node.</p></item><item><p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                           element that is an even-numbered <code>bullet</code> child of its
                           parent.</p></item><item><p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                           with a <code>div</code> ancestor element that has a <code>class</code>
                           attribute with value <code>appendix</code>. </p></item><item><p><code>@class</code> matches any <code>class</code> attribute
                              (<emph>not</emph> any element that has a <code>class</code>
                           attribute).</p></item><item><p><code>@*</code> matches any attribute node.</p></item><item><p diff="add" at="C"><code>$xyz</code> matches any node that is present in
                           the value of the variable <code>$xyz</code>.</p></item><item><p diff="add" at="C"><code>$xyz//*</code> matches any element that is a
                           descendant of a node that is present in the value of the variable
                              <code>$xyz</code>.</p></item><item><p diff="add" at="C"><code>doc('product.xml')//*</code> matches any element
                           within the document whose document URI is 'product.xml'.</p></item><item><p diff="add" at="C"><code>~item()</code> matches any item whatsoever.</p></item><item><p diff="add" at="C"><code>~node()</code> matches any node. (Note the
                           distinction from the pattern <code>node()</code>.)</p></item><item><p diff="add" at="C"><code>~element()</code> matches any element. (This is
                           precisely equivalent to the pattern <code>element()</code>.)</p></item><item><p diff="add" at="C"><code>~xs:date</code> matches any atomic value of type
                              <code>xs:date</code> (or a type derived by restriction from
                              <code>xs:date</code>).</p></item><item><p diff="add" at="C"><code>~xs:date[. gt current-date()]</code> matches any
                           date in the future.</p></item><item><p diff="add" at="C"><code>~function(*)</code> matches any function item.</p></item><item><p diff="add" at="C"><code>~function(xs:integer) as xs:integer</code>
                           matches any function item whose underlying function takes an integer
                           argument and returns an integer result.</p></item></ulist></example></div3><div3 id="pattern-syntax"><head>Syntax of Patterns</head><p>
                  <error spec="XT" type="static" class="SE" code="0340"><p>Where an attribute is defined to contain a <termref def="dt-pattern">pattern</termref>, it is a <termref def="dt-static-error">static
                           error</termref> if the pattern does not match the production <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>.</p></error></p><p diff="add" at="C">The grammar for patterns uses the notation defined in <xspecref spec="XP30" ref="EBNFNotation">Notation</xspecref>. </p><p diff="add" at="C">The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <xspecref spec="XP30" ref="lexical-structure">Lexical structure</xspecref>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p><p diff="del" at="C"> Every pattern is a valid XPath <termref def="dt-expression">expression</termref>, but the converse is not true: <code>2+2</code> is an
                  example of a valid XPath expression that is not a pattern. The XPath expressions
                  that can be used as patterns are those that match the grammar for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>, given below.</p><p diff="del" at="C">Informally, a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> is a set of path
                  expressions separated by <code>|</code>, where each step in the path expression is
                  constrained to be an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-AxisStep" xlink:type="simple">AxisStep</xnt>
                  that uses only the <code>child</code> or <code>attribute</code> axes. Patterns may
                  also use the <code>//</code> operator. A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath30-Predicate" spec="XP30" xlink:type="simple">Predicate</xnt> within the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt> in a pattern can contain
                  arbitrary XPath expressions (enclosed between square brackets) in the same way as
                  a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Predicate" xlink:type="simple">predicate</xnt> in a path
                  expression.</p><p diff="del" at="C">Patterns may start with an <xfunction>id</xfunction> or
                     <function>key</function> function call, provided that the value to be matched
                  is supplied as either a literal or a reference to a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, and the
                  key name (in the case of the <function>key</function> function) is supplied as a
                  string literal. These patterns will never match a node in a tree whose root is not
                  a document node.</p><p>If a pattern appears <phrase diff="chg" at="D">in an attribute of an element that
                     is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase> (see <specref ref="backwards"/>), then the
                  semantics of the pattern are defined on the basis that the equivalent XPath
                  expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                     compatibility mode</termref> set to true.</p><scrap headstyle="show" diff="chg" at="C"><head>Patterns</head><prodgroup pcw5="1" pcw2="10"><prod id="NT-Pattern"><lhs>Pattern</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt> ( ('|' | 'union') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">PatternTerm</nt> )*</rhs></prod><prod id="NT-PatternTerm"><lhs>PatternTerm</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPattern</nt> ( ('intersect' | 'except')
                              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">BasicPattern</nt> )*</rhs></prod><prod id="NT-BasicPattern"><lhs>BasicPattern</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">PathPattern</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-QualifiedPattern" xlink:type="simple">QualifiedPattern</nt></rhs></prod><prod id="NT-QualifiedPattern"><lhs>QualifiedPattern</lhs><rhs>'(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> ')' <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt></rhs></prod><prod id="NT-TypePattern"><lhs>TypePattern</lhs><rhs>'~' <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt>
                           <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt></rhs></prod><prod id="NT-PathPattern"><lhs>PathPattern</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt></rhs><rhs>| '/' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt>?</rhs><rhs>| '//' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt></rhs><rhs>| <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RootedPattern" xlink:type="simple">RootedPattern</nt></rhs></prod><prod id="NT-RootedPattern"><lhs>RootedPattern</lhs><rhs>( <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-VarRefRoot" xlink:type="simple">VarRefRoot</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-DocCall" xlink:type="simple">DocCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-IdCall" xlink:type="simple">IdCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ElementWithIdCall" xlink:type="simple">ElementWithIdCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-KeyCall" xlink:type="simple">KeyCall</nt> )</rhs><rhs> (('/' | '//') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt>)?</rhs></prod><prod id="NT-VarRefRoot"><lhs>VarRefRoot</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-VarRef" xlink:type="simple">VarRef</xnt></rhs></prod><prod id="NT-RelativePathPattern"><lhs>RelativePathPattern</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternStep" xlink:type="simple">PatternStep</nt> (('/' | '//') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternStep" xlink:type="simple">PatternStep</nt>)*</rhs></prod><prod id="NT-PatternStep"><lhs>PatternStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>? <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>
                           <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>
                        </rhs></prod><prod id="NT-PatternAxis"><lhs>PatternAxis</lhs><rhs>(('child' | 'attribute' | 'namespace' | 'descendant' | 'descendant-or-self') '::') |
                           '@' </rhs></prod><prod id="NT-DocCall"><lhs>DocCall</lhs><rhs>'doc' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> ')'</rhs></prod><prod id="NT-IdCall"><lhs>IdCall</lhs><rhs>'id' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs></prod><prod id="NT-ElementWithIdCall"><lhs>ElementWithIdCall</lhs><rhs>'element-with-id' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs></prod><prod id="NT-KeyCall"><lhs>KeyCall</lhs><rhs>'key' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> ',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs></prod><prod id="NT-ArgValue"><lhs>ArgValue</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Literal" xlink:type="simple">Literal</xnt> | <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-VarRef" xlink:type="simple">VarRef</xnt></rhs></prod></prodgroup></scrap><p>The constructs <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-VarRef" xlink:type="simple">VarRef</xnt>, and <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Literal" xlink:type="simple">Literal</xnt> are part of the XPath expression
                  language, and are defined in <bibref ref="xpath-30"/>.</p><p>In a <code>DocCall</code>, <code>IdCall</code>, <code>ElementWithIdCall</code>, or
                     <code>KeyCall</code>, the construct has the same semantics as a call to the
                  corresponding function in an XPath expression. In particular, the arguments
                     <rfc2119>must</rfc2119> (after conversion using the <termref def="dt-function-conversion-rules">function conversion rules</termref> if
                  necessary) be of the correct type required by the signature of the function. The
                  function conversion rules are applied with XPath 1.0 compatibility mode set to
                  false. If an argument cannot be converted to the required type, a type error
                  results: if the type error can be detected statically then it
                     <rfc2119>may</rfc2119> be signaled statically.</p><note><p>As with XPath expressions, the pattern <code>/ union /*</code> can be
                     parsed in two different ways, and the chosen interpretation is to treat
                     <code>union</code> as an element name rather than as an operator. The
                     other interpretation can be achieved by writing <code>(/) union
                        (/*)</code></p></note></div3><div3 id="pattern-semantics" diff="chg" at="K"><head>The Meaning of a Pattern</head><p>The meaning of a pattern is defined formally as follows, where "if" is to be read
               as "if and only if".</p><p>First the pattern is converted to an <termref def="dt-expression">expression</termref>,
                  called the <term>equivalent expression</term>. 
                  The equivalent expression to a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> is the XPath expression that takes the same lexical
                     form as the <code>Pattern</code> as written, with two adjustments:</p><olist><item><p>Any occurrence of <code>~ ItemType</code> in a <code>TypePattern</code> 
                        is replaced by
                        <code>.[. instance of ItemType]</code>. For example, the equivalent expression for the pattern 
                        <code>~xs:integer[. gt 5]</code> is <code>.[. instance of xs:integer][. gt 5]</code></p></item><item><p>If the
                        <code>Pattern</code> is a <code>RelativePathPattern</code>, then the
                        first <code>PatternStep</code>
                        <var>PS</var> of this <code>RelativePathPattern</code> is adjusted to allow
                        it to match a parentless element, attribute, or namespace node. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <xspecref spec="XP30" ref="abbrev"/>), and is made as follows:</p><olist><item><p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                                 explicit axis is specified, then the axis in step <var>PS</var> is
                                 taken as <code>self</code> rather than <code>child</code>.</p></item><item><p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                                 if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                                 axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                                 which is defined as follows. If the context node is a parentless
                                 element, comment, processing-instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                                 it selects the children of the context node. It is a forwards axis
                                 whose principal node kind is element.</p></item><item><p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                                 then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                                 context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                                 otherwise it selects the attributes of the context node. It is a
                                 forwards axis whose principal node kind is attribute.</p></item><item><p>If <var>PS</var> uses the namespace axis (implicitly, by using
                                 <code>namespace-node()</code> as a <code>KindTest</code>), then the
                                 axis in step <var>PS</var> is replaced by
                                 <code>namespace-or-top</code>, which is defined as follows. If the
                                 context node is a namespace node with no parent, then the
                                 <code>namespace-or-top</code> axis selects the context node;
                                 otherwise it selects the namespace nodes of the context node. It is a
                                 forwards axis whose principal node kind is namespace.</p></item></olist><p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                           purposes. They cannot be used explicitly in a user-written pattern or
                           expression.</p><note><p>The purpose of this adjustment is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                              even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                              even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                              matches a document node. The pattern <code>node()</code> will match any
                              element, text node, comment, or processing instruction, whether or not it
                              has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                              match document nodes, attribute nodes, or namespace nodes. The rules are
                              also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                              if they have one. To match any node at all, XSLT 3.0 allows the pattern
                              <code>~node()</code> to be used (note the tilde).</p></note></item></olist><p>The meaning of the pattern is then defined in terms of the semantics of the
               equivalent expression, denoted below as <code>EE</code>.</p><p>Specifically, an item <var>N</var> matches a pattern <var>P</var> 
                  if either of the following applies, where <code>EE</code> is the
                  <term>equivalent expression</term> to <var>P</var>:</p><olist><item><p><var>N</var> is a node, and the result of evaluating the expression
                           <code>root(.)//(EE)</code> with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var> is a sequence that
                        includes the node <var>N</var> </p></item><item><p><var>N</var> is not a node, and the result of evaluating the expression
                        <code>exists(EE)</code> with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var> is the boolean value
                          <code>true</code>.</p></item></olist><example><head>The Semantics of Path Patterns</head><p>The path pattern <code>p</code> matches any <code>p</code> element, because a
                        <code>p</code> element will always be present in the result of evaluating
                     the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a
                     document node, and only a document node, because the result of the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(/)</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p><p>The path pattern <code>node()</code> matches all nodes selected by the
                     expression <code>root(.)//(child-or-top::node())</code>, that is, all element,
                     text, comment, and processing instruction nodes, whether or not they have a
                     parent. It does not match attribute or namespace nodes because the expression
                     does not select nodes using the attribute or namespace axes. It does not match
                     document nodes because for backwards compatibility reasons the
                        <code>child-or-top</code> axis does not match a document node.</p><p>The path pattern <code>$V</code> matches all nodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <elcode>xsl:number</elcode> or
                        <elcode>xsl:for-each-group</elcode> instructions, it can also be a local
                     variable).</p><p>The path pattern <code>doc('product.xml')//product</code> matches all nodes
                     selected by the expression <code>root(.)//(doc('product.xml')//product)</code>,
                     that is, all <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p></example><p>Although the semantics of path patterns are specified formally in terms of
                  expression evaluation, it is possible to understand pattern matching using a
                  different model. A path pattern such as <code>book/chapter/section</code> can be
                  examined from right to left. A node will only match this pattern if it is a
                     <code>section</code> element; and then, only if its parent is a
                     <code>chapter</code>; and then, only if the parent of that <code>chapter</code>
                  is a <code>book</code>. When the pattern uses the <code>//</code> operator, one
                  can still read it from right to left, but this time testing the ancestors of a
                  node rather than its parent. For example <code>appendix//section</code> matches
                  every <code>section</code> element that has an ancestor <code>appendix</code>
                  element.</p><p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p><note><p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p></note></div3><div3 id="pattern-errors"><head>Errors in Patterns</head><p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs during the evaluation of a
                     <termref def="dt-pattern">pattern</termref> against a particular <phrase diff="chg" at="C">item</phrase> is treated as a <termref def="dt-recoverable-error">recoverable error</termref> even if the error would
                  not be recoverable under other circumstances. The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to
                  treat the pattern as not matching that node.</p><note><p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node. Making errors in
                     patterns recoverable enables an implementation, if it chooses to do so, to
                     report such errors while stylesheets are under development, while masking them
                     if they occur during production running.</p></note><p>There are several particular cases where a processor <rfc2119>must not</rfc2119>
                  raise a dynamic error:</p><ulist><item><p>When evaluating a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> that starts with
                           <code>/</code> or <code>//</code> or <phrase diff="chg" at="C">with a
                           call on <xfunction>id</xfunction>,
                           <xfunction>element-with-id</xfunction>, or
                           <function>key</function></phrase>, the result of testing this pattern
                        against a node in a tree whose root is not a document node must be a
                        non-match, rather than a dynamic error. This rule applies to each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> within a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>.</p><note><p>Without the above rule, any attempt to apply templates to a parentless
                           element node would create the risk of a dynamic error if the stylesheet
                           has a template rule specifying <code>match="/"</code>.</p></note></item><item diff="add" at="C"><p>When matching an atomic value against a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt>, the result <rfc2119>must</rfc2119> always be a
                        non-match, rather than a dynamic error.</p></item><item diff="add" at="C"><p>A processor <rfc2119>must not</rfc2119> evaluate a predicate within a
                        pattern unless the item matches the part of the pattern that is qualified by
                        the predicate. (Or equivalently, if it does evaluate the predicate, it must
                        not signal an error when the evaluation fails.) For example, evaluation of
                        the pattern <code>~xs:integer[. gt 5]</code> must not cause an error when
                        testing an item of type <code>xs:date</code>, and the pattern
                           <code>$var[child::*]</code> must not cause an error when testing an
                        atomic value. If there are multiple predicates, they must be evaluated from
                        left to right.</p></item></ulist></div3></div2><div2 id="attribute-value-templates"><head>Attribute Value Templates</head><p>
               <termdef id="dt-attribute-value-template" term="attribute value template">In an
                  attribute that is designated as an <term>attribute value template</term>, such as
                  an attribute of a <termref def="dt-literal-result-element">literal result
                     element</termref>, an <termref def="dt-expression">expression</termref> can be
                  used by surrounding the expression with curly brackets
               (<code>{}</code>)</termdef>.</p><p>An attribute value template consists of an alternating sequence of fixed parts and
               variable parts. A variable part consists of an XPath <termref def="dt-expression">expression</termref> enclosed in curly brackets (<code>{}</code>). A fixed part
               may contain any characters, except that a left curly bracket <rfc2119>must</rfc2119>
               be written as <code>{{</code> and a right curly bracket <rfc2119>must</rfc2119> be
               written as <code>}}</code>. <phrase diff="add" at="C">If the XPath expression ends
                  with a closing curly bracket, this must be separated from the delimiting closing
                  bracket by whitespace.</phrase>
            </p><note><p>An expression within a variable part may contain an unescaped curly bracket within
                  a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-StringLiteral" xlink:type="simple">StringLiteral</xnt> or within
                  a comment.</p><p diff="add" at="C">Currently no XPath expression starts with an opening curly
                  bracket, and the only XPath expression that can end in a closing curly bracket is
                  an inline function literal, which cannot usefully appear in an attribute value
                  template.</p></note><p>
               <error spec="XT" type="static" class="SE" code="0350"><p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     left curly bracket appears in a fixed part of an attribute value template
                     without a matching right curly bracket.</p></error>
            </p><p>It is a <termref def="dt-static-error">static error</termref> if the string contained
               between matching curly brackets in an attribute value template does not match the
               XPath production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Expr" xlink:type="simple">Expr</xnt>, or if it
               contains other XPath static errors. The error is signaled using the appropriate XPath
               error code.</p><p>
               <error spec="XT" type="static" class="SE" code="0370"><p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     right curly bracket occurs in a fixed part of an attribute value template.</p></error>
            </p><p>
               <termdef id="dt-effective-value" term="effective value">The result of evaluating an
                  attribute value template is referred to as the <term>effective value</term> of the
                  attribute.</termdef> The effective value is the string obtained by concatenating
               the expansions of the fixed and variable parts:</p><ulist><item><p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p></item><item><p>The expansion of a variable part is obtained by evaluating the enclosed XPath
                        <termref def="dt-expression">expression</termref> and converting the
                     resulting value to a string. This conversion is done using the rules given in
                        <specref ref="constructing-simple-content"/>.</p></item></ulist><note><p>This process can generate dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p></note><p><phrase diff="chg" at="D">If the element containing the attribute is processed with
                     <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then the rules
                  for converting the value of the expression to a string are modified as
                  follows.</phrase> After <termref def="dt-atomization">atomizing</termref> the
               result of the expression, all items other than the first item in the resulting
               sequence are discarded, and the effective value is obtained by converting the first
               item in the sequence to a string. If the atomized sequence is empty, the result is a
               zero-length string.</p><p>Curly brackets are not treated specially in an attribute value in an XSLT <termref def="dt-stylesheet">stylesheet</termref> unless the attribute is specifically
               designated as one that permits an attribute value template; in an element syntax
               summary, the value of such attributes is surrounded by curly brackets.</p><note><p>Not all attributes are designated as attribute value templates. Attributes whose
                  value is an <termref def="dt-expression">expression</termref> or <termref def="dt-pattern">pattern</termref>, attributes of <termref def="dt-declaration">declaration</termref> elements and attributes that refer to named XSLT objects
                  are generally not designated as attribute value templates (an exception is the
                     <code>format</code> attribute of <elcode>xsl:result-document</elcode>).
                  Namespace declarations are not XDM attribute nodes and are therefore never treated
                  as attribute value templates.</p></note><example><head>Attribute Value Templates</head><p>The following example creates an <code>img</code> result element from a
                     <code>photograph</code> element in the source; the value of the
                     <code>src</code> and <code>width</code> attributes are computed using XPath
                  expressions enclosed in attribute value templates:</p><eg xml:space="preserve">&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</eg><p>With this source</p><eg xml:space="preserve">&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</eg><p>the result would be</p><eg xml:space="preserve">&lt;img src="/images/headquarters.jpg" width="300"/&gt;</eg></example><example><head>Producing a Space-Separated List</head><p>The following example shows how the values in a sequence are output as a
                  space-separated list. The following literal result element:</p><eg xml:space="preserve">&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</eg><p>produces the output node:</p><eg xml:space="preserve">&lt;temperature readings="10.32 5.5 8.31"/&gt;</eg></example><p>Curly brackets are <emph>not</emph> recognized recursively inside expressions.</p><example><head>Curly Brackets can not be Nested</head><p>For example:</p><eg role="error" xml:space="preserve">&lt;a href="#{id({@ref})/title}"&gt;</eg><p>is <emph>not</emph> allowed. Instead, use simply:</p><eg xml:space="preserve">&lt;a href="#{id(@ref)/title}"&gt;</eg></example></div2><div2 id="sequence-constructors"><head>Sequence Constructors</head><p>
               <termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
                     constructor</term> is a sequence of zero or more sibling nodes in the <termref def="dt-stylesheet">stylesheet</termref> that can be evaluated to return a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and function
                     items</phrase>. The way that the resulting sequence is used depends on the
                  containing instruction.</termdef>
            </p><p>Many <termref def="dt-xslt-element">XSLT elements</termref>, and also <termref def="dt-literal-result-element">literal result elements</termref>, are defined to
               take a <termref def="dt-sequence-constructor"/> as their
               content.</p><p>Four kinds of nodes may be encountered in a sequence constructor:</p><ulist diff="chg" at="F"><item><p>
                     A <emph>Text node</emph> appearing in the <termref def="dt-stylesheet">stylesheet</termref> (if it has not been removed in the process of
                     whitespace stripping: see <specref ref="stylesheet-stripping"/>) is copied to
                     create a new parentless text node.</p></item><item><p>
                     A <termref def="dt-literal-result-element">literal result element</termref> is
                     evaluated to create a new parentless element node, having the same <termref def="dt-expanded-qname">expanded QName</termref> as the literal result
                     element: see <specref ref="literal-result-element"/>.
                  </p></item><item><p>An XSLT <termref def="dt-instruction">instruction</termref> produces a sequence of
                     zero, one, or more items as its result. For most XSLT instructions, these items are nodes, but some
                     instructions (<phrase diff="add" at="D">such as</phrase>
                     <elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>) can also
                     produce atomic values <phrase diff="add" at="C">or function items</phrase>.
                     Several instructions, such as <elcode>xsl:element</elcode>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <elcode>xsl:if</elcode>, pass on the items produced by their own nested
                     sequence constructors. The <elcode>xsl:sequence</elcode> instruction may return
                     atomic values, <phrase diff="add" at="C">function items</phrase>, or existing
                     nodes.</p></item><item><p>
                     An <termref def="dt-extension-instruction"/> (see
                        <specref ref="extension-instruction"/>) also produces a sequence of items as
                     its result.</p></item></ulist><p diff="add" at="F">The result of evaluating a <termref def="dt-sequence-constructor"/> is the sequence of items
            formed by concatenating the results of evaluating each of the nodes in the sequence constructor,
            retaining order.</p><p>There are several ways the result of a sequence constructor may be used.</p><ulist><item><p>The sequence may be bound to a variable or returned from a stylesheet function,
                     in which case it becomes available as a value to be manipulated in arbitrary
                     ways by XPath expressions. The sequence is bound to a variable when the
                     sequence constructor appears within one of the elements
                        <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:with-param</elcode>, when this instruction has an
                        <code>as</code> attribute. The sequence is returned from a stylesheet
                     function when the sequence constructor appears within the
                        <elcode>xsl:function</elcode> element.</p><note><p>This will typically expose to the stylesheet elements, attributes, and other
                        nodes that have not yet been attached to a parent node in a <termref def="dt-result-tree">result tree</termref>. The semantics of XPath
                        expressions when applied to parentless nodes are well-defined; however, such
                        expressions should be used with care. For example, the expression
                           <code>/</code> causes a type error if the root of the tree containing the
                        context node is not a document node.</p><p>Parentless attribute nodes require particular care because they have no
                        namespace nodes associated with them. A parentless attribute node is not
                        permitted to contain namespace-sensitive content (for example, a QName or an
                        XPath expression) because there is no information enabling the prefix to be
                        resolved to a namespace URI. Parentless attributes can be useful in an
                        application (for example, they provide an alternative to the use of
                        attribute sets: see <specref ref="attribute-sets"/>) but they need to be
                        handled with care.</p></note></item><item><p>The sequence may be returned as the result of the containing element. This
                     happens when the <phrase diff="chg" at="C">element</phrase> containing the
                     sequence constructor is <elcode>xsl:analyze-string</elcode>,
                        <elcode>xsl:apply-imports</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <phrase diff="add" at="C"><elcode>xsl:break</elcode></phrase>,
                        <elcode>xsl:call-template</elcode>, <phrase diff="add" at="B"><elcode>xsl:catch</elcode></phrase>, <elcode>xsl:choose</elcode>,
                        <elcode>xsl:fallback</elcode>, <elcode>xsl:for-each</elcode>,
                        <elcode>xsl:for-each-group</elcode>, <phrase diff="add" at="C"><elcode>xsl:fork</elcode></phrase>, <elcode>xsl:if</elcode>, <phrase diff="add" at="C"><elcode>xsl:iterate</elcode></phrase>,
                        <elcode>xsl:matching-substring</elcode>, <elcode>xsl:next-match</elcode>,
                        <elcode>xsl:non-matching-substring</elcode>, <phrase diff="add" at="C"><elcode>xsl:on-completion</elcode></phrase>,
                        <elcode>xsl:otherwise</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:sequence</elcode>, <phrase diff="add" at="B"><elcode>xsl:try</elcode></phrase>, or <elcode>xsl:when</elcode>. </p></item><item><p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <termref def="dt-literal-result-element">literal result element</termref>,
                     or of one of the instructions <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:document</elcode>,
                     <elcode>xsl:result-document</elcode>, <phrase diff="add" at="L"><elcode>xsl:assert</elcode></phrase>, or <elcode>xsl:message</elcode>. It
                     also happens when the sequence constructor is contained in one of the elements
                        <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
                        <elcode>xsl:with-param</elcode>, or <phrase diff="add" at="D"><elcode>xsl:context-item</elcode></phrase>, when this instruction has no
                        <code>as</code> attribute. For details, see <specref ref="constructing-complex-content"/>.</p></item><item><p>The sequence may be used to construct the <termref def="dt-string-value">string
                        value</termref> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:namespace</elcode>,
                        <elcode>xsl:comment</elcode>, or
                     <elcode>xsl:processing-instruction</elcode>. For details, see <specref ref="constructing-simple-content"/>.</p></item></ulist><note diff="del" at="A"><p>The term <emph>sequence constructor</emph> replaces <emph>template</emph> as used
                  in XSLT 1.0. The change is made partly for clarity (to avoid confusion with
                     <termref def="dt-template-rule">template rules</termref> and <termref def="dt-named-template">named templates</termref>), but also to reflect a more
                  formal definition of the semantics. Whereas XSLT 1.0 described a template as a
                  sequence of instructions that write to the result tree, XSLT 2.0 describes a
                  sequence constructor as something that can be evaluated to return a sequence of
                  items; what happens to these items depends on the containing instruction.</p></note><div3 id="constructing-complex-content"><head>Constructing Complex Content</head><p>This section describes how the sequence obtained by evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref> may be used to
                  construct the children of a newly constructed document node, or the children,
                  attributes and namespaces of a newly constructed element node. The sequence of
                  items may be obtained by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in an instruction such as
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>,
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, or a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p><p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p><p>The sequence is processed as follows (applying the rules in the order they are
                  listed):</p><olist><item><p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <termref def="dt-literal-result-element">literal result
                           element</termref>. Any such nodes are prepended to the sequence produced
                        by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref>.</p></item><item><p>Any atomic value in the sequence is cast to a string.</p><note><p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p></note></item><item><p>Any consecutive sequence of strings within the result sequence is converted
                        to a single text node, whose <termref def="dt-string-value">string
                           value</termref> contains the content of each of the strings in turn, with
                        a single space (#x20) used as a separator between successive strings.</p></item><item><p>Any document node within the result sequence is replaced by a sequence
                        containing each of its children, in document order.</p></item><item><p>Zero-length text nodes within the result sequence are removed.</p></item><item><p>Adjacent text nodes within the result sequence are merged into a single text
                        node.</p></item><item><p>Invalid <phrase diff="chg" at="C">items in the result sequence</phrase> are
                        detected as follows.</p><p>
                        <error spec="XT" type="dynamic" class="DE" code="0410"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence used to construct the
                              content of an element node contains a namespace node or attribute node
                              that is preceded in the sequence by a node that is neither a namespace
                              node nor an attribute node.</p></error>
                     </p><p>
                        <error spec="XT" type="dynamic" class="DE" code="0420"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence used to construct the
                              content of a document node contains a namespace node or attribute
                              node.</p></error>
                     </p><p>
                        <error spec="XT" type="dynamic" class="DE" code="0430"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains two or more
                              namespace nodes having the same name but different <termref def="dt-string-value">string values</termref> (that is, namespace
                              nodes that map the same prefix to different namespace URIs).</p></error>
                     </p><p>
                        <error spec="XT" type="dynamic" class="DE" code="0440"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains a namespace node
                              with no name and the element node being constructed has a null
                              namespace URI (that is, it is an error to define a default namespace
                              when the element is in no namespace). </p></error>
                     </p><p diff="add" at="C">
                        <error spec="XT" type="dynamic" class="DE" code="0450"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains a function item.
                           </p></error>
                     </p></item><item><p>If the result sequence contains two or more namespace nodes with the same
                        name (or no name) and the same <termref def="dt-string-value">string
                           value</termref> (that is, two namespace nodes mapping the same prefix to
                        the same namespace URI), then all but one of the duplicate nodes are
                        discarded.</p><note><p>Since the order of namespace nodes is 
                           <termref def="dt-implementation-dependent">implementation-dependent</termref>, it is not significant
                           which of the duplicates is retained.</p></note></item><item><!--Text replaced by erratum E10 change 1"--><p>If an attribute <var>A</var> in the result sequence has the same name as
                        another attribute <var>B</var> that appears later in the result sequence,
                        then attribute <var>A</var> is discarded from the result sequence. Before
                        discarding attribute <var>A</var>, the processor <rfc2119>may</rfc2119>
                        signal any <termref def="dt-type-error">type errors</termref> that would be
                        signaled if attribute <var>B</var> were not present. </p><!--End of text replaced by erratum E10--></item><item><p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p></item><item><p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <specref ref="namespace-fixup"/>.</p></item><item><p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p></item></olist><example><head>A Sequence Constructor for Complex Content</head><p>Consider the following stylesheet fragment:</p><eg xml:space="preserve">&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</eg><p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <elcode>xsl:value-of</elcode> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p></example><example><head>Space Separators in Element Content</head><p>Consider the following stylesheet fragment:</p><eg xml:space="preserve">&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</eg><p>This produces the output (when indented):</p><eg xml:space="preserve">&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</eg><p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p><p>It is important to be aware of the distinction between
                        <elcode>xsl:sequence</elcode>, which returns the value of its
                        <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>,
                     which constructs a text node.</p></example></div3><div3 id="constructing-simple-content"><head>Constructing Simple Content</head><p>The instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                  and <elcode>xsl:value-of</elcode> all create nodes that cannot have children.
                  Specifically, the <elcode>xsl:attribute</elcode> instruction creates an attribute
                  node, <elcode>xsl:comment</elcode> creates a comment node,
                     <elcode>xsl:processing-instruction</elcode> creates a processing instruction
                  node, <elcode>xsl:namespace</elcode> creates a namespace node, and
                     <elcode>xsl:value-of</elcode> creates a text node. The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <termref def="dt-string-value">string value</termref> of the new node is derived from
                  this result sequence according to the rules below.</p><p>These rules are also used to compute the <termref def="dt-effective-value">effective value</termref> of an <termref def="dt-attribute-value-template">attribute value template</termref>. In this case the sequence being processed
                  is the result of evaluating an XPath expression enclosed between curly brackets,
                  and the separator is a single space character.</p><olist><item><p>Zero-length text nodes in the sequence are discarded.</p></item><item><p>Adjacent text nodes in the sequence are merged into a single text node.</p></item><item><p>The sequence is <termref def="dt-atomization">atomized</termref>
                        <phrase diff="add" at="C">(which may cause a dynamic error)</phrase>.</p></item><item><p>Every value in the atomized sequence is cast to a string.</p></item><item><p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. The default
                        separator is a single space. In the case of <elcode>xsl:attribute</elcode>
                        and <elcode>xsl:value-of</elcode>, a different separator can be specified
                        using the <code>separator</code> attribute of the instruction; it is
                        permissible for this to be a zero-length string, in which case the strings
                        are concatenated with no separator. In the case of
                           <elcode>xsl:comment</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, and
                           <elcode>xsl:namespace</elcode>, and when expanding an <termref def="dt-attribute-value-template">attribute value template</termref>, the
                        default separator cannot be changed.</p></item><item><p>In the case of <elcode>xsl:processing-instruction</elcode>, any leading
                        spaces in the resulting string are removed.</p></item><item><p>The resulting string forms the <termref def="dt-string-value">string
                           value</termref> of the new attribute, namespace, comment,
                        processing-instruction, or text node.</p></item></olist><example><head>Space Separators in Attribute Content</head><p>Consider the following stylesheet fragment:</p><eg xml:space="preserve">&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
&lt;/doc&gt;</eg><p>This produces the output:</p><eg xml:space="preserve">&lt;doc e="1 2 3 4 5" f="12345"/&gt;</eg><p>The difference between the two cases is that for the <code>e</code> attribute,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> attribute, the content is
                     supplied as a sequence of five text nodes, which are concatenated without space
                     separation.</p><p>Specifying <code>separator=""</code> on the first
                        <elcode>xsl:attribute</elcode> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <elcode>xsl:attribute</elcode> instruction would have no effect, since the
                     separator only affects the way adjacent atomic values are handled: separators
                     are never inserted between adjacent text nodes.</p></example><note><p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <termref def="dt-effective-value">effective
                        value</termref> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p></note></div3><div3 id="namespace-fixup"><head>Namespace Fixup</head><p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <bibref ref="xpath-datamodel-30"/>
                  <rfc2119>must</rfc2119> be satisfied. For example</p><ulist><item><p>If an element node has an <termref def="dt-expanded-qname">expanded QName</termref> with a non-null namespace URI, then that
                        element node <rfc2119>must</rfc2119> have at least one namespace node whose
                           <termref def="dt-string-value">string value</termref> is the same as that
                        namespace URI.</p></item><item><p>If an element node has an attribute node whose <termref def="dt-expanded-qname">expanded QName</termref> has a non-null namespace
                        URI, then the element <rfc2119>must</rfc2119> have at least one namespace
                        node whose <termref def="dt-string-value">string value</termref> is the same
                        as that namespace URI and whose name is non-empty.</p></item><item><p>Every element <rfc2119>must</rfc2119> have a namespace node whose <termref def="dt-expanded-qname">expanded QName</termref> has local-part
                           <code>xml</code> and whose <termref def="dt-string-value">string
                           value</termref> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code> must not be associated with any other
                        namespace URI, and the namespace URI
                           <code>http://www.w3.org/XML/1998/namespace</code> must not be associated
                        with any other prefix.</p></item><item><!--Text replaced by erratum E6 change 7"--><p>A namespace node <rfc2119>must not</rfc2119> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p><!--End of text replaced by erratum E6--></item></ulist><p>
                  <termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the
                     individual XSLT instructions that construct a <termref def="dt-result-tree">result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <term>namespace fixup</term>.</termdef>
               </p><p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <termref def="dt-implementation-dependent">implementation-dependent</termref>, provided firstly, that at the end of the
                  process the above constraints <rfc2119>must</rfc2119> all be satisfied, and
                  secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <termref def="dt-stylesheet">stylesheet</termref>.</p><p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
                  namespace nodes with the same name.</p><p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p><note><p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p><p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user's responsibility to ensure that the element
                     being validated has the required namespace nodes to enable validation to
                     succeed.</p><p>Where existing elements are copied along with their existing type annotations
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p><p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p></note><p>Namespace fixup is applied to every element that is constructed using a <termref def="dt-literal-result-element">literal result element</termref>, or one of the
                  instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>. An implementation is not
                     <rfc2119>required</rfc2119> to perform namespace fixup for elements in any
                  source document, that is, for a document in the initial input sequence, documents
                  loaded using the <function>document</function>, <xfunction>doc</xfunction> or
                     <xfunction>collection</xfunction> function, documents supplied as the value of
                  a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or
                  documents returned by an <termref def="dt-extension-function">extension
                     function</termref> or <termref def="dt-extension-instruction">extension
                     instruction</termref>.</p><note><p>A source document (an input document, a document returned by the
                        <function>document</function>, <xfunction>doc</xfunction> or
                        <xfunction>collection</xfunction> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <bibref ref="xpath-datamodel-30"/>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></note><p>In an Infoset (see <bibref ref="xml-infoset"/>) created from a document conforming
                  to <bibref ref="xml-names"/>, it will always be true that if a parent element
                  has an in-scope namespace with a non-empty namespace prefix, then its child
                  elements will also have an in-scope namespace with the same namespace prefix,
                  though possibly with a different namespace URI. This constraint is removed in
                     <bibref ref="xml-names11"/>. XSLT <phrase diff="chg" at="A">3.0</phrase>
                  supports the creation of result trees that do not satisfy this constraint: the
                  namespace fixup process does not add a namespace node to an element merely because
                  its parent node in the <termref def="dt-result-tree">result tree</termref> has
                  such a namespace node. However, the process of constructing the children of a new
                  element, which is described in <specref ref="constructing-complex-content"/>, does
                  cause the namespaces of a parent element to be inherited by its children unless
                  this is prevented using <code>[xsl:]inherit-namespaces="no"</code> on the
                  instruction that creates the parent element.</p><note><p>This has implications on serialization, defined in <bibref ref="xslt-xquery-serialization-30"/>. It means that it is possible to create
                        <termref def="dt-final-result-tree">final result trees</termref> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p></note></div3></div2><div2 id="uri-references"><head>URI References</head><p>
               <termdef id="dt-uri-reference" term="URI Reference">Within this specification, the
                  term <term>URI Reference</term>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <bibref ref="xmlschema-2"/>.</termdef> Note that this is a wider definition than that
               in <bibref ref="RFC3986"/>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <bibref ref="RFC3987"/>, and thus allows the use of non-ASCII characters without escaping.</p><p>URI References are used in XSLT with three main roles:</p><ulist><item><p>As namespace URIs</p></item><item><p>As collation URIs</p></item><item><p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <elcode>xsl:import</elcode>, <elcode>xsl:include</elcode>, and
                        <elcode>xsl:result-document</elcode>.</p></item></ulist><p>The rules for namespace URIs are given in <bibref ref="xml-names"/> and <bibref ref="xml-names11"/>. Those specifications deprecate the use of relative URI <phrase diff="add" at="F">references</phrase> as
               namespace URIs.</p><p>The rules for collation URIs are given in <bibref ref="xpath-functions-30"/>.</p><p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <bibref ref="xlink"/>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <bibref ref="RFC3986"/>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI <phrase diff="add" at="F">reference</phrase> in
               the <code>href</code> attribute of <elcode>xsl:result-document</elcode> is resolved
               against the <termref def="dt-base-output-uri">Base Output URI</termref>.)</p><p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p><p diff="add" at="M"><!--bug 17595-->The base URI of an element node in the stylesheet is determined 
               as defined in <xspecref spec="DM30" ref="dm-base-uri"/>.
               Some implementations may allow the output of the static analysis phase of
               stylesheet processing (a "compiled stylesheet") to be evaluated in a different
               location from that where static analysis took place. Furthermore, stylesheet authors may in
               such cases which to avoid exposing the location of resources that are private to the
               development environment. If the base URI of an element in the stylesheet is defined by an absolute
               URI appearing in an <code>xml:base</code> attribute within the stylesheet, this value <rfc2119>must</rfc2119>
               be used as the static base URI. In other cases where processing depends on the
               static base URI of a stylesheet module, implementations <rfc2119>may</rfc2119>
               use different values for the static base URI during static
               analysis and during dynamic evaluation (for example, an implementation <rfc2119>may</rfc2119>
               use different base URIs for resolving <elcode>xsl:import</elcode> module references and for
               resolving a relative reference used as an argument to the <function>doc</function> function). In
               such cases an implementation <rfc2119>must</rfc2119> document how the static base URI is computed for
               each situation in which it is required.
             </p></div2></div1><div1 id="rules"><head>Template Rules</head><p>Template rules define the processing that can be applied to <phrase diff="chg" at="D">items</phrase> that match a particular <termref def="dt-pattern">pattern</termref>.</p><div2 id="defining-templates"><head>Defining Templates</head><e:element-syntax name="template"><e:in-category name="declaration"/><e:attribute name="match"><e:data-type name="pattern"/></e:attribute><e:attribute name="name"><e:data-type name="eqname"/></e:attribute><e:attribute name="priority"><e:data-type name="decimal"/></e:attribute><e:attribute name="mode"><e:data-type name="tokens"/></e:attribute><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="visibility"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:sequence><e:element repeat="zero-or-one" name="context-item"/><e:element repeat="zero-or-more" name="param"/><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/><e:parent name="override"/></e:allowed-parents></e:element-syntax><p>
               <termdef id="dt-template" term="template">An <elcode>xsl:template</elcode>
                  declaration defines a <term>template</term>, which contains a <termref def="dt-sequence-constructor">sequence constructor</termref> 
                  <phrase diff="chg" at="I">; this sequence constructor is evaluated to
                  determine the result of the template</phrase>. A
                  template can serve either as a <termref def="dt-template-rule">template
                     rule</termref>, invoked by matching <phrase diff="chg" at="C">items</phrase>
                  against a <termref def="dt-pattern">pattern</termref>, or as a <termref def="dt-named-template">named template</termref>, invoked explicitly by name.
                  It is also possible for the same template to serve in both capacities.</termdef>
            </p><p>
               <error spec="XT" type="static" class="SE" code="0500"><p>An <elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <elcode>xsl:template</elcode> element that has no <code>match</code>
                     attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. <phrase diff="add" at="I">An <elcode>xsl:template</elcode>
                        element that has no <code>name</code> attribute <rfc2119>must</rfc2119> have no <code>visibility</code>
                        attribute.</phrase></p></error>
            </p><p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
               it is a <termref def="dt-template-rule">template rule</termref>. If it has a
                  <code>name</code> attribute, then it is a <termref def="dt-named-template">named
                  template</termref>.</p><p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
               depending on whether it is a <termref def="dt-template-rule">template rule</termref>,
               a <termref def="dt-named-template">named template</termref>, or both. The result of
               invoking the template is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                  <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"/>).</p><p diff="add" at="G">If an <elcode>xsl:context-item</elcode> element is present as the first child element,
            it defines whether the template requires a context item to be supplied, and if so, what the
            type of the context item must be. If this template is the <termref def="dt-initial-template">initial template</termref>,
            then this has the effect of placing constraints on the <termref def="dt-initial-context-item">initial context item</termref>
            for the transformation as a whole.</p><p diff="add" at="G">The <code>use</code> attribute of <elcode>xsl:context-item</elcode> takes the value
            <code>required</code>, <code>optional</code>, or <code>prohibited</code>. If the value
            <code>required</code> is specified, then there must be a context item. (This will automatically
            be the case if the template is invoked using <elcode>xsl:apply-templates</elcode>, 
               <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, but not if it
            is invoked using <elcode>xsl:call-template</elcode>). If the value <code>optional</code> is
            specified, or if the attribute is omitted, or if the <elcode>xsl:context-item</elcode> element
            is omitted, then there may or may not be a context item when the template is invoked.
            If the containing <elcode>xsl:template</elcode> element has no <code>name</code> attribute
             then the only permitted value is <code>required</code>.
            If the value <code>prohibited</code> is specified, then there will be no context item
            available to the body template (if the calling template has a context item, it will not
            be made available to the called template).</p><p diff="add" at="G">The <code>as</code> attribute of the <elcode>xsl:context-item</elcode> defines the required type
            of the context item supplied to the template if one is supplied. The default value is <code>as="item()"</code>.
               If a context item is supplied (which will automatically
               be the case if the template is invoked using <elcode>xsl:apply-templates</elcode>, 
               <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>) then 
               if will be converted to the required type by applying the 
               <termref def="dt-function-conversion-rules">function conversion rules</termref>;
               a <termref def="dt-type-error">type error</termref> (<errorref spec="XT" class="TE" code="0590"/>)
               occurs if conversion to the required type is not possible.
               The processor <rfc2119>may</rfc2119> signal a <termref def="dt-type-error">type error</termref> statically if the required
               context item type is incompatible with the <code>match</code> pattern, that is, if no
               item that satisfies the match pattern can also satisfy the required context item type.</p><p diff="add" at="G">The <elcode>xsl:context-item</elcode> element plays no part in deciding whether and when the
              template rule is invoked in response to an <elcode>xsl:apply-templates</elcode> instruction.               
            </p><p>
               <error spec="XT" type="type" class="TE" code="3090"><p>It is a <termref def="dt-type-error">type error</termref> if the <elcode>xsl:context-item</elcode>
                  child of <elcode>xsl:template</elcode> specifies that a context item is required and none is supplied
                  by the caller, that is, if the context item is absent at the point where <elcode>xsl:call-template</elcode>
                  is evaluated.</p></error>
            </p><p>If an <code>as</code> attribute of the <elcode>xsl:template</elcode> element 
               is present, the <code>as</code> attribute defines the
               required type of the result. The result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> is then converted to
               the required type using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>. If no <code>as</code> attribute is specified, the
               default value is <code>item()*</code>, which permits any value. No conversion then
               takes place.</p><p>
               <error spec="XT" type="type" class="TE" code="0505"><p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> cannot be converted to the required type.</p></error>
            </p><p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
               <code>abstract</code> then (a) the <termref def="dt-sequence-constructor"/>
               defining the template body <rfc2119>must</rfc2119> be empty: that is, the only permitted children
               are <elcode>xsl:context-item</elcode> and <elcode>xsl:param</elcode>, and (b) there
               <rfc2119>must</rfc2119> be no <code>match</code> attribute.</p><p diff="add" at="I">If the parent of the <elcode>xsl:template</elcode> element is an
            <elcode>xsl:override</elcode> element, then there must be a <code>name</code> attribute and
            no <code>match</code> attribute, and the <termref def="dt-package">package</termref> that is
            the target of the containing <elcode>xsl:use-package</elcode> element must contain among its
            <termref def="dt-component">components</termref> a 
               <termref def="dt-named-template">named template</termref> whose 
            <termref def="dt-symbolic-identifier">symbolic identifier</termref> is the same as this
            named template, and which has a <termref def="dt-compatible">compatible</termref> signature.</p></div2><div2 id="defining-template-rules"><head>Defining Template Rules</head><p>This section describes <termref def="dt-template-rule">template rules</termref>.
                  <termref def="dt-named-template">Named templates</termref> are described in
                  <specref ref="named-templates"/>.</p><p>A <termref def="dt-template-rule">template rule</termref> is specified using the
                  <elcode>xsl:template</elcode> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> that
               identifies the <phrase diff="chg" at="C">items</phrase> to which the rule applies.
               The result of applying the template rule is the result of evaluating the sequence
               constructor contained in the <elcode>xsl:template</elcode> element, with the matching
                  <phrase diff="chg" at="C">item</phrase> used as the <phrase diff="chg" at="C"><termref def="dt-context-item">context item</termref></phrase>.</p><example><head>A Simple Template Rule</head><p>For example, an XML document might contain:</p><eg xml:space="preserve">This is an &lt;emph&gt;important&lt;/emph&gt; point.</eg><p>The following <termref def="dt-template-rule">template rule</termref> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p><eg xml:space="preserve">&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</eg></example><p>A <termref def="dt-template-rule">template rule</termref> is evaluated when an
                  <elcode>xsl:apply-templates</elcode> instruction selects <phrase diff="chg" at="C">an item</phrase> that matches the pattern specified in the <code>match</code>
               attribute. The <elcode>xsl:apply-templates</elcode> instruction is described in the
               next section. If several template rules match a selected <phrase diff="chg" at="C">item</phrase>, only one of them is evaluated, as described in <specref ref="conflict"/>.</p></div2><div2 id="applying-templates"><head>Applying Template Rules</head><e:element-syntax name="apply-templates"><e:in-category name="instruction"/><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="mode"><e:data-type name="token"/></e:attribute><e:choice repeat="zero-or-more"><e:element name="sort"/><e:element name="with-param"/></e:choice><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:apply-templates</elcode> instruction takes as input a sequence of
                  <phrase diff="chg" at="C">items</phrase> (typically nodes in a <termref def="dt-source-tree">source tree</termref>), and produces as output a sequence of
               items; these will often be nodes to be added to a <termref def="dt-result-tree">result tree</termref>.</p><p>If the instruction has one or more <elcode>xsl:sort</elcode> children, then the input
               sequence is sorted as described in <specref ref="sorting"/>. The result of this sort
               is referred to below as the <term>sorted sequence</term>; if there are no
                  <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same as the
               input sequence.</p><p>Each <phrase diff="chg" at="C">item</phrase> in the input sequence is processed by
               finding a <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-pattern">pattern</termref> matches that <phrase diff="chg" at="C">item</phrase>. If there is more than one such template rule, the best among them
               is chosen, using rules described in <specref ref="conflict"/>. If there is no
               template rule whose pattern matches the <phrase diff="chg" at="C">item</phrase>, a
               built-in template rule is used (see <specref ref="built-in-rule"/>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th <phrase diff="chg" at="C">item</phrase> in the sorted sequence is evaluated with that
                  <phrase diff="chg" at="C">item</phrase> as the <termref def="dt-context-item">context item</termref>, with <var>N</var> as the <termref def="dt-context-position">context position</termref>, and with the length of the
               sorted sequence as the <termref def="dt-context-size">context size</termref>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each <phrase diff="chg" at="C">item</phrase> in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the <phrase diff="chg" at="C">items</phrase> in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <elcode>xsl:apply-templates</elcode> instruction. </p><example><head>Applying Template Rules</head><p>Suppose the source document is as follows:</p><eg xml:space="preserve">&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</eg><p>This can be processed using the two template rules shown below.</p><eg xml:space="preserve">&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</eg><p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <termref def="dt-result-tree">result tree</termref>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <elcode>xsl:apply-templates</elcode> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value "<code>Proceed </code>", an <code>emph</code> element node, and a text node
                  containing the value "<code> to the exit!</code>"). The two text nodes are
                  processed using the built-in template rule for text nodes, which returns a copy of
                  the text node. The <code>emph</code> element is processed using the explicit
                  template rule that specifies <code>match="emph"</code>.</p><p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <elcode>xsl:apply-templates</elcode> instruction,
                  which in this case selects a single node (the text node containing the value
                     "<code>at once</code>"). This is again processed using the built-in template
                  rule for text nodes, which returns a copy of the text node.</p><p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value "<code>Proceed </code>", a <code>b</code> element that is the parent of a
                  text node containing the value "<code>at once</code>", and a text node containing
                  the value "<code> to the exit!</code>". This <termref def="dt-result-tree">result
                     tree</termref> might be serialized as:</p><eg xml:space="preserve">&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</eg></example><p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p><p>
               <error spec="XT" type="type" class="TE" code="0510"><p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code>
                     attribute is evaluated when the <termref def="dt-context-item">context
                        item</termref> is not a node. </p></error>
            </p><p>A <code>select</code> attribute can be used to process <phrase diff="chg" at="C">items</phrase> selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <termref def="dt-expression">expression</termref>. <phrase diff="del" at="C">The expression
                     <rfc2119>must</rfc2119> evaluate to a sequence of nodes (it can contain zero,
                  one, or more nodes).</phrase></p><p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="0520"><p>It is a <termref def="dt-type-error">type error</termref> if the sequence
                     returned by the <code>select</code> expression <error.extra>of
                           <elcode>xsl:apply-templates</elcode>
                     </error.extra> contains an item that is not a node.</p></error>
            </p><note diff="del" at="A"><p>In XSLT 1.0, the <code>select</code> attribute selected a set of nodes, which by
                  default were processed in document order. In XSLT 2.0, it selects a sequence of
                  nodes. In cases that would have been valid in XSLT 1.0, the expression will return
                  a sequence of nodes in document order, so the effect is the same.</p></note><example><head>Applying Templates to Selected Nodes</head><p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p><eg xml:space="preserve">&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Applying Templates to Nodes that are not Descendants</head><p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee's department and then processes the <code>group</code> children of the
                     <code>department</code>.</p><eg xml:space="preserve">&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Matching Nodes by Schema-Defined Types</head><p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p><eg xml:space="preserve">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</eg><p>The <elcode>xsl:next-match</elcode> instruction is described in <specref ref="apply-imports"/>.</p></example><example><head>Re-ordering Elements in the Result Tree</head><p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p><eg xml:space="preserve">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Processing Recursive Structures</head><p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p><p> For example, given a source document</p><eg xml:space="preserve">&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</eg><p>the rule</p><eg xml:space="preserve">&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</eg><p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p><p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p></example><example diff="add" at="C"><head>Applying Templates to Atomic Values</head><p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p><eg xml:space="preserve">&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string"&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</eg></example><note><p>The <elcode>xsl:apply-templates</elcode> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
                  processing loops. However, when <elcode>xsl:apply-templates</elcode> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p><eg role="error" xml:space="preserve">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</eg><p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p></note></div2><div2 id="conflict"><head>Conflict Resolution for Template Rules</head><p>It is possible for <phrase diff="chg" at="C">a selected item</phrase> to match more
               than one <termref def="dt-template-rule">template rule</termref> with a given
                  <termref def="dt-mode">mode</termref>
               <var>M</var>. When this happens, only one template rule is evaluated for the <phrase diff="chg" at="C">item</phrase>. The template rule to be used is determined as
               follows:</p><olist><item><p>First, only the matching template rule or rules with the highest <termref def="dt-import-precedence">import precedence</termref> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p></item><item><p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p><p><termdef term="priority" id="dt-priority">The <term>priority</term> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <elcode>xsl:template</elcode> declaration. If no priority is specified
                        explicitly for a template rule, its <termref def="dt-default-priority">default priority</termref> is used, as defined in <specref ref="default-priority"/>.</termdef></p><p>
                     <error spec="XT" type="static" class="SE" code="0530"><p>The value of the <code>priority</code> attribute <error.extra> of the
                                 <elcode>xsl:template</elcode> element</error.extra>
                           <rfc2119>must</rfc2119> conform to the rules for the
                              <code>xs:decimal</code> type defined in <bibref ref="xmlschema-2"/>.
                           Negative values are permitted.</p></error>
                  </p></item><item diff="add" at="C"><p>If this leaves more than one matching template rule, then:</p><olist><item><p>If the <termref def="dt-mode">mode</termref>
                           <var>M</var> has an <elcode>xsl:mode</elcode> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is signaled. The error is treated as
                           occurring in the <elcode>xsl:apply-templates</elcode> instruction, and
                           can be recovered by wrapping that instruction in an
                              <elcode>xsl:try</elcode> instruction.</p><p diff="chg" at="C">
                           <error spec="XT" type="dynamic" class="RE" code="0540"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                                    dynamic error</termref> if the conflict resolution algorithm for
                                 template rules leaves more than one matching template rule <phrase diff="add" at="G"> when the declaration of the relevant <termref def="dt-mode">mode</termref> has an
                                       <code>on-multiple-match</code> attribute with the value
                                    <code>fail</code></phrase>. <phrase diff="add" at="M"><emph>Note: the
                                       error code used is anomolous, for legacy reasons.</emph></phrase></p></error></p></item><item><p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <termref def="dt-declaration-order">declaration
                              order</termref> is used.</p></item></olist><note diff="add" at="C"><p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was signaled, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order. The choice of error code reflects this legacy. In XSLT 3.0 this
                        situation is not an error unless the attribute value
                           <code>on-multiple-match="fail"</code> is specified in the mode
                        declaration. It is also possible to request warnings when this condition
                        arises, by means of the attribute 
                        <phrase diff="chg" at="F"><code>warnings-on-multiple-match="yes"</code></phrase>.
                     </p></note></item></olist></div2><div2 id="default-priority"><head>Default Priority for Template Rules</head><p><termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
                  attribute is specified on an <elcode>xsl:template</elcode> element, a
                     <term>default priority</term> is computed, based on the syntax of the <termref def="dt-pattern">pattern</termref> supplied in the <code>match</code>
                  attribute.</termdef> The rules are as follows. </p><olist><item diff="add" at="C"><p>If the top-level pattern consists of multiple alternatives separated by
                        <code>|</code> , then the template rule is treated equivalently to a set of
                     template rules, one for each alternative. However, it is not an error if an
                        <phrase diff="chg" at="C">item</phrase> matches more than one of the
                     alternatives. </p></item><item diff="add" at="C"><p>If the top-level pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt>
                     containing two or more <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPatterns</nt> separated
                     by <code>intersect</code> or <code>except</code> operators, then the priority
                     of the pattern is that of the first <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPattern</nt>. </p></item><item diff="add" at="C"><p>If the pattern (in its entirety) is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>
                     with an empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>, then:</p><olist><item><p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>item()</code>, the priority is −2 (minus two).</p></item><item><p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>node()</code>, <code>function(*)</code>, or
                              <code>xs:anyAtomicType</code>, the priority is −1 (minus
                           one).</p></item><item><p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other atomic type, the priority is the priority associated with its base
                           type plus 1. This means for example that the priority of
                              <code>~xs:decimal</code> is 0 (zero), and the priority of
                              <code>~xs:integer</code> is +1 (plus one).</p></item><item><p diff="add" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is a
                           union type, the priority is the minimum priority of the atomic types in
                           the transitive membership of the union, minus 0.5. 
                           This means for example that the priority of a type formed as the union
                           of <code>xs:date</code> and <code>xs:dateTime</code> has a lower priority than 
                           <code>xs:dateTime</code> but a higher priority than
                           <code>xs:anyAtomicType</code>, while a type formed as the union
                           of <code>xs:ID</code> and <code>xs:IDREF</code> has a lower priority than 
                           <code>xs:IDREF</code> but a
                           higher priority than <code>xs:NCName</code>.</p></item><item><p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>, the
                           priority is the same as when that NodeTest appears as a pattern in its
                           own right (see below). For example, the priority of
                              <code>~element()</code> is −0.5 (minus 0.5), while that of
                              <code>~element(E)</code> is 0 (zero).</p></item><item><p diff="chg" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is 
                           an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</xnt>
                           the priority is -1, while for any other 
                              <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</xnt>, 
                           the priority is 0 (zero).</p></item><item><p diff="add" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is 
                           a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-MapType" xlink:type="simple">MapType</nt> of the form <code>map(*)</code>,
                           then the priority is +0.5, while for a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-MapType" xlink:type="simple">MapType</nt>
                           of the form <code>map(K, V)</code> the priority is the same as that of the
                           pattern <code>~K</code>.</p></item></olist></item><item diff="add" at="C"><p>If the pattern (in its entirety) is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>
                     with a non-empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>, then the priority is that of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> in the absence of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>, as given
                     above, plus 0.5. So, for example, the priority of the pattern
                        <code>~xs:integer[. gt 0]</code> is +1.5.</p></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                        <code>/</code>, then the priority is −0.5 (minus 0.5).</p></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of an <termref def="dt-eqname">EQName</termref> optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt> or has the form
                        <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-StringLiteral" xlink:type="simple">StringLiteral</xnt>
                     <code>)</code> or <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>
                     <code>)</code> optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is 0 (zero).</p></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-AttributeTest" xlink:type="simple">AttributeTest</xnt>, optionally
                     preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is
                     as shown in the table below. In this table, the symbols <var>E</var>,
                        <var>A</var>, and <var>T</var> represent an arbitrary element name,
                     attribute name, and type name respectively, while the symbol <code>*</code>
                     represents itself. The presence or absence of the symbol <code>?</code>
                     following a type name does not affect the priority.</p><table border="1" cellpadding="5" summary="default priority of patterns"><thead><tr><th align="left" rowspan="1" colspan="1">Format</th><th align="left" rowspan="1" colspan="1">Priority</th><th align="left" rowspan="1" colspan="1">Notes</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">
                              <code>element()</code>
                           </td><td rowspan="1" colspan="1">−0.5</td><td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>element(*)</code>
                           </td><td rowspan="1" colspan="1">−0.5</td><td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>attribute()</code>
                           </td><td rowspan="1" colspan="1">−0.5</td><td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>attribute(*)</code>
                           </td><td rowspan="1" colspan="1">−0.5</td><td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>element(<var>E</var>)</code>
                           </td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(equivalent to E)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>element(*,<var>T</var>)</code>
                           </td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(matches by type only)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>)</code>
                           </td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(equivalent to <code>@A</code>)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>attribute(*,<var>T</var>)</code>
                           </td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(matches by type only)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>element(<var>E</var>,<var>T</var>)</code>
                           </td><td rowspan="1" colspan="1">0.25</td><td rowspan="1" colspan="1">(matches by name and type)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>schema-element(<var>E</var>)</code>
                           </td><td rowspan="1" colspan="1">0.25</td><td rowspan="1" colspan="1">(matches by substitution group and type)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>,<var>T</var>)</code>
                           </td><td rowspan="1" colspan="1">0.25</td><td rowspan="1" colspan="1">(matches by name and type)</td></tr><tr><td rowspan="1" colspan="1">
                              <code>schema-attribute(<var>A</var>)</code>
                           </td><td rowspan="1" colspan="1">0.25</td><td rowspan="1" colspan="1">(matches by name and type)</td></tr></tbody></table></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-DocumentTest" xlink:type="simple">DocumentTest</xnt>, then
                     if it includes no <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt> the priority is −0.5. If it does include an
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt>,
                     then the priority is the same as the priority of that <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt>, computed
                     according to the table above.</p></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt><code>:*</code> or
                        <code>*:</code><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, optionally
                     preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is
                     −0.25.</p></item><item><p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of any other <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>,
                     optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the
                     priority is −0.5.</p></item><item><p>In all other cases, the priority is +0.5.</p></item></olist><note><p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <termref def="dt-expanded-qname">expanded QName</termref> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <termref def="dt-expanded-qname">expanded QName</termref> with a particular
                  namespace URI) has priority −0.25. Patterns less specific than this
                  (patterns that just test for nodes of a given kind) have priority −0.5.
                  Patterns that specify both the name and the required type have a priority of
                  +0.25, putting them above patterns that only specify the name <emph>or</emph> the
                  type. Patterns more specific than this, for example patterns that include
                  predicates or that specify the ancestry of the required node, have priority
                  0.5.</p><p diff="add" at="C">In the case of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>, the
                  default priority reflects the position of the type in the type hierarchy.</p><p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <termref def="dt-stylesheet">stylesheet</termref> it is good practice to allocate
                  explicit priorities.</p></note></div2><div2 id="modes"><head>Modes</head><p>
               <termdef id="dt-mode" term="mode">
                  <term>Modes</term> allow a node in a <termref def="dt-source-tree">source
                     tree</termref> to be processed multiple times, each time producing a different
                  result. They also allow different sets of <termref def="dt-template-rule">template
                     rules</termref> to be active when processing different trees, for example when
                  processing documents loaded using the <function>document</function> function (see
                     <specref ref="func-document"/>) or when processing <termref def="dt-temporary-tree">temporary trees</termref>.</termdef>
            </p><p diff="add" at="A">Modes are identified by an <termref def="dt-expanded-qname">expanded QName</termref>;
               in addition to any named modes, there is always one unnamed mode available. Whether a
               mode is named or unnamed, its properties <rfc2119>may</rfc2119> be defined in an
                  <elcode>xsl:mode</elcode> declaration. If a mode name is used (for example in an
                  <elcode>xsl:template</elcode> declaration or an
                  <elcode>xsl:apply-templates</elcode> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p><div3 diff="add" at="A" id="declaring-modes"><head>Declaring Modes</head><e:element-syntax name="mode" diff="chg" at="C"><e:in-category name="declaration"/><e:attribute name="name"><e:data-type name="eqname"/></e:attribute><e:attribute name="streamable"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="initial"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="on-no-match"><e:constant value="deep-copy"/><e:constant value="shallow-copy"/><e:constant value="deep-skip"/><e:constant value="shallow-skip"/><e:constant value="text-only-copy"/><e:constant value="fail"/></e:attribute><e:attribute name="on-multiple-match"><e:constant value="use-last"/><e:constant value="fail"/></e:attribute><e:attribute name="warning-on-no-match"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="warning-on-multiple-match"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="typed"><e:constant value="yes"/><e:constant value="no"/><e:constant value="strict"/><e:constant value="lax"/><e:constant value="unspecified"/></e:attribute><e:attribute name="visibility"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/></e:attribute><e:sequence><e:element repeat="zero-or-one" name="context-item"/></e:sequence><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>
                  <termdef id="dt-unnamed-mode" term="unnamed mode">There is always an <term>unnamed
                        mode</term> available. The unnamed mode is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <elcode>xsl:apply-templates</elcode> instruction or
                        <elcode>xsl:template</elcode> declaration, unless a different default mode
                     has been specified using the <code>default-mode</code> attribute of the
                     containing <elcode>xsl:stylesheet</elcode> element.</termdef>
               </p><p>Every <termref def="dt-mode">mode</termref> other than the <termref def="dt-unnamed-mode">unnamed mode</termref> is identified by an <termref def="dt-expanded-qname">expanded QName</termref>.</p><p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                     <elcode>xsl:mode</elcode> declarations and may include or import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                     <elcode>xsl:mode</elcode> declarations. The name of an
                     <elcode>xsl:mode</elcode> declaration is the value of its <code>name</code>
                  attribute, if any.</p><p>
                  <termdef id="dt-mode-definition" term="mode definition">All the
                        <elcode>xsl:mode</elcode> declarations in a stylesheet that share the same
                     name are grouped into a named <term>mode definition</term>; those that have no
                     name are grouped into a single unnamed mode definition.</termdef>
               </p><p>If a <termref def="dt-stylesheet">stylesheet</termref> does not contain a
                  declaration of the unnamed mode, a declaration is implied equivalent to an
                     <elcode>xsl:mode</elcode> element with the single attribute
                     <code>initial="yes"</code>. Similarly, if there is a mode that is named in an
                     <elcode>xsl:template</elcode> or <elcode>xsl:apply-templates</elcode> element,
                  or in the <code>default-mode</code> attribute of an
                     <elcode>xsl:stylesheet</elcode> element, and the <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of that mode, then a
                  declaration is implied comprising an <elcode>xsl:mode</elcode> element with a
                     <code>name</code> attribute plus the attribute <code>initial="yes"</code>. </p><p>The contained <elcode>xsl:context-item</elcode> element, if present, is used to
                  declare requirements for the <termref def="dt-initial-context-item"/> when this
                  mode is used as the <termref def="dt-initial-mode"/>. Therefore, there must be no
                     <elcode>xsl:context-item</elcode> child if <code>initial="no"</code> is
                  specified.</p><p>
                  <error spec="XT" type="static" class="SE" code="0542"><p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:mode</elcode> declaration specifying
                           <code>initial="no"</code> contains an <elcode>xsl:context-item</elcode>
                        element.</p></error>
               </p><p>The attributes of the <elcode>xsl:mode</elcode> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p><table diff="chg" at="C" cellpadding="5" width="100%" summary="attributes of the xsl:mode element"><thead><tr><th rowspan="1" colspan="1">Attribute</th><th rowspan="1" colspan="1">Values</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">name</td><td valign="top" rowspan="1" colspan="1">A <termref def="dt-eqname">EQName</termref></td><td valign="top" rowspan="1" colspan="1">Specifies the name of the mode. If omitted, this
                              <elcode>xsl:mode</elcode> declaration provides properties of the
                              <termref def="dt-unnamed-mode">unnamed mode</termref></td></tr><tr><td valign="top" rowspan="1" colspan="1">streamable</td><td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>no</code>)</td><td valign="top" rowspan="1" colspan="1">Determines whether template rules in this mode are to be
                           capable of being processed using <termref def="dt-streaming"/>. If the value
                              <code>yes</code> is specified, then the body of any <termref def="dt-template-rule">template rule</termref> that uses this mode
                              <rfc2119>must</rfc2119> conform to the rules for streamable templates
                           given in <specref ref="streamable-templates"/>. </td></tr><tr><td valign="top" rowspan="1" colspan="1">initial</td><td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>yes</code>)</td><td valign="top" rowspan="1" colspan="1">Determines whether this mode can be used as the <termref def="dt-initial-mode"/> when the transformation is invoked. If the
                           value <code>yes</code> is specified, or if the attribute is omitted, then
                           the mode is eligible to be used as the <termref def="dt-initial-mode"/>;
                           if the value <code>no</code> is specified then processing in the mode can
                           only be achieved by means of an <elcode>xsl:apply-templates</elcode>
                           instruction within the stylesheet that names this mode.</td></tr><tr><td valign="top" rowspan="1" colspan="1">on-no-match</td><td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="I">One of 
                           <code>deep-copy</code>, 
                           <code>shallow-copy</code>,
                           <code>deep-skip</code>,
                           <code>shallow-skip</code>,
                           <code>text-only-copy</code>
                               or <code>fail</code> (default
                              <code>text-only-copy</code>)</phrase></td><td valign="top" rowspan="1" colspan="1">Determines selection of the built-in <termref def="dt-template-rule">template rules</termref> that are used to
                           process a node when an <elcode>xsl:apply-templates</elcode> instruction
                           selects a node that does not match any user-written <termref def="dt-template-rule">template rule</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. For details, see <specref ref="built-in-rule"/>.</td></tr><tr><td valign="top" rowspan="1" colspan="1">on-multiple-match</td><td valign="top" rowspan="1" colspan="1">One of <code>fail</code> or <code>use-last</code> (default
                              <code>use-last</code>)</td><td valign="top" rowspan="1" colspan="1">Defines the action to be taken when
                              <elcode>xsl:apply-templates</elcode> is used in this mode and more
                           than one user-written <termref def="dt-template-rule">template
                              rule</termref> is available to process the node, having the same
                              <termref def="dt-import-precedence">import precedence</termref> and
                              <termref def="dt-priority">priority</termref>. The value
                              <code>fail</code> indicates that it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
                           if more than one template rule matches the node. The value
                              <code>use-last</code> indicates that the situation is not to be
                           treated as an error (the last template in <termref def="dt-declaration-order">declaration order</termref> is the one that
                           is used). </td></tr><tr><td valign="top" rowspan="1" colspan="1">warning-on-no-match</td><td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                        </td><td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output (or not to output) a warning message in
                           the case where an <elcode>xsl:apply-templates</elcode> instruction
                           selects a node that matches no template rule. The form and destination of
                           such warnings is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.
                           </td></tr><tr><td valign="top" rowspan="1" colspan="1">warning-on-multiple-match</td><td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                           </td><td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output a warning message in the case where an
                              <elcode>xsl:apply-templates</elcode> instruction selects a node that
                           matches multiple template rules having the same <termref def="dt-import-precedence">import precedence</termref> and <termref def="dt-priority">priority</termref>. The form and destination of such
                           warnings is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td></tr><tr diff="add" at="G"><td valign="top" rowspan="1" colspan="1">typed</td><td valign="top" rowspan="1" colspan="1">One of <code>yes</code>, <code>no</code>, 
                           <code>strict</code>, <code>lax</code>, or <code>unspecified</code>. The default is
                           <code>unspecified</code>.</td><td valign="top" rowspan="1" colspan="1"><phrase diff="add" at="G">Informs the <termref def="dt-processor">processor</termref> whether the nodes to be processed by template rules
                        in this mode are to be typed or untyped. If the value <code>yes</code> is specified,
                           then all nodes processed in this mode <rfc2119>must</rfc2119> be typed (a dynamic
                        error occurs if <elcode>xsl:apply-templates</elcode> in this mode selects an element or attribute
                        whose type annotation is <code>xs:untyped</code> or <code>xs:untypedAtomic</code>).
                           If the value <code>no</code> is specified,
                           then all nodes processed in this mode <rfc2119>must</rfc2119> be untyped (a dynamic
                           error occurs if <elcode>xsl:apply-templates</elcode> in this mode selects an element
                           or attribute
                           whose type annotation is anything other than <code>xs:untyped</code> or 
                           <code>xs:untypedAtomic</code>).
                           The value <code>strict</code> is equivalent to <code>yes</code>, with the additional
                           provision that within the match pattern of every template rule in this mode, any 
                           <code>NameTest</code> used without a <code>PatternAxis</code> in the first
                           <code>PatternStep</code> of a <code>RelativePathPattern</code> is interpreted
                           as a <code>SchemaElementTest</code>: for example, <code>match="product"</code> is
                           interpreted as <code>match="schema-element(product)"</code>, while
                           <code>match="product/code"</code> is interpreted as 
                           <code>match="schema-element(product)/code"</code>. The value <code>lax</code>
                           is equivalent to <code>strict</code>, except that the interpretation of a <code>NameTest</code>
                           as a <code>SchemaElementTest</code> occurs only if it matches the name of a global
                           element declaration in the in-scope schema declarations. The value <code>unspecified</code>
                        is equivalent to omitting the attribute, and places no constraints on whether the nodes
                        to be processed in this mode are typed or untyped.</phrase></td></tr></tbody></table><p>
                  <error spec="XT" type="type" class="TE" code="3100"><p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction in a particular <code>mode</code>
                        selects an element or attribute whose type is <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that
                        mode specifies the value <code>yes</code>, <code>strict</code>, or <code>lax</code>.</p></error>
               </p><p>
                  <error spec="XT" type="type" class="TE" code="3110"><p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction in a particular <code>mode</code>
                        selects an element or attribute whose type is anything other than <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that
                        mode specifies the value <code>no</code>.</p></error>
               </p><imp-def-feature>The default values for the <code>warning-on-no-match</code> and
                     <code>warning-on-multiple-match</code> attributes of <elcode>xsl:mode</elcode>
                  are <termref def="dt-implementation-defined"/>.</imp-def-feature><imp-def-feature>The form of any warnings output when there is no matching template rule
                  or when there are multiple matching template rules is implementation-defined.</imp-def-feature><p>
                  <termdef id="dt-streamable-mode" term="streamable mode">A <term>streamable
                        mode</term> is a <termref def="dt-mode">mode</termref> that is declared in
                     an <elcode>xsl:mode</elcode> declaration with the attribute
                        <code>streamable="yes"</code>.</termdef>
               </p><p>For any named <termref def="dt-mode">mode</termref>, the effective value of each
                  attribute is taken from an <elcode>xsl:mode</elcode> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. If there is more than one such declaration, the
                  one with highest <termref def="dt-import-precedence">import precedence</termref>
                  is used.</p><p>For the <termref def="dt-unnamed-mode">unnamed mode</termref>, the effective value
                  of each attribute is taken from an <elcode>xsl:mode</elcode> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <termref def="dt-import-precedence">import precedence</termref> is
                  used.</p><p>The above rules apply both to the attributes (other than <code>name</code>) of the
                     <elcode>xsl:mode</elcode> element itself, and to the attributes of the
                  contained <elcode>xsl:context-item</elcode> element if present.</p><p>
                  <error spec="XT" type="static" class="SE" code="0545"><p>It is a <termref def="dt-static-error">static error</termref> if a named or
                        unnamed <termref def="dt-mode">mode</termref> contains two conflicting
                        values for the same attribute in different <elcode>xsl:mode</elcode>
                        declarations having the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <elcode>xsl:mode</elcode>
                        element, and the <code>as</code> attribute on the contained
                           <elcode>xsl:context-item</elcode> element if present.</p></error>
               </p><p diff="add" at="E">If the <termref def="dt-initial-context-item"/> supplied to a
                  stylesheet is a streamed document node, then it is not permitted for the values of
                  global variables to be dependent on the context item in a way that requires
                  reading of the input stream. This constraint is enforced by the following static
                  rule:</p><p diff="add" at="E"><error spec="XT" type="static" class="SE" code="0548"><p>It is a <termref def="dt-static-error">static error</termref> if there is
                        both (a) a <termref def="dt-mode-definition"/> in the <termref def="dt-stylesheet"/> that has the effective attribute values
                           <code>streamable="yes"</code> and <code>initial="yes"</code>, and (b) a
                           <termref def="dt-global-variable"/> in the <termref def="dt-stylesheet"/>
                        whose initializing expression is not <termref def="dt-motionless"/> with
                        respect to its context item, as defined in <specref ref="streamability"/>.</p></error></p></div3><div3 diff="chg" at="E" id="initial-context-for-mode"><head>Declaring the Initial Context Item for a Mode</head><p>Given a <termref def="dt-mode"/> that is used as the <termref def="dt-initial-mode"/>, the <elcode>xsl:context-item</elcode> element may be
                  used to constrain the type of the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> that is supplied by the calling
                  application.</p><e:element-syntax name="context-item"><!--<e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>--><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="use"><e:constant value="required"/><e:constant value="optional"/><e:constant value="prohibited"/></e:attribute><!--<e:model name="sequence-constructor"/>--><e:empty/><e:allowed-parents><e:parent name="mode"/><e:parent name="template"/></e:allowed-parents></e:element-syntax><p>If the <code>as</code> attribute is present then its value must be an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt>. When this mode (the
                  mode defined in the containing <elcode>xsl:mode</elcode> declaration) is used as
                  the <termref def="dt-initial-mode"/>, then an <termref def="dt-initial-context-item"/> must be supplied externally, and its value will
                  be converted to this type using the <termref def="dt-function-conversion-rules"/>;
                  this may result in a <termref def="dt-type-error"/> if the conversion is not
                  possible.</p><p>If the <code>as</code> attribute is omitted this is equivalent to specifying
                     <code>as="item()"</code>.</p><p diff="add" at="G">When the <elcode>xsl:context-item</elcode> element appears as a child of
                  <elcode>xsl:mode</elcode>, the only permitted value for the <code>use</code>
                  attribute is <code>required</code>, indicating that an initial context item
                  <rfc2119>must</rfc2119> be supplied by the calling application when this
                  mode is selected as the <termref def="dt-initial-mode">initial mode</termref>.</p><note><p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <termref def="dt-processor">processor</termref>
                     <rfc2119>may</rfc2119> interpret this as a request to apply schema validation
                     to the input. Similarly, if the <code>KindTest</code> indicates that an element
                     node is required, the processor <rfc2119>may</rfc2119> interpret this as a
                     request to supply the document element rather than the document node of a
                     supplied input document.</p></note><p>If there is no <elcode>xsl:context-item</elcode> element for an
                     <elcode>xsl:mode</elcode> that specifies <code>initial="yes"</code>, this is
                  equivalent to specifying <code>&lt;xsl:context-item as="item()"/&gt;</code></p><!--
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0300">
                     <p>It is a
                        <termref def="dt-static-error">static error</termref> if a
                        <termref def="dt-stylesheet">stylesheet</termref> contains more than one <elcode>xsl:context-item</elcode> declaration with the same
                        <termref def="dt-import-precedence">import precedence</termref>,
                        unless it also contains another <elcode>xsl:context-item</elcode> declaration with higher import precedence.</p>
                  </error>
               </p>--><p diff="add" at="D">A <termref def="dt-type-error"/> is signaled if the supplied
                  context item does not match its required type. The error code is the same as for
                     <elcode>xsl:param</elcode>
                  <errorref spec="XT" class="TE" code="0590"/>.</p><example><head>Declaring the Required Context Item</head><p>The following example declares two modes, both of which have
                        <code>initial="yes"</code> meaning that they can be used as entry points to
                     the stylesheet. In the first mode, named <code>invoice</code>, the required
                     context item is a schema-validated <code>invoice</code> element. In the second
                     mode, named <code>po</code>, the required context item is a schema-validated
                        <code>purchase-order</code> element. A third mode,
                        <code>format-address</code> is declared with <code>initial="no"</code> so it
                     cannot be used as an initial entry point; this mode might be used when
                     processing content that is common to invoices and purchase orders.</p><eg xml:space="preserve">&lt;xsl:mode name="invoice" initial="yes" on-no-match="deep-copy"&gt;
  &lt;xsl:context-item as="schema-element(invoice)"/&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="po" initial="yes" on-no-match="deep-copy"&gt;
  &lt;xsl:context-item as="schema-element(purchase-order)"/&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="format-address" initial="no"/&gt;</eg></example><note><p diff="add" at="I">The <elcode>xsl:context-item</elcode> element
               can also appear as a child of <elcode>xsl:template</elcode> to define
               the type of the context item passed to a named template. If the named template
               is also the <termref def="dt-initial-template">initial template</termref>, then
               this constrains the <termref def="dt-initial-context-item">initial context item</termref>
               for the transformation as a whole.</p></note></div3><div3 id="using-modes"><head>Using Modes</head><p>A <termref def="dt-template-rule">template rule</termref> is applicable to one or
                  more modes. The modes to which it is applicable are defined by the
                     <code>mode</code> attribute of the <elcode>xsl:template</elcode> element. If
                  the attribute is omitted, then the template rule is applicable to the <phrase diff="chg" at="A">default mode specified in the <code>default-mode</code>
                     attribute of the containing <elcode>xsl:stylesheet</elcode> element, which in
                     turn defaults to the <termref def="dt-unnamed-mode">unnamed
                     mode</termref>.</phrase> If the <code>mode</code> attribute is present, then
                  its value <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of
                  tokens, each of which defines a mode to which the template rule is applicable.
                  Each token <rfc2119>must</rfc2119> be one of the following:</p><ulist><item><p>an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                           <specref ref="qname"/> to define the name of the mode</p></item><item><p>the token <code>#default</code>, to indicate that the template rule is
                        applicable to the <phrase diff="chg" at="A">default mode for the stylesheet
                           module</phrase>
                     </p></item><item><p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <termref def="dt-unnamed-mode">unnamed
                           mode</termref>
                     </p></item><item><p>the token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes (specifically, to the <phrase diff="chg" at="D">unnamed</phrase> mode and to every mode that is named <phrase diff="add" at="D">explicitly or implicitly</phrase> in an
                           <elcode>xsl:apply-templates</elcode> instruction <phrase diff="del" at="D">or
                              <elcode>xsl:template</elcode> declaration</phrase> anywhere in the
                        stylesheet).</p></item></ulist><p>
                  <error spec="XT" type="static" class="SE" code="0550"><p>It is a <termref def="dt-static-error">static error</termref> if the list
                           <error.extra>of modes in the <code>mode</code> attribute of
                              <elcode>xsl:template</elcode>
                        </error.extra> is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p></error>
               </p><p>The <elcode>xsl:apply-templates</elcode> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <rfc2119>must</rfc2119> be one of the following:</p><ulist><item><p>an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                           <specref ref="qname"/> to define the name of a mode</p></item><item><p>the token <code>#default</code>, to indicate that the default mode <phrase diff="add" at="A">for the <termref def="dt-stylesheet-module">stylesheet
                              module</termref>
                        </phrase> is to be used</p></item><item><p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                           <termref def="dt-unnamed-mode">unnamed mode</termref> is to be used</p></item><item><p>the token <code>#current</code>, to indicate that the <termref def="dt-current-mode">current mode</termref> is to be used</p></item></ulist><p>If the attribute is omitted, the default mode <phrase diff="add" at="A">for the
                        <termref def="dt-stylesheet-module">stylesheet module</termref>
                  </phrase> is used.</p><p>When searching for a template rule to process each <phrase diff="chg" at="C">item</phrase> selected by the <elcode>xsl:apply-templates</elcode>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p><!--Text replaced by erratum E19 change 2"--><p>
                  <termdef id="dt-current-mode" term="current mode">At any point in the processing
                     of a stylesheet, there is a <term>current mode</term>. When the transformation
                     is initiated, the current mode is the <phrase diff="chg" at="E"><termref def="dt-initial-mode"/></phrase>, as described in <specref ref="initiating"/>. Whenever an <elcode>xsl:apply-templates</elcode>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</termdef> When a <phrase diff="chg" at="M"><termref def="dt-non-contextual-function-call"/> is made</phrase>, the current mode
                  is set to the <termref def="dt-unnamed-mode">unnamed mode</termref>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <termref def="dt-attribute-set">attribute set</termref>
                  is the same as the current mode of the caller. On completion of the
                     <elcode>xsl:apply-templates</elcode> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <elcode>xsl:apply-templates</elcode> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>
                  instructions (see <specref ref="apply-imports"/>).</p></div3><!--End of text replaced by erratum E19--></div2><div2 id="built-in-rule"><head>Built-in Template Rules</head><p diff="chg" at="C">When a node is selected by <elcode>xsl:apply-templates</elcode> and
               there is no user-specified <termref def="dt-template-rule">template rule</termref> in
               the <termref def="dt-stylesheet">stylesheet</termref> that can be used to process
               that node, then a built-in template rule is evaluated instead. </p><p>The built-in <termref def="dt-template-rule">template rules</termref> have lower
                  <termref def="dt-import-precedence">import precedence</termref> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p><p diff="chg" at="I">There are six sets of built-in template rules available. The set
               that is chosen is a property of the <termref def="dt-mode">mode</termref> selected by
               the <elcode>xsl:apply-templates</elcode> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <elcode>xsl:mode</elcode> declaration,
               which takes one of the six values <code>deep-copy</code>, <code>shallow-copy</code>,
               <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>,
               or <code>fail</code>, the default being
                  <code>text-only-copy</code>. The effect of these six sets of built-in template rules
               is explained in the following subsections.</p><div3 id="built-in-templates-text-only-copy"><head>Built-in Templates: Text-only Copy</head><p diff="chg" at="I">The effect of choosing
                     <code>on-no-match="text-only-copy"</code> for a <termref def="dt-mode">mode</termref> is that
                  the textual content of the source document is retained while
                  losing the markup, except where explicit template rules dictate otherwise. 
                  When an element is encountered for which there is no explicit
                     <termref def="dt-template-rule">template rule</termref>, the processing
                  continues with the children of that element. Text nodes are copied to the
                  output.</p><p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p><p>The built-in <termref def="dt-template-rule">template rule</termref> for text and
                  attribute nodes <phrase diff="add" at="C">and atomic values</phrase> returns a
                  text node containing the <termref def="dt-string-value">string value</termref> of
                  the context node. It is effectively:</p><eg xml:space="preserve">&lt;xsl:template match="text()|@*|xs:anyAtomicType" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg><note><p>This text node may have a string value that is zero-length.</p></note><p diff="chg" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for processing instructions, comments, namespace nodes, and
                  function items does nothing (it returns the empty sequence).</p><eg xml:space="preserve">&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()|function(*)" 
   mode="M"/&gt;</eg><p diff="del" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for namespace nodes is also to do nothing. There is no pattern
                  that can match a namespace node, so the built-in template rule is always used when
                     <elcode>xsl:apply-templates</elcode> selects a namespace node.</p><example><head>Using a Built-In Template Rule</head><p>Suppose the stylesheet contains the following instruction:</p><eg xml:space="preserve">&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</eg><p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p><eg xml:space="preserve">&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</eg></example></div3><div3 id="built-in-templates-deep-copy" diff="add" at="I"><head>Built-in Templates: Deep Copy</head><p>The effect of choosing <code>on-no-match="deep-copy"</code> for a <termref def="dt-mode">mode</termref> is that an unmatched element in the source tree is copied 
                  unchanged to the output, together with its entire subtree. The subtree is copied
               unconditionally, without attempting to match nodes in the subtree against template rules.</p><p>When this default action is selected for a mode <var>M</var>, all items are
               processed using a template rule that is equivalent to the following:</p><eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;</eg></div3><div3 id="built-in-templates-shallow-copy" diff="chg" at="I"><head>Built-in Templates: Shallow Copy</head><p>The effect of choosing <code>on-no-match="shallow-copy"</code> for a <termref def="dt-mode">mode</termref> is that the source tree is copied unchanged to the
                  output, except for nodes where different processing is specified using an explicit
                     <termref def="dt-template-rule">template rule</termref>.</p><p>When this default action is selected for a mode <var>M</var>, all items are
                  processed using a template rule that is equivalent to the following, except that
                  all parameters supplied in <elcode>xsl:with-param</elcode> elements are passed on
                  implicitly to the called templates:</p><eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</eg><p>This rule is often referred to as the <emph>identity template</emph>, though it
                  should be noted that it does not preserve node identity.</p><note><p>This rule differs from the "traditional" identity template rule by using two
                        <elcode>xsl:apply-templates</elcode> instructions, one to process the
                     attributes and one to process the children. The only observable difference is
                     that with two separate instructions, the value of <code>position()</code> in
                     the called templates forms one sequence starting at 1 for the attributes, and a
                     new sequence starting at 1 for the children.</p></note><example><head>Modified Identity Transformation</head><p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p><eg xml:space="preserve">&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg></example></div3><div3 id="built-in-templates-deep-skip" diff="add" at="I"><head>Built-in Templates: Deep Skip</head><p>The effect of choosing <code>on-no-match="deep-skip"</code> for a <termref def="dt-mode">mode</termref> is that an unmatched element in the source tree is skipped
               in its entirety; neither the element nor any of its descendants is copied to the result tree
               or processed any further.</p><p>When this default action is selected for a mode <var>M</var>, all items are
                  processed using a template rule that is equivalent to the following:</p><eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"/&gt;</eg></div3><div3 id="built-in-templates-shallow-skip" diff="chg" at="I"><head>Built-in Templates: Shallow Skip</head><p diff="add" at="E">The effect of choosing
                  <code>on-no-match="shallow-skip"</code> for a <termref def="dt-mode">mode</termref>
                  is to drop both the textual content and the markup from the result document, except where there is
                  an explicit user-written <termref def="dt-template-rule">template rules</termref> that dictates otherwise.</p><p>The built-in rule for document nodes and element nodes is the same as for
                  <code>on-no-match="text-only-copy"</code>: that is, it is equivalent to calling
                  <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <elcode>xsl:apply-templates</elcode> instruction.</p><p>The built-in template rule for all other kinds of node, and for atomic values and
                  function items, is empty: that is, when the item is matched, the built-in template
                  rule returns an empty sequence.</p></div3><div3 id="built-in-templates-fail" diff="add" at="E"><head>Built-in Templates: Fail</head><p diff="add" at="E">The effect of choosing <code>on-no-match="fail"</code>
                  for a <termref def="dt-mode">mode</termref> is that every node selected in an
                     <elcode>xsl:apply-templates</elcode> instruction must be matched by an explicit
                  user-written <termref def="dt-template-rule">template rule</termref>.</p><p>The built-in template rule is effectively: </p><eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</eg><p>with an <termref def="dt-implementation-dependent"/> message body.</p><p>
                  <error spec="XT" type="dynamic" class="DE" code="0555"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> is
                        used to process a node using a mode whose declaration specifies
                           <code>on-no-match="fail"</code> when there is no <termref def="dt-template-rule"/> in the <termref def="dt-stylesheet"/> whose
                        match pattern matches that node. </p></error>
               </p></div3></div2><div2 id="apply-imports"><head>Overriding Template Rules</head><e:element-syntax name="apply-imports"><e:in-category name="instruction"/><e:element name="with-param" repeat="zero-or-more"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="next-match"><e:in-category name="instruction"/><e:choice repeat="zero-or-more"><e:element name="with-param"/><e:element name="fallback"/></e:choice><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>A <termref def="dt-template-rule">template rule</termref> that is being used to
               override another template rule (see <specref ref="conflict"/>) can use the
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode>
               instruction only considers template rules in imported stylesheet modules; the
                  <elcode>xsl:next-match</elcode> instruction considers all other template rules of
               lower <termref def="dt-import-precedence">import precedence</termref> and/or
               priority. Both instructions will invoke the built-in template rule for the <phrase diff="chg" at="C">context item</phrase> (see <specref ref="built-in-rule"/>) if no
               other template rule is found.</p><p>
               <termdef id="dt-current-template-rule" term="current template rule">At any point in
                  the processing of a <termref def="dt-stylesheet">stylesheet</termref>, there may
                  be a <term>current template rule</term>. Whenever a <termref def="dt-template-rule">template rule</termref> is chosen as a result of
                  evaluating <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, the
                  template rule becomes the current template rule for the evaluation of the rule's
                  sequence constructor. When an <elcode>xsl:for-each</elcode>,
                     <elcode>xsl:for-each-group</elcode>, <elcode>xsl:analyze-string</elcode>,
                  <phrase diff="add" at="F"><elcode>xsl:iterate</elcode>, <elcode>xsl:stream</elcode>,
                  <elcode>xsl:merge</elcode>, or <elcode>xsl:evaluate</elcode></phrase>
                  instruction is evaluated, or when evaluating a sequence constructor contained in
                  an <elcode>xsl:sort</elcode> or <elcode>xsl:key</elcode> element, or when a
                     <phrase diff="chg" at="M"><termref def="dt-non-contextual-function-call"/> is made,</phrase> the current template rule becomes
                  <phrase diff="chg" at="M"><termref def="dt-absent"/></phrase> for the evaluation of that instruction or function.</termdef>
            </p><p>The current template rule is not affected by invoking named templates (see <specref ref="named-templates"/>) or named attribute sets (see <specref ref="attribute-sets"/>). While evaluating a <termref def="dt-global-variable">global variable</termref> or the default value of a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> (see <specref ref="global-variables"/>) the current template rule is 
                   <phrase diff="chg" at="M"><termref def="dt-absent"/></phrase>.</p><note><p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item">context item</termref> is the same as when the current template rule was
                     invoked<phrase diff="del" at="C">, and is always a node</phrase>.</p></note><p> Both <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode> search
               for a <termref def="dt-template-rule">template rule</termref> that matches the
                  <phrase diff="chg" at="C"><termref def="dt-context-item">context
                  item</termref></phrase>, and that is applicable to the <termref def="dt-current-mode">current mode</termref> (see <specref ref="modes"/>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <termref def="dt-import-precedence">import precedence</termref> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
               two instructions:</p><ulist><item><p>The <elcode>xsl:apply-imports</elcode> instruction considers as candidates only
                     those template rules contained in <termref def="dt-stylesheet-level">stylesheet
                        levels</termref> that are descendants in the <termref def="dt-import-tree">import tree</termref> of the <termref def="dt-stylesheet-level">stylesheet
                        level</termref> that contains the <termref def="dt-current-template-rule">current template rule</termref>.</p><note><p>This is <emph>not</emph> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p></note></item><item><p>The <elcode>xsl:next-match</elcode> instruction considers as candidates all
                     those template rules that come after the <termref def="dt-current-template-rule">current template rule</termref> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <specref ref="conflict"/>. That is, it considers all template rules with
                     lower <termref def="dt-import-precedence">import precedence</termref> than the
                        <termref def="dt-current-template-rule">current template rule</termref>,
                     plus the template rules that are at the same import precedence that have lower
                     priority than the current template rule, <phrase diff="chg" at="D">plus
                        the</phrase> template rules with the same import precedence and priority
                     that occur before the current template rule in <termref def="dt-declaration-order">declaration order</termref>.</p><note><p>As explained in <specref ref="conflict"/>, a template rule whose match
                        pattern contains multiple alternatives separated by <code>|</code> is
                        treated equivalently to a set of template rules, one for each alternative.
                        This means that where the same <phrase diff="chg" at="C">item</phrase>
                        matches more than one alternative, and the alternatives have different
                        priority, it is possible for an <elcode>xsl:next-match</elcode> instruction
                        to cause the current template rule to be invoked recursively. This situation
                        does not occur when the alternatives have the same priority.</p></note></item></ulist><p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the <phrase diff="chg" at="C">context item</phrase> is used (see
                  <specref ref="built-in-rule"/>).</p><p>An <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               may use <elcode>xsl:with-param</elcode> child elements to pass parameters to the
               chosen <termref def="dt-template-rule">template rule</termref> (see <specref ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter">tunnel parameters</termref> as described in <specref ref="tunnel-params"/>.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0560"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if <elcode>xsl:apply-imports</elcode> or
                        <elcode>xsl:next-match</elcode> is evaluated when the <termref def="dt-current-template-rule">current template rule</termref> is 
                     <phrase diff="chg" at="M"><termref def="dt-absent"/></phrase>.</p></error>
            </p><example><head>Using <elcode>xsl:apply-imports</elcode>
               </head><p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <termref def="dt-template-rule">template rule</termref> for <code>example</code>
                  elements:</p><eg xml:space="preserve">&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</eg><p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p><eg xml:space="preserve">&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg><p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p><eg xml:space="preserve">&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</eg></example><p>An <elcode>xsl:fallback</elcode> instruction appearing as a child of an
                  <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 <phrase diff="chg" at="A">or 3.0</phrase> processor, but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with
               forwards compatible behavior.</p></div2><div2 id="parameters-to-template-rules" diff="add" at="D"><head>Passing Parameters to Template Rules</head><p>A template rule may have parameters. The parameters are declared in the body of the
               template using <elcode>xsl:param</elcode> elements, as described in <specref ref="parameters"/>.</p><p>Values for these parameters may be supplied in the calling
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction by means of
                  <elcode>xsl:with-param</elcode> elements appearing as children of the calling
               instruction. The <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the <elcode>xsl:with-param</elcode>
               element must match the <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the corresponding
                  <elcode>xsl:param</elcode> element. </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0700"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if a template that is invoked using
                        <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                        <elcode>xsl:next-match</elcode> declares a <termref def="dt-template-parameter">template parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied by
                     the calling instruction. </p><p>The same error is reported in the case of a <termref def="dt-tunnel-parameter">tunnel parameter</termref> whether invoked using one of these three
                     instructions or by <elcode>xsl:call-template</elcode>, as explained in <specref ref="tunnel-params"/>.</p></error>
            </p><p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p><p>A parameter may be declared as a <termref def="dt-tunnel-parameter">tunnel
                  parameter</termref> by specifying <code>tunnel="yes"</code> in the
                  <elcode>xsl:param</elcode> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <elcode>xsl:with-param</elcode> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <specref ref="tunnel-params"/>.</p></div2></div1><div1 id="repetition"><head>Repetition</head><p diff="add" at="A">XSLT offers two constructs for processing each item of a sequence:
               <elcode>xsl:for-each</elcode> and <elcode>xsl:iterate</elcode>.</p><p diff="add" at="A">The main difference between the two constructs is that with
               <elcode>xsl:for-each</elcode>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <elcode>xsl:iterate</elcode>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <elcode>xsl:iterate</elcode>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p><p diff="add" at="A">A further difference is that <elcode>xsl:for-each</elcode> permits
            sorting of the input sequence, while <elcode>xsl:iterate</elcode> does not.</p><div2 id="for-each"><head>The <code>xsl:for-each</code> instruction</head><e:element-syntax name="for-each"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="sort"/><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:for-each</elcode> instruction processes each item in a sequence of
               items, evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> within the <elcode>xsl:for-each</elcode> instruction once
               for each item in that sequence.</p><p> The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence. If there is an <elcode>xsl:sort</elcode> element
               present (see <specref ref="sorting"/>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p><p>The <elcode>xsl:for-each</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>. The <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated once for
               each item in the sorted sequence, with the <termref def="dt-focus">focus</termref>
               set as follows:</p><ulist><item><p>The <termref def="dt-context-item">context item</termref> is the item being
                     processed. <phrase diff="del" at="D">If this is a node, it will also be the
                           <termref def="dt-context-node">context node</termref>. If it is not a
                        node, there will be no context node: that is, any attempt to reference the
                        context node will result in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</phrase>
                  </p></item><item><p>The <termref def="dt-context-position">context position</termref> is the
                     position of this item in the sorted sequence.</p></item><item><p>The <termref def="dt-context-size">context size</termref> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p></item></ulist><p> For each item in the input sequence, evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
               of items (see <specref ref="sequence-constructors"/>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <elcode>xsl:for-each</elcode> instruction is the concatenated sequence of
               items.</p><example><head>Using <elcode>xsl:for-each</elcode>
               </head><p>For example, given an XML document with this structure</p><eg xml:space="preserve">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</eg><p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p><eg xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	&lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
		&lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
		&lt;td&gt;
		  &lt;xsl:apply-templates/&gt;
		&lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</eg></example></div2><div2 id="iterate" diff="add" at="A"><head>The <code>xsl:iterate</code> Instruction</head><e:element-syntax name="iterate"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="param"/><e:model name="sequence-constructor"/><e:element repeat="zero-or-one" name="on-completion"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="next-iteration"><e:in-category name="instruction"/><e:sequence><e:element repeat="zero-or-more" name="with-param"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="break"><e:in-category name="instruction"/><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:sequence><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="on-completion"><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:sequence><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent name="iterate"/></e:allowed-parents></e:element-syntax><p>The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence.</p><p>The <termref def="dt-sequence-constructor"/> contained
               in the <elcode>xsl:iterate</elcode> instruction is evaluated once for each item in
               the input sequence, in order, or until the loop exits by evaluating an
                  <elcode>xsl:break</elcode> instruction, whichever is earlier. Within the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the body
               of the <elcode>xsl:iterate</elcode> instruction, the <termref def="dt-context-item">context item</termref> is set to each item from the value of the
                  <code>select</code> expression in turn; the <termref def="dt-context-position">context position</termref> reflects the position of this item in the input
               sequence, and the <termref def="dt-context-size">context size</termref> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <elcode>xsl:break</elcode>).</p><note><p>If <elcode>xsl:iterate</elcode> is used in conjunction with
                     <elcode>xsl:stream</elcode> to achieve streaming, calls on the
                  function <xfunction>last</xfunction> will be disallowed.
                  </p></note><p diff="add" at="G">The <elcode>xsl:break</elcode> and <elcode>xsl:on-completion</elcode> elements may have 
            either a <code>select</code> attribute or a non-empty contained 
               <termref def="dt-sequence-constructor"/>
            but not both. The effect of the element in both cases is obtained by evaluating the
            <code>select</code> expression if present or the contained sequence constructor otherwise;
            if neither is present, the value is an empty sequence.</p><p>The effect of <elcode>xsl:next-iteration</elcode> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <elcode>xsl:break</elcode> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <elcode>xsl:iterate</elcode> element.</p><p>The instructions <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode>
               are allowed only as descendants of an <elcode>xsl:iterate</elcode> instruction, and
               only in a <termref def="dt-tail-position">tail position</termref> within the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:iterate</elcode> instruction. </p><p>
               <termdef id="dt-tail-position" term="tail position">An <termref def="dt-instruction">instruction</termref>
                  <var>J</var> is in a <term>tail position</term> within a <termref def="dt-sequence-constructor">sequence constructor</termref>
                  <var>SC</var> if it satisfies one of the following conditions:</termdef></p><ulist><item><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <elcode>xsl:fallback</elcode> instructions.</p></item><item><p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:if</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p></item><item><p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode> branch of an
                        <elcode>xsl:choose</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p></item><item><p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:try</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var> (that
                     is, it is immediately followed by an <elcode>xsl:catch</elcode> element,
                     ignoring any <elcode>xsl:fallback</elcode> elements).</p></item><item><p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:catch</elcode> element within an <elcode>xsl:try</elcode>
                     instruction that is itself in a <termref def="dt-tail-position">tail
                        position</termref> within <var>SC</var>.</p></item></ulist><p>
               <error spec="XT" type="static" class="SE" code="3120"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode> element
                     appears other than in a <termref def="dt-tail-position">tail position</termref>
                     within the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> forming the body of an <elcode>xsl:iterate</elcode>
                     instruction.</p></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="3130"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>name</code> attribute of an <elcode>xsl:with-param</elcode> child of
                     an <elcode>xsl:next-iteration</elcode> element does not match the
                        <code>name</code> attribute of an <elcode>xsl:param</elcode> child of the
                        <phrase diff="add" at="F">innermost</phrase> containing
                        <elcode>xsl:iterate</elcode> instruction.</p></error>
            </p><p>Parameter names in <elcode>xsl:with-param</elcode> must be unique: <errorref spec="XT" class="SE" code="0670"/>.</p><p>The result of the <elcode>xsl:iterate</elcode> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, followed by the
               sequence that results from evaluating the <elcode>xsl:break</elcode> or
                  <elcode>xsl:on-completion</elcode> element if any.</p><p>Any <elcode>xsl:param</elcode> element that appears as a child of
                  <elcode>xsl:iterate</elcode> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <specref ref="variable-values"/>. The dynamic context
               for evaluating the initial value of an <elcode>xsl:param</elcode> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <elcode>xsl:iterate</elcode> instruction (the context item is thus
                  <emph>not</emph> the first item in the input sequence).</p><p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p><ulist diff="chg" at="F"><item><p>If an <elcode>xsl:next-iteration</elcode> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <elcode>xsl:with-param</elcode> children of that instruction; in the
                     absence of an <elcode>xsl:with-param</elcode> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p></item><item><p>If an <elcode>xsl:break</elcode> instruction is evaluated, no further items in
                     the input sequence are processed.</p></item><item><p>If neither an <elcode>xsl:next-iteration</elcode> nor an
                        <elcode>xsl:break</elcode> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p></item></ulist><p>The <elcode>xsl:next-iteration</elcode> instruction contributes nothing to the result
               sequence (technically, it returns an empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <specref ref="with-param"/>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <elcode>xsl:on-completion</elcode> element if any.</p><p>The <elcode>xsl:break</elcode> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The
               <phrase diff="add" at="G"><code>select</code> expression or </phrase>
               contained sequence constructor is evaluated using the same context item, position,
               and size as the <elcode>xsl:break</elcode> instruction itself, and the result is
               appended to the result of the <elcode>xsl:iterate</elcode> instruction as a
               whole.</p><p>If neither an <elcode>xsl:next-iteration</elcode> nor an <elcode>xsl:break</elcode>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p><p>The optional <elcode>xsl:on-completion</elcode> element (which is not technically an
                  <termref def="dt-instruction">instruction</termref> and is not technically part of
               the <termref def="dt-sequence-constructor"/>) is
               evaluated when the input sequence is exhausted. It is not evaluated if the evaluation
               is terminated using <elcode>xsl:break</elcode>. During evaluation of this sequence
               constructor the context item, position, and size are <termref def="dt-absent">absent</termref> (that is, any
               reference to these values is an error). However, the values of the parameters to
                  <elcode>xsl:iterate</elcode> are available, and take the values supplied by the
                  <elcode>xsl:next-iteration</elcode> instruction evaluated while processing the
               last item in the sequence.</p><p diff="add" at="D">If the input sequence is empty, then the result of the
                  <elcode>xsl:iterate</elcode> instruction is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:on-completion</elcode> element, using the initial values of the
                  <elcode>xsl:param</elcode> elements. If there is no
                  <elcode>xsl:on-completion</elcode> element, the result is an empty sequence.</p><note><p>Conceptually, <elcode>xsl:iterate</elcode> behaves like a tail-recursive function.
                  The <elcode>xsl:next-iteration</elcode> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <elcode>xsl:iterate</elcode> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <elcode>xsl:iterate</elcode> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <elcode>xsl:stream</elcode>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire
                  document tree in memory.</p></note><p>The examples below use <elcode>xsl:iterate</elcode> in conjunction with the
                  <elcode>xsl:stream</elcode> instruction. This is not the only way of using
                  <elcode>xsl:iterate</elcode>, but it illustrates the way in which the two features
               can be combined to achieve streaming of a large input document.</p><example><head>Using <elcode>xsl:iterate</elcode> to Compute Cumulative Totals</head><p>Suppose that the input XML document has this structure</p><eg xml:space="preserve">&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;</eg><p>and that the requirement is to transform this to:</p><eg xml:space="preserve">&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;</eg><p>This can be achieved using the following code, which is designed to process the
                  transaction file using streaming:</p><eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{$newBalance}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg><p>The following example modifies this by only outputting the information for the
                  first day's transactions:</p><eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="'transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg><p>The following code outputs the balance only at the end of each day, together with
                  the final balance:</p><eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg><p>If the sequence of transactions is empty, this code outputs a single element:
                     <code>&lt;balance date="" value="0.00"/&gt;</code>.</p></example><example><head>Collecting Multiple Values in a Single Pass</head><p>Problem: Given a sequence of <code>employee</code> elements, find the employees
                  having the highest and lowest salary, while processing each employee only
                  once.</p><p>Solution:</p><eg xml:space="preserve">&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="employees/employee"&gt;
    &lt;xsl:param name="highest" as="element(employee)*"/&gt;
    &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
    &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                  select="empty($highest[@salary ge current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                  select="exists($highest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                  select="empty($lowest[@salary le current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                  select="exists($lowest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                  select="if ($is-new-highest) then .
                          else if ($is-equal-highest) then ($highest, .)
                          else $highest"/&gt;
    &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                  select="if ($is-new-lowest) then .
                          else if ($is-equal-lowest) then ($lowest, .)
                          else $lowest"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
      &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;highest-paid-employees&gt;
        &lt;xsl:value-of select="$highest/name"/&gt;
      &lt;/highest-paid-employees&gt;
      &lt;lowest-paid-employees&gt;
        &lt;xsl:value-of select="$lowest/name"/&gt;
      &lt;/lowest-paid-employees&gt;  
    &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:stream&gt;</eg><p>If the input sequence is empty, this code outputs an empty
                     <code>highest-paid-employees</code> element and an empty
                     <code>lowest-paid-employees</code> element.</p></example><example diff="add" at="E"><head>Processing the Last Item in a Sequence Specially</head><p>When streaming, some limited look-ahead is needed to determine whether the item
                  being processed is the last in a sequence. The <xfunction>last</xfunction>
                  function cannot be used in <termref def="dt-guaranteed-streamable"/> code. The <elcode>xsl:iterate</elcode>
                  instruction provides a solution to this problem.</p><p>Problem: render the last paragraph in a section in some special way, for example
                  by using bold face. (The actual rendition is achieved by processing the paragraph
                  with mode <code>last-para</code>.)</p><p>The solution uses <elcode>xsl:iterate</elcode> to maintain a one-element lookahead
                  by explicit coding:</p><eg xml:space="preserve">&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="."/&gt;
     &lt;/xsl:next-iteration&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;</eg></example></div2></div1><div1 id="conditionals"><head>Conditional Processing</head><p>There are two instructions in XSLT that support conditional processing:
               <elcode>xsl:if</elcode> and <elcode>xsl:choose</elcode>. The <elcode>xsl:if</elcode>
            instruction provides simple if-then conditionality; the <elcode>xsl:choose</elcode>
            instruction supports selection of one choice when there are several possibilities.</p><p diff="add" at="B">XSLT 3.0 also supports <elcode>xsl:try</elcode> and
               <elcode>xsl:catch</elcode> which define conditional processing to handle <termref def="dt-dynamic-error">dynamic errors</termref>.</p><div2 id="xsl-if"><head>Conditional Processing with <elcode>xsl:if</elcode>
            </head><e:element-syntax name="if"><e:in-category name="instruction"/><e:attribute name="test" required="yes"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
               which specifies an <termref def="dt-expression">expression</termref>. The content is
               a <termref def="dt-sequence-constructor"/>.</p><p>The result of the <elcode>xsl:if</elcode> instruction depends on the <xtermref spec="XP30" ref="dt-ebv">effective boolean value</xtermref> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <bibref ref="xpath-30"/>: they are the same as
               the rules used for XPath conditional expressions.</p><p>If the effective boolean value of the <termref def="dt-expression">expression</termref> is true, then the <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated (see <specref ref="sequence-constructors"/>), and the resulting <phrase diff="del" at="K">node</phrase> sequence is returned as the
               result of the <elcode>xsl:if</elcode> instruction; otherwise, the sequence
               constructor is not evaluated, and the empty sequence is returned.</p><example><head>Using <elcode>xsl:if</elcode>
               </head><p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p><eg xml:space="preserve">&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</eg><p>The following colors every other table row yellow:</p><eg xml:space="preserve">&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</eg></example></div2><div2 id="xsl-choose"><head>Conditional Processing with <elcode>xsl:choose</elcode>
            </head><e:element-syntax name="choose"><e:in-category name="instruction"/><e:sequence><e:element repeat="one-or-more" name="when"/><e:element repeat="zero-or-one" name="otherwise"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="when"><e:attribute name="test" required="yes"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="choose"/></e:allowed-parents></e:element-syntax><e:element-syntax name="otherwise"><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="choose"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:choose</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
                  <elcode>xsl:when</elcode> element has a single attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref>. The content of the
                  <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements is a
                  <termref def="dt-sequence-constructor"/>.</p><p>When an <elcode>xsl:choose</elcode> element is processed, each of the
                  <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
               elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
               satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
               described below.</p><p>An <elcode>xsl:when</elcode> element is satisfied if the <xtermref spec="XP30" ref="dt-ebv">effective boolean value</xtermref> of the <termref def="dt-expression">expression</termref> in its <code>test</code> attribute is
                  <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <bibref ref="xpath-30"/>: they are the same as the rules used
               for XPath conditional expressions.</p><p>The content of the first, and only the first, <elcode>xsl:when</elcode> element that
               is satisfied is evaluated, and the resulting sequence is returned as the result of
               the <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
               and the resulting sequence is returned as the result of the
                  <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
               the <elcode>xsl:choose</elcode> instruction is an empty sequence.</p><p>Only the sequence constructor of the selected <elcode>xsl:when</elcode> or
                  <elcode>xsl:otherwise</elcode> instruction is evaluated. The <code>test</code>
               expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
               evaluated.</p><example><head>Using <elcode>xsl:choose</elcode>
               </head><p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p><eg xml:space="preserve">&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</eg></example></div2><div2 diff="add" at="B" id="try-catch"><head>Try/Catch</head><p diff="add" at="C">The <elcode>xsl:try</elcode> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <elcode>xsl:catch</elcode> element.</p><e:element-syntax name="try" diff="chg" at="F"><e:in-category name="instruction"/><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:sequence><e:model name="sequence-constructor"/><e:element name="catch"/><e:choice repeat="zero-or-more"><e:element name="catch"/><e:element name="fallback"/></e:choice></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><note><p>Because a sequence constructor may contain an <elcode>xsl:fallback</elcode>
                  element, the effect of this content model is that an <elcode>xsl:fallback</elcode>
                  instruction may appear as a child of <elcode>xsl:try</elcode> in any position.</p></note><e:element-syntax name="catch"><e:attribute name="errors" required="no"><e:data-type name="tokens"/></e:attribute><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="try"/></e:allowed-parents></e:element-syntax><p>An <elcode>xsl:try</elcode> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and returns the
               result of that evaluation if it succeeds without error. If a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the evaluation, the
               processor evaluates the first <elcode>xsl:catch</elcode> child element applicable to
               the error, and returns that result instead.</p><p>If the <elcode>xsl:try</elcode> element has a <code>select</code> attribute, then it
               <rfc2119>must</rfc2119> have no children other than <elcode>xsl:catch</elcode> and
                  <elcode>xsl:fallback</elcode>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <elcode>xsl:try</elcode> is an empty sequence (no dynamic error can
               occur in this case).</p><p>
               <error spec="XT" type="static" class="SE" code="3140"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:try</elcode> element is
                     present and the element has children other than <elcode>xsl:catch</elcode> and
                        <elcode>xsl:fallback</elcode> elements.</p></error>
            </p><p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:try</elcode> element
               are ignored by an XSLT 3.0 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <termref def="dt-forwards-compatible-behavior"/>.</p><p>The <elcode>xsl:catch</elcode> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <elcode>xsl:catch</elcode> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest" xlink:type="simple">NameTests</xnt>; an <elcode>xsl:catch</elcode> element
               catches an error condition if this list includes a <code>NameTest</code> that matches
               the error code associated with that error condition.</p><note><p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <termref def="dt-standard-error-namespace">standard
                     error namespace</termref>, and may therefore be caught using an
                     <elcode>xsl:catch</elcode> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementors,
                  and errors raised by an explicit call of the <xfunction>error</xfunction> function
                  or by use of the <elcode>xsl:message</elcode> 
                  <phrase diff="add" at="L">or <elcode>xsl:assert</elcode></phrase> instruction, <rfc2119>may</rfc2119>
                  use error codes in other namespaces.</p></note><p>If more than one <elcode>xsl:catch</elcode> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <elcode>xsl:catch</elcode> matches the error, then the error is not caught (that
               is, evaluation of the <elcode>xsl:try</elcode> element fails with the dynamic
               error).</p><p>An <elcode>xsl:catch</elcode> element may have either a <code>select</code>
               attribute, or a contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p><p>
               <error spec="XT" type="static" class="SE" code="3150"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:catch</elcode> element is
                     present unless the element has empty content.</p></error>
            </p><p>The result of evaluating the <elcode>xsl:catch</elcode> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               an empty sequence. This result is delivered as the result of the <code>xsl:try</code>
               instruction.</p><p>If a dynamic error occurs during the evaluation of <elcode>xsl:catch</elcode>, it
               causes the containing <elcode>xsl:try</elcode> to fail with this error. The error is
               not caught by other sibling <elcode>xsl:catch</elcode> elements within the same
                  <elcode>xsl:try</elcode> instruction, but it may be caught by an
                  <elcode>xsl:try</elcode> instruction at an outer level, or by an
                  <elcode>xsl:try</elcode> instruction nested within the
               <elcode>xsl:catch</elcode>. </p><p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <elcode>xsl:catch</elcode> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <code>xsl:catch</code> element. These variables are all in
               the <termref def="dt-standard-error-namespace">standard error namespace</termref>,
               and they are initialized as described in the following table:</p><table border="1" cellpadding="5" summary="variables containing information for use within try/catch"><thead><tr><th align="left" rowspan="1" colspan="1">Variable</th><th align="left" rowspan="1" colspan="1">Type</th><th align="left" rowspan="1" colspan="1">Value</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">err:code</td><td valign="top" rowspan="1" colspan="1">xs:QName</td><td valign="top" rowspan="1" colspan="1">The error code</td></tr><tr><td valign="top" rowspan="1" colspan="1">err:description</td><td valign="top" rowspan="1" colspan="1">xs:string<phrase diff="add" at="G">?</phrase></td><td valign="top" rowspan="1" colspan="1">A description of the error condition; <phrase diff="chg" at="G">an empty sequence
                     if no description is available (for example, if the <xfunction>error</xfunction>
                     function was called with one argument)</phrase>.</td></tr><tr><td valign="top" rowspan="1" colspan="1">err:value</td><td valign="top" rowspan="1" colspan="1">item()*</td><td valign="top" rowspan="1" colspan="1">Value associated with the error. For an error raised by
                        calling the <xfunction>error</xfunction> function, this is the value of the
                        third argument (if supplied). For an error raised by evaluating
                        <elcode>xsl:message</elcode> with <code>terminate="yes"</code>, 
                        <phrase diff="add" at="L">or a failing <elcode>xsl:assert</elcode></phrase>, this is
                        the document node at the root of the tree containing the XML message
                        body.</td></tr><tr><td valign="top" rowspan="1" colspan="1">err:module</td><td valign="top" rowspan="1" colspan="1">xs:string?</td><td valign="top" rowspan="1" colspan="1">The URI (or system ID) of the stylesheet module containing the
                        instruction where the error occurred; an empty sequence if the information
                        is not available.</td></tr><tr><td valign="top" rowspan="1" colspan="1">err:line-number</td><td valign="top" rowspan="1" colspan="1">xs:integer?</td><td valign="top" rowspan="1" colspan="1">The line number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td></tr><tr><td valign="top" rowspan="1" colspan="1">err:column-number</td><td valign="top" rowspan="1" colspan="1">xs:integer?</td><td valign="top" rowspan="1" colspan="1">The column number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td></tr></tbody></table><p>Variables declared within the sequence constructor of the <elcode>xsl:try</elcode>
               element (and not within an <elcode>xsl:catch</elcode>) are not visible within the
                  <elcode>xsl:catch</elcode> element.</p><note><p>Within an <elcode>xsl:catch</elcode> it is possible to re-throw the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p></note><p>The following additional rules apply to the catching of errors:</p><olist><item><p>All dynamic errors occurring during the evaluation of the
                        <elcode>xsl:try</elcode> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <elcode>xsl:catch</elcode> elements). </p><ulist><item><p>This includes errors occurring in functions or templates invoked in the
                           course of this evaluation, unless already caught by a nested
                              <elcode>xsl:try</elcode>.</p></item><item><p>It also includes errors caused by calling the
                              <xfunction>error</xfunction> function, or the
                           <elcode>xsl:message</elcode> instruction with
                           <code>terminate="yes"</code>, or the 
                           <phrase diff="add" at="L"> <elcode>xsl:assert</elcode> instruction</phrase>. </p></item><item><p>It does not include errors that occur while evaluating references to
                           variables whose declaration and initialization is outside the
                              <elcode>xsl:try</elcode>.</p></item></ulist></item><item><p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     right of the processor to recover, or not recover, from errors classified as
                        <termref def="dt-recoverable-error">recoverable dynamic errors</termref>. An
                        <elcode>xsl:catch</elcode> element will be activated only if the processor
                     chooses to signal the error rather than taking the defined recovery action.</p></item><item><p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     obligation of the processor to signal certain errors as static errors, or its
                     right to choose whether to signal some errors (such as <termref def="dt-type-error">type errors</termref>) statically
                     or dynamically. Static errors are never caught.</p></item><item><p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <elcode>xsl:try</elcode> instruction. This is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></item><item><p>If the sequence constructor or <code>select</code> expression of the
                        <elcode>xsl:try</elcode> causes execution of
                     <elcode>xsl:result-document</elcode>, <elcode>xsl:message</elcode>, <phrase diff="add" at="L">or <elcode>xsl:assert</elcode></phrase>
                     instructions and fails with a dynamic error that is caught, it is
                     implementation-dependent whether these instructions have any externally visible
                     effect. The processor is <rfc2119>not required</rfc2119> to do a "rollback" of
                     any changes made by these instructions. The same applies to any side effects
                     caused by extension functions or extension instructions.</p></item><item><p diff="del" at="M">If the <elcode>xsl:try</elcode> element appears in a context where it is
                     required to deliver a value of a specified type (for example, if it appears as
                     the body of a stylesheet function), then any error that occurs because it
                     delivers a value of the wrong type, or an error that occurs during conversion
                     to the required type (for example, during atomization), is treated as occurring
                     within the scope of the <elcode>xsl:try</elcode> instruction.</p><p diff="add" at="M">A serialization error that occurs during the serialization of a <termref def="dt-final-result-tree"/> 
                     produced using <elcode>xsl:result-document</elcode> is treated as a dynamic error 
                     in the evaluation of the <elcode>xsl:result-document</elcode> instruction, and may be caught
                     by a containing <elcode>xsl:try</elcode> instruction. A serialization error that occurs
                     while serializing the implicit <termref def="dt-final-result-tree"/> returned by the
                     <termref def="dt-initial-template"/> is treated as occurring after the transformation has
                     finished, and cannot be caught.
                  </p></item><item><p diff="del" at="M">When an instruction <var>J</var> computes a value that will inevitably cause
                     some outer-level instruction <var>O</var> to fail with a dynamic error, then
                     the failure <rfc2119>may</rfc2119> be treated as occurring in <var>J</var>, in
                     which case it will be caught by an <elcode>xsl:try</elcode> instruction whose
                     scope includes <var>J</var> but does not include <var>O</var>. For example,
                     creating an element may fail because the element is not allowed by the content
                     model of a containing element; although the specification describes this as a
                     failure associated with the construction of the containing element, a processor
                     is allowed to detect the error as soon as it becomes inevitable.</p><note diff="del" at="M"><p>The effect of this rule is that when stylesheet output is streamed to a
                        schema validator or to a serializer, errors detected by the validation or
                        serialization process may be treated if they occurred in the instruction
                        that generated the offending output; however, stylesheet authors cannot rely
                        on this. In fact, where serialization is applied to a <termref def="dt-final-result-tree"/>, there is no guarantee that it will be
                        possible to catch the error at all, since serialization is outside the scope
                        of the transformation process proper.</p></note><p diff="add" at="M">A validation error is treated as occurring in the instruction
                  that requested validation. For example, if the stylesheet is producing XHTML output and
                  requests validation of the entire result document by means of the attribute <code>validation="strict"</code>
                  on the instruction that creates the outermost <code>html</code> element, then a validation failure
                  can be caught only at that level. Although the validation error might be detected, for example, while writing
                  a <code>p</code> element at a location where no <code>p</code> element is allowed, it is not treated as
                  an error in the instruction that writes the <code>p</code> element and cannot be caught at that level.</p></item><item><p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     "early exit", rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p></item><item><p>A failure occurring while evaluating the match pattern of a template rule, if
                     not treated as a recoverable error, is treated as occurring during the
                     evaluation of the calling <elcode>xsl:apply-templates</elcode> instruction (or
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> if
                     appropriate).</p></item><item><p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to
                     the try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p></item></olist><note><p>If an error occurs while evaluating an instruction within
                  <elcode>xsl:try</elcode>, then no instruction within the <elcode>xsl:try</elcode>
                  has any effect on the result returned by the <elcode>xsl:try</elcode> instruction.
                  This means that if a processor is streaming the output to a serializer, it needs
                  to adopt a strategy such as buffering the output in memory so that nothing is
                  written until successful completion of the <elcode>xsl:try</elcode> instruction,
                  or checkpointing the output so it can be rolled back when an error occurs.</p></note><note diff="add" at="M"><p>Use of try/catch may affect the ability of a processor to perform streamed evaluation
               of a stylesheet. If the sequence constructor contained within <elcode>xsl:try</elcode>
               creates a sequence of ten elements, and these form part of a final result tree,
               then if a failure occurs while writing the tenth element,
               the work of creating the previous nine must be "undone". In effect this means that either
               the processor must delay sending the new elements to the serializer until it is assured of
               success, or the serializer must provide a mechanism to roll back elements already written.</p></note><div3 id="try-catch-examples"><head>Try/Catch Examples</head><example><head>Catching a Divide-by-Zero Error</head><p>The following example divides an employee's salary by the number of years they
                     have served, catching the divide-by-zero error if the latter is zero.</p><eg xml:space="preserve">&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FAOR0001" select="()"/&gt;
&lt;/xsl:try&gt;</eg></example><example><head>Catching an Error during Result-tree Validation</head><p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p><eg xml:space="preserve">&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</eg><p>The reason that the result tree is constructed in a variable in this example is so
                  that the unvalidated tree is available to be used within the
                     <elcode>xsl:catch</elcode> element. An alternative approach would be to repeat
                  the logic for constructing the tree:</p><eg xml:space="preserve">&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;</eg></example></div3></div2></div1><div1 id="variables-and-parameters"><head>Variables and Parameters</head><p>
            <termdef id="dt-variable-binding-element" term="variable-binding element">The two
               elements <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are referred to
               as <term>variable-binding elements</term>
            </termdef>.</p><p>
            <termdef id="dt-variable" term="variable">The <elcode>xsl:variable</elcode> element
               declares a <term>variable</term>, which may be a <termref def="dt-global-variable">global variable</termref> or a <termref def="dt-local-variable">local
                  variable</termref>.</termdef>
         </p><p>
            <termdef id="dt-parameter" term="parameter">The <elcode>xsl:param</elcode> element
               declares a <term>parameter</term>, which may be a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, a <termref def="dt-template-parameter">template parameter</termref>, a <termref def="dt-function-parameter">function parameter</termref><phrase diff="add" at="D">, or an <elcode>xsl:iterate</elcode> parameter</phrase>. A parameter is a
                  <termref def="dt-variable">variable</termref> with the additional property that
               its value can be set by the caller.</termdef>
         </p><p>
            <termdef id="dt-value" term="value">A variable is a binding between a name and a value.
               The <term>value</term> of a variable is any sequence (of nodes, atomic values,
                  <phrase diff="add" at="C">and/or function items</phrase>), as defined in <bibref ref="xpath-datamodel-30"/>.</termdef>
         </p><div2 id="variables"><head>Variables</head><e:element-syntax name="variable"><e:in-category name="declaration"/><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="static"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="visibility"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/><e:parent name="override"/><e:parent name="function"/><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:variable</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the variable. The value of
               the <code>name</code> attribute is an 
               <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which
               is expanded as described in <specref ref="qname"/>.</p><p>The <elcode>xsl:variable</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               variable. The value of the <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-30"/>.</p><p>
               <termdef id="dt-supplied-value" term="supplied value">The value of the variable is
                  computed using the <termref def="dt-expression">expression</termref> given in the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, as described in
                     <specref ref="variable-values"/>. This value is referred to as the
                     <term>supplied value</term> of the variable.</termdef> If the
                  <elcode>xsl:variable</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p><p>If the <code>as</code> attribute is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is converted to
               the required type, using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>.</p><p>
               <error spec="XT" type="type" class="TE" code="0570"><p>It is a <termref def="dt-type-error">type error</termref> if the <termref def="dt-supplied-value">supplied value</termref> of a variable cannot be
                     converted to the required type.</p></error>
            </p><p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value">supplied value</termref> of the variable is used directly, and no conversion
                  takes place.</p><p diff="add" at="M">For the effect of the <code>static</code> attribute, see
            <specref ref="static-params"/>.</p><p diff="add" at="I">The <code>visibility</code> attribute <rfc2119>must not</rfc2119>
            be specified for a local variable: that is, it is allowed only when the parent element
            is <code>xsl:stylesheet</code>, <code>xsl:transform</code>, or <code>xsl:override</code>.</p><p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
               <code>abstract</code> then the <code>select</code> attribute <rfc2119>must</rfc2119> be absent and
               the contained <termref def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref def="dt-supplied-value">supplied value</termref>, and therefore the constraint that the supplied value is consistent
               with the required type does not apply.</p></div2><div2 id="parameters"><head>Parameters</head><e:element-syntax name="param"><e:in-category name="declaration"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="required"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="tunnel"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="static"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="visibility"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/><e:parent name="override"/><e:parent name="function"/><e:parent name="template"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:param</elcode> element may be used:</p><ulist><item><p>as a child of <elcode>xsl:stylesheet</elcode>, to define a parameter to the
                     transformation</p></item><item><p>as a child of <elcode>xsl:template</elcode> to define a parameter to a
                     template, which may be supplied when the template is invoked using
                        <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>;</p></item><item><p>as a child of <elcode>xsl:function</elcode> to define a parameter to a
                     stylesheet function, which may be supplied when the function is called from an
                     XPath <termref def="dt-expression">expression</termref>
                  </p></item><item diff="add" at="A"><p>as a child of <elcode>xsl:iterate</elcode> to define a parameter that can vary
                     from one iteration to the next.</p></item></ulist><p>The <elcode>xsl:param</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the parameter. The value of
               the <code>name</code> attribute is an 
               <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which
               is expanded as described in <specref ref="qname"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0580"><p>It is a <termref def="dt-static-error">static error</termref> if the values of
                     the <code>name</code> attribute of two <phrase diff="chg" at="A">sibling
                           <elcode>xsl:param</elcode> elements represent the same <termref def="dt-expanded-qname">expanded QName</termref></phrase>.</p></error>
            </p><note><p>For rules concerning stylesheet parameters, see <specref ref="global-variables"/>.
                  Local variables may <termref def="dt-shadows">shadow</termref> template parameters
                  and function parameters: see <specref ref="scope-of-variables"/>.</p></note><p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is the
               value supplied by the caller. If no value was supplied by the caller, and if the
               parameter is not mandatory, then the supplied value is computed using the <termref def="dt-expression">expression</termref> given in the <code>select</code>
               attribute or the contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>, as described in <specref ref="variable-values"/>. If the
                  <elcode>xsl:param</elcode> element has a <code>select</code> attribute, then the
               sequence constructor <rfc2119>must</rfc2119> be empty.</p><note><p>This specification does not dictate whether and when the default value of a
                  parameter is evaluated. For example, if the default is specified as
                     <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it
                  is not specified whether a distinct <code>foo</code> element node will be created
                  on each invocation of the template, or whether the same <code>foo</code> element
                  node will be used for each invocation. However, it is permissible for the default
                  value to depend on the values of other parameters, or on the evaluation context,
                  in which case the default must effectively be evaluated on each invocation.</p></note><p>The <elcode>xsl:param</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               parameter. The value of the <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-30"/>.</p><p>If the <code>as</code> attribute is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the parameter is converted to
               the required type, using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>.</p><p>
               <error spec="XT" type="type" class="TE" code="0590"><p>It is a <termref def="dt-type-error">type error</termref> if the conversion of
                     the <termref def="dt-supplied-value">supplied value</termref> of a parameter to
                     its required type fails.</p></error>
            </p><p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value">supplied value</termref> of the parameter is used directly, and no conversion
               takes place.</p><p>The optional <code>required</code> attribute may be used to indicate that a parameter
               is mandatory. This attribute may be specified for <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> and for <termref def="dt-template-parameter">template parameters</termref>; it <rfc2119>must
                  not</rfc2119> be specified for <termref def="dt-function-parameter">function
                  parameters</termref>, which are always mandatory, <phrase diff="add" at="A"> or
                  for parameters to <elcode>xsl:iterate</elcode>, which are always initialized to a
                  default value</phrase>. A parameter is mandatory if it is a <termref def="dt-function-parameter">function parameter</termref> or if the
                  <code>required</code> attribute is present and has the value <code>yes</code>.
               Otherwise, the parameter is optional. If the parameter is mandatory, then the
                  <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> be empty and
                  <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p><p>
               <error spec="XT" type="type" class="TE" code="0600"><p>If a default value is given explicitly, that is, if there is either a
                        <code>select</code> attribute or a non-empty <termref def="dt-sequence-constructor">sequence constructor</termref>, then it is a
                        <termref def="dt-type-error">type error</termref> if the default value
                     cannot be converted to the required type, using the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p></error>
            </p><p>If an optional parameter has no <code>select</code> attribute and has an empty
                  <termref def="dt-sequence-constructor"/>, and if
               there is no <code>as</code> attribute, then the default value of the parameter is a
               zero length string.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0610"><p>If an optional parameter has no <code>select</code> attribute and has an empty
                        <termref def="dt-sequence-constructor"/>, and
                     if there is an <code>as</code> attribute, then the default value of the
                     parameter is an empty sequence. If the empty sequence is not a valid instance
                     of the required type defined in the <code>as</code> attribute, then the
                     parameter is treated as a required parameter, which means that it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                     caller supplies no value for the parameter.</p></error>
            </p><p diff="add" at="M">For the effect of the <code>static</code> attribute, see
               <specref ref="static-params"/>.</p><p diff="add" at="I">The <code>visibility</code> attribute <rfc2119>must not</rfc2119>
               be specified for a local parameter: that is, it is allowed only when the parent element
               is <code>xsl:stylesheet</code>, <code>xsl:transform</code>, or <code>xsl:override</code>.</p><p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
               <code>abstract</code> then the <code>select</code> attribute <rfc2119>must</rfc2119> be absent and
               the contained <termref def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref def="dt-supplied-value">supplied value</termref>, and therefore the constraint that the supplied value is consistent
               with the required type does not apply.</p><note><p>The effect of these rules is that specifying <code>&lt;xsl:param name="p"
                     as="xs:date" select="2"/&gt;</code> is an error, but if the default value of
                  the parameter is never used, then the processor has discretion whether or not to
                  report the error. By contrast, <code>&lt;xsl:param name="p"
                     as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had been
                  specified: the empty sequence is not a valid instance of <code>xs:date</code>, so
                  in effect there is no default value and the parameter is therefore treated as
                  being mandatory.</p></note><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>; the value <code>yes</code> may be specified only for <termref def="dt-template-parameter">template parameters</termref>. Tunnel parameters are
               described in <specref ref="tunnel-params"/>
            </p></div2><div2 id="variable-values"><head>Values of Variables and Parameters</head><p>A <termref def="dt-variable-binding-element">variable-binding element</termref> may
               specify the <termref def="dt-supplied-value">supplied value</termref> of a <termref def="dt-variable">variable</termref>
               <phrase diff="add" at="D">or the default value of a</phrase>
               <termref def="dt-parameter">parameter</termref> in four different ways.</p><ulist><item><p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has a <code>select</code> attribute, then the value of the
                     attribute <rfc2119>must</rfc2119> be an <termref def="dt-expression">expression</termref> and the <termref def="dt-supplied-value">supplied
                        value</termref> of the variable is the value that results from evaluating
                     the expression. In this case, the content of the variable-binding element
                        <rfc2119>must</rfc2119> be empty.</p></item><item><p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has empty content and has neither a <code>select</code>
                     attribute nor an <code>as</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is a
                     zero-length string. Thus</p><eg xml:space="preserve">&lt;xsl:variable name="x"/&gt;</eg><p>is equivalent to</p><eg xml:space="preserve">&lt;xsl:variable name="x" select="''"/&gt;</eg></item><item><p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has no <code>select</code> attribute and has non-empty
                     content (that is, the variable-binding element has one or more child nodes),
                     and has no <code>as</code> attribute, then the content of the variable-binding
                     element specifies the <termref def="dt-supplied-value">supplied
                     value</termref>. The content of the variable-binding element is a <termref def="dt-sequence-constructor">sequence constructor</termref>; a new document
                     is constructed with a document node having as its children the sequence of
                     nodes that results from evaluating the sequence constructor and then applying
                     the rules given in <specref ref="constructing-complex-content"/>. The value of
                     the variable is then a singleton sequence containing this document node. For
                     further information, see <specref ref="temporary-trees"/>. </p></item><item><p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has an <code>as</code> attribute but no
                        <code>select</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> is the sequence that results from evaluating the
                     (possibly empty) <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the variable-binding element (see
                        <specref ref="sequence-constructors"/>). </p></item></ulist><p>These combinations are summarized in the table below.</p><table border="1" cellpadding="5" summary="effect of different attribute combinations on xsl:variable"><col width="12%" span="1"/><col width="12%" span="1"/><col width="12%" span="1"/><col span="1"/><thead><tr><th align="left" rowspan="1" colspan="1">select attribute</th><th align="left" rowspan="1" colspan="1">as attribute</th><th align="left" rowspan="1" colspan="1">content</th><th align="left" rowspan="1" colspan="1">Effect</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">empty</td><td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute</td></tr><tr><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">empty</td><td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute, adjusted to the type required by the
                           <code>as</code> attribute</td></tr><tr><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">Static error</td></tr><tr><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">Static error</td></tr><tr><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">empty</td><td valign="top" rowspan="1" colspan="1">Value is a zero-length string</td></tr><tr><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">empty</td><td valign="top" rowspan="1" colspan="1">Value is an empty sequence, provided
                        the <code>as</code> attribute permits an empty sequence</td></tr><tr><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">Value is a document node whose content
                        is obtained by evaluating the sequence constructor</td></tr><tr><td valign="top" rowspan="1" colspan="1">absent</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">present</td><td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                        sequence constructor, adjusted to the type required by the <code>as</code>
                        attribute</td></tr></tbody></table><p>
               <error spec="XT" type="static" class="SE" code="0620"><p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-variable-binding-element">variable-binding element</termref> has a
                        <code>select</code> attribute and has non-empty content.</p></error>
            </p><example><head>Values of Variables</head><p>The value of the following variable is the sequence of integers (1, 2, 3):</p><eg xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</eg><p>The value of the following variable is an integer, assuming that the attribute
                     <code>@size</code> exists, and is annotated either as an integer, or as
                     <code>xs:untypedAtomic</code>:</p><eg xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</eg><p>The value of the following variable is a zero-length string:</p><eg xml:space="preserve">&lt;xsl:variable name="z"/&gt;</eg><p>The value of the following variable is a document node containing an empty element
                  as a child:</p><eg xml:space="preserve">&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</eg><p>The value of the following variable is a sequence of integers (2, 4, 6):</p><eg xml:space="preserve">&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</eg><p>The value of the following variable is a sequence of parentless attribute nodes:</p><eg xml:space="preserve">&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</eg><p>The value of the following variable is an empty sequence:</p><eg xml:space="preserve">&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</eg></example><p>The actual value of the variable depends on the <termref def="dt-supplied-value">supplied value</termref>, as described above, and the required type, which is
               determined by the value of the <code>as</code> attribute.</p><example><head>Pitfalls with Numeric Predicates</head><p>When a variable is used to select nodes by position, be careful not to do:</p><eg xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg><p>This will output the values of all the <code>td</code> elements, space-separated
                  (or <phrase diff="chg" at="D">with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase>, the value of the first <code>td</code>
                  element), because the variable <code>n</code> will be bound to a node, not a
                  number. Instead, do one of the following:</p><eg xml:space="preserve">&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg><p>or</p><eg xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</eg><p>or</p><eg xml:space="preserve">&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg></example></div2><div2 id="temporary-trees"><head>Creating Implicit Document Nodes</head><p>A document node is created implicitly when evaluating an
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                  <elcode>xsl:with-param</elcode> element that has non-empty content and that has no
                  <code>as</code> attribute. The value of the <termref def="dt-variable">variable</termref> is a single node, the document node of a <termref def="dt-temporary-tree">temporary tree</termref>. The content of the document node
               is formed from the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained within the variable-binding element, as
               described in <specref ref="constructing-complex-content"/>. </p><note><p>The construct:</p><eg xml:space="preserve">&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;</eg><p>can be regarded as a shorthand for:</p><eg xml:space="preserve">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;</eg></note><p>The base URI of the document node is taken from the base URI of the variable binding
               element in the stylesheet. (See <xspecref spec="DM30" ref="dm-base-uri"/> in <bibref ref="xpath-datamodel-30"/>)</p><p>No document-level validation takes place (which means, for example, that there is no
               checking that ID values are unique). However, type annotations on nodes within the
               new tree are copied unchanged.</p><note><p>The base URI of other nodes in the tree is determined by the rules for
                  constructing complex content. The effect of these rules is that the base URI of a
                  node in the temporary tree is determined as if all the nodes in the temporary tree
                  came from a single entity whose URI was the base URI of the <termref def="dt-variable-binding-element">variable-binding element</termref>. Thus, the
                  base URI of the document node will be equal to the base URI of the
                  variable-binding element, while an <code>xml:base</code> attribute within the
                  temporary tree will change the base URI for its parent element and that element's
                  descendants, just as it would within a document constructed by parsing.</p></note><p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p><p>A <termref def="dt-temporary-tree">temporary tree</termref> is available for
               processing in exactly the same way as any source document. For example, its nodes are
               accessible using path expressions, and they can be processed using instructions such
               as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>. Also, the
                  <function>key</function> and <xfunction>id</xfunction> functions can be used to
               find nodes within a temporary tree, <phrase diff="chg" at="D"> by supplying the
                  document node at the root of the tree as an argument to the function or by making
                  it the context node</phrase>.</p><example><head>Two-Phase Transformation</head><p>For example, the following stylesheet uses a temporary tree as the intermediate
                  result of a two-phase transformation, using different <termref def="dt-mode">modes</termref> for the two phases (see <specref ref="modes"/>). Typically,
                  the template rules in module <code>phase1.xsl</code> will be declared with
                     <code>mode="phase1"</code>, while those in module <code>phase2.xsl</code> will
                  be declared with <code>mode="phase2"</code>: </p><eg xml:space="preserve">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg></example><note><p>The algorithm for matching nodes against template rules is exactly the same
                  regardless which tree the nodes come from. If different template rules are to be
                  used when processing different trees, then unless nodes from different trees can
                  be distinguished by means of <termref def="dt-pattern">patterns</termref>, it is a
                  good idea to use <termref def="dt-mode">modes</termref> to ensure that each tree
                  is processed using the appropriate set of template rules.</p></note></div2><div2 id="global-variables"><head>Global Variables and Parameters</head><p>Both <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are allowed as
                  <termref def="dt-declaration">declaration</termref> elements: that is, they may
               appear as children of the <elcode>xsl:stylesheet</elcode> element.</p><p>
               <termdef id="dt-global-variable" term="global variable">A top-level <termref def="dt-variable-binding-element">variable-binding element</termref> declares a
                     <term>global variable</term> that is visible everywhere (except where it is
                     <termref def="dt-shadows">shadowed</termref> by another binding).</termdef>
            </p><p>
               <termdef id="dt-stylesheet-parameter" term="stylesheet parameter">A top-level
                     <elcode>xsl:param</elcode> element declares a <term>stylesheet
                  parameter</term>. A stylesheet parameter is a global variable with the additional
                  property that its value can be supplied by the caller when a transformation is
                  initiated.</termdef> As described in <specref ref="parameters"/>, a stylesheet
               parameter may be declared as being mandatory, or may have a default value specified
               for use when no value is supplied by the caller. The mechanism by which the caller
               supplies a value for a stylesheet parameter is <termref def="dt-implementation-defined">implementation-defined</termref>. An XSLT <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> provide such a mechanism.</p><imp-def-feature>The mechanism by which the caller supplies a value for a <termref def="dt-stylesheet-parameter"/> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature><p>It is an error if no value is supplied for a mandatory stylesheet parameter <errorref spec="XT" class="DE" code="0050"/>.</p><p>If a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding
               for a global variable of a particular name, then the binding with the highest
                  <termref def="dt-import-precedence">import precedence</termref> is used.</p><p>
               <error spec="XT" type="static" class="SE" code="0630"><p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding of a
                     global variable with the same name and same <termref def="dt-import-precedence">import precedence</termref>, unless it also contains another binding with
                     the same name and higher import precedence.</p></error>
            </p><p>For a global variable or the default value of a stylesheet parameter, the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref> specifying the variable value is evaluated with a
                  <termref def="dt-singleton-focus">singleton focus</termref> based on the root node
               of the tree containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>. An XPath error will be reported if
               the evaluation of a global variable or parameter references the context item, context
               position, or context size when no initial context item is supplied. The values of
               other components of the dynamic context are the initial values as defined in <specref ref="xpath-dynamic-context"/> and <specref ref="additional-dynamic-context"/>.</p><example><head>A Stylesheet Parameter</head><p>The following example declares a global parameter <code>para-font-size</code>,
                  which is referenced in an <termref def="dt-attribute-value-template">attribute
                     value template</termref>.</p><eg xml:space="preserve">&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</eg><p>The implementation must provide a mechanism allowing the user to supply a value
                  for the parameter <code>para-font-size</code> when invoking the stylesheet; the
                  value <code>12pt</code> acts as a default.</p></example></div2><div2 id="static-params" diff="add" at="M"><head>Static Variables and Parameters</head><p>Static variables and parameters are global variables and can be used in the same way as other
            global variables. In addition, they can be used in <code>[xsl:]use-when</code> expressions.</p><p>
               <termdef id="dt-static-variable" term="static variable">A <termref def="dt-top-level"/> <termref def="dt-variable-binding-element">variable-binding element</termref> having the
                  attribute <code>static="yes"</code> declares a
                  <term>static variable</term>: that is, a <termref def="dt-global-variable"/> whose value
                  is known during static analysis of the stylesheet.</termdef>
            </p><p>
               <termdef id="dt-static-parameter" term="static parameter">A <termref def="dt-static-variable"/>
                  declared using an <elcode>xsl:param</elcode> element is referred to as a
                  <term>static parameter</term>.</termdef>
            </p><p>The <code>static</code> attribute <rfc2119>must not</rfc2119> be present on an <elcode>xsl:variable</elcode>
            or <elcode>xsl:param</elcode> element unless it is a <termref def="dt-top-level"/> element.</p><p>When the attribute <code>static="yes"</code> is specified, the <elcode>xsl:variable</elcode>
            or <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> have empty content. In the case of 
               <elcode>xsl:variable</elcode> the <code>select</code> attribute must be present to define the value
               of the variable.</p><p>If the <code>select</code> attribute is present, then it is evaluated using the rules for
            <termref def="dt-static-expression">static expressions</termref>.</p></div2><div2 id="static-expression" diff="add" at="M"><head>Static Expressions</head><p><termdef id="dt-static-expression" term="static expression">A <term>static expression</term> is an XPath
            <termref def="dt-expression"/> whose value must be computed during static analysis
            of the stylesheet.</termdef></p><p>Static expressions appear in two contexts:</p><ulist><item><p>In <code>[xsl:]use-when</code> attributes (see <specref ref="conditional-inclusion"/>)</p></item><item><p>In the <code>select</code> attribute of <termref def="dt-static-variable"/> declarations 
                  (<elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> with <code>static="yes"</code>).</p></item></ulist><p>There are no syntactic constraints on the XPath expression that can be used as a
               <termref def="dt-static-expression"/>. However, there are severe constraints
               on the information provided in its evaluation context. These constraints are designed
               to ensure that the expression can be evaluated at the earliest possible stage of
               stylesheet processing, without any dependency on information contained in the
               stylesheet itself or in any source document.</p><p>Specifically, the components of the static and dynamic context are defined by the
               following two tables:</p><table border="1" cellpadding="5" width="100%" summary="static context for static expressions"><caption>Static Context Components for Static Expressions</caption><col align="left" width="30%" span="1"/><col align="left" span="1"/><thead><tr><th rowspan="1" colspan="1">Component</th><th rowspan="1" colspan="1">Value</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">XPath 1.0 compatibility mode</td><td rowspan="1" colspan="1">false</td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known namespaces</td><td rowspan="1" colspan="1">determined by the in-scope namespaces for the
                        containing element in the stylesheet</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default element/type namespace</td><td rowspan="1" colspan="1">determined by the
                        <code>xpath-default-namespace</code> attribute if present (see <specref ref="unprefixed-qnames"/>); otherwise the null namespace</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default function namespace</td><td rowspan="1" colspan="1">The <termref def="dt-standard-function-namespace">standard function namespace</termref>
                     </td></tr><tr><td valign="top" rowspan="1" colspan="1">In-scope schema types</td><td rowspan="1" colspan="1">The type definitions that would be available in the
                        absence of any <elcode>xsl:import-schema</elcode> declaration</td></tr><tr><td valign="top" rowspan="1" colspan="1">In-scope element declarations</td><td rowspan="1" colspan="1">None</td></tr><tr><td valign="top" rowspan="1" colspan="1">In-scope attribute declarations</td><td rowspan="1" colspan="1">None</td></tr><tr><td valign="top" rowspan="1" colspan="1">In-scope variables</td><td rowspan="1" colspan="1">The <termref def="dt-static-variable">static variables</termref> 
                        visible within the containing package whose declarations
                        occur prior to the element containing the static expression
                        in stylesheet tree order. Stylesheet tree order is the order that results
                        when all <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode>
                     declarations are replaced by the declarations in the imported or included
                     stylesheet module. A variable is not in scope within its own declaration.
                     If two static variables satisfying this rule have the same name and are both in scope,
                     the one that has highest <termref def="dt-import-precedence"/> is used (it is a consequence
                     of rules defined elsewhere that there cannot be more than one declaration with highest import
                     precedence). Note that the declaration with highest import precedence is not necessarily
                     the one that appears last in stylesheet tree order; note also that because forwards
                     references are not allowed, the declaration that is used will not necessarily be the one
                     with highest import precedence in the stylesheet as a whole.</td></tr><tr><td valign="top" rowspan="1" colspan="1">Context item static type</td><td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known function signatures</td><td rowspan="1" colspan="1">The <termref def="dt-core-function">core
                        functions</termref> defined in <bibref ref="xpath-functions-30"/>, together
                        with the functions <function>element-available</function>,
                        <function>function-available</function>,
                        <function>type-available</function>, and
                        <function>system-property</function> defined in this specification, plus
                        the set of extension functions that are present in the static context of
                        every XPath expression (other than a use-when expression) within the content
                        of the element that is the parent of the <code>use-when</code> attribute.
                        Note that <termref def="dt-stylesheet-function">stylesheet
                           functions</termref> are <emph>not</emph> included in the context, which
                        means that the function <function>function-available</function> will return
                        <code>false</code> in respect of such functions. The effect of this rule
                        is to ensure that <function>function-available</function> returns true in
                        respect of functions that can be called within the scope of the
                        <code>use-when</code> attribute. It also has the effect that these
                        extension functions will be recognized within the <code>use-when</code>
                        attribute itself; however, the fact that a function is available in this
                        sense gives no guarantee that a call on the function will succeed.</td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known collations</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default collation</td><td rowspan="1" colspan="1">The Unicode Codepoint Collation</td></tr><tr><td valign="top" rowspan="1" colspan="1">Static Base URI</td><td rowspan="1" colspan="1">The base URI of the containing element in the
                        stylesheet document <phrase diff="add" at="M">(see <xspecref spec="DM30" ref="dm-base-uri"/>)</phrase></td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known documents</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known collections</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known default collection type</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Statically known decimal formats</td><td rowspan="1" colspan="1">A single unnamed <termref def="dt-decimal-format">decimal format</termref> equivalent to the
                        decimal format that is created by an <elcode>xsl:decimal-format</elcode>
                        declaration with no attributes.</td></tr></tbody></table><p> </p><table border="1" cellpadding="5" width="100%" summary="dynamic context for static expressions"><caption>Dynamic Context Components for Static Expressions</caption><col align="left" width="30%" span="1"/><col align="left" span="1"/><thead><tr><th rowspan="1" colspan="1">Component</th><th rowspan="1" colspan="1">Value</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">Context item, position, and size</td><td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td></tr><tr><td valign="top" rowspan="1" colspan="1">Variable values</td><td rowspan="1" colspan="1">A value for every variable present in the in-scope variables. 
                        For <termref def="dt-static-parameter">static parameters</termref> where an external
                        value is supplied: the externally-supplied value of the parameter.
                     In all other cases: the value of the variable as defined in <specref ref="variable-values"/>.</td></tr><tr><td valign="top" rowspan="1" colspan="1">Named functions</td><td rowspan="1" colspan="1">The function implementation corresponding to each function signature in the
                     statically known function signatures</td></tr><tr><td valign="top" rowspan="1" colspan="1">Current dateTime</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Implicit timezone</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default language</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default calendar</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default place</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Available documents</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Available collections</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Default collection</td><td rowspan="1" colspan="1">Implementation-defined</td></tr><tr><td valign="top" rowspan="1" colspan="1">Environment variables</td><td rowspan="1" colspan="1">Implementation-defined</td></tr></tbody></table><p>Within a <termref def="dt-stylesheet-module">stylesheet module</termref>, all
               static expressions are evaluated in a
               single <xtermref spec="FO30" ref="execution-scope">execution scope</xtermref>. This
               need not be the same execution scope as that used for static
               expressions in other stylesheet modules, or as that used when evaluating XPath
               expressions appearing elsewhere in the stylesheet module. This means that a function
               such as <xfunction>current-date</xfunction> will return the same result when called
               in different <code>[xsl:]use-when</code> expressions within the same stylesheet
               module, but will not necessarily return the same result as the same call in an
               <code>[xsl:]use-when</code> expression within a different stylesheet module, or as
               a call on the same function executed during the transformation proper.</p></div2><div2 id="local-variables"><head>Local Variables and Parameters</head><p>
               <termdef id="dt-local-variable" term="local variable">As well as being allowed as a
                     <termref def="dt-declaration">declaration</termref>, the
                     <elcode>xsl:variable</elcode> element is also allowed in <termref def="dt-sequence-constructor">sequence constructors</termref>. Such a variable
                  is known as a <term>local variable</term>.</termdef>
            </p><p>An <elcode>xsl:param</elcode> element may also be used to create a variable binding
               with local scope:</p><ulist><item><p>
                     <termdef id="dt-template-parameter" term="template parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:template</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>template parameter</term>. A template parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <elcode>xsl:call-template</elcode>,
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                        or <elcode>xsl:next-match</elcode>.</termdef>
                  </p></item><item><p>
                     <termdef id="dt-function-parameter" term="function parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:function</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>function parameter</term>. A function parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <termref def="dt-expression">expression</termref>.</termdef>
                  </p></item><item><p diff="add" at="D">An <elcode>xsl:param</elcode> element may appear as a child
                     of an <elcode>xsl:iterate</elcode> instruction, before any
                        non-<elcode>xsl:param</elcode> children of that element. This defines a
                     parameter whose value may be initialized on entry to the iteration, and which
                     may be varied each time round the iteration by use of an
                        <elcode>xsl:with-param</elcode> element in the
                        <elcode>xsl:next-iteration</elcode> instruction. </p></item></ulist><p>The result of evaluating a local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element (that is, the contribution it makes to the
               result of the <termref def="dt-sequence-constructor"/>
               it is part of) is an empty sequence.</p></div2><div2 id="scope-of-variables"><head>Scope of Variables</head><p>For any <termref def="dt-variable-binding-element">variable-binding
               element</termref>, there is a region (more specifically, a set of element nodes) of
               the <termref def="dt-stylesheet">stylesheet</termref> within which the binding is
               visible. The set of variable bindings in scope for an XPath <termref def="dt-expression">expression</termref> consists of those bindings that are
               visible at the point in the stylesheet where the expression occurs.</p><p>A global <termref def="dt-variable-binding-element">variable binding
                  element</termref> is visible everywhere in the <termref def="dt-stylesheet">stylesheet</termref> (including other <termref def="dt-stylesheet-module">stylesheet modules</termref>) except within the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself and any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.</p><p>A local <termref def="dt-variable-binding-element">variable binding element</termref>
               is visible for all following siblings and their descendants, with <phrase diff="chg" at="B">the following</phrase> exceptions:</p><olist><item><p>It is not visible in any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.</p></item><item><p>It is not visible within the subtree rooted at an <elcode>xsl:fallback</elcode>
                     instruction that is a sibling of the variable binding element.</p></item><item><p diff="add" at="B">It is not visible within the subtree rooted at an
                        <elcode>xsl:catch</elcode> instruction that is a sibling of the variable
                     binding element.</p></item></olist><p>The binding is not visible for the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself.</p><p>
               <termdef id="dt-shadows" term="shadows">A binding <term>shadows</term> another
                  binding if the binding occurs at a point where the other binding is visible, and
                  the bindings have the same name. </termdef> It is not an error if a binding
               established by a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
               <termref def="dt-shadows">shadows</termref> a global binding. In this case, the
               global binding will not be visible in the region of the <termref def="dt-stylesheet">stylesheet</termref> where it is shadowed by the other binding.</p><example><head>Local Variable Shadowing a Global Variable</head><p>The following is allowed:</p><eg xml:space="preserve">&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</eg></example><p>It is also not an error if a binding established by a local
                  <elcode>xsl:variable</elcode> element <termref def="dt-shadows">shadows</termref>
               a binding established by another local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode>.</p><example><head>Misuse of Variable Shadowing</head><p>The following is not an error, but the effect is probably not what was intended.
                  The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of
                  the inner variable named <code>$x</code> has no effect on the value of the outer
                  variable named <code>$x</code>.</p><eg xml:space="preserve">&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;</eg></example><note><p>Once a variable has been given a value, the value cannot subsequently be changed.
                  XSLT does not provide an equivalent to the assignment operator available in many
                  procedural programming languages. </p><p>This is because an assignment operator would make it harder to create an
                  implementation that processes a document other than in a batch-like way, starting
                  at the beginning and continuing through to the end.</p></note><p>As well as global variables and local variables, an XPath <termref def="dt-expression">expression</termref> may also declare range variables for use
               locally within an expression. For details, see <bibref ref="xpath-30"/>.</p><p>Where a reference to a variable occurs in an XPath expression, it is resolved first
               by reference to range variables that are in scope, then by reference to local
               variables and parameters, and finally by reference to global variables and
               parameters. A range variable may shadow a local variable or a global variable. XPath
               also allows a range variable to shadow another range variable.</p></div2><div2 id="with-param"><head>Setting Parameter Values</head><e:element-syntax name="with-param"><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="tunnel"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="apply-templates"/><e:parent name="apply-imports"/><e:parent name="call-template"/><e:parent name="next-match"/></e:allowed-parents></e:element-syntax><p>Parameters are passed to templates using the <elcode>xsl:with-param</elcode> element.
               The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the <termref def="dt-template-parameter">template parameter</termref> (the variable the value
               of whose binding is to be replaced). The value of the <code>name</code> attribute is
               an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as described in <specref ref="qname"/>.</p><p><phrase diff="add" at="D">The <elcode>xsl:with-param</elcode> element is also used
                  when passing parameters to an iteration of the <elcode>xsl:iterate</elcode>
                  instruction, or to a dynamic invocation of an XPath expression using
                     <elcode>xsl:evaluate</elcode>. In consequence, </phrase>
               <elcode>xsl:with-param</elcode> may appear within 
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, 
               <elcode>xsl:call-template</elcode>, <phrase diff="add" at="B"><elcode>xsl:evaluate</elcode>,
                     <elcode>xsl:next-iteration</elcode>, </phrase> and
                  <elcode>xsl:next-match</elcode>. (Arguments to <termref def="dt-stylesheet-function">stylesheet functions</termref>, however, are supplied
               as part of an XPath function call: see <specref ref="stylesheet-functions"/>.) </p><p>
               <error spec="XT" type="static" class="SE" code="0670"><p diff="chg" at="B">It is a <termref def="dt-static-error">static error</termref>
                     if two or more sibling <elcode>xsl:with-param</elcode> elements have
                        <code>name</code> attributes that represent the same <termref def="dt-expanded-qname">expanded QName</termref>.</p></error>
            </p><p>The value of the parameter is specified in the same way as for
                  <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> (see <specref ref="variable-values"/>), taking account of the values of the <code>select</code>
               and <code>as</code> attributes and the content of the <elcode>xsl:with-param</elcode>
               element, if any.</p><note><p>It is possible to have an <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element that differs from the <code>as</code>
                  attribute on the corresponding <elcode>xsl:param</elcode> element<phrase diff="del" at="D"> describing the formal parameters of the called
                     template</phrase>.</p><p>In this situation, the supplied value of the parameter will first be processed
                  according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element, and the resulting value will then be
                  further processed according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:param</elcode> element.</p><p>For example, suppose the supplied value is a node with <termref def="dt-annotation">type annotation</termref>
                  <code>xs:untypedAtomic</code>, and the <elcode>xsl:with-param</elcode> element
                  specifies <code>as="xs:integer"</code>, while the <elcode>xsl:param</elcode>
                  element specifies <code>as="xs:double"</code>. Then the node will first be
                  atomized and the resulting untyped atomic value will be cast to
                     <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
                  then be promoted to an <code>xs:double</code>.</p></note><p>The <termref def="dt-focus">focus</termref> used for computing the value specified by
               the <elcode>xsl:with-param</elcode> element is the same as that used for <phrase diff="chg" at="B">its parent <termref def="dt-instruction">instruction</termref></phrase>.</p><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>. They are used only when passing parameters to templates: for an
                  <elcode>xsl:with-param</elcode> element that is a child of
                  <elcode>xsl:evaluate</elcode> or <elcode>xsl:next-iteration</elcode> the
                  <code>tunnel</code> attribute <rfc2119>must</rfc2119> either be omitted or take
               the value <code>no</code>. </p><p>
               
                  In other cases it is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                        dynamic error</termref> if the template that is invoked declares a <termref def="dt-template-parameter">template parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied by
               the calling instruction. <errorref spec="XT" class="DE" code="0700"/> 
               
            </p></div2><div2 id="circularity"><head>Circular Definitions</head><p>
               <termdef id="dt-circularity" term="circularity">A <term>circularity</term> is said to
                  exist if a construct such as a <termref def="dt-global-variable">global
                     variable</termref>, an <termref def="dt-attribute-set">attribute set</termref>,
                  or a <termref def="dt-key">key</termref>,
                  
                  is defined in terms of itself. For example, if the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence
                     constructor</termref> specifying the value of a <termref def="dt-global-variable">global variable</termref>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <rfc2119>must</rfc2119> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.</termdef>
            </p><example><head>Circular Variable Definitions</head><p>The following two declarations create a circularity:</p><eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;</eg></example><example><head>Circularity involving Variables and Functions</head><p>The definition of a global variable can be circular even if no other variable is
                  involved. For example the following two declarations (see <specref ref="stylesheet-functions"/> for an explanation of the
                     <elcode>xsl:function</elcode> element) also create a circularity:</p><eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</eg></example><example><head>Circularity involving Variables and Templates</head><p>The definition of a variable is also circular if the evaluation of the variable
                  invokes an <elcode>xsl:apply-templates</elcode> instruction and the variable is
                  referenced in the pattern used in the <code>match</code> attribute of any template
                  rule in the <termref def="dt-stylesheet">stylesheet</termref>. For example the
                  following definition is circular:</p><eg role="error" xml:space="preserve">&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</eg></example><example><head>Circularity involving Variables and Keys</head><p>Similarly, a variable definition is circular if it causes a call on the
                     <function>key</function> function, and the definition of that <termref def="key">key</termref> refers to that variable in its <code>match</code> or
                     <code>use</code> attributes. So the following definition is circular:</p><eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:sequence select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</eg></example><p>
               <error spec="XT" type="dynamic" class="DE" code="0640"><p>In general, a <termref def="dt-circularity">circularity</termref> in a <termref def="dt-stylesheet">stylesheet</termref> is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</p></error> However, as with all other dynamic errors, an implementation will signal the
               error only if it actually executes the instructions and expressions that participate
               in the circularity. Because different implementations may optimize the execution of a
               stylesheet in different ways, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether a particular circularity will actually
               be signaled.</p><p>For example, in the following declarations, the function declares a local variable
                  <code>$b</code>, but it returns a result that does not require the variable to be
               evaluated. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether the value is actually evaluated, and
               it is therefore implementation-dependent whether the circularity is signaled as an
               error:</p><eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</eg><p>Circularities usually involve global variables or parameters, but they can also exist
               between <termref def="key">key</termref> definitions (see <specref ref="key"/>),
               between named <termref def="dt-attribute-set">attribute sets</termref> (see <specref ref="attribute-sets"/>), or between any combination of these constructs. For
               example, a circularity exists if a key definition invokes a function that references
               an attribute set that calls the <function>key</function> function, supplying the name
               of the original key definition as an argument.</p><p>Circularity is not the same as recursion. Stylesheet functions (see <specref ref="stylesheet-functions"/>) and named templates (see <specref ref="named-templates"/>) may call other functions and named templates without
               restriction. With careless coding, recursion may be non-terminating. Implementations
               are <rfc2119>required</rfc2119> to signal circularity as a <termref def="dt-dynamic-error">dynamic error</termref>, but they are not
                  <rfc2119>required</rfc2119> to detect non-terminating recursion.</p></div2></div1><div1 id="callable-components"><head>Callable Components</head><p>This section describes three constructs that can be used to provide subroutine-like
            functionality that can be invoked from anywhere in the stylesheet: named templates (see
               <specref ref="named-templates"/>), named attribute sets (see <specref ref="attribute-sets"/>), and <termref def="dt-stylesheet-function">stylesheet
               functions</termref> (see <specref ref="stylesheet-functions"/>).</p><div2 id="named-templates"><head>Named Templates</head><e:element-syntax name="call-template"><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:element repeat="zero-or-more" name="with-param"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>
               <termdef id="dt-named-template" term="named template">Templates can be invoked by
                  name. An <elcode>xsl:template</elcode> element with a <code>name</code> attribute
                  defines a <term>named template</term>.</termdef> The value of the
               <code>name</code> attribute is an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is
               expanded as described in <specref ref="qname"/>. If an <elcode>xsl:template</elcode>
               element has a <code>name</code> attribute, it may, but need not, also have a
                  <code>match</code> attribute. An <elcode>xsl:call-template</elcode> instruction
               invokes a template by name; it has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that identifies the template to be invoked. Unlike
                  <elcode>xsl:apply-templates</elcode>, the <elcode>xsl:call-template</elcode>
               instruction does not change the <termref def="dt-focus">focus</termref>.</p><p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the <termref def="dt-template">template</termref> is invoked by an
                  <elcode>xsl:call-template</elcode> instruction. Similarly, the <code>name</code>
               <phrase diff="add" at="I"> and <code>visibility</code></phrase> attributes 
               on an <elcode>xsl:template</elcode> element have no effect when the template
               is invoked by an <elcode>xsl:apply-templates</elcode> instruction.</p><p>
               <error spec="XT" type="static" class="SE" code="0650"><p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet">stylesheet</termref> contains an
                        <elcode>xsl:call-template</elcode> instruction whose <code>name</code>
                     attribute does not match the <code>name</code> attribute of any
                        <phrase diff="chg" at="I"><termref def="dt-named-template">named template</termref> 
                           visible in the containing <termref def="dt-package">package</termref> 
                           (this includes any template defined in this package, as well as templates
                           accepted from used packages whose visibility in this package
                           is not <code>hidden</code>). For more details of the
                  process of binding the called template, see <specref ref="component-references"/>.</phrase></p></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="0660"><p>It is a <termref def="dt-static-error">static error</termref> if a <!--<termref
                  def="dt-stylesheet">stylesheet</termref>--> <phrase diff="chg" at="I">
                        <termref def="dt-package">package</termref></phrase> contains more than one <termref def="dt-template">template</termref> with the same name and the same
                        <termref def="dt-import-precedence">import precedence</termref>, unless it
                     also contains a <termref def="dt-template">template</termref> with the same
                     name and higher <termref def="dt-import-precedence">import
                     precedence</termref>.</p></error>
            </p><p><phrase diff="chg" at="I">The target <termref def="dt-template">template</termref> for an
                  <elcode>xsl:call-template</elcode> instruction 
               is established using the binding rules described in
               <specref ref="component-references"/>.         
               This will always be a template whose
                  <code>name</code> attribute matches the <code>name</code> attribute of the
                  <elcode>xsl:call-template</elcode> instruction. 
               It may be a template defined in the same package that has higher <termref def="dt-import-precedence">import precedence</termref> than any other template
               with this name, or it may be a template accepted from a used package, or (if the template
               is not defined as <code>private</code> or <code>final</code>) it may
               be an overriding template in a package that uses the containing package. </phrase>
               The result of evaluating an <elcode>xsl:call-template</elcode>
               instruction is the sequence produced by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in its
               target <termref def="dt-template">template</termref> (see <specref ref="sequence-constructors"/>).</p><p diff="add" at="bug9743">The template name <code>xsl:initial-template</code> is specially
            recognized in that it provides a default entry point for stylesheet execution (see <specref ref="initiating"/>.) 
               A template with this name
            <rfc2119>must not</rfc2119> have any <elcode>xsl:param</elcode> children that specify <code>required="yes"</code>.
            In all other respects a template with this name behaves exactly like a template with any other name.</p><ednote><edtext>Define the error condition.</edtext></ednote><div3 id="call-template-params"><head>Passing Parameters to Named Templates</head><p>Parameters are passed to named templates using the <elcode>xsl:with-param</elcode>
                  element as a child of the <elcode>xsl:call-template</elcode> instruction.</p><p>
                  <error spec="XT" type="static" class="SE" code="0680"><p>In the case of <elcode>xsl:call-template</elcode>, it is a <termref def="dt-static-error">static error</termref> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a 
                        <phrase diff="add" at="I">non-tunnel</phrase> <!-- see bug 10534 --><termref def="dt-template-parameter">template parameter</termref> named
                           <var>x</var>, unless <phrase diff="chg" at="D">the
                              <elcode>xsl:call-template</elcode> instruction is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref></phrase>.</p></error> This is not an error in the case of <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, and <elcode>xsl:next-match</elcode>; in
                  these cases the parameter is simply ignored.</p><p>The optional <code>tunnel</code> attribute may be used to indicate that a
                  parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The
                  default is <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>
               </p><p>
                  <error spec="XT" type="static" class="SE" code="0690"><p>It is a <termref def="dt-static-error">static error</termref> if a template
                        that is invoked using <elcode>xsl:call-template</elcode> declares a <termref def="dt-template-parameter">template parameter</termref> specifying
                           <code>required="yes"</code> and not specifying <code>tunnel="yes"</code>,
                        if no value for this parameter is supplied by the calling
                           <elcode>xsl:call-template</elcode> instruction.</p></error>
               </p><example><head>Calling a Named Template with a Parameter</head><p>This example defines a named template for a <code>numbered-block</code> with a
                     parameter to control the format of the number.</p><eg xml:space="preserve">&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg></example></div3><div3 id="tunnel-params"><head>Tunnel Parameters</head><p>
                  <termdef id="dt-tunnel-parameter" term="tunnel parameter">A parameter passed to a
                     template may be defined as a <term>tunnel parameter</term>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.</termdef> Tunnel
                  parameters thus allow values to be set that are accessible during an entire phase
                  of stylesheet processing, without the need for each template that is used during
                  that phase to be aware of the parameter.</p><note><p>Tunnel parameters are conceptually similar to dynamically scoped variables in
                     some functional programming languages.</p></note><p>A <termref def="dt-tunnel-parameter">tunnel parameter</termref> is created by
                  using an <elcode>xsl:with-param</elcode> element that specifies
                     <code>tunnel="yes"</code>. A template that requires access to the value of a
                  tunnel parameter must declare it using an <elcode>xsl:param</elcode> element that
                  also specifies <code>tunnel="yes"</code>.</p><p>On any template call using an <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> instruction, a set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> is passed from the
                  calling template to the called template. This set consists of any parameters
                  explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
                  overlaid on a base set of tunnel parameters. If the
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>
                  instruction has an <elcode>xsl:template</elcode> declaration as an ancestor
                  element in the stylesheet, then the base set consists of the tunnel parameters
                  that were passed to that template; otherwise (for example, if the instruction is
                  within a global variable declaration, an <termref def="dt-attribute-set">attribute
                     set</termref> declaration, or a <termref def="dt-stylesheet-function">stylesheet function</termref>), the base set is empty. If a parameter created
                  using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <termref def="dt-expanded-qname">expanded QName</termref> as a parameter in the base
                  set, then the parameter created using <elcode>xsl:with-param</elcode> overrides
                  the parameter in the base set; otherwise, the parameter created using
                     <elcode>xsl:with-param</elcode> is added to the base set.</p><p>When a template accesses the value of a <termref def="dt-tunnel-parameter">tunnel
                     parameter</termref> by declaring it with <code>xsl:param tunnel="yes"</code>,
                  this does not remove the parameter from the base set of tunnel parameters that is
                  passed on to any templates called by this template.</p><p>Two sibling <elcode>xsl:with-param</elcode> elements <rfc2119>must</rfc2119> have
                  distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not. Equally, two sibling
                     <elcode>xsl:param</elcode> elements representing <termref def="dt-template-parameter">template parameters</termref>
                  <rfc2119>must</rfc2119> have distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not.
                  However, the tunnel parameters that are implicitly passed in a template call
                     <rfc2119>may</rfc2119> have names that duplicate the names of non-tunnel
                  parameters that are explicitly passed on the same call.</p><p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are not passed in
                  calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p><p>All other options of <elcode>xsl:with-param</elcode> and
                     <elcode>xsl:param</elcode> are available with <termref def="dt-tunnel-parameter">tunnel parameters</termref> just as with non-tunnel
                  parameters. For example, parameters may be declared as mandatory or optional, a
                  default value may be specified, and a required type may be specified. If any
                  conversion is required from the supplied value of a tunnel parameter to the
                  required type specified in <elcode>xsl:param</elcode>, then the converted value is
                  used within the receiving template, but the value that is passed on in any further
                  template calls is the original supplied value before conversion. Equally, any
                  default value is local to the template: specifying a default value for a tunnel
                  parameter does not change the set of tunnel parameters that is passed on in
                  further template calls.</p><p>The set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> that is
                  passed to the <termref def="dt-initial-template">initial template</termref> is
                  empty.</p><p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are passed
                  unchanged through a built-in template rule (see <specref ref="built-in-rule"/>).</p><p diff="add" at="D">If a tunnel parameter is declared in an
                     <elcode>xsl:param</elcode> element with the attribute
                  <code>tunnel="yes"</code>, then a non-recoverable dynamic error occurs <errorref spec="XT" class="DE" code="0700"/> if the set of tunnel parameters passed to
                  the template does not include a parameter with a matching <termref def="dt-expanded-qname">expanded QName</termref>.</p><example><head>Using Tunnel Parameters</head><p>Suppose that the equations in a scientific paper are to be sequentially
                     numbered, but that the format of the number depends on the context in which the
                     equations appear. It is possible to reflect this using a rule of the form:</p><eg xml:space="preserve">&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;</eg><p>At any level of processing above this level, it is possible to determine how
                     the equations will be numbered, for example:</p><eg xml:space="preserve">&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;</eg><p>The parameter value is passed transparently through all the intermediate layers
                     of template rules until it reaches the rule with <code>match="equation"</code>.
                     The effect is similar to using a global variable, except that the parameter can
                     take different values during different phases of the transformation.</p></example></div3></div2><div2 id="attribute-sets"><head>Named Attribute Sets</head><e:element-syntax name="attribute-set"><e:in-category name="declaration"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="use-attribute-sets"><e:data-type name="eqnames"/></e:attribute><e:attribute name="visibility"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:element repeat="zero-or-more" name="attribute"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/><e:parent name="override"/></e:allowed-parents></e:element-syntax><p>
               <termdef id="dt-attribute-set" term="attribute set">The
                     <elcode>xsl:attribute-set</elcode> element defines a named <term>attribute
                     set</term>: that is, a collection of attribute definitions that can be used
                  repeatedly on different constructed elements.</termdef>
            </p><p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the attribute set. The value of the
               <code>name</code> attribute is an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is
               expanded as described in <specref ref="qname"/>. The content of the
                  <elcode>xsl:attribute-set</elcode> element consists of zero or more
                  <elcode>xsl:attribute</elcode> instructions that are evaluated to produce the
                  attributes in the set.</p><p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
               <code>abstract</code> then there must be no <elcode>xsl:attribute</elcode> children.</p><p>The result of evaluating an attribute set is a sequence of attribute nodes.
               Evaluating the same attribute set more than once can produce different results,
               because although an attribute set does not have parameters, it may contain
               expressions or instructions whose value depends on the evaluation context.</p><p>
               <termref def="dt-attribute-set">Attribute sets</termref> are used by specifying a
                  <code>use-attribute-sets</code> attribute on the <elcode>xsl:element</elcode> or
                  <elcode>xsl:copy</elcode> instruction, or by specifying an
                  <code>xsl:use-attribute-sets</code> attribute on a literal result element. An
               attribute set may be defined in terms of other attribute sets by using the
                  <code>use-attribute-sets</code> attribute on the
                  <elcode>xsl:attribute-set</elcode> element itself. The value of the
                  <code>[xsl:]use-attribute-sets</code> attribute is in each case a
               whitespace-separated list of names of attribute sets. Each name is specified as
               an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                  <specref ref="qname"/>.</p><p>Specifying a <code>use-attribute-sets</code> attribute is broadly equivalent to
               adding <elcode>xsl:attribute</elcode> instructions for each of the attributes in each
               of the named attribute sets to the beginning of the content of the instruction with
               the <code>[xsl:]use-attribute-sets</code> attribute, in the same order in which the
               names of the attribute sets are specified in the <code>use-attribute-sets</code>
               attribute.</p><p>More formally, an <code>xsl:use-attribute-sets</code> attribute is expanded using the
               following recursive algorithm, or any algorithm that produces the same results:</p><ulist><item><p>The value of the attribute is tokenized as a list of QNames.</p></item><item><p>Each QName in the list is processed, in order, as follows:</p><ulist><item><p>The QName must match the <code>name</code> attribute of one or more
                              <elcode>xsl:attribute-set</elcode> declarations in the stylesheet.</p></item><item><p>Each <elcode>xsl:attribute-set</elcode> declaration whose name matches is
                           processed as follows. Where two such declarations have different <termref def="dt-import-precedence">import precedence</termref>, the one with
                           lower import precedence is processed first. Where two declarations have
                           the same import precedence, they are processed in <termref def="dt-declaration-order">declaration order</termref>.</p><ulist><item><p>If the <elcode>xsl:attribute-set</elcode> declaration has a
                                    <code>use-attribute-sets</code> attribute, the attribute is
                                 expanded by applying this algorithm recursively.</p></item><item><p>If the <elcode>xsl:attribute-set</elcode> declaration contains one
                                 or more <elcode>xsl:attribute</elcode> instructions, these
                                 instructions are evaluated (following the rules for evaluating a
                                    <termref def="dt-sequence-constructor">sequence
                                    constructor</termref>: see <specref ref="sequence-constructors"/>) to produce a sequence of attribute nodes. These attribute nodes
                                 are appended to the result sequence.</p></item></ulist></item></ulist></item></ulist><p>The <elcode>xsl:attribute</elcode> instructions are evaluated using the same <termref def="dt-focus">focus</termref> as is used for evaluating the element that is the
               parent of the <code>[xsl:]use-attribute-sets</code> attribute forming the initial
               input to the algorithm. However, the static context for the evaluation depends on the
               position of the <elcode>xsl:attribute</elcode> instruction in the stylesheet: thus,
               only local variables declared within an <elcode>xsl:attribute</elcode> instruction,
               and global variables, are visible.</p><p>The set of attribute nodes produced by expanding <code>xsl:use-attribute-sets</code>
               may include several attributes with the same name. When the attributes are added to
               an element node, only the last of the duplicates will take effect.</p><p>The way in which each instruction uses the results of expanding the
                  <code>[xsl:]use-attribute-sets</code> attribute is described in the specification
               for the relevant instruction: see <specref ref="literal-result-element"/>, <specref ref="xsl-element"/>, and <specref ref="copying"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0710"><p>It is a <termref def="dt-static-error">static error</termref> if the value of
                     the <code>use-attribute-sets</code> attribute of an <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, or <elcode>xsl:attribute-set</elcode> element,
                     or the <code>xsl:use-attribute-sets</code> attribute of a <termref def="dt-literal-result-element">literal result element</termref>, is not a
                     whitespace-separated sequence of <phrase diff="chg" at="K"><termref def="dt-eqname">EQNames</termref></phrase>, or
                     if it contains a QName that does not match the <code>name</code> attribute of
                     any <elcode>xsl:attribute-set</elcode> declaration in the stylesheet.</p></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="0720"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:attribute-set</elcode> element directly or indirectly references
                     itself via the names contained in the <code>use-attribute-sets</code>
                     attribute.</p></error>
            </p><p>Each attribute node produced by expanding an attribute set has a <termref def="dt-annotation">type annotation</termref> determined by the rules for the
                  <elcode>xsl:attribute</elcode> instruction that created the attribute node: see
                  <specref ref="annotation-for-constructed-attribute"/>. These type annotations may
               be preserved, stripped, or replaced as determined by the rules for the instruction
               that creates the element in which the attributes are used.</p><p>Attribute sets are used as follows:</p><ulist><item><p>The <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode> instructions
                     have an <code>use-attribute-sets</code> attribute. The sequence of attribute
                     nodes produced by evaluating this attribute is prepended to the sequence
                     produced by evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the instruction.</p></item><item><p>
                     <termref def="dt-literal-result-element">Literal result elements</termref>
                     allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated in
                     the same way as the <code>use-attribute-sets</code> attribute of
                        <elcode>xsl:element</elcode> and <elcode>xsl:copy</elcode>. The sequence of
                     attribute nodes produced by evaluating this attribute is prepended to the
                     sequence of attribute nodes produced by evaluating the attributes of the
                     literal result element, which in turn is prepended to the sequence produced by
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained with the literal result element.</p></item></ulist><example><head>Using Attribute Sets</head><p>The following example creates a named <termref def="dt-attribute-set">attribute
                     set</termref>
                  <code>title-style</code> and uses it in a <termref def="dt-template-rule">template
                     rule</termref>.</p><eg xml:space="preserve">&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</eg></example><example><head>Overriding Attributes in an Attribute Set</head><p>The following example creates a named attribute set <code>base-style</code> and
                  uses it in a template rule with multiple specifications of the attributes:</p><glist><gitem><label>font-family</label><def><p>is specified only in the attribute set</p></def></gitem><gitem><label>font-size</label><def><p>is specified in the attribute set, is specified on the literal result
                           element, and in an <elcode>xsl:attribute</elcode> instruction</p></def></gitem><gitem><label>font-style</label><def><p>is specified in the attribute set, and on the literal result element</p></def></gitem><gitem><label>font-weight</label><def><p>is specified in the attribute set, and in an
                              <elcode>xsl:attribute</elcode> instruction</p></def></gitem></glist><!--
<table cellspacing="5">
<tbody>
<tr><td valign="top"><code>font-family</code></td>is specified only in the attribute set<td></td></tr>
 <tr><td valign="top"><code>font-size</code></td><td>is specified in the attribute set, is specified
             on the literal result element, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
 <tr><td valign="top"><code>font-style</code></td><td>is specified in the attribute set, and on
             the literal result element</td></tr>
 <tr><td valign="top"><code>font-weight</code></td><td>is specified in the attribute set, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
</tbody>             
</table>--><p>Stylesheet fragment:</p><eg xml:space="preserve">&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg><p>Result:</p><eg xml:space="preserve">&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</eg></example></div2><div2 id="stylesheet-functions"><head>Stylesheet Functions</head><p>
               <termdef id="dt-stylesheet-function" term="stylesheet function">An
                     <elcode>xsl:function</elcode> declaration declares the name, parameters, and
                  implementation of a <term>stylesheet function</term> that can be called from any
                  XPath <termref def="dt-expression">expression</termref> within the <termref def="dt-stylesheet">stylesheet</termref>.</termdef>
            </p><e:element-syntax name="function"><e:in-category name="declaration"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="as" required="no"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="visibility" required="no"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:attribute name="override-extension-function" required="no"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="override" required="no" deprecated="yes"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="param"/><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/><e:parent name="override"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:function</elcode> declaration defines a <termref def="dt-stylesheet-function">stylesheet function</termref> that can be called from
               any XPath <termref def="dt-expression">expression</termref> used in the <termref def="dt-stylesheet">stylesheet</termref> (including an XPath expression used
               within a predicate in a <termref def="dt-pattern">pattern</termref>). The
                  <code>name</code> attribute specifies the name of the function. The value of the
               <code>name</code> attribute is an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is
               expanded as described in <specref ref="qname"/>.</p><p>An <elcode>xsl:function</elcode> declaration can only appear as a <termref def="dt-top-level"/> element
               in a stylesheet module.</p><p diff="add" at="L">
               <error spec="XT" type="static" class="SE" code="0740"><p>It is a <termref def="dt-static-error">static error</termref> if
                     a <termref def="dt-stylesheet-function">stylesheet function</termref>
                     has a name that is in no namespace.</p></error></p><note><p>To prevent the namespace declaration used for the function name appearing in the
                  result document, use the <code>exclude-result-prefixes</code> attribute on the
                     <elcode>xsl:stylesheet</elcode> element: see <specref ref="lre-namespaces"/>.</p><p>The name of the function <rfc2119>must not</rfc2119> be in a <termref def="dt-reserved-namespace">reserved namespace</termref>: <errorref spec="XT" class="SE" code="0080"/>
               </p></note><p>The content of the <elcode>xsl:function</elcode> element consists of zero or more
                  <elcode>xsl:param</elcode> elements that specify the formal arguments of the
               function, followed by a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that defines the value to be returned by the function.</p><p>
               <termdef id="dt-arity" term="arity">The <term>arity</term> of a stylesheet function
                  is the number of <elcode>xsl:param</elcode> elements in the function
                  definition.</termdef> Optional arguments are not allowed.</p><p>
               <error spec="XT" type="static" class="SE" code="0760"><p>Because arguments to a stylesheet function call <rfc2119>must</rfc2119> all be
                     specified, the <elcode>xsl:param</elcode> elements within an
                        <elcode>xsl:function</elcode> element <rfc2119>must not</rfc2119> specify a
                     default value: this means they <rfc2119>must</rfc2119> be empty, and
                        <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p></error>
            </p><p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
            <code>abstract</code> then the <termref def="dt-sequence-constructor"/>
            defining the function body <rfc2119>must</rfc2119> be empty.</p><p>A <termref def="dt-stylesheet-function">stylesheet function</termref> is included in
               the <emph>in-scope functions</emph> of the static context for all XPath expressions
               used in the <phrase diff="chg" at="I">containing <termref def="dt-package">package</termref></phrase>, 
               unless </p><ulist><item><p>there is another <termref def="dt-stylesheet-function">stylesheet
                        function</termref> with the same name and <termref def="dt-arity">arity</termref>, and higher <termref def="dt-import-precedence">import
                        precedence</termref>, or</p></item><item><p>the <code>override-extension-function</code> or <code>override</code> attribute has the value <code>no</code> and there is
                     already a function with the same name and <termref def="dt-arity">arity</termref> in the in-scope functions.</p></item></ulist><p diff="add" at="I">The <termref def="dt-visibility">visibility</termref> of the function in other 
               packages depends on the value
            of the <code>visibility</code> attribute and other factors, as described in <specref ref="packages"/></p><p>The optional <phrase diff="chg" at="M"><code>override-extension-function</code></phrase> attribute defines what happens if this function
               has the same name and <termref def="dt-arity">arity</termref> as a function provided
               by the implementer or made available in the static context using an
               implementation-defined mechanism. If the 
               <phrase diff="chg" at="M"><code>override-extension-function</code></phrase> attribute has the
               value <code>yes</code>, then this function is used in preference; if it has the value
                  <code>no</code>, then the other function is used in preference. The default value
               is <code>yes</code>.</p><note><p>Specifying <phrase diff="chg" at="M"><code>override-extension-function="yes"</code></phrase> ensures interoperable behavior: the same
                  code will execute with all processors. Specifying <phrase diff="chg" at="M"><code>override-extension-function="no"</code></phrase> is
                  useful when writing a fallback implementation of a function that is available with
                  some processors but not others: it allows the vendor's implementation of the
                  function (or a user's implementation written as an extension function) to be used
                  in preference to the stylesheet implementation, which is useful when the extension
                  function is more efficient.</p><p>The <code>override-extension-function</code> attribute does <emph>not</emph> affect the rules for
                  deciding which of several <termref def="dt-stylesheet-function">stylesheet
                     functions</termref> with the same name and <termref def="dt-arity">arity</termref> takes precedence.</p></note><p diff="add" at="M">The <code>override</code> attribute is a 
               <termref def="dt-deprecated"/> synonym of <code>override-extension-function</code>,
            retained for compatibility with XSLT 2.0. If both attributes are present then they <rfc2119>must</rfc2119>
            have the same value.</p><p>
               <error spec="XT" type="static" class="SE" code="0770"><p>It is a <termref def="dt-static-error">static error</termref> for a <termref def="dt-stylesheet">stylesheet</termref> to contain two or more functions
                     with the same <termref def="dt-expanded-qname">expanded QName</termref>, the
                     same <termref def="dt-arity">arity</termref>, and the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another function with the same <termref def="dt-expanded-qname">expanded QName</termref> and arity, and a higher import precedence.</p></error>
            </p><p diff="add" at="I">When the <elcode>xsl:function</elcode> declaration appears as a child of 
               <elcode>xsl:override</elcode>, there <rfc2119>must</rfc2119> be a stylesheet function
               with the same <termref def="dt-expanded-qname">expanded QName</termref> and 
               <termref def="dt-arity">arity</termref> in the <termref def="dt-package">package</termref>
               referenced by the containing <elcode>xsl:use-package</elcode> element; the 
               <termref def="dt-visibility">visibility</termref> of
               that function must be <code>public</code> or <code>abstract</code>, and the overriding
               and overridden functions <rfc2119>must</rfc2119> have the same argument types and result
               type.</p><p>As defined in XPath, the function that is executed as the result of a function call
               is identified by looking in the in-scope functions of the static context for a
               function whose name and <termref def="dt-arity">arity</termref> matches the name and
               number of arguments in the function call. </p><note><p>Functions are not polymorphic. Although the XPath function call mechanism allows
                  two functions to have the same name and different <termref def="dt-arity">arity</termref>, it does not allow them to be distinguished by the types of
                  their arguments.</p></note><p>The optional <code>as</code> attribute indicates the <termref def="dt-required-type">required type</termref> of the result of the function. The value of the
                  <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-30"/>.</p><p>
               <error spec="XT" type="type" class="TE" code="0780"><p>If the <code>as</code> attribute <error.extra>of <elcode>xsl:function</elcode>
                     </error.extra> is specified, then the result evaluated by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see <specref ref="sequence-constructors"/>) is converted to the required type, using the
                        <termref def="dt-function-conversion-rules">function conversion
                        rules</termref>. It is a <termref def="dt-type-error">type error</termref>
                     if this conversion fails.</p></error> If the <code>as</code> attribute is omitted, the calculated result is used
               as supplied, and no conversion takes place.</p><p>If a <termref def="dt-stylesheet-function">stylesheet function</termref> has been
               defined with a particular <termref def="dt-expanded-qname">expanded QName</termref>,
               then a call on <function>function-available</function> will return true when called
               with an argument that is a <termref def="dt-eqname">EQName</termref>
               that expands to this same <termref def="dt-expanded-qname">expanded QName</termref>.</p><p>The <elcode>xsl:param</elcode> elements define the formal arguments to the function.
               These are interpreted positionally. When the function is called using a function-call
               in an XPath <termref def="dt-expression">expression</termref>, the first argument
               supplied is assigned to the first <elcode>xsl:param</elcode> element, the second
               argument supplied is assigned to the second <elcode>xsl:param</elcode> element, and
               so on.</p><p>The <code>as</code> attribute of the <elcode>xsl:param</elcode> element defines the
               required type of the parameter. The rules for converting the values of the actual
               arguments supplied in the function call to the types required by each
                  <elcode>xsl:param</elcode> element are defined in <bibref ref="xpath-30"/>. The
               rules that apply are those for the case where <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is set to <code>false</code>.</p><p>
               <error spec="XT" type="type" class="TE" code="0790"><p>If the value of a parameter to a <termref def="dt-stylesheet-function">stylesheet function</termref> cannot be converted to the required type, a
                        <termref def="dt-type-error">type error</termref> is signaled.</p></error>
            </p><p>If the <code>as</code> attribute is omitted, no conversion takes place and any value
               is accepted.</p><p>Within the body of a stylesheet function, the <termref def="dt-focus">focus</termref>
               is initially <termref def="dt-absent">absent</termref>; this means that any attempt to reference the context item,
               context position, or context size is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.
               <xerrorref spec="XP" class="DY" code="0002"/></p><p>It is not possible within the body of the <termref def="dt-stylesheet-function">stylesheet function</termref> to access the values of local variables that were
               in scope in the place where the function call was written. Global variables, however,
               remain available.</p><example><head>A Stylesheet Function</head><p>The following example creates a recursive <termref def="dt-stylesheet-function">stylesheet function</termref> named <code>str:reverse</code> that reverses the
                  words in a supplied sentence, and then invokes this function from within a
                     <termref def="dt-template-rule">template rule</termref>. </p><eg xml:space="preserve">&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</eg><p>An alternative way of writing the same function is to implement the conditional
                  logic at the XSLT level, thus:</p><eg xml:space="preserve">&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence 
           select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</eg></example><example><head>Declaring the Return Type of a Function</head><p>The following example illustrates the use of the <code>as</code> attribute in a
                  function definition. It returns a string containing the representation of its
                  integer argument, expressed as a roman numeral. For example, the function call
                     <code>num:roman(7)</code> will return the string <code>"vii"</code>. This
                  example uses the <elcode>xsl:number</elcode> instruction, described in <specref ref="number"/>. The <elcode>xsl:number</elcode> instruction returns a text
                  node, and the <termref def="dt-function-conversion-rules">function conversion
                     rules</termref> are invoked to convert this text node to the type declared in
                  the <elcode>xsl:function</elcode> element, namely <code>xs:string</code>. So the
                  text node is <termref def="dt-atomization">atomized</termref> to a string.</p><eg xml:space="preserve">&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;</eg></example><example diff="add" at="D"><head>A Higher-Order Function</head><p>XPath 3.0 introduces the ability to pass function items as argument to a function.
                  A function that takes function items as arguments is known as a higher-order
                  function.</p><p>The following example is a higher-order function that operates on any
                  tree-structured data, for example an organization chart. Given as input a function
                  that finds the direct subordinates of a node in this tree structure (for example,
                  the direct reports of a manager, or the geographical subdivisions of an
                  administrative area), it determines whether one object is present in the subtree
                  rooted at another object (for example, whether one person is among the staff
                  managed directly or indirectly by a manager, or whether one parcel of land is
                  contained directly or indirectly within another parcel. The function does not
                  check for cycles in the data.</p><eg xml:space="preserve">&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;</eg><p>Given source data representing an organization chart in the form of elements such
                  as:</p><eg xml:space="preserve">&lt;employee id="P57832" manager="P68951"/&gt;</eg><p>the following function can be defined to get the direct reports of a manager:</p><eg xml:space="preserve">&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = current()/@id]"/&gt;
    &lt;/xsl:function&gt;</eg><p>It is then possible to test whether one employee $E reports directly or indirectly
                  to another employee $M by means of the function call:</p><eg xml:space="preserve">f:is-subordinate($M, $E, f:direct-reports#1)</eg></example></div2><div2 id="dynamic-xpath" diff="add" at="B"><head>Dynamic XPath Evaluation</head><e:element-syntax name="evaluate"><e:in-category name="instruction"/><e:attribute name="xpath" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="as" required="no"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="base-uri" required="no"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="context-item" required="no"><e:data-type name="expression"/></e:attribute><e:attribute name="namespace-context" required="no"><e:data-type name="expression"/></e:attribute><e:attribute name="schema-aware" required="no"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:choice repeat="zero-or-more"><e:element name="with-param"/><e:element name="fallback"/></e:choice><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:evaluate</elcode> instruction constructs an XPath expression in the
               form of a string, evaluates the expression in a specified context, and returns the
               result of the evaluation.</p><p>The expression given as the value of the <code>xpath</code> attribute is evaluated
               and the result is converted to a string using the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p><p><termdef id="dt-target-expression" term="target expression">The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <term>target expression</term>.</termdef></p><p><error spec="XT" type="dynamic" class="DE" code="3160"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-target-expression">target
                        expression</termref>
                     <error.extra>of an <elcode>xsl:evaluate</elcode> instruction</error.extra> is
                     not a valid XPath 3.0 expression (that is, if a static error occurs when
                     analyzing the string according to the rules of the XPath 3.0
                     specification).</p></error></p><p>The <code>as</code> attribute, if present, indicates the required type of the result.
               If the attribute is absent, the required type is <code>item()*</code>, which allows
               any result. The result of evaluating the <termref def="dt-target-expression">target
                  expression</termref> is converted to the required type using the <termref def="dt-function-conversion-rules">function conversion rules</termref>. This may
               cause a <termref def="dt-type-error">type error</termref> if conversion is not
               possible. The result after conversion is returned as the result of the
                  <elcode>xsl:evaluate</elcode> instruction.</p><p>The <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> for the
                  <termref def="dt-target-expression">target expression</termref> is as follows:</p><ulist><item><p>XPath 1.0 compatibility mode is <code>false</code>.</p></item><item><p>Statically known namespaces and default element/type namespace:</p><ulist><item><p>if the <code>namespace-context</code> attribute is present, then its
                           value is an <termref def="dt-expression">expression</termref> whose
                           required type is a single node. The expression is evaluated, and the
                           in-scope namespaces of the resulting node are used as the statically
                           known namespaces for the target expression. The binding for the default
                           namespace in the in-scope namespaces is used as the default namespace for
                           elements and types in the target expression.</p><p>
                           <error spec="XT" type="type" class="TE" code="3170"><p>It is a <termref def="dt-type-error">type error</termref> if the
                                 result of evaluating the <code>namespace-context</code> attribute
                                 of the <elcode>xsl:evaluate</elcode> instruction is anything other
                                 than a single node.</p></error>
                        </p></item><item><p>if the <code>namespace-context</code> attribute is absent, then the
                           in-scope namespaces of the <elcode>xsl:evaluate</elcode> instruction
                           (with the exception of any binding for the default namespace) are used as
                           the statically known namespaces for the target expression, and the value
                           of the innermost <code>[xsl:]xpath-default-namespace</code> attribute, if
                           any, is used as the default namespace for elements and types in the
                           target expression.</p></item></ulist><note><p>XPath 3.0 allows expanded names to be written in a context-independent way
                        using the syntax <code>"namespace-uri":local-name</code></p></note></item><item><p>Default function namespace: the <termref def="dt-standard-function-namespace">standard function namespace</termref>.</p></item><item><p>In-scope schema definitions: if the <code>schema-aware</code> attribute is
                     present and has the <termref def="dt-effective-value">effective value</termref>
                     <code>yes</code>, then the in-scope schema definitions from the stylesheet
                     context (that is, the schema definitions imported using
                        <elcode>xsl:import-schema</elcode>). Otherwise, the built-in types (see
                        <specref ref="built-in-types"/>).</p></item><item><p>In-scope variables: the variables defined in the contained
                        <elcode>xsl:with-param</elcode> elements.</p><note><p>Variables declared in the stylesheet in <elcode>xsl:variable</elcode> or
                           <elcode>xsl:param</elcode> elements are <emph>not</emph> in-scope within
                        the target expression.</p></note></item><item><p>Function signatures: All <termref def="dt-core-function">core
                        functions</termref>; constructor functions for atomic types included in the
                     in-scope schema definitions; user-defined functions declared using
                        <elcode>xsl:function</elcode> <phrase diff="add" at="K">(but not those declared using
                     <elcode>xsl:accumulator</elcode>)</phrase>; and an <termref def="dt-implementation-defined">implementation-defined</termref> set of
                        <termref def="dt-extension-function">extension functions</termref>.</p><p>Note that this set deliberately excludes XSLT-defined functions in the <termref def="dt-standard-function-namespace">standard function namespace</termref>
                     including for example, <function>key</function>,
                        <function>current-group</function>, and <function>system-property</function>
                     A list of these functions is in <specref ref="XSLT-defined-functions"/>.</p><imp-def-feature>The set of extension functions available in the static context
                     for the target expression of <elcode>xsl:evaluate</elcode> is <termref def="dt-implementation-defined"/>.</imp-def-feature></item><item><p>Statically known collections: the same as the collations available at this
                     point in the stylesheet.</p></item><item><p>Default collation: the same as the default collation defined at this point in
                     the stylesheet (for example, by use of the <code>[xsl:]default-collation</code>
                     attribute)</p></item><item><p>Base URI: if the <code>base-uri</code> attribute is present, then its <termref def="dt-effective-value">effective value</termref>; otherwise, the base URI
                     of the <elcode>xsl:evaluate</elcode> instruction.</p></item><item><p>Statically known documents: the empty set</p></item><item><p>Statically known collections: the empty set</p></item><item><p>Statically known default collection type: <code>node()*</code></p></item></ulist><p diff="chg" at="K">The dynamic context for evaluation of the target expression is 
            as follows:</p><ulist><item><p>The context item, position, and size depend on the result of evaluating
               the expression in the <code>context-item</code> attribute. If this attribute is
               absent, or if the result is an empty sequence, then the context item, position, and
               size for evaluation of the target expression are all <termref def="dt-absent"/>.
               If the result of evaluating the <code>context-item</code> expression is a single
               item, then the target expression is evaluated with a <termref def="dt-singleton-focus"/>
               based on this item.</p><p><error spec="XT" type="type" class="TE" code="3210"><p>If the result of evaluating the 
                     <code>context-item</code> expression <error.extra>of an <elcode>xsl:evaluate</elcode> instruction</error.extra>
                  is a sequence containing more than one item, then a <termref def="dt-type-error"/>
                   is signaled.</p></error></p></item><item><p>The <term>variable values</term> consists of the values bound to 
                  parameters defined in the contained
                  <elcode>xsl:with-param</elcode> elements, which are evaluated as described in
                  <specref ref="variable-values"/>.</p></item><item><p>The XSLT-specific aspects of the dynamic context described in
                  <specref ref="additional-dynamic-context"/> are all <termref def="dt-absent"/>.</p></item><item><p>All other aspects of the dynamic context are the same as the
                  dynamic context for the <elcode>xsl:evaluate</elcode> instruction itself.</p></item></ulist><p>The dynamic context for evaluation of the target expression is the same as the
               dynamic context for the <elcode>xsl:evaluate</elcode> instruction (in particular, the
                  <termref def="dt-focus">focus</termref> is the same), except for </p><p>An XSLT 3.0 <termref def="dt-processor">processor</termref> will ignore any
                  <elcode>xsl:fallback</elcode> children of the <elcode>xsl:evaluate</elcode>
               instruction; they can be used to define the behavior of an XSLT 1.0 or XSLT 2.0
               processor when this instruction is encountered.</p><p>The XPath expression is evaluated in the same <xtermref ref="execution-scope" spec="FO30">execution scope</xtermref> as the calling XSLT transformation; this
               means that the results of <xtermref spec="FO30" ref="dt-deterministic">deterministic</xtermref>
               functions such as <xfunction>doc</xfunction> or
                  <xfunction>current-dateTime</xfunction> will be consistent between the calling
               stylesheet and the called XPath expression.</p><p diff="add" at="E">It is a <termref def="dt-nonrec-dynamic-error"/> if evaluation of
               the XPath expression fails with a dynamic error. The XPath-defined error code is used
               unchanged.</p><note><p>Implementations wanting to avoid the cost of repeated compilation of the same
                  XPath expression should cache the compiled form internally.</p></note><p diff="add" at="M">There may be circumstances where it is inappropriate to
               allow use of <elcode>xsl:evaluate</elcode>. Implementations <rfc2119>should</rfc2119>
               provide mechanisms allowing calls on <elcode>xsl:evaluate</elcode> to be disabled.
               Implementations <rfc2119>may</rfc2119> disable the feature by default, and they
               <rfc2119>may</rfc2119> disable it unconditionally.
            </p><p diff="add" at="M">The function call <code>element-available('xsl:evaluate')</code>
            must return false if use of <elcode>xsl:evaluate</elcode> is disabled, and must return true
            if it is enabled.</p><p><error spec="XT" type="dynamic" class="DE" code="3175"><p>It is a <termref def="dt-nonrec-dynamic-error"/> 
               if an <elcode>xsl:evaluate</elcode>
               instruction is evaluated when use of <elcode>xsl:evaluate</elcode> is disabled.
            </p></error></p><note><p diff="add" at="L">Stylesheet authors need to be aware of the security risks associated with the
               use of <elcode>xsl:evaluate</elcode>. The instruction should not be used to execute
               code from an untrusted source. To avoid the risk of code injection, user-supplied
               data should never be inserted into the expression using string concatenation, but
               should always be referenced by use of parameters.</p></note><note><p diff="add" at="M">A processor <rfc2119>may</rfc2119> permanently disable
            the use of <elcode>xsl:evaluate</elcode>. Such a processor must nevertheless treat the use
            of <elcode>xsl:evaluate</elcode> as a dynamic error rather than a static error, so that
            applications can test for its availability and include fallback logic for use when it is
            not available, either by calling <function>element-available</function> or by use of
            <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>.</p></note><example><head>Using a Dynamic Sort Key</head><p>A common requirement is to sort a table on the value of an expression which is
                  selected at run-time, perhaps by supplying the expression as a string-valued
                  parameter to the stylesheet. Suppose that such an expression is supplied to the
                  parameter:</p><eg xml:space="preserve">&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;</eg><p>Then the data may be sorted as follows:</p><eg xml:space="preserve">&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;</eg><p>Note the importance in this use case of caching the compiled expression, since it
                  is evaluated repeatedly, once for each item in the list being sorted.</p></example><example diff="add" at="K"><head>Getting a Function if it Exists</head><p>The <xfunction>function-lookup</xfunction> function, if it were not available in the
               standard library, could be implemented like this:</p><eg xml:space="preserve">
     &lt;xsl:function name="f:function-lookup"&gt;
       &lt;xsl:param name="name" as="xs:QName"/&gt;
       &lt;xsl:param name="arity" as="xs:integer"/&gt;
       &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                            || local-name-from-QName($name) || '#' || $arity"&gt;
         &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
         &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
       &lt;/xsl:evaluate&gt;
     &lt;/xsl:function&gt;  
     </eg><p>The <elcode>xsl:evaluate</elcode> instruction uses the supplied QName and arity to construct an
               expression of the form <code>Q{namespace-uri}local#arity</code>, which is then evaluated
               to return a function item representing the requested function.</p></example></div2></div1><div1 id="creating-new-nodes"><head>Creating Nodes and Sequences</head><p>This section describes instructions that directly create new nodes, or sequences of
            nodes, atomic values, <phrase diff="add" at="C">and/or function items</phrase>.</p><div2 id="literal-result-element"><head>Literal Result Elements</head><p>
               <termdef id="dt-literal-result-element" term="literal result element">In a <termref def="dt-sequence-constructor">sequence constructor</termref>, an element in the
                     <termref def="dt-stylesheet">stylesheet</termref> that does not belong to the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> and that is not an
                     <termref def="dt-extension-instruction">extension instruction</termref> (see
                     <specref ref="extension-instruction"/>) is classified as a <term>literal result
                     element</term>.</termdef> A literal result element is evaluated to construct a
               new element node with the same <termref def="dt-expanded-qname">expanded QName</termref> (that is, the same namespace URI, local name, and
               namespace prefix). The result of evaluating a literal result element is a node
               sequence containing one element, the newly constructed element node.</p><p>The content of the element is a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> (see <specref ref="sequence-constructors"/>). The sequence
               obtained by evaluating this sequence constructor, after prepending any attribute
               nodes produced as described in <specref ref="attributes-for-lres"/> and namespace
               nodes produced as described in <specref ref="lre-namespaces"/>, is used to construct
               the content of the element, following the rules in <specref ref="constructing-complex-content"/>
            </p><p>The base URI of the new element is copied from the base URI of the literal result
               element in the stylesheet, unless the content of the new element includes an
                  <code>xml:base</code> attribute, in which case the base URI of the new element is
               the value of that attribute, resolved (if it is a relative URI <phrase diff="add" at="F">reference</phrase>) against the base URI
               of the literal result element in the stylesheet. (Note, however, that this is only
               relevant when creating a parentless element. When the literal result element is
               copied to form a child of an element or document node, the base URI of the new copy
               is taken from that of its new parent.)</p><div3 id="setting-annotation-for-lre"><head>Setting the Type Annotation for Literal Result Elements</head><p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used
                  on a literal result element to invoke validation of the contents of the element
                  against a type definition or element declaration in a schema, and to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new element
                  node will carry. These attributes also affect the type annotation carried by any
                  elements and attributes that have the new element node as an ancestor. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted.</p><p>The value of the <code>xsl:validation</code> attribute, if present, must be one of
                  the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or
                     <code>strip</code>. The value of the <code>xsl:type</code> attribute, if
                  present, must be an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase> identifying a type
                  definition that is present in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the stylesheet. Neither attribute may
                  be specified as an <termref def="dt-attribute-value-template">attribute value
                     template.</termref> The effect of these attributes is described in <specref ref="validation"/>.</p></div3><div3 id="attributes-for-lres"><head>Attribute Nodes for Literal Result Elements</head><p>Attribute nodes for a literal result element may be created by including
                     <elcode>xsl:attribute</elcode> instructions within the <termref def="dt-sequence-constructor">sequence constructor</termref>. Additionally,
                  attribute nodes are created corresponding to the attributes of the literal result
                  element in the stylesheet, and as a result of expanding the
                     <code>xsl:use-attribute-sets</code> attribute of the literal result element, if
                  present.</p><p>The sequence that is used to construct the content of the literal result element
                  (as described in <specref ref="constructing-complex-content"/>) is the
                  concatenation of the following four sequences, in order:</p><olist><item><p>The sequence of namespace nodes produced as described in <specref ref="lre-namespaces"/>.</p></item><item><p>The sequence of attribute nodes produced by expanding the
                           <code>xsl:use-attribute-sets</code> attribute (if present) following the
                        rules given in <specref ref="attribute-sets"/>
                     </p></item><item><p>The attributes produced by processing the attributes of the literal result
                        element itself, other than attributes in the <termref def="xslt-namespace">XSLT namespace</termref>. The way these are processed is described
                        below.</p></item><item><p>The sequence produced by evaluating the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, if the
                        element is not empty.</p></item></olist><note><p>The significance of this order is that an attribute produced by an
                        <code>xsl:attribute</code>, <elcode>xsl:copy</elcode>, or
                        <elcode>xsl:copy-of</elcode> instruction in the content of the literal
                     result element takes precedence over an attribute produced by expanding an
                     attribute of the literal result element itself, which in turn takes precedence
                     over an attribute produced by expanding the <code>xsl:use-attribute-sets</code>
                     attribute. This is because of the rules in <specref ref="constructing-complex-content"/>, which specify that when two or more
                     attributes in the sequence have the same name, all but the last of the
                     duplicates are discarded.</p><p>Although the above rules place namespace nodes before attributes, this is not
                     strictly necessary, because the rules in <specref ref="constructing-complex-content"/> allow the namespaces and attributes to
                     appear in any order so long as both come before other kinds of node. The order
                     of namespace nodes and attribute nodes in the sequence has no effect on the
                     relative position of the nodes in document order once they are added to a
                     tree.</p></note><p>Each attribute of the literal result element, other than an attribute in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, is processed to
                  produce an attribute for the element in the <termref def="dt-result-tree">result
                     tree</termref>.</p><p>The value of such an attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>: it can
                  therefore contain <termref def="dt-expression">expressions</termref> contained in
                  curly brackets (<code>{}</code>). The new attribute node will have the same
                     <termref def="dt-expanded-qname">expanded QName</termref> (that is, the same
                  namespace URI, local name, and namespace prefix) as the attribute in the
                  stylesheet tree, and its <termref def="dt-string-value">string value</termref>
                  will be the same as the <termref def="dt-effective-value">effective
                     value</termref> of the attribute in the stylesheet tree. The <termref def="dt-annotation">type annotation</termref> on the attribute will initially
                  be <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                     value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>.</p><note><p>The eventual <termref def="dt-annotation">type annotation</termref> of the
                     attribute in the <termref def="dt-result-tree">result tree</termref> depends on
                     the <code>xsl:validation</code> and <code>xsl:type</code> attributes of the
                     parent literal result element, and on the instructions used to create its
                     ancestor elements. If the <code>xsl:validation</code> attribute is set to
                        <code>preserve</code> or <code>strip</code>, the type annotation will be
                        <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                        value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>. If the
                        <code>xsl:validation</code> attribute is set to <code>strict</code> or
                        <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the
                     type annotation on the attribute will be set as a result of the schema
                     validation process applied to the parent element. If neither attribute is
                     present, the type annotation on the attribute will be
                        <code>xs:untypedAtomic</code>.</p></note><p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
                  perform attribute value normalization by effectively applying the
                     <xfunction>normalize-space</xfunction> function to the value of the attribute,
                  and the resulting attribute node must be given the <code>is-id</code>
                  property.</p><p>
                  <error spec="XT" type="dynamic" class="RE" code="0795"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic
                           error</termref> if the name of a constructed attribute is
                           <code>xml:space</code> and the value is not either <code>default</code>
                        or <code>preserve</code>. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref>
                           is to construct the attribute with the value as requested.</error.action>
                     </p></error> <phrase diff="chg" at="L">This applies however the attribute is constructed 
                     (for example, by using a literal result
                  element, by using the <elcode>xsl:attribute</elcode> instruction,
                  or by implicit or explicit copying from a source document).</phrase></p><note><p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and
                        <code>xml:id</code> attributes have two effects in XSLT. They behave as
                     standard XSLT attributes, which means for example that if they appear on a
                     literal result element, they will be copied to the <termref def="dt-result-tree">result tree</termref> in the same way as any other
                     attribute. In addition, they have their standard meaning as defined in the core
                     XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet
                     affects the base URI of the element on which it appears, and an
                        <code>xml:space</code> attribute affects the interpretation of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> within that
                     element. One consequence of this is that it is inadvisable to write these
                     attributes as attribute value templates: although an XSLT processor will
                     understand this notation, the XML parser will not. See also <specref ref="namespace-aliasing"/> which describes how to use
                        <elcode>xsl:namespace-alias</elcode> with these attributes.</p><p>The same is true of the schema-defined attributes <code>xsi:type</code>,
                        <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and
                        <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema
                     processor, these attributes will be recognized and interpreted by the schema
                     processor, but in addition the XSLT processor treats them like any other
                     attribute on a literal result element: that is, their <termref def="dt-effective-value">effective value</termref> (after expanding <termref def="dt-attribute-value-template">attribute value templates</termref>) is
                     copied to the result tree in the same way as any other attribute. If the
                        <termref def="dt-result-tree">result tree</termref> is validated, the copied
                     attributes will again be recognized and interpreted by the schema
                     processor.</p><p>None of these attributes will be generated in the <termref def="dt-result-tree">result tree</termref> unless the stylesheet writes them to the result tree
                     explicitly, in the same way as any other attribute.</p></note><p>
                  <error spec="XT" type="static" class="SE" code="0805"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        attribute on a literal result element is in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, unless it is one of the
                        attributes explicitly defined in this specification.</p></error>
               </p><note><p>If there is a need to create attributes in the XSLT namespace, this can be
                     achieved using <elcode>xsl:attribute</elcode>, or by means of the
                        <elcode>xsl:namespace-alias</elcode> declaration.</p></note></div3><div3 id="lre-namespaces"><head>Namespace Nodes for Literal Result Elements</head><p>The created element node will have a copy of the namespace nodes that were present
                  on the element node in the stylesheet tree with the exception of any namespace
                  node whose <termref def="dt-string-value">string value</termref> is designated as
                  an <term>excluded namespace</term>. Special considerations apply to aliased
                  namespaces: see <specref ref="namespace-aliasing"/>
               </p><p>The following namespaces are designated as excluded namespaces:</p><ulist><item><p>The <termref def="dt-xslt-namespace">XSLT namespace</termref> URI
                           (<code>http://www.w3.org/1999/XSL/Transform</code>)</p></item><item><p>A namespace URI declared as an extension namespace (see <specref ref="extension-instruction"/>)</p></item><item><p>A namespace URI designated by using an
                           <code>[xsl:]exclude-result-prefixes</code> attribute either on the
                        literal result element itself or on an ancestor element. The attribute
                           <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent
                        element is <emph>not</emph> in the XSLT namespace.</p><p>The value of the attribute is either <code>#all</code>, or a
                        whitespace-separated list of tokens, each of which is either a namespace
                        prefix or <code>#default</code>. The namespace bound to each of the prefixes
                        is designated as an excluded namespace.</p><p>
                        <error class="SE" type="static" spec="XT" code="0808"><p>It is a <termref def="dt-static-error">static error</termref> if a
                              namespace prefix is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and there is
                              no namespace binding in scope for that prefix.</p></error>
                     </p><p>The default namespace of the parent element of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute (see <xspecref spec="DM30" ref="ElementNode"/>) may be designated as an excluded
                        namespace by including <code>#default</code> in the list of namespace
                        prefixes.</p><p>
                        <error class="SE" type="static" spec="XT" code="0809"><p>It is a <termref def="dt-static-error">static error</termref> if the
                              value <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.</p></error>
                     </p><p>The value <code>#all</code> indicates that all namespaces that are in scope
                        for the stylesheet element that is the parent of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute are designated as
                        excluded namespaces.</p><p>The designation of a namespace as an excluded namespace is effective within
                        the subtree of the stylesheet module rooted at the element bearing the
                           <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at
                        an <elcode>xsl:stylesheet</elcode> element does not include any stylesheet
                        modules imported or included by children of that
                           <elcode>xsl:stylesheet</elcode> element.</p></item></ulist><p>The excluded namespaces, as described above, <emph>only</emph> affect namespace
                  nodes copied from the stylesheet when processing a literal result element. There
                  is no guarantee that an excluded namespace will not appear on the <termref def="dt-result-tree">result tree</termref> for some other reason. Namespace
                  nodes are also written to the result tree as part of the process of namespace
                  fixup (see <specref ref="namespace-fixup"/>), or as the result of instructions
                  such as <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode>.</p><note><p>When a stylesheet uses a namespace declaration only for the purposes of
                     addressing a <termref def="dt-source-tree">source tree</termref>, specifying
                     the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will
                     avoid superfluous namespace declarations in the serialized <termref def="dt-result-tree">result tree</termref>. The attribute is also useful to
                     prevent namespaces used solely for the naming of stylesheet functions or
                     extension functions from appearing in the serialized result tree.</p></note><example><head>Excluding Namespaces from the Result Tree</head><p>For example, consider the following stylesheet:</p><eg xml:space="preserve">&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg><p>The result of this stylesheet will be:</p><eg xml:space="preserve">&lt;foo xmlns:d="d.uri"/&gt;</eg><p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue
                     of the <code>exclude-result-prefixes</code> attribute on the
                        <elcode>xsl:stylesheet</elcode> element, and the namespace
                        <code>c.uri</code> is excluded by virtue of the
                        <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code>
                     element. The setting <code>#all</code> does not affect the namespace
                        <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace
                     for the <elcode>xsl:stylesheet</elcode> element. The element in the <termref def="dt-result-tree">result tree</termref> does not have a namespace node
                     corresponding to <code>xmlns:a2="a.uri"</code> because the effect of
                        <code>exclude-result-prefixes</code> is to designate the namespace URI
                        <code>a.uri</code> as an excluded namespace, irrespective of how many
                     prefixes are bound to this namespace URI.</p><p>If the stylesheet is changed so that the literal result element has an
                     attribute <code>b:bar="3"</code>, then the element in the <termref def="dt-result-tree">result tree</termref> will typically have a namespace
                     declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different
                     namespace prefix if this is necessary to avoid conflicts). The
                        <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an
                     excluded namespace, so the namespace node is not automatically copied from the
                     stylesheet, but the presence of an attribute whose name is in the namespace
                        <code>b.uri</code> forces the namespace fixup process (see <specref ref="namespace-fixup"/>) to introduce a namespace node for this
                     namespace.</p></example><p>A literal result element may have an optional <code>xsl:inherit-namespaces</code>
                  attribute, with the value <code>yes</code> or <code>no</code>. The default value
                  is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then
                  the namespace nodes created for the newly constructed element are copied to the
                  children and descendants of the newly constructed element, as described in
                     <specref ref="constructing-complex-content"/>. If the value is set to
                     <code>no</code>, then these namespace nodes are not automatically copied to the
                  children. This may result in namespace undeclarations (such as
                     <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
                  appearing on the child elements when a <termref def="dt-final-result-tree">final
                     result tree</termref> is serialized.</p></div3><div3 id="conditional-literal-result-elements" diff="add" at="L"><head>Conditional Creation of Literal Result Elements</head><p>If a literal result element has an <code>xsl:on-empty</code> attribute, then
               the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. If the
               attribute is present and the content of the constructed element contains nothing
               other than namespace nodes and zero-length text nodes, then instead of returning
               the constructed element, the instruction returns the result of evaluating the
               expression in the <code>xsl:on-empty</code> attribute.</p><p>In this situation (when no element is returned because the content is empty),
               the <code>xsl:validation</code> and <code>xsl:type</code> attributes are ignored: no
               validation of the content is performed.</p><p>Note that when a literal result element has one or more attributes (other than
               attributes in the XSLT namespace), or when it references a non-empty attribute set,
               the <code>on-empty</code> attribute has no effect because these conditions will
               not be satisfied.</p><example><head>Generating a Wrapper Element for a non-Empty Sequence</head><p>The following example generates an <code>events</code> element if
                     and only if there are one or more <code>event</code> elements. The code could
                     be written like this:</p><eg xml:space="preserve">
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</eg><p>However, the above code would not be guaranteed streamable. To make it
                     streamable, it can be rewritten as:</p><eg xml:space="preserve">
&lt;events xsl:on-empty="()"&gt;
    &lt;xsl:copy-of select="event"/&gt;
&lt;/events&gt;</eg></example><note><p>The reason for introducing the <code>on-empty</code> attribute
                  is primarily to make it easier to write applications that conform to the rules
                  for guaranteed streamability. A common requirement is to generate a wrapper element
                  for a sequence of elements (for example an <code>events</code> wrapper
                  for a sequence of <code>event</code> elements) only if the content sequence
                  is non-empty. Without the <code>xsl:on-empty</code> attribute this is difficult to
                  achieve, because testing whether any <code>event</code> element exists and
                  processing the set of <code>event</code> elements both count as <termref def="dt-consuming"/>
                  instructions.</p></note></div3><div3 id="namespace-aliasing"><head>Namespace Aliasing</head><p>When a stylesheet is used to define a transformation whose output is itself a
                  stylesheet module, or in certain other cases where the result document uses
                  namespaces that it would be inconvenient to use in the stylesheet, namespace
                  aliasing can be used to declare a mapping between a namespace URI used in the
                  stylesheet and the corresponding namespace URI to be used in the result
                  document.</p><p>
                  <termdef id="dt-literal-namespace-uri" term="literal namespace URI">A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <termref def="dt-result-tree">result tree</termref> is called a
                        <term>literal namespace URI</term>.</termdef>
               </p><p>
                  <termdef id="dt-target-namespace-uri" term="target namespace URI">The namespace
                     URI that is to be used in the <termref def="dt-result-tree">result
                        tree</termref> as a substitute for a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is called the <term>target namespace
                        URI</term>.</termdef>
               </p><p>Either of the <termref def="dt-literal-namespace-uri">literal namespace
                     URI</termref> or the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref> can be <emph>null</emph>: this is treated as a reference to the
                  set of names that are in no namespace.</p><e:element-syntax name="namespace-alias"><e:in-category name="declaration"/><e:attribute name="stylesheet-prefix" required="yes"><e:data-type name="prefix"/><e:constant value="#default"/></e:attribute><e:attribute name="result-prefix" required="yes"><e:data-type name="prefix"/><e:constant value="#default"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>
                  <termdef id="dt-alias" term="alias">A stylesheet can use the
                        <elcode>xsl:namespace-alias</elcode> element to declare that a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is being used
                     as an <term>alias</term> for a <termref def="dt-target-namespace-uri">target
                        namespace URI</termref>.</termdef>
               </p><p>The effect is that when names in the namespace identified by the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> are copied to
                  the <termref def="dt-result-tree">result tree</termref>, the namespace URI in the
                  result tree will be the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>, instead of the literal namespace URI. This applies to:</p><ulist><item><p>the namespace URI in the <termref def="dt-expanded-qname">expanded QName</termref> of a literal result element in the
                        stylesheet</p></item><item><p>the namespace URI in the <termref def="dt-expanded-qname">expanded QName</termref> of an attribute specified on a literal result
                        element in the stylesheet</p></item></ulist><p diff="add" at="I">The effect of an <elcode>xsl:namespace-alias</elcode> declaration
               is local to the <termref def="dt-package">package</termref> in which it appears: that is,
               it only affects the result of <termref def="dt-literal-result-element">literal result elements</termref>
               within the same package.</p><p>Where namespace aliasing changes the namespace URI part of the <termref def="dt-expanded-qname">expanded QName</termref> containing the name of an
                  element or attribute node, the namespace prefix in that expanded QName is replaced
                  by the prefix indicated by the <code>result-prefix</code> attribute of the
                     <elcode>xsl:namespace-alias</elcode> declaration.</p><p>The <elcode>xsl:namespace-alias</elcode> element declares that the namespace URI
                  bound to the prefix specified by the <code>stylesheet-prefix</code> is the
                     <termref def="dt-literal-namespace-uri">literal namespace URI</termref>, and
                  the namespace URI bound to the prefix specified by the <code>result-prefix</code>
                  attribute is the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>. Thus, the <code>stylesheet-prefix</code> attribute specifies the
                  namespace URI that will appear in the stylesheet, and the
                     <code>result-prefix</code> attribute specifies the corresponding namespace URI
                  that will appear in the <termref def="dt-result-tree">result tree</termref>. </p><p>The default namespace (as declared by <code>xmlns</code>) may be specified by
                  using <code>#default</code> instead of a prefix. If no default namespace is in
                  force, specifying <code>#default</code> denotes the null namespace URI. This
                  allows elements that are in no namespace in the stylesheet to acquire a namespace
                  in the result document, or vice versa.</p><p>If a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is
                  declared to be an alias for multiple different <termref def="dt-literal-namespace-uri">target namespace URIs</termref>, then the
                  declaration with the highest <termref def="dt-import-precedence">import
                     precedence</termref> is used.</p><p>
                  <error spec="XT" type="static" class="SE" code="0810"><p>It is a <termref def="dt-static-error">static error</termref> if 
                        <phrase diff="add" at="I">within a <termref def="dt-package">package</termref></phrase> there is
                        more than one such declaration <error.extra>more than one
                              <elcode>xsl:namespace-alias</elcode> declaration</error.extra> with
                        the same <termref def="dt-literal-namespace-uri">literal namespace
                           URI</termref> and the same <termref def="dt-import-precedence">import
                           precedence</termref> and different values for the <termref def="dt-target-namespace-uri">target namespace URI</termref>, unless
                        there is also an <elcode>xsl:namespace-alias</elcode> declaration with the
                        same <termref def="dt-literal-namespace-uri">literal namespace URI</termref>
                        and a higher import precedence. </p></error>
               </p><p>
                  <error spec="XT" type="static" class="SE" code="0812"><p>It is a <termref def="dt-static-error">static error</termref> if a value
                        other than <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <elcode>xsl:namespace-alias</elcode> element when there is
                        no in-scope binding for that namespace prefix.</p></error>
               </p><p>When a literal result element is processed, its namespace nodes are handled as
                  follows:</p><ulist><item><p>A namespace node whose string value is a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is not
                        copied to the <termref def="dt-result-tree">result tree</termref>.</p></item><item><p>A namespace node whose string value is a <termref def="dt-target-namespace-uri">target namespace URI</termref> is copied to
                        the <termref def="dt-result-tree">result tree</termref>, whether or not the
                        URI identifies an excluded namespace.</p></item></ulist><p>In the event that the same URI is used as a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and a <termref def="dt-target-namespace-uri">target namespace URI</termref>, the second of
                  these rules takes precedence.</p><note><p>These rules achieve the effect that the element generated from the literal
                     result element will have an in-scope namespace node that binds the
                        <code>result-prefix</code> to the <termref def="dt-target-namespace-uri">target namespace URI</termref>, provided that the namespace declaration
                     associating this prefix with this URI is in scope for both the
                        <elcode>xsl:namespace-alias</elcode> instruction and for the literal result
                     element. Conversely, the <code>stylesheet-prefix</code> and the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> will not
                     normally appear in the <termref def="dt-result-tree">result tree</termref>.</p></note><example><head>Using <elcode>xsl:namespace-alias</elcode> to Generate a Stylesheet</head><p>When literal result elements are being used to create element, attribute, or
                     namespace nodes that use the <termref def="dt-xslt-namespace">XSLT
                        namespace</termref> URI, the stylesheet may use an alias. </p><p>For example, the stylesheet</p><eg xml:space="preserve">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg><p>will generate an XSLT stylesheet from a document of the form:</p><eg xml:space="preserve">&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</eg><p>The output of the transformation will be a stylesheet such as the following.
                     Whitespace has been added for clarity. Note that an implementation may output
                     different namespace prefixes from those appearing in this example; however, the
                     rules guarantee that there will be a namespace node that binds the prefix
                        <code>xsl</code> to the URI
                        <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to
                     use the QName <code>xsl:version</code> in the content of the generated
                     stylesheet.</p><eg xml:space="preserve">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg></example><note><p>It may be necessary also to use aliases for namespaces other than the XSLT
                     namespace URI. For example, it can be useful to define an alias for the
                     namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
                     stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>,
                     and <code>xsi:schemaLocation</code> on a literal result element, without
                     running the risk that a schema processor will interpret these as applying to
                     the stylesheet itself. Equally, literal result elements belonging to a
                     namespace dealing with digital signatures might cause XSLT stylesheets to be
                     mishandled by general-purpose security software; using an alias for the
                     namespace would avoid the possibility of such mishandling.</p></note><example><head>Aliasing the XML Namespace</head><p>It is possible to define an alias for the XML namespace.</p><eg xml:space="preserve">
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg><p>produces the output:</p><eg xml:space="preserve">&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;</eg><p>This allows an <code>xml:space</code> attribute to be generated in the output
                     without affecting the way the stylesheet is parsed. The same technique can be
                     used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>,
                     and <code>xml:id</code>.</p></example><note><p>Namespace aliasing is only necessary when literal result elements are used. The
                     problem of reserved namespaces does not arise when using
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> to construct
                     the <termref def="dt-result-tree">result tree</termref>. Therefore, as an
                     alternative to using <elcode>xsl:namespace-alias</elcode>, it is always
                     possible to achieve the desired effect by replacing literal result elements
                     with <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode>
                     instructions.</p></note></div3></div2><div2 id="xsl-element"><head>Creating Element Nodes Using <code>xsl:element</code>
            </head><e:element-syntax name="element"><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:attribute-value-template><e:data-type name="qname"/></e:attribute-value-template></e:attribute><e:attribute name="namespace"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="inherit-namespaces"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="use-attribute-sets"><e:data-type name="eqnames"/></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="on-empty"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:element</elcode> instruction allows an element to be created with a
               computed name. The <termref def="dt-expanded-qname">expanded QName</termref> of the
               element to be created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute.</p><p>The result of evaluating the <elcode>xsl:element</elcode> instruction, 
               <phrase diff="chg" at="L">in usual circumstances</phrase>, is the newly constructed element node.</p><div3 id="xsl-element-content"><head>The Content of the Constructed Element Node</head><p>The content of the <elcode>xsl:element</elcode> instruction is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children,
               attributes, and namespaces of the created element. The sequence obtained by
               evaluating this sequence constructor (see <specref ref="sequence-constructors"/>) is
               used to construct the content of the element, as described in <specref ref="constructing-complex-content"/>.</p><p>The <elcode>xsl:element</elcode> element may have a <code>use-attribute-sets</code>
               attribute, whose value is a whitespace-separated list of QNames that identify
                  <elcode>xsl:attribute-set</elcode> declarations. If this attribute is present, it
               is expanded as described in <specref ref="attribute-sets"/> to produce a sequence of
               attribute nodes. This sequence is prepended to the sequence produced as a result of
               evaluating the <termref def="dt-sequence-constructor"/>, as described
               in <specref ref="constructing-complex-content"/>.</p></div3><div3 id="xsl-element-name"><head>The Name of the Constructed Element Node</head><p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0820"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:element</elcode> instruction</error.extra> is not a <termref def="dt-lexical-qname">lexical QName</termref>. </p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0830"><p>In the case of an <elcode>xsl:element</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical QName</termref>
                     whose prefix is not declared in an in-scope namespace declaration for the
                        <elcode>xsl:element</elcode> instruction.</p></error>
            </p><p>If the <code>namespace</code> attribute is not present then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:element</elcode> element, including any default
               namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded QName</termref> of the element has a null namespace URI. Otherwise, the
               string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded QName</termref> of the element to be created. The local part of the
                  <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                  <code>name</code> attribute is used as the local part of the <termref def="dt-expanded-qname">expanded QName</termref> of the element to be created.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0835"><!--Text replaced by erratum E6 change 2"--><p> It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:element</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p><!--End of text replaced by erratum E6--></error>
            </p><note><p>The XDM data model requires the name of a node to be an instance of
                     <code>xs:QName</code>, and XML Schema defines the namespace part of an
                     <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However, the
                  schema specification, and the specifications that it refers to, give
                  implementations some flexibility in how strictly they enforce these
                  constraints.</p></note><p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded QName</termref>
               representing the name of the new element node. In the event of a conflict a prefix
               may subsequently be added, changed, or removed during the namespace fixup process
               (see <specref ref="namespace-fixup"/>).<!--Text inserted by erratum E6 change 3"-->
               The term <emph>conflict</emph> here means any violation of the constraints defined in
                  <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix to refer
               to two different namespaces in the element and in one of its attributes, the use of
               the prefix <code>xml</code> to refer to a namespace other than the XML namespace, or
               any use of the prefix
               <code>xmlns</code>.<!--End of text inserted by erratum E6--></p></div3><div3 id="xsl-element-properties"><head>Other Properties of the Constructed Element Node</head><p>The <elcode>xsl:element</elcode> instruction has an optional
                  <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                  <code>no</code>. The default value is <code>yes</code>. If the value is set to
                  <code>yes</code>, or is omitted, then the namespace nodes created for the newly
               constructed element (whether these were copied from those of the source node, or
               generated as a result of namespace fixup) are copied to the children and descendants
               of the newly constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then
               these namespace nodes are not automatically copied to the children. This may result
               in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML
               Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements when a
                  <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p><p>The base URI of the new element is copied from the base URI of the
                  <elcode>xsl:element</elcode> instruction in the stylesheet, unless the content of
               the new element includes an <code>xml:base</code> attribute, in which case the base
               URI of the new element is the value of that attribute, resolved (if it is a relative
               URI) against the base URI of the <elcode>xsl:element</elcode> instruction in the
               stylesheet. (Note, however, that this is only relevant when creating parentless
               elements. When the new element is copied to form a child of an element or document
               node, the base URI of the new copy is taken from that of its new parent.)</p></div3><div3 id="annotation-for-constructed-element"><head>The Type Annotation of the Constructed Element Node</head><p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:element</elcode> instruction to invoke validation of the
                  contents of the element against a type definition or element declaration in a
                  schema, and to determine the <termref def="dt-annotation">type
                     annotation</termref> that the new element node will carry. These attributes
                  also affect the type annotation carried by any elements and attributes that have
                  the new element node as an ancestor. These two attributes are both optional, and
                  if one is specified then the other <rfc2119>must</rfc2119> be omitted. The
                  permitted values of these attributes and their semantics are described in <specref ref="validation"/>.</p><note><p>The final type annotation of the element in the <termref def="dt-result-tree">result tree</termref> also depends on the <code>type</code> and
                        <code>validation</code> attributes of the instructions used to create the
                     ancestors of the element.</p></note></div3><div3 id="xsl-element-on-empty" diff="add" at="L"><head>Conditional Construction of Element Nodes</head><p>If the <code>on-empty</code> attribute is present and the content of the
               constructed element as determined by the rules in <specref ref="xsl-element-content"/>
               (that is, the result of evaluating the sequence constructor and prepending any
               attributes generated by the <code>use-attribute-sets</code> attribute) is
               a sequence containing nothing other than namespace nodes and zero-length text nodes,
               then instead of returning the newly constructed element node, the instruction
               returns the result of evaluating the expression in the <code>on-empty</code>
               attribute.</p><p>In this situation (when no element is returned because the content is empty),
                  the <code>validation</code> and <code>type</code> attributes are ignored: no
                  validation of the content is performed.</p></div3></div2><div2 id="creating-attributes"><head>Creating Attribute Nodes Using <code>xsl:attribute</code>
            </head><e:element-syntax name="attribute"><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:attribute-value-template><e:data-type name="qname"/></e:attribute-value-template></e:attribute><e:attribute name="namespace"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="separator"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="on-empty"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="attribute-set"/><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:attribute</elcode> element can be used to add attributes to result
               elements whether created by literal result elements in the stylesheet or by
               instructions such as <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>. The
                  <termref def="dt-expanded-qname">expanded QName</termref> of the attribute to be
               created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute. Except
               in error cases, the result of evaluating an <elcode>xsl:attribute</elcode>
               instruction is the newly constructed attribute node.</p><p>The string value of the new attribute node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:attribute</elcode> element. <phrase diff="chg" at="K">These are mutually exclusive: if
               the <code>select</code> attribute is present then the sequence constructor must be empty,
               and if the sequence constructor is non-empty then the <code>select</code> attribute
               must be absent. If the <code>select</code> attribute is absent and the
               sequence constructor is empty</phrase>, then the string value of the new 
               attribute node will be a zero-length string. The way
               in which the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0840"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:attribute</elcode> element
                     is present unless the element has empty content.</p></error>
            </p><p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
               separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the default
               separator is a single space (#x20) when the content is specified using the
                  <code>select</code> attribute, or a zero-length string when the content is
               specified using a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p><p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0850"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of an
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not a
                        <termref def="dt-lexical-qname">lexical QName</termref>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0855"><p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is the string <code>xmlns</code>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0860"><p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical
                        QName</termref> whose prefix is not declared in an in-scope namespace
                     declaration for the <elcode>xsl:attribute</elcode> instruction.</p></error>
            </p><p>If the <code>namespace</code> attribute is not present, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:attribute</elcode> element, <emph>not</emph> including
               any default namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded QName</termref> of the attribute has a null namespace URI. Otherwise,
               the string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded QName</termref> of the attribute to be created. The local part of the
                  <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                  <code>name</code> attribute is used as the local part of the <termref def="dt-expanded-qname">expanded QName</termref> of the attribute to be
               created.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0865"><!--Text replaced by erratum E6 change 4"--><p> It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p><!--End of text replaced by erratum E6--></error>
            </p><note><p>The same considerations apply as for elements: <errorref spec="XT" class="DE" code="0835"/> in <specref ref="xsl-element"/>.</p></note><!--Text replaced by erratum E18 change 1"--><p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded QName</termref>
               representing the name of the new attribute node. In the event of a conflict this
               prefix may subsequently be added, changed, or removed during the namespace fixup
               process (see <specref ref="namespace-fixup"/>). If the attribute is in a non-null
               namespace and no prefix is specified, then the namespace fixup process will invent a
               prefix. The term <emph>conflict</emph> here means any violation of the constraints
               defined in <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix to
               refer to two different namespaces in the element and in one of its attributes, the
               use of the prefix <code>xml</code> to refer to a namespace other than the XML
               namespace, or any use of the prefix <code>xmlns</code>.</p><!--End of text replaced by erratum E18--><p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
               perform attribute value normalization by effectively applying the
                  <xfunction>normalize-space</xfunction> function to the value of the attribute, and
               the resulting attribute node must be given the <code>is-id</code> property. This
               applies whether the attribute is constructed using the <elcode>xsl:attribute</elcode>
               instruction or whether it is constructed using an attribute of a literal result
               element. This does not imply any constraints on the value of the attribute, or on its
               uniqueness, and it does not affect the <termref def="dt-annotation">type
                  annotation</termref> of the attribute, unless the containing document is
               validated.</p><note><p>The effect of setting the <code>is-id</code> property is that the parent element
                  can be located within the containing document by use of the
                     <xfunction>id</xfunction> function. In effect, XSLT when constructing a
                  document performs some of the functions of an <code>xml:id</code> processor, as
                  defined in <bibref ref="xml-id"/>; the other aspects of <code>xml:id</code>
                  processing are performed during validation.</p></note><example><head>Creating a List-Valued Attribute</head><p>The following instruction creates the attribute <code>colors="red green
                     blue"</code>:</p><eg xml:space="preserve">&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;</eg></example><example><head>Namespaces are not Attributes</head><p>It is not an error to write:</p><eg xml:space="preserve">&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;</eg><p>However, this will not result in the namespace declaration
                     <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output.
                  Instead, it will produce an attribute node with local name <code>xsl</code>, and
                  with a system-allocated namespace prefix mapped to the namespace URI
                     <code>file://some.namespace</code>. This is because the namespace fixup process
                  is not allowed to use <code>xmlns</code> as the name of a namespace node.</p></example><p>As described in <specref ref="constructing-complex-content"/>, in a sequence that is
               used to construct the content of an element, any attribute nodes
                  <rfc2119>must</rfc2119> appear in the sequence before any element, text, comment,
               or processing instruction nodes. Where the sequence contains two or more attribute
               nodes with the same <termref def="dt-expanded-qname">expanded QName</termref>, the
               one that comes last is the only one that takes effect.</p><note><p>If a collection of attributes is generated repeatedly, this can be done
                  conveniently by using named attribute sets: see <specref ref="attribute-sets"/>
               </p></note><div3 id="annotation-for-constructed-attribute"><head>Setting the Type Annotation for a Constructed Attribute Node</head><p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:attribute</elcode> instruction to invoke validation of the
                  contents of the attribute against a type definition or attribute declaration in a
                  schema, and to determine the <termref def="dt-annotation">type
                     annotation</termref> that the new attribute node will carry. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p><note><p>The final <termref def="dt-annotation">type annotation</termref> of the
                     attribute in the <termref def="dt-result-tree">result tree</termref> also
                     depends on the <code>type</code> and <code>validation</code> attributes of the
                     instructions used to create the ancestors of the attribute.</p></note></div3><div3 id="xsl-attribute-on-empty" diff="add" at="L"><head>Conditional Creation of Attribute Nodes</head><p>If the <code>on-empty</code> attribute is present and the string value of
                  the constructed attribute is a zero-length string, then instead of returning
                  the constructed attribute, the instruction returns the result of evaluating
                  the expression in the <code>on-empty</code> attribute.
               </p><p>In this situation (where the constructed attribute is not returned because
               its value is zero-length) the <code>validation</code> and <code>type</code>
               attributes are ignored; no validation of the content takes place.</p></div3></div2><div2 id="creating-text-nodes"><head>Creating Text Nodes</head><p>This section describes three different ways of creating text nodes: by means of
               literal text nodes in the stylesheet, or by using the <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode> instructions. It is also possible to create text
               nodes using the <elcode>xsl:number</elcode> instruction described in <specref ref="number"/>.</p><p>If and when the sequence that results from evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref> is used to form the
               content of a node, as described in <specref ref="constructing-simple-content"/> and
                  <specref ref="constructing-complex-content"/>, adjacent text nodes in the sequence
               are merged. Within the sequence itself, however, they exist as distinct nodes.</p><example><head>A Sequence of Text Nodes</head><p>The following function returns a sequence of three text nodes:</p><eg xml:space="preserve">&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</eg><p>When this function is called as follows:</p><eg xml:space="preserve">&lt;xsl:value-of select="f:wrap('---')"/&gt;</eg><p>the result is:</p><eg xml:space="preserve">(---)</eg><p>No additional spaces are inserted, because the calling
                     <elcode>xsl:value-of</elcode> instruction merges adjacent text nodes before
                  atomizing the sequence. However, the result of the instruction:</p><eg xml:space="preserve">&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</eg><p>is:</p><eg xml:space="preserve">( --- )</eg><p>because in this case the three text nodes are atomized to form three strings, and
                  spaces are inserted between adjacent strings.</p></example><p>It is possible to construct text nodes whose string value is zero-length. A
               zero-length text node, when atomized, produces a zero-length string. However,
               zero-length text nodes are ignored when they appear in a sequence that is used to
               form the content of a node, as described in <specref ref="constructing-complex-content"/> and <specref ref="constructing-simple-content"/>.</p><div3 id="literal-text-nodes"><head>Literal Text Nodes</head><p>A <termref def="dt-sequence-constructor"/> can
                  contain text nodes. Each text node in a sequence constructor remaining after
                     <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have
                  been stripped as specified in <specref ref="stylesheet-stripping"/> will construct
                  a new text node with the same <termref def="dt-string-value">string
                     value</termref>. The resulting text node is added to the result of the
                  containing sequence constructor.</p><p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a
                  template will be represented in the stylesheet tree by a text node that includes
                  the character <code>&lt;</code>. This will create a text node in the <termref def="dt-result-tree">result tree</termref> that contains a <code>&lt;</code>
                  character, which will be represented by the markup <code>&amp;lt;</code> (or an
                  equivalent character reference) when the result tree is serialized as an XML
                  document, unless otherwise specified using <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) or
                     <code>disable-output-escaping</code> (see <specref ref="disable-output-escaping"/>).</p></div3><div3 id="xsl-text"><head>Creating Text Nodes Using <code>xsl:text</code>
               </head><e:element-syntax name="text"><e:in-category name="instruction"/><e:attribute name="disable-output-escaping" deprecated="yes"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:text/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:text</elcode> element is evaluated to construct a new text node.
                  The content of the <elcode>xsl:text</elcode> element is a single text node whose
                  value forms the <termref def="dt-string-value">string value</termref> of the new
                  text node. An <elcode>xsl:text</elcode> element may be empty, in which case the
                  result of evaluating the instruction is a text node whose string value is the
                  zero-length string.</p><p>The result of evaluating an <elcode>xsl:text</elcode> instruction is the newly
                  constructed text node.</p><p>A text node that is an immediate child of an <elcode>xsl:text</elcode> instruction
                  will not be stripped from the stylesheet tree, even if it consists entirely of
                  whitespace (see <specref ref="strip"/>).</p><p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p><note><p>It is not always necessary to use the <elcode>xsl:text</elcode> instruction to
                     write text nodes to the <termref def="dt-result-tree">result tree</termref>.
                     Literal text can be written to the result tree by including it anywhere in a
                        <termref def="dt-sequence-constructor"/>, while
                     computed text can be output using the <elcode>xsl:value-of</elcode>
                     instruction. The principal reason for using <elcode>xsl:text</elcode> is that
                     it offers improved control over whitespace handling.</p></note></div3><div3 id="value-of"><head>Generating Text with <elcode>xsl:value-of</elcode>
               </head><p>Within a <termref def="dt-sequence-constructor"/>,
                  the <elcode>xsl:value-of</elcode> instruction can be used to generate computed
                  text nodes. The <elcode>xsl:value-of</elcode> instruction computes the text using
                  an <termref def="dt-expression">expression</termref> that is specified as the
                  value of the <code>select</code> attribute, or by means of contained instructions.
                  This might, for example, extract text from a <termref def="dt-source-tree">source
                     tree</termref> or insert the value of a variable. </p><e:element-syntax name="value-of"><e:in-category name="instruction"/><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="separator"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="disable-output-escaping" deprecated="yes"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:value-of</elcode> instruction is evaluated to construct a new text
                  node; the result of the instruction is the newly constructed text node.</p><p>The string value of the new text node may be defined either by using the
                     <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see <specref ref="sequence-constructors"/>)
                  that forms the content of the <elcode>xsl:value-of</elcode> element. 
                  <phrase diff="chg" at="K">These are mutually exclusive: if
                     the <code>select</code> attribute is present then the sequence constructor must be empty,
                     and if the sequence constructor is non-empty then the <code>select</code> attribute
                     must be absent. If the <code>select</code> attribute is absent and the
                     sequence constructor is empty, then the result of the instruction is a text node whose
                  string value is zero-length.</phrase> The way in which the value is
                  constructed is specified in <specref ref="constructing-simple-content"/>.</p><p>
                  <error spec="XT" type="static" class="SE" code="0870"><p>It is a <termref def="dt-static-error">static error</termref> if the
                           <code>select</code> attribute of the <elcode>xsl:value-of</elcode>
                        element is present when the content of the element is non-empty<phrase diff="del" at="L">, or if the
                           <code>select</code> attribute is absent when the content is empty.</phrase></p></error>
               </p><p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
                  separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the
                  default separator is a single space (#x20) when the content is specified using the
                     <code>select</code> attribute, or a zero-length string when the content is
                  specified using a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p><p><phrase diff="chg" at="D">Special rules apply when the instruction is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>.</phrase>
                  If no <code>separator</code> attribute is present, and if the <code>select</code>
                  attribute is present, then all items in the <termref def="dt-atomization">atomized</termref> result sequence other than the first are ignored.</p><example><head>Generating a List with Separators</head><p>The instruction:</p><eg xml:space="preserve">&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;</eg><p>produces the output:</p><eg xml:space="preserve">&lt;x&gt;1|2|3|4&lt;/x&gt;</eg></example><note><p>The <elcode>xsl:copy-of</elcode> element can be used to copy a sequence of
                     nodes to the <termref def="dt-result-tree">result tree</termref> without
                        <termref def="dt-atomization">atomization</termref>. See <specref ref="copy-of"/>.</p></note><p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p></div3></div2><div2 id="creating-document-nodes"><head>Creating Document Nodes</head><e:element-syntax name="document"><e:in-category name="instruction"/><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:document</elcode> instruction is used to create a new document node.
               The content of the <elcode>xsl:document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the new document node. A document node is created, and the sequence obtained by
               evaluating the sequence constructor is used to construct the content of the document,
               as described in <specref ref="constructing-complex-content"/>. The <termref def="dt-temporary-tree">temporary tree</termref> rooted at this document node
               forms the <termref def="dt-result-tree">result tree</termref>.</p><p>Except in error situations, the result of evaluating the
                  <elcode>xsl:document</elcode> instruction is a single node, the newly constructed
               document node.</p><note><p>The new document is not serialized. To construct a document that is to form a
                  final result rather than an intermediate result, use the
                     <elcode>xsl:result-document</elcode> instruction described in <specref ref="creating-result-trees"/>.</p></note><p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:document</elcode> instruction to validate the contents of the new
               document, and to determine the <termref def="dt-annotation">type annotation</termref>
               that elements and attributes within the <termref def="dt-result-tree">result
                  tree</termref> will carry. The permitted values and their semantics are described
               in <specref ref="validating-document-nodes"/>.</p><p>The base URI of the new document node is taken from the base URI of the
                  <elcode>xsl:document</elcode> instruction.</p><p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p><example><head>Checking Uniqueness Constraints in a Temporary Tree</head><p>The following example creates a temporary tree held in a variable. The use of an
                  enclosed <elcode>xsl:document</elcode> instruction ensures that uniqueness
                  constraints defined in the schema for the relevant elements are checked.</p><eg xml:space="preserve">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;</eg></example></div2><div2 id="creating-processing-instructions"><head>Creating Processing Instructions</head><e:element-syntax name="processing-instruction"><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:attribute-value-template><e:data-type name="ncname"/></e:attribute-value-template></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:processing-instruction</elcode> element is evaluated to create a
               processing instruction node.</p><p>The <elcode>xsl:processing-instruction</elcode> element has a
                  <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the processing instruction
               node. The value of the <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p><p>The string value of the new processing-instruction node may be defined either by
               using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:processing-instruction</elcode> element. 
               <phrase diff="chg" at="K">These are mutually exclusive: if
                  the <code>select</code> attribute is present then the sequence constructor must be empty,
                  and if the sequence constructor is non-empty then the <code>select</code> attribute
                  must be absent. If the <code>select</code> attribute is absent and the
                  sequence constructor is empty</phrase>, then the string value of the new
               processing-instruction node will be a zero-length string. The way in which the value
               is constructed is specified in <specref ref="constructing-simple-content"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0880"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the
                        <elcode>xsl:processing-instruction</elcode> element is present unless the
                     element has empty content.</p></error>
            </p><p>Except in error situations, the result of evaluating the
                  <elcode>xsl:processing-instruction</elcode> instruction is a single node, the
               newly constructed processing instruction node.</p><example><head>Creating a Processing Instruction</head><p>This instruction:</p><eg xml:space="preserve">&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;)"/&gt;</eg><p>creates the processing instruction</p><eg xml:space="preserve">&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</eg><p>Note that the <code>xml-stylesheet</code> processing instruction contains
                     <emph>pseudo-attributes</emph> in the form <code>name="value"</code>. Although
                  these have the same textual form as attributes in an element start tag, they are
                  not represented as XDM attribute nodes, and cannot therefore be constructed using
                     <elcode>xsl:attribute</elcode> instructions.</p></example><p>
               <error spec="XT" type="dynamic" class="DE" code="0890"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:processing-instruction</elcode> instruction</error.extra> is
                     not both an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt> and a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PITarget" xlink:type="simple">PITarget</xnt>.</p></error>
            </p><note><p>Because these rules disallow the name <code>xml</code>, the
                     <elcode>xsl:processing-instruction</elcode> cannot be used to output an XML
                  declaration. The <elcode>xsl:output</elcode> declaration should be used to control
                  this instead (see <specref ref="serialization"/>).</p></note><p>If the result of evaluating the content of the
                  <elcode>xsl:processing-instruction</elcode> contains the string
               <code>?&gt;</code>, this string is modified by inserting a space between the
                  <code>?</code> and <code>&gt;</code> characters.</p><p>The base URI of the new processing-instruction is copied from the base URI of the
                  <elcode>xsl:processing-instruction</elcode> element in the stylesheet. (Note,
               however, that this is only relevant when creating a parentless processing
               instruction. When the new processing instruction is copied to form a child of an
               element or document node, the base URI of the new copy is taken from that of its new
               parent.)</p></div2><div2 id="creating-namespace-nodes"><head>Creating Namespace Nodes</head><e:element-syntax name="namespace"><e:in-category name="instruction"/><e:attribute name="name" required="yes"><e:attribute-value-template><e:data-type name="ncname"/></e:attribute-value-template></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:namespace</elcode> element is evaluated to create a namespace node.
               Except in error situations, the result of evaluating the
                  <elcode>xsl:namespace</elcode> instruction is a single node, the newly constructed
               namespace node.</p><p>The <elcode>xsl:namespace</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the namespace node (that is,
               the namespace prefix). The value of the <code>name</code> attribute is interpreted as
               an <termref def="dt-attribute-value-template">attribute value template</termref>. If
               the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute is a zero-length string, a namespace node is added for
               the default namespace.</p><p>The string value of the new namespace node (that is, the namespace URI) may be
               defined either by using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:namespace</elcode> element. 
               <phrase diff="chg" at="K">These are mutually exclusive: if
                  the <code>select</code> attribute is present then the sequence constructor must be empty,
                  and if the sequence constructor is non-empty then the <code>select</code> attribute
                  must be absent.</phrase>
               
               Since the string value of a namespace node cannot be a zero-length string, <phrase diff="chg" at="K">either a 
               <code>select</code> attribute or a non-empty sequence constructor <rfc2119>must</rfc2119> be present</phrase>. 
               The way in which the value is constructed is specified in
                  <specref ref="constructing-simple-content"/>.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="0905"><!--Text replaced by erratum E6 change 6"--><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                     error</termref> if the string value of the new namespace
                     node is not valid in the lexical space of the datatype <code>xs:anyURI</code>,
                     or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p><!--End of text replaced by erratum E6--></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="0910"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:namespace</elcode> element
                     is present when the element has content other than one or more
                        <elcode>xsl:fallback</elcode> instructions, or if the <code>select</code>
                     attribute is absent when the element has empty content.</p></error>
            </p><p>Note the restrictions described in <specref ref="constructing-complex-content"/> for
               the position of a namespace node relative to other nodes in the node sequence
               returned by a sequence constructor.</p><example><head>Constructing a QName-Valued Attribute</head><p>This literal result element:</p><eg xml:space="preserve">&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;</eg><p>would typically cause the output document to contain the element:</p><eg xml:space="preserve">&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;</eg><p>In this case, the element is constructed using a literal result element, and the
                  namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore
                  have been added to the <termref def="dt-result-tree">result tree</termref> simply
                  by declaring it as one of the in-scope namespaces in the stylesheet. In practice,
                  the <elcode>xsl:namespace</elcode> instruction is more likely to be useful in
                  situations where the element is constructed using an <elcode>xsl:element</elcode>
                  instruction, which does not copy all the in-scope namespaces from the
                  stylesheet.</p></example><p>
               <error spec="XT" type="dynamic" class="DE" code="0920"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:namespace</elcode> instruction</error.extra> is neither a
                     zero-length string nor an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, or if
                     it is <code>xmlns</code>. </p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0925"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <elcode>xsl:namespace</elcode> instruction generates
                     a namespace node whose name is <code>xml</code> and whose string value is not
                        <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose
                     string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose
                     name is not <code>xml</code>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="0930"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if evaluating the <code>select</code> attribute or the
                     contained <termref def="dt-sequence-constructor"/>
                     of an <elcode>xsl:namespace</elcode> instruction results in a zero-length
                     string. </p></error>
            </p><p>For details of other error conditions that may arise, see <specref ref="sequence-constructors"/>.</p><note><p>It is rarely necessary to use <elcode>xsl:namespace</elcode> to create a namespace
                  node in the <termref def="dt-result-tree">result tree</termref>; in most
                  circumstances, the required namespace nodes will be created automatically, as a
                  side-effect of writing elements or attributes that use the namespace. An example
                  where <elcode>xsl:namespace</elcode> is needed is a situation where the required
                  namespace is used only within attribute values in the result document, not in
                  element or attribute names; especially where the required namespace prefix or
                  namespace URI is computed at run-time and is not present in either the source
                  document or the stylesheet.</p><p>Adding a namespace node to the <termref def="dt-result-tree">result tree</termref>
                  will never change the <termref def="dt-expanded-qname">expanded QName</termref> of
                  any element or attribute node in the result tree: that is, it will never change
                  the namespace URI of an element or attribute. It might, however, constrain the
                  choice of prefixes when namespace fixup is performed.</p><!--Text replaced by erratum E7 change 1"--><p>Namespace prefixes for element and attribute names are initially established by
                  the rules of the instruction that creates the element or attribute node, and in
                  the event of conflicts, they may be changed by the namespace fixup process
                  described in <specref ref="namespace-fixup"/>. The fixup process ensures that an
                  element has in-scope namespace nodes for the namespace URIs used in the element
                  name and in its attribute names, and the serializer will typically use these
                  namespace nodes to determine the prefix to use in the serialized output. The fixup
                  process cannot generate namespace nodes that are inconsistent with those already
                  present in the tree. This means that it is not possible for the processor to
                  decide the prefix to use for an element or for any of its attributes until all the
                  namespace nodes for the element have been added.</p><!--End of text replaced by erratum E7--><p>If a namespace prefix is mapped to a particular namespace URI using the
                     <elcode>xsl:namespace</elcode> instruction, or by using
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> to copy a namespace
                  node, this prevents the namespace fixup process (and hence the serializer) from
                  using the same prefix for a different namespace URI on the same element.</p></note><example><head>Conflicting Namespace Prefixes</head><p>Given the instruction:</p><eg xml:space="preserve">&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;</eg><p>a possible serialization of the <termref def="dt-result-tree">result
                     tree</termref> is:</p><eg xml:space="preserve">&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;</eg><p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it
                  cannot use the prefix <code>p</code> because that prefix has been explicitly
                  associated with a different URI.</p></example><note><p>The <elcode>xsl:namespace</elcode> instruction cannot be used to generate a
                     <term>namespace undeclaration</term> of the form <code>xmlns=""</code> (nor the
                  new forms of namespace undeclaration permitted in <bibref ref="xml-names11"/>).
                  Namespace undeclarations are generated automatically by the serializer if
                     <code>undeclare-prefixes="yes"</code> is specified on
                     <elcode>xsl:output</elcode>, whenever a parent element has a namespace node for
                  the default namespace prefix, and a child element has no namespace node for that
                  prefix.</p></note></div2><div2 id="creating-comments"><head>Creating Comments</head><e:element-syntax name="comment"><e:in-category name="instruction"/><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:comment</elcode> element is evaluated to construct a new comment
               node. Except in error cases, the result of evaluating the
                  <elcode>xsl:comment</elcode> instruction is a single node, the newly constructed
               comment node.</p><p>The string value of the new comment node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:comment</elcode> element. 
               <phrase diff="chg" at="K">These are mutually exclusive: if
                  the <code>select</code> attribute is present then the sequence constructor must be empty,
                  and if the sequence constructor is non-empty then the <code>select</code> attribute
                  must be absent. If the <code>select</code> attribute is absent and the
                  sequence constructor is empty</phrase>, then the string value of the new comment node 
               will be a zero-length string. The way in
               which the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p><p>
               <error spec="XT" type="static" class="SE" code="0940"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:comment</elcode> element is
                     present unless the element has empty content.</p></error>
            </p><example><head>Generating a Comment Node</head><p>For example, this</p><eg xml:space="preserve">&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</eg><p>would create the comment</p><eg xml:space="preserve">&lt;!--This file is automatically generated. Do not edit!--&gt;</eg></example><p>In the generated comment node, the processor <rfc2119>must</rfc2119> insert a space
               after any occurrence of <code>-</code> that is followed by another <code>-</code> or
               that ends the comment.</p></div2><div2 id="copying"><head>Copying Nodes</head><div3 id="shallow-copy"><head>Shallow Copy</head><e:element-syntax name="copy" diff="chg" at="C"><e:in-category name="instruction"/><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="copy-namespaces"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="inherit-namespaces"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="use-attribute-sets"><e:data-type name="eqnames"/></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="on-empty"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:copy</elcode> instruction provides a way of copying <phrase diff="chg" at="C">a selected item. The selected item is the item selected by
                     evaluating the expression in the <code>select</code> attribute if present, or
                     the <termref def="dt-context-item">context item</termref> otherwise</phrase>.
                  If the selected item is a node, evaluating the <elcode>xsl:copy</elcode>
                  instruction constructs a copy of the selected node, and the result of the
                     <elcode>xsl:copy</elcode> instruction is this newly constructed node. By
                  default, the namespace nodes of the context node are automatically copied as well,
                  but the attributes and children of the node are not automatically copied.</p><p>When the <phrase diff="chg" at="C">selected item</phrase> is an atomic value
                     <phrase diff="add" at="C">or function item</phrase>, the
                     <elcode>xsl:copy</elcode> instruction returns this value. The <termref def="dt-sequence-constructor">sequence constructor</termref>, if present, is
                  not evaluated, <phrase diff="add" at="C">and <rfc2119>must not</rfc2119> generate
                     any <termref def="dt-type-error">type errors</termref>.</phrase></p><p>When the <phrase diff="chg" at="C">selected item</phrase> is an attribute node,
                  text node, comment node, processing instruction node, or namespace node, the
                     <elcode>xsl:copy</elcode> instruction returns a new node that is a copy of the
                  context node. The new node will have the same node kind, name, and string value as
                  the context node. In the case of an attribute node, it will also have the same
                  values for the <code>is-id</code> and <code>is-idrefs</code> properties. The
                     <termref def="dt-sequence-constructor"/>, if
                  present, is not evaluated, <phrase diff="add" at="C">and <rfc2119>must
                        not</rfc2119> generate any <termref def="dt-type-error">type
                        errors</termref>.</phrase>.</p><p>When the <phrase diff="chg" at="C">selected item</phrase> is a document node or
                  element node, the <elcode>xsl:copy</elcode> instruction returns a new node that
                  has the same node kind and name as the <phrase diff="chg" at="C">selected</phrase>
                  node. The content of the new node is formed by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                     <elcode>xsl:copy</elcode> instruction.
                  <phrase diff="add" at="I">If the <code>select</code> attribute is present then
                  the sequence constructor is evaluated with the
                        selected item as the <termref def="dt-singleton-focus">singleton focus</termref>;
                  otherwise it is evaluated using the context of the <elcode>xsl:copy</elcode>
                  instruction unchanged.</phrase>
                  The sequence obtained by evaluating this
                  sequence constructor is used (after prepending any attribute nodes or namespace
                  nodes as described in the following paragraphs) to construct the content of the
                  document or element node, as described in <specref ref="constructing-complex-content"/>.</p><p diff="add" at="C">If the <code>select</code> expression returns an empty sequence,
                  the <elcode>xsl:copy</elcode> instruction returns an empty sequence, and the
                  contained <termref def="dt-sequence-constructor"/> is
                  not evaluated.</p><p diff="add" at="C"><error spec="XT" type="type" class="TE" code="3180"><p>It is a <termref def="dt-type-error">type error</termref> if the result of
                        evaluating the <code>select</code> expression <error.extra>of the
                              <elcode>xsl:copy</elcode> element</error.extra> is a sequence of more
                        than one item.</p></error></p><note diff="del" at="C"><p>The <elcode>xsl:copy</elcode> instruction is most useful when copying element
                     nodes. In other cases, the <elcode>xsl:copy-of</elcode> instruction is more
                     flexible, because it has a <code>select</code> attribute allowing selection of
                     the nodes or values to be copied.</p></note><p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. This attribute is used only
                  when copying element nodes. This list is expanded as described in <specref ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence
                  is prepended to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p><p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>copy-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then all the namespace nodes of the source element are copied as
                  namespace nodes for the result element. These copied namespace nodes are prepended
                  to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> (it is immaterial
                  whether they come before or after any attribute nodes produced by expanding the
                     <code>use-attribute-sets</code> attribute). If the value is set to
                     <code>no</code>, then the namespace nodes are not copied. However, namespace
                  nodes will still be added to the result element as <rfc2119>required</rfc2119> by
                  the namespace fixup process: see <specref ref="namespace-fixup"/>.</p><p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then the namespace nodes created for the newly constructed element
                  (whether these were copied from those of the source node, or generated as a result
                  of namespace fixup) are copied to the children and descendants of the newly
                  constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these namespace nodes are not
                  automatically copied to the children. This may result in namespace undeclarations
                  (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
                     <code>xmlns:p=""</code>) appearing on the child elements when a <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p><p>
                  <error spec="XT" type="type" class="TE" code="0950"><p>It is a <termref def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.</p></error>
               </p><note><p>When attribute nodes are copied, whether with <elcode>xsl:copy</elcode> or with
                        <elcode>xsl:copy-of</elcode>, the processor does not automatically copy any
                     associated namespace information. The namespace used in the attribute name
                     itself will be declared by virtue of the namespace fixup process (see <specref ref="namespace-fixup"/>) when the attribute is added to an element in the
                        <termref def="dt-result-tree">result tree</termref>, but if namespace
                     prefixes are used in the content of the attribute (for example, if the value of
                     the attribute is an XPath expression) then it is the responsibility of the
                     stylesheet author to ensure that suitable namespace nodes are added to the
                        <termref def="dt-result-tree">result tree</termref>. This can be achieved by
                     copying the namespace nodes using <elcode>xsl:copy</elcode>, or by generating
                     them using <elcode>xsl:namespace</elcode>.</p></note><p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema, and thus to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new copy of an
                  element or attribute node will carry. These attributes are ignored when copying an
                  item that is not an element, attribute or document node. When the node being
                  copied is an element or document node, these attributes also affect the type
                  annotation carried by any elements and attributes that have the copied element or
                  document node as an ancestor. These two attributes are both optional, and if one
                  is specified then the other <rfc2119>must</rfc2119> be omitted. The permitted
                  values of these attributes and their semantics are described in <specref ref="validation"/>.</p><note><p>The final <termref def="dt-annotation">type annotation</termref> of the node in
                     the <termref def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the node.</p></note><p>The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy</elcode> instruction. If the
                  copied node is subsequently attached as a child to a new element or document node,
                  the final copy of the node inherits its base URI from its parent node, unless this
                  is overridden using an <code>xml:base</code> attribute.</p><p>When an <code>xml:id</code> attribute is copied, using either the
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction, it is
                     <termref def="dt-implementation-defined"/>
                  whether the value of the attribute is subjected to attribute value normalization
                  (that is, effectively applying the <xfunction>normalize-space</xfunction>
                  function).</p><note><p>In most cases the value will already have been subjected to attribute value
                     normalization on the source tree, but if this processing has not been performed
                     on the source tree, it is not an error for it to be performed on the result
                     tree.</p></note><imp-def-feature>If an <code>xml:id</code> attribute that has not been subjected to
                  attribute value normalization is copied from a source tree to a result tree, it is
                  implementation-defined whether attribute value normalization will be applied
                  during the copy process.</imp-def-feature><div4 id="conditional-copy" diff="add" at="L"><head>Conditional Copying of Elements</head><p>If an <elcode>xsl:copy</elcode> instruction has an <code>on-empty</code> attribute, and
                     the context node is an element or document node, and the content of the copied element
                     or document node contains nothing
                     other than namespace nodes and zero-length text nodes, then instead of returning
                     the constructed element or document node, the instruction returns the result of evaluating the
                     expression in the <code>on-empty</code> attribute.</p><p>In this situation (when the copied document or element node is not returned because it is empty),
                  the <code>validation</code> and <code>type</code> attributes are ignored; no validation of the
                  content takes place.</p></div4></div3><div3 id="copy-of"><head>Deep Copy</head><e:element-syntax name="copy-of"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="copy-namespaces"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:empty/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:copy-of</elcode> instruction can be used to construct a copy of a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                     items</phrase> with each new node containing copies of all the children,
                  attributes, and (by default) namespaces of the original node, recursively. The
                  result of evaluating the instruction is a sequence of items corresponding
                  one-to-one with the supplied sequence, and retaining its order.</p><p>The <rfc2119>required</rfc2119>
                  <code>select</code> attribute contains an <termref def="dt-expression">expression</termref>, whose value may be any sequence of nodes, atomic values,
                     <phrase diff="add" at="C">and/or function items</phrase>. The items in this
                  sequence are processed as follows:</p><ulist><item><p>If the item is an element node, a new element is constructed and appended to
                        the result sequence. The new element will have the same <termref def="dt-expanded-qname">expanded QName</termref> as the original, and it
                        will have deep copies of the attribute nodes and children of the element
                        node.</p><p>The new element will also have namespace nodes copied from the original
                        element node, unless they are excluded by specifying
                           <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes
                        the value <code>yes</code>, then all the namespace nodes of the original
                        element are copied to the new element. If it takes the value
                        <code>no</code>, then none of the namespace nodes are copied: however,
                        namespace nodes will still be created in the <termref def="dt-result-tree">result tree</termref> as <rfc2119>required</rfc2119> by the namespace
                        fixup process: see <specref ref="namespace-fixup"/>. This attribute affects
                        all elements copied by this instruction: both elements selected directly by
                        the <code>select</code>
                        <termref def="dt-expression">expression</termref>, and elements that are
                        descendants of nodes selected by the <code>select</code> expression. </p><p>The new element will have the same values of the <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties as the
                        original element.</p></item><item><p>If the item is a document node, the instruction adds a new document node to
                        the result sequence; the children of this document node will be one-to-one
                        copies of the children of the original document node (each copied according
                        to the rules for its own node kind).</p></item><item><p>If the item is an attribute or namespace node, or a text node, a comment, or
                        a processing instruction, the same rules apply as with
                           <elcode>xsl:copy</elcode> (see <specref ref="shallow-copy"/>).</p></item><item><p>If the item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, the value is appended to the result sequence, as with
                           <elcode>xsl:sequence</elcode>.</p></item></ulist><p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy-of</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema and thus to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new copy of an
                  element or attribute node will carry. These attributes are applied individually to
                  each element, attribute, and document node that is selected by the expression in
                  the <code>select</code> attribute. These attributes are ignored when copying an
                  item that is not an element, attribute or document node.</p><p>The specified <code>type</code> and <code>validation</code> apply directly only to
                  elements, attributes and document nodes created as copies of nodes actually
                  selected by the <code>select</code> expression, they do not apply to nodes that
                  are implicitly copied because they have selected nodes as an ancestor. However,
                  these attributes do indirectly affect the <termref def="dt-annotation">type
                     annotation</termref> carried by such implicitly copied nodes, as a consequence
                  of the validation process.</p><p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p><p>Errors may occur when copying namespace-sensitive elements or attributes using
                     <code>validation="preserve"</code>. <errorref class="TE" code="0950"/>.</p><p>The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy-of</elcode> instruction. If
                  the copied node is subsequently attached as a child to a new element or document
                  node, the final copy of the node inherits its base URI from its parent node,
                  unless this is overridden using an <code>xml:base</code> attribute.</p></div3></div2><div2 id="constructing-sequences"><head>Constructing Sequences</head><e:element-syntax name="sequence"><e:in-category name="instruction"/><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:sequence</elcode> instruction may be used within a <termref def="dt-sequence-constructor">sequence constructor</termref> to construct a
               sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                  items</phrase>. This sequence is returned as the result of the instruction. Unlike
               most other instructions, <elcode>xsl:sequence</elcode> can return a sequence
               containing existing nodes, rather than constructing new nodes. When
                  <elcode>xsl:sequence</elcode> is used to select atomic values <phrase diff="add" at="C">or function items</phrase>, the effect is very similar to the
                  <elcode>xsl:copy-of</elcode> instruction.</p><p diff="chg" at="E">The items comprising the result sequence are evaluated either using
               the <code>select</code> attribute, or using the contained <termref def="dt-sequence-constructor"/>. These are mutually exclusive; if the instruction
               has a <code>select</code> attribute, then it <rfc2119>must</rfc2119> have no children
               other than <elcode>xsl:fallback</elcode> instructions. If there is no
               <code>select</code> attribute and no contained <termref def="dt-sequence-constructor"/>, the result is
               an empty sequence.</p><p>Any contained <elcode>xsl:fallback</elcode> instructions are ignored by an XSLT 2.0
                  <phrase diff="add" at="A">or 3.0</phrase> processor, but can be used to define
               fallback behavior for an XSLT 1.0 processor running in forwards compatibility
               mode.</p><example><head>Constructing a Sequence of Integers</head><p>For example, the following code:</p><eg xml:space="preserve">&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</eg><p>produces the output: <code>37</code>
               </p></example><example><head>Using <code>xsl:for-each</code> to Construct a Sequence</head><p>The following code constructs a sequence containing the value of the
                     <code>@price</code> attribute for selected elements (which we assume to be
                  typed as <code>xs:decimal</code>), or a computed price for those elements that
                  have no <code>@price</code> attribute. It then returns the average price:</p><eg xml:space="preserve">&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;</eg><p>Note that the existing <code>@price</code> attributes could equally have been
                  added to the <code>$prices</code> sequence using <elcode>xsl:copy-of</elcode> or
                     <elcode>xsl:value-of</elcode>. However, <elcode>xsl:copy-of</elcode> would
                  create a copy of the attribute node, which is not needed in this situation, while
                     <elcode>xsl:value-of</elcode> would create a new text node, which then has to
                  be converted to an <code>xs:decimal</code>. Using <elcode>xsl:sequence</elcode>,
                  which in this case atomizes the existing attribute node and adds an
                     <code>xs:decimal</code> atomic value to the result sequence, is a more direct
                  way of achieving the same result.</p><p>This example could alternatively be solved at the XPath level:</p><eg xml:space="preserve">&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;</eg><p>The apparently redundant <code>+</code> operator is there to atomize the attribute
                  value: the expression on the right hand side of the <code>/</code> operator must
                  not return a <phrase diff="chg" at="C"> sequence containing both nodes and
                     non-nodes (atomic values or function items).</phrase></p></example><note diff="add" at="E"><p>The main use case for allowing <elcode>xsl:sequence</elcode> to contain a sequence
                  constructor is to allow the instructions within an <elcode>xsl:fork</elcode>
                  element to be divided into groups.</p><p>It can also be used to limit the scope of local variables or of
               standard attributes such as <code>[xsl:]default-collation</code>.</p></note></div2></div1><div1 id="number"><head>Numbering</head><e:element-syntax name="number"><e:in-category name="instruction"/><e:attribute name="value"><e:data-type name="expression"/></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="level"><e:constant value="single"/><e:constant value="multiple"/><e:constant value="any"/></e:attribute><e:attribute name="count"><e:data-type name="pattern"/></e:attribute><e:attribute name="from"><e:data-type name="pattern"/></e:attribute><e:attribute name="format"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="lang"><e:attribute-value-template><e:data-type name="language"/></e:attribute-value-template></e:attribute><e:attribute name="letter-value"><e:attribute-value-template><e:constant value="alphabetic"/><e:constant value="traditional"/></e:attribute-value-template></e:attribute><e:attribute name="ordinal"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="start-at"><e:attribute-value-template><e:data-type name="integer"/></e:attribute-value-template></e:attribute><e:attribute name="grouping-separator"><e:attribute-value-template><e:data-type name="char"/></e:attribute-value-template></e:attribute><e:attribute name="grouping-size"><e:attribute-value-template><e:data-type name="integer"/></e:attribute-value-template></e:attribute><e:empty/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:number</elcode> instruction is used to create a formatted number. The
            result of the instruction is a newly constructed text node containing the formatted
            number as its <termref def="dt-string-value">string value</termref>.</p><p>
            <termdef id="dt-place-marker" term="place marker">The <elcode>xsl:number</elcode>
               instruction performs two tasks: firstly, determining a <term>place marker</term>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.</termdef> The place marker
            to be formatted can either be supplied directly, in the <code>value</code> attribute, or
            it can be computed based on the position of a selected node within the tree that
            contains it.</p><p>
            <error spec="XT" type="static" class="SE" code="0975"><p>It is a <termref def="dt-static-error">static error</termref> if the
                     <code>value</code> attribute of <elcode>xsl:number</elcode> is present unless
                  the <code>select</code>, <code>level</code>, <code>count</code>, and
                     <code>from</code> attributes are all absent.</p></error>
         </p><note><p>The facilities described in this section are specifically designed to enable the
               calculation and formatting of section numbers, paragraph numbers, and the like. For
               formatting of other numeric quantities, the <xfunction>format-number</xfunction>
               function may be more suitable: see <xspecref spec="FO30" ref="func-format-number"/>.</p><p>Furthermore, formatting of integers where there is no requirement to calculate the
               position of a node in the document can now be accomplished using the
                  <xfunction>format-number</xfunction> function, which borrows many concepts from
               the <elcode>xsl:number</elcode> specification.</p></note><div2 id="formatting-supplied-number"><head>Formatting a Supplied Number</head><p>The <termref def="dt-place-marker">place marker</termref> to be formatted may be
               specified by an expression. The <code>value</code> attribute contains the <termref def="dt-expression">expression</termref>. The value of this expression is <termref def="dt-atomization">atomized</termref> using the procedure defined in <bibref ref="xpath-30"/>, and each value <var>$V</var> in the atomized sequence is then
               converted to the integer value returned by the XPath expression
                  <code>xs:integer(round(number($V)))</code>. <phrase diff="add" at="G"><!--bug 8402-->If the <code>start-at</code>
                  attribute is present, then its effective value is converted to an integer and decremented by one,
                  and the resulting value is added to each integer in the sequence.</phrase> The resulting sequence of integers is
               used as the place marker to be formatted.</p><p diff="chg" at="D">If the instruction is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then:</p><ulist><item><p>all items in the <termref def="dt-atomization">atomized</termref> sequence
                     after the first are discarded;</p></item><item><p>If the atomized sequence is empty, it is replaced by a sequence containing the
                        <code>xs:double</code> value <code>NaN</code> as its only item;</p></item><item><p>If any value in the sequence cannot be converted to an integer (this includes
                     the case where the sequence contains a <code>NaN</code> value) then the string
                        <code>NaN</code> is inserted into the formatted result string in its proper
                     position. The error described in the following paragraph does not apply in this
                     case.</p></item></ulist><p>
               <error spec="XT" type="dynamic" class="DE" code="0980"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if any undiscarded item in the atomized sequence supplied as
                     the value of the <code>value</code> attribute of <elcode>xsl:number</elcode>
                     cannot be converted to an integer, or if the resulting integer is less than 0
                     (zero). </p></error>
            </p><note><p>The value zero does not arise when numbering nodes in a source document, but it
                  can arise in other numbering sequences. It is permitted specifically because the
                  rules of the <elcode>xsl:number</elcode> instruction are also invoked by functions
                  such as <xfunction>format-time</xfunction>: the minutes and seconds component of a
                  time value can legitimately be zero.</p></note><p>The resulting sequence is formatted as a string using the <termref def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the <elcode>xsl:number</elcode> element constructs a new text node
               containing the resulting string, and returns this node.</p><example><head>Numbering a Sorted List</head><p>The following example numbers a sorted list:</p><eg xml:space="preserve">&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</eg></example></div2><div2 id="numbering-based-on-position"><head>Numbering based on Position in a Document </head><p>If no <code>value</code> attribute is specified, then the <elcode>xsl:number</elcode>
               instruction returns a new text node containing a formatted <termref def="dt-place-marker">place marker</termref> that is based on the position of a
               selected node within its containing document. If the <code>select</code> attribute is
               present, then the expression contained in the <code>select</code> attribute is
               evaluated to determine the selected node. If the <code>select</code> attribute is
               omitted, then the selected node is the <termref def="dt-context-node">context
                  node</termref>.</p><p>
               <error spec="XT" type="type" class="TE" code="0990"><p>It is a <termref def="dt-type-error">type error</termref> if the
                        <elcode>xsl:number</elcode> instruction is evaluated, with no
                        <code>value</code> or <code>select</code> attribute, when the <termref def="dt-context-item">context item</termref> is not a node. </p></error>
            </p><p>
               <error spec="XT" type="type" class="TE" code="1000"><p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>select</code> attribute of the <elcode>xsl:number</elcode>
                     instruction is anything other than a single node.</p></error>
            </p><p diff="add" at="G">
               <error spec="XT" type="dynamic" class="DE" code="1001"><p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref>
                     of the <code>start-at</code> attribute of the <elcode>xsl:number</elcode>
                     instruction is not in the lexical space of <code>xs:integer</code>. The error may be signaled
                  statically if it can be detected statically.</p></error>
            </p><p> The following attributes control how the selected node is to be numbered:</p><ulist><item><p>The <code>level</code> attribute specifies rules for selecting the nodes that
                     are taken into account in allocating a number; it has the values
                        <code>single</code>, <code>multiple</code> or <code>any</code>. The default
                     is <code>single</code>.</p></item><item><p>The <code>count</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies which nodes are to be counted at those
                     levels. If <code>count</code> attribute is not specified, then it defaults to
                     the pattern that matches any node with the same node kind as the selected node
                     and, if the selected node has an <termref def="dt-expanded-qname">expanded QName</termref>, with the same <termref def="dt-expanded-qname">expanded QName</termref> as the selected node.</p></item><item><p>The <code>from</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies where counting starts.</p></item></ulist><p>In addition, the attributes specified in <specref ref="convert"/> are used for number
               to string conversion, as in the case when the <code>value</code> attribute is
               specified.</p><p>The <elcode>xsl:number</elcode> element first constructs a sequence of positive
               integers using the <code>level</code>, <code>count</code> and <code>from</code>
               attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this
               sequence will either be empty or contain a single number; where <code>level</code> is
                  <code>multiple</code>, the sequence may be of any length. The sequence is
               constructed as follows:</p><p>Let <code>matches-count($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>count</code>
               attribute, or the implied pattern (according to the rules given above) if the
                  <code>count</code> attribute is omitted.</p><p>Let <code>matches-from($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>from</code>
               attribute, or if <code>$node</code> is the root node of a tree. If the
                  <code>from</code> attribute is omitted, then the function returns true if and only
               if <code>$node</code> is the root node of a tree.</p><p>Let <code>$S</code> be the selected node.</p><p>When <code>level="single"</code>: </p><ulist><item><p>Let <code>$A</code> be the node sequence selected by the following
                     expression:</p><p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)][1]</code>
                  </p><p>(this selects the innermost ancestor-or-self node that matches the
                        <code>count</code> pattern)</p></item><item><p>Let <code>$F</code> be the node sequence selected by the expression</p><p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p><p>(this selects the innermost ancestor-or-self node that matches the
                        <code>from</code> pattern):</p></item><item><p>Let <code>$AF</code> be the value of:</p><p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p><p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence
                     otherwise)</p></item><item><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p></item><item><p>Otherwise return the value of:</p><p>
                     <code>   1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
                  </p><p>(the number of preceding siblings of the counted node that match the
                        <code>count</code> pattern, plus one).</p></item></ulist><p>When <code>level="multiple"</code>: </p><ulist><item><p>Let <code>$A</code> be the node sequence selected by the expression</p><p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)]</code>
                  </p><p>(the set of ancestor-or-self nodes that match the <code>count</code>
                     pattern)</p></item><item><p>Let <code>$F</code> be the node sequence selected by the expression</p><p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p><p>(the innermost ancestor-or-self node that matches the <code>from</code>
                     pattern)</p></item><item><p>Let <code>$AF</code> be the value of</p><p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p><p>(the nodes selected in the first step that are in the subtree rooted at the
                     node selected in the second step)</p></item><item><p>Return the result of the expression </p><p>
                     <code>   for $af in $AF return
                        1+count($af/preceding-sibling::node()[matches-count(.)])</code>
                  </p><p>(a sequence of integers containing, for each of these nodes, one plus the
                     number of preceding siblings that match the <code>count</code> pattern)</p></item></ulist><p>When <code>level="any"</code>: </p><ulist><item><p>Let <code>$A</code> be the node sequence selected by the expression</p><p>
                     <code>   $S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
                  </p><p>(the set of nodes consisting of the selected node together with all nodes,
                     other than attributes and namespaces, that precede the selected node in
                     document order, provided that they match the <code>count</code> pattern)</p></item><item><p>Let <code>$F</code> be the node sequence selected by the expression</p><p>
                     <code>   $S/(preceding::node()|ancestor::node())[matches-from(.)][last()]</code>
                  </p><p>(the last node in document order that matches the <code>from</code> pattern and
                     that precedes the selected node, using the same definition)</p></item><item><p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt;
                        $F]</code>.</p><p>(the nodes selected in the first step, excluding those that precede the node
                     selected in the second step)</p></item><item><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p></item><item><p>Otherwise return the value of the expression <code>count($AF)</code>
                  </p></item></ulist><p>The resulting sequence of numbers is referred to as the <termref def="dt-place-marker">place marker</termref>).</p><p diff="add" at="G">If the <code>start-at</code>
               attribute is present, then the effective value of the attribute is converted to an integer and decremented by one,
               and the resulting value is added to each number in the <termref def="dt-place-marker">place marker</termref>.</p><p>The sequence of numbers (the 
               is then converted into a string using the <termref def="dt-effective-value">effective
                  values</termref> of the attributes specified in <specref ref="convert"/>; each of
               these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After conversion, the resulting string is
               used to create a text node, which forms the result of the <elcode>xsl:number</elcode>
               instruction.</p><example><head>Numbering the Items in an Ordered List</head><p>The following will number the items in an ordered list:</p><eg xml:space="preserve">&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Multi-Level Numbering</head><p>The following two rules will number <code>title</code> elements. This is intended
                  for a document that contains a sequence of chapters followed by a sequence of
                  appendices, where both chapters and appendices contain sections, which in turn
                  contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B,
                  C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are
                  numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2,
                  1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p><eg xml:space="preserve">&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Numbering Notes within a Chapter</head><p>This example numbers notes sequentially within a chapter, <phrase diff="add" at="G">starting from the number 100:</phrase> :</p><eg xml:space="preserve">&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg></example></div2><div2 id="convert"><head>Number to String Conversion Attributes</head><note><p diff="add" at="M">This specification is aligned with that of the <function>format-integer</function>
            function, but there are differences; for example grouping separators are part of the
            primary format token in <function>format-integer</function>, but are indicated by separate
            attributes in <elcode>xsl:number</elcode>.</p></note><p>The following attributes are used to control conversion of a sequence of numbers into
               a string. The numbers are integers greater than or equal to 0 (zero). The attributes
               are all optional.</p><p>The main attribute is <code>format</code>. The default value for the
                  <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute
               is split into a sequence of tokens where each token is a maximal sequence of
               alphanumeric characters or a maximal sequence of non-alphanumeric characters.
                  <emph>Alphanumeric</emph> means any character that has a Unicode category of Nd,
               Nl, No, Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens (<emph>format tokens</emph>)
               indicate the format to be used for each number in the sequence; in most cases the
               format token is the same as the required representation of the number 1 (one).</p><p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is
               a non-alphanumeric token but no format token, then the single non-alphanumeric token
               is used as both the prefix and the suffix. The prefix, if it exists, is the
               non-alphanumeric token that precedes the first format token: the prefix always
               appears exactly once in the constructed string, at the start. The suffix, if it
               exists, is the non-alphanumeric token that follows the last format token: the suffix
               always appears exactly once in the constructed string, at the end. All other
               non-alphanumeric tokens (those that occur between two format tokens) are
                  <emph>separator tokens</emph> and are used to separate numbers in the
               sequence.</p><p>The <var>n</var>th format token is used to format the <var>n</var>th number in the
               sequence. If there are more numbers than format tokens, then the last format token is
               used to format remaining numbers. If there are no format tokens, then a format token
               of <code>1</code> is used to format all numbers. Each number after the first is
               separated from the preceding number by the separator token preceding the format token
               used to format that number, or, if that is the first format token, then by
                  <code>.</code> (dot).</p><example><head>Formatting a List of Numbers</head><p>Given the sequence of numbers <code>5, 13, 7</code> and the format token
                     <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code>
               </p></example><p>Format tokens are interpreted as follows:</p><ulist><item><p>Any token where the last character has a decimal digit value of 1 (as specified
                     in the Unicode character property database), and the Unicode value of preceding
                     characters is one less than the Unicode value of the last character generates a
                     decimal representation of the number where each number is at least as long as
                     the format token. The digits used in the decimal representation are the set of
                     digits containing the digit character used in the format token. Thus, a format
                     token <code>1</code> generates the sequence <code>0 1 2 ... 10 11 12
                     ...</code>, and a format token <code>01</code> generates the sequence <code>00
                        01 02 ... 09 10 11 12 ... 99 100 101</code>. A format token of
                        <code>&amp;#x661;</code> (Arabic-Indic digit one) generates the sequence
                        <code>١</code> then <code>٢</code> then <code>٣</code>
                     ...</p></item><item><p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB
                        AC...</code>.</p></item><item><p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab
                        ac...</code>.</p></item><item><p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii
                        viii ix x ...</code>.</p></item><item><p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII
                        VIII IX X ...</code>.</p></item><item><p>A format token <code>w</code> generates numbers written as lower-case words,
                     for example in English, <code>one two three four ...</code>
                  </p></item><item><p>A format token <code>W</code> generates numbers written as upper-case words,
                     for example in English, <code>ONE TWO THREE FOUR ...</code>
                  </p></item><item><p>A format token <code>Ww</code> generates numbers written as title-case words,
                     for example in English, <code>One Two Three Four ...</code>
                  </p></item><item><p>Any other format token indicates a numbering sequence in which that token
                     represents the number 1 (one) (but see the note below).
                     <!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
                     It is <termref def="dt-implementation-defined"/>
                     which numbering sequences, additional to those listed above, are supported. If
                     an implementation does not support a numbering sequence represented by the
                     given token, it <rfc2119>must</rfc2119> use a format token of
                     <code>1</code>.</p><note><p>In some traditional numbering sequences additional signs are added to denote
                        that the letters should be interpreted as numbers; these are not included in
                        the format token. An example, see also the example below, is classical Greek
                        where a <emph>dexia keraia</emph> and sometimes an <emph>aristeri
                           keraia</emph> is added.</p></note></item></ulist><imp-def-feature>The numbering sequences supported by the <elcode>xsl:number</elcode>
               instructions, beyond those defined in this specification, are
               implementation-defined.</imp-def-feature><p>For all format tokens other than the first kind above (one that consists of decimal
               digits), there <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> lower and upper bounds on the range of numbers
               that can be formatted using this format token; indeed, for some numbering sequences
               there may be intrinsic limits. For example, the formatting token
                  <code>&amp;#x2460;</code> (circled digit one) has a range of 1 to 20 imposed by
               the Unicode character repertoire. For the numbering sequences described above any
               upper bound imposed by the implementation <rfc2119>must not</rfc2119> be less than
               1000 (one thousand) and any lower bound must not be greater than 1. Numbers that fall
               outside this range <rfc2119>must</rfc2119> be formatted using the format token
                  <code>1</code>. The numbering sequence associated with the format token
                  <code>1</code> has a lower bound of 0 (zero).</p><imp-def-feature>There <rfc2119>may</rfc2119> be implementation-defined upper bounds on
               the numbers that can be formatted by <elcode>xsl:number</elcode> using any particular
               numbering sequence.</imp-def-feature><p>The above expansions of numbering sequences for format tokens such as <code>a</code>
               and <code>i</code> are indicative but not prescriptive. There are various conventions
               in use for how alphabetic sequences continue when the alphabet is exhausted, and
               differing conventions for how roman numerals are written (for example,
                  <code>IV</code> versus <code>IIII</code> as the representation of the number 4).
               Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and
                  <code>o</code>. This specification does not prescribe the detail of any sequence
               other than those sequences consisting entirely of decimal digits.</p><p>Many numbering sequences are language-sensitive. This applies especially to the
               sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>.
               It also applies to other sequences, for example different languages using the
               Cyrillic alphabet use different sequences of characters, each starting with the
               letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code>
               attribute specifies which language's conventions are to be used; it has the same
               range of values as <code>xml:lang</code> (see <bibref ref="REC-xml"/>). If no
                  <code>lang</code> value is specified, the language that is used is <termref def="dt-implementation-defined">implementation-defined</termref>. The set of
               languages for which numbering is supported is <termref def="dt-implementation-defined">implementation-defined</termref>. If a language is
               requested that is not supported, the processor uses the language that it would use if
               the <code>lang</code> attribute were omitted.</p><imp-def-feature>The set of languages for which numbering is supported by
                  <elcode>xsl:number</elcode>, and the method of choosing a default language, are
               implementation-defined.</imp-def-feature><p>If the optional <code>ordinal</code> attribute is present, and if its value is not a
               zero-length string, this indicates a request to output ordinal numbers rather than
               cardinal numbers. For example, in English, the value <code>ordinal="yes"</code> when
               used with the format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th
                  ...</code>, and when used with the format token <code>w</code> outputs the
               sequence <code>first second third fourth ...</code>. In some languages, ordinal
               numbers vary depending on the grammatical context, for example they may have
               different genders and may decline with the noun that they qualify. In such cases the
               value of the <code>ordinal</code> attribute may be used to indicate the variation of
               the ordinal number required. The way in which the variation is indicated will depend
               on the conventions of the language. For inflected languages that vary the ending of
               the word, the preferred approach is to indicate the required ending, preceded by a
               hyphen: for example in German, appropriate values are <code>-e, -er, -es, -en</code>.
               It is <termref def="dt-implementation-defined"/> what
               combinations of values of the format token, the language, and the
                  <code>ordinal</code> attribute are supported. If ordinal numbering is not
               supported for the combination of the format token, the language, and the actual value
               of the <code>ordinal</code> attribute, the request is ignored and cardinal numbers
               are generated instead.</p><imp-def-feature>With <elcode>xsl:number</elcode>, it is <termref def="dt-implementation-defined">implementation-defined</termref> what combinations
               of values of the format token, the language, and the <code>ordinal</code> attribute
               are supported. </imp-def-feature><example><head>Ordinal Numbering in Italian</head><p>The specification <code>format="1" ordinal="-º" lang="it"</code>, if supported,
                  should produce the sequence:</p><eg xml:space="preserve">1º 2º 3º 4º ...</eg><p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported,
                  should produce the sequence:</p><eg xml:space="preserve">Primo Secondo Terzo Quarto Quinto ...</eg></example><p>The <code>letter-value</code> attribute disambiguates between numbering sequences
               that use letters. In many languages there are two commonly used numbering sequences
               that use letters. One numbering sequence assigns numeric values to letters in
               alphabetic sequence, and the other assigns numeric values to each letter in some
               other manner traditional in that language. In English, these would correspond to the
               numbering sequences specified by the format tokens <code>a</code> and <code>i</code>.
               In some languages, the first member of each sequence is the same, and so the format
               token alone would be ambiguous. A value of <code>alphabetic</code> specifies the
               alphabetic sequence; a value of <code>traditional</code> specifies the other
               sequence. If the <code>letter-value</code> attribute is not specified, then it is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref> how
               any ambiguity is resolved.</p><note><p>Implementations may use <termref def="dt-extension-attribute">extension
                     attributes</termref> on <elcode>xsl:number</elcode> to provide additional
                  control over the way in which numbers are formatted.</p></note><p>The <code>grouping-separator</code> attribute gives the separator used as a grouping
               (for example, thousands) separator in decimal numbering sequences, and the optional
                  <code>grouping-size</code> specifies the size (normally 3) of the grouping. For
               example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would
               produce numbers of the form <code>1,000,000</code> while
                  <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would
               produce numbers of the form <code>1.00.00.00</code>. If only one of the
                  <code>grouping-separator</code> and <code>grouping-size</code> attributes is
               specified, then it is ignored.</p><example><head>Format Tokens and the Resulting Sequences</head><p>These examples use non-Latin characters which might not display correctly in all
                  browsers, depending on the system configuration.</p><table border="1" cellpadding="5" summary="format tokens for use with xsl:number"><thead><tr><th align="left" rowspan="1" colspan="1">Description</th><th align="left" rowspan="1" colspan="1">Format Token</th><th align="left" rowspan="1" colspan="1">Sequence</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">French cardinal words</td><td rowspan="1" colspan="1">
                           <code>format="Ww" lang="fr"</code>
                        </td><td rowspan="1" colspan="1">Un, Deux, Trois, Quatre</td></tr><tr><td rowspan="1" colspan="1">German ordinal words</td><td rowspan="1" colspan="1">
                           <code>format="w" ordinal="-e" lang="de"</code>
                        </td><td rowspan="1" colspan="1">erste, zweite, dritte, vierte</td></tr><tr><td rowspan="1" colspan="1">Katakana numbering</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A2;"</code>
                        </td><td rowspan="1" colspan="1">ア, イ, ウ, エ,
                           オ, カ, キ, ク, ケ, コ, サ,
                           シ, ス, セ, ソ, タ, チ, ツ,
                           テ, ト, ナ, ニ, ヌ, ネ, ノ,
                           ハ, ヒ, フ, ヘ, ホ, マ, ミ,
                           ム, メ, モ, ヤ, ユ, ヨ, ラ,
                           リ, ル, レ, ロ, ワ, ヰ, ヱ,
                           ヲ, ン</td></tr><tr><td rowspan="1" colspan="1">Katakana numbering in iroha order</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A4;"</code>
                        </td><td rowspan="1" colspan="1">イ, ロ, ハ, ニ,
                           ホ, ヘ, ト, チ, リ, ヌ, ル,
                           ヲ, ワ, カ, ヨ, タ, レ, ソ,
                           ツ, ネ, ナ, ラ, ム, ウ, ヰ,
                           ノ, オ, ク, ヤ, マ, ケ, フ,
                           コ, エ, テ, ア, サ, キ, ユ,
                           メ, ミ, シ, ヱ, ヒ, モ, セ,
                           ス</td></tr><tr><td rowspan="1" colspan="1">Thai numbering</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x0E51;"</code>
                        </td><td rowspan="1" colspan="1">๑, ๒, ๓, ๔, ๕,
                           ๖, ๗, ๘, ๙, ๑๐, ๑๑,
                           ๑๒, ๑๓, ๑๔, ๑๕,
                           ๑๖, ๑๗, ๑๘, ๑๙,
                           ๒๐</td></tr><tr><td rowspan="1" colspan="1">Traditional Hebrew numbering</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x05D0;" letter-value="traditional"</code>
                        </td><td rowspan="1" colspan="1">א, ב, ג, ד, ה,
                           ו, ז, ח, ט, י, יא,
                           יב, יג, יד, טו,
                           טז, יז, יח, יט,
                           כ</td></tr><tr><td rowspan="1" colspan="1">Traditional Georgian numbering</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x10D0;" letter-value="traditional"</code>
                        </td><td rowspan="1" colspan="1">ა, ბ, გ, დ,
                           ე, ვ, ზ, ჱ, თ, ი,
                           ია, იბ, იგ, იდ,
                           იე, ივ, იზ, იჱ,
                           ით, კ </td></tr><tr><td rowspan="1" colspan="1">Classical Greek numbering (see note)</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x03B1;" letter-value="traditional"</code>
                        </td><td rowspan="1" colspan="1"> αʹ, βʹ, γʹ,
                           δʹ, εʹ, ϛʹ, ζʹ,
                           ηʹ, θʹ, ιʹ, ιαʹ,
                           ιβʹ, ιγʹ, ιδʹ,
                           ιεʹ, ιϛʹ, ιζʹ,
                           ιηʹ, ιθʹ, κʹ</td></tr><tr><td rowspan="1" colspan="1">Old Slavic numbering</td><td rowspan="1" colspan="1">
                           <code>format="&amp;#x0430;" letter-value="traditional"</code>
                        </td><td rowspan="1" colspan="1">А, В, Г, Д, Е,
                           Ѕ, З, И, Ѳ, Ӏ, АӀ,
                           ВӀ, ГӀ, ДӀ, ЕӀ,
                           ЅӀ, ЗӀ, ИӀ, ѲӀ,
                           К</td></tr></tbody></table><p>Note that Classical Greek is an example where the format token is not the same as
                  the representation of the number 1.</p></example></div2></div1><div1 id="sorting"><head>Sorting</head><p>
            <termdef id="dt-sort-key-specification" term="sort key specification">A <term>sort key
                  specification</term> is a sequence of one or more adjacent
                  <elcode>xsl:sort</elcode> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.</termdef>
         </p><p>
            <termdef id="dt-sort-key-component" term="sort key component">Within a <termref def="dt-sort-key-specification">sort key specification</termref>, each
                  <elcode>xsl:sort</elcode> element defines one <term>sort key
               component</term>.</termdef> The first <elcode>xsl:sort</elcode> element specifies the
            primary component of the sort key specification, the second <elcode>xsl:sort</elcode>
            element specifies the secondary component of the sort key specification, and so on.</p><p>A sort key specification may occur immediately within an
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
               <elcode>xsl:perform-sort</elcode>, or <elcode>xsl:for-each-group</elcode>
            element.</p><note><p>When used within <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
               or <elcode>xsl:perform-sort</elcode>, <elcode>xsl:sort</elcode> elements must occur
               before any other children.</p></note><div2 id="xsl-sort"><head>The <elcode>xsl:sort</elcode> Element</head><e:element-syntax name="sort"><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="lang"><e:attribute-value-template><e:data-type name="language"/></e:attribute-value-template></e:attribute><e:attribute name="order"><e:attribute-value-template><e:constant value="ascending"/><e:constant value="descending"/></e:attribute-value-template></e:attribute><e:attribute name="collation"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="stable"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="case-order"><e:attribute-value-template><e:constant value="upper-first"/><e:constant value="lower-first"/></e:attribute-value-template></e:attribute><e:attribute name="data-type"><e:attribute-value-template><e:constant value="text"/><e:constant value="number"/><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="apply-templates"/><e:parent name="for-each"/><e:parent name="for-each-group"/><e:parent name="perform-sort"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:sort</elcode> element defines a <termref def="dt-sort-key-component">sort key component</termref>. A sort key component specifies how a <termref def="dt-sort-key-value">sort key value</termref> is to be computed for each item
               in the sequence being sorted, and also how two sort key values are to be
               compared.</p><p>The value of a <termref def="dt-sort-key-component">sort key component</termref> is
               determined either by its <code>select</code> attribute or by the contained <termref def="dt-sequence-constructor">sequence constructor</termref>. If neither is
               present, the default is <code>select="."</code>, which has the effect of sorting on
               the actual value of the item if it is an atomic value, or on the typed-value of the
               item if it is a node. If a <code>select</code> attribute is present, its value
                  <rfc2119>must</rfc2119> be an XPath <termref def="dt-expression">expression</termref>.</p><p>
               <error spec="XT" type="static" class="SE" code="1015"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element with a <code>select</code> attribute has
                     non-empty content.</p></error>
            </p><p>Those attributes of the <elcode>xsl:sort</elcode> elements whose values are <termref def="dt-attribute-value-template">attribute value templates</termref> are
               evaluated using the same <termref def="dt-focus">focus</termref> as is used to
               evaluate the <code>select</code> attribute of the containing instruction
               (specifically, <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                  <elcode>xsl:for-each-group</elcode>, or <elcode>xsl:perform-sort</elcode>).</p><p>The <code>stable</code> attribute is permitted only on the first
                  <elcode>xsl:sort</elcode> element within a <termref def="dt-sort-key-specification">sort key specification</termref>
            </p><p>
               <error spec="XT" type="static" class="SE" code="1017"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element other than the first in a sequence of
                     sibling <elcode>xsl:sort</elcode> elements has a <code>stable</code>
                     attribute.</p></error>
            </p><p>
               <termdef id="dt-stable" term="stable">A <termref def="dt-sort-key-specification">sort
                     key specification</termref> is said to be <term>stable</term> if its first
                     <elcode>xsl:sort</elcode> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <termref def="dt-effective-value">effective
                     value</termref> is <code>yes</code>.</termdef>
            </p><div3 id="sorting-process"><head>The Sorting Process</head><p>
                  <termdef id="dt-initial-sequence" term="initial sequence">The sequence to be
                     sorted is referred to as the <term>initial sequence</term>.</termdef>
               </p><p>
                  <termdef id="dt-sorted-sequence" term="sorted sequence">The sequence after sorting
                     as defined by the <elcode>xsl:sort</elcode> elements is referred to as the
                        <term>sorted sequence</term>.</termdef>
               </p><p>
                  <termdef id="dt-sort-key-value" term="sort key value"> For each item in the
                        <termref def="dt-initial-sequence">initial sequence</termref>, a value is
                     computed for each <termref def="dt-sort-key-component">sort key
                        component</termref> within the <termref def="dt-sort-key-specification">sort
                        key specification</termref>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <term>sort key value</term> of that item.</termdef>
               </p><p>The items in the <termref def="dt-initial-sequence">initial sequence</termref> are
                  ordered into a <termref def="dt-sorted-sequence">sorted sequence</termref> by
                  comparing their <termref def="dt-sort-key-value">sort key values</termref>. The
                  relative position of two items <var>A</var> and <var>B</var> in the sorted
                  sequence is determined as follows. The first sort key value of <var>A</var> is
                  compared with the first sort key value of <var>B</var>, according to the rules of
                  the first <termref def="dt-sort-key-component">sort key component</termref>. If,
                  under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will
                  precede <var>B</var> in the sorted sequence, unless the <code>order</code>
                  attribute of this <termref def="dt-sort-key-component">sort key
                     component</termref> specifies <code>descending</code>, in which case
                     <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the
                  relevant sort key values compare equal, then the second sort key value of
                     <var>A</var> is compared with the second sort key value of <var>B</var>,
                  according to the rules of the second <termref def="dt-sort-key-component">sort key
                     component</termref>. This continues until two sort key values are found that
                  compare unequal. If all the sort key values compare equal, and the <termref def="dt-sort-key-specification">sort key specification</termref> is <termref def="dt-stable">stable</termref>, then <var>A</var> will precede <var>B</var>
                  in the <termref def="dt-sorted-sequence">sorted sequence</termref> if and only if
                     <var>A</var> preceded <var>B</var> in the <termref def="dt-initial-sequence">initial sequence</termref>. If all the sort key values compare equal, and the
                     <termref def="dt-sort-key-specification">sort key specification</termref> is
                  not <termref def="dt-stable">stable</termref>, then the relative order of
                     <var>A</var> and <var>B</var> in the <termref def="dt-sorted-sequence">sorted
                     sequence</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p><note><p>If two items have equal <termref def="dt-sort-key-value">sort key
                        values</termref>, and the sort is <termref def="dt-stable">stable</termref>,
                     then their order in the <termref def="dt-sorted-sequence">sorted
                        sequence</termref> will be the same as their order in the <termref def="dt-initial-sequence">initial sequence</termref>, regardless of whether
                        <code>order="descending"</code> was specified on any or all of the <termref def="dt-sort-key-component">sort key components</termref>.</p></note><p>The <var>N</var>th sort key value is computed by evaluating either the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref> of the
                     <var>N</var>th <elcode>xsl:sort</elcode> element, or the expression
                     <code>.</code> (dot) if neither is present. This evaluation is done with the
                     <termref def="dt-focus">focus</termref> set as follows:</p><ulist><item><p>The <termref def="dt-context-item">context item</termref> is the item in the
                           <termref def="dt-initial-sequence">initial sequence</termref> whose
                           <termref def="dt-sort-key-value">sort key value</termref> is being
                        computed.</p></item><item><p>The <termref def="dt-context-position">context position</termref> is the
                        position of that item in the initial sequence.</p></item><item><p>The <termref def="dt-context-size">context size</termref> is the size of the
                        initial sequence.</p></item></ulist><note><p>As in any other XPath expression, the <function>current</function> function may
                     be used within the <code>select</code> expression of <elcode>xsl:sort</elcode>
                     to refer to the item that is the context item for the expression as a whole;
                     that is, the item whose <termref def="dt-sort-key-value">sort key
                        value</termref> is being computed.</p></note><p>The <termref def="dt-sort-key-value">sort key values</termref> are <termref def="dt-atomization">atomized</termref>, and are then compared. The way they
                  are compared depends on their datatype, as described in the next section.</p></div3><div3 id="comparing-sort-keys"><head>Comparing Sort Key Values</head><p>It is possible to force the system to compare <termref def="dt-sort-key-value">sort key values</termref> using the rules for a particular datatype by
                  including a cast as part of the <termref def="dt-sort-key-component">sort key
                     component</termref>. For example, <code>&lt;xsl:sort
                     select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as
                  dates. In the absence of such a cast, the sort key values are compared using the
                  rules appropriate to their datatype. Any values of type
                     <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p><p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute
                  remains available. If this has the <termref def="dt-effective-value">effective
                     value</termref>
                  <code>text</code>, the atomized <termref def="dt-sort-key-value">sort key
                     values</termref> are converted to strings before being compared. If it has the
                  effective value <code>number</code>, the atomized sort key values are converted to
                  doubles before being compared. The conversion is done by using the
                     <xfunction>string</xfunction> or <xfunction>number</xfunction> function as
                  appropriate. <phrase diff="chg" at="K">If the <code>data-type</code> attribute has any other <termref def="dt-effective-value">effective value</termref>, then this value
                     <rfc2119>must</rfc2119> be a <termref def="dt-eqname">EQName</termref> 
                  denoting an <termref def="dt-expanded-qname">expanded QName</termref> 
                  with a non-absent namespace</phrase>, and the effect of the attribute is
                     <termref def="dt-implementation-defined"/>.</p><imp-def-feature>If the <code>data-type</code> attribute of the
                     <elcode>xsl:sort</elcode> element has a value other than <code>text</code> or
                     <code>number</code>, the effect is implementation-defined.</imp-def-feature><p>
                  <error spec="XT" type="type" class="TE" code="1020"><p>If any <termref def="dt-sort-key-value">sort key value</termref>, after
                           <termref def="dt-atomization">atomization</termref> and any type
                        conversion <rfc2119>required</rfc2119> by the <code>data-type</code>
                        attribute, is a sequence containing more than one item, then the effect
                        depends on whether the <elcode>xsl:sort</elcode> element <phrase diff="chg" at="D">is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                              behavior</termref>. With XSLT 1.0 behavior,</phrase> the effective
                        sort key value is the first item in the sequence. In other cases, this is a
                           <termref def="dt-type-error">type error</termref>.</p></error>
               </p><p>The set of <termref def="dt-sort-key-value">sort key values</termref> (after any
                  conversion) is first divided into two categories: empty values, and ordinary
                  values. The empty sort key values represent those items where the sort key value
                  is an empty sequence. These values are considered for sorting purposes to be equal
                  to each other, but less than any other value. The remaining values are classified
                  as ordinary values.</p><p>
                  <error spec="XT" type="dynamic" class="DE" code="1030"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if, for any <termref def="dt-sort-key-component">sort key
                           component</termref>, the set of <termref def="dt-sort-key-value">sort key
                           values</termref> evaluated for all the items in the <termref def="dt-initial-sequence">initial sequence</termref>, after any type
                        conversion requested, contains a pair of ordinary values for which the
                        result of the XPath <code>lt</code> operator is an error.</p></error>
               </p><note><p>The above error condition may occur if the values to be sorted are of a type
                     that does not support ordering (for example, <code>xs:QName</code>) or if the
                     sequence is heterogeneous (for example, if it contains both strings and
                     numbers). The error can generally be prevented by invoking a cast or
                     constructor function within the sort key component.</p><p>The error condition is subject to the usual caveat that a processor is not
                     required to evaluate any expression solely in order to determine whether it
                     raises an error. For example, if there are several sort key components, then a
                     processor is not required to evaluate or compare minor sort key values unless
                     the corresponding major sort key values are equal.</p></note><!--Text replaced by erratum E13 change 1"--><p>In general, comparison of two ordinary values is performed according to the rules
                  of the XPath <code>lt</code> operator. To ensure a total ordering, the same
                  implementation of the <code>lt</code> operator <rfc2119>must</rfc2119> be used for
                  all the comparisons: the one that is chosen is the one appropriate to the most
                  specific type to which all the values can be converted by subtype substitution
                  and/or type promotion. For example, if the sequence contains both
                     <code>xs:decimal</code> and <code>xs:double</code> values, then the values are
                  compared using <code>xs:double</code> comparison, even when comparing two
                     <code>xs:decimal</code> values. NaN values, for sorting purposes, are
                  considered to be equal to each other, and less than any other numeric value.
                  Special rules also apply to the <code>xs:string</code> and <code>xs:anyURI</code>
                  types, and types derived by restriction therefrom, as described in the next
                  section.</p><!--End of text replaced by erratum E13--></div3><div3 id="collating-sequences"><head>Sorting Using Collations</head><p>The rules given in this section apply when comparing values whose type is
                     <code>xs:string</code> or a type derived by restriction from
                     <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type
                  derived by restriction from <code>xs:anyURI</code>.</p><p>
                  <termdef id="dt-collation" term="collation">Facilities in XSLT <phrase diff="chg" at="A">3.0</phrase> and XPath <phrase diff="chg" at="C">3.0</phrase> that
                     require strings to be ordered rely on the concept of a named
                        <term>collation</term>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.</termdef> A collation is identified by a URI, but the manner in which
                  this URI is associated with an actual rule or algorithm is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><imp-def-feature>The facilities for defining collations and allocating URIs to
                  identify them are implementation-defined.</imp-def-feature><p>The one collation URI that <rfc2119>must</rfc2119> be recognized by every implementation is
                     <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which
                  provides the ability to compare strings based on the Unicode codepoint values of
                  the characters in the string.</p><p>For more information about collations, see <xspecref spec="FO30" ref="string-compare"/> in <bibref ref="xpath-functions-30"/>. Some specifications,
                  for example <bibref ref="UNICODE-TR10"/>, use the term "collation" to describe
                  rules that can be tailored or parameterized for various purposes. In this
                  specification, a collation URI refers to a collation in which all such parameters
                  have already been fixed. Therefore, if a collation URI is specified, other
                  attributes such as <code>case-order</code> and <code>lang</code> are ignored. </p><note><p>The reason XSLT does not provide detailed mechanisms for defining collating
                     sequences is that many implementations will re-use collating mechanisms
                     available from the underlying implementation platform (for example, from the
                     operating system or from the run-time library of a chosen programming
                     language). These will inevitably differ from one XSLT implementation to
                     another.</p></note><p>If the <elcode>xsl:sort</elcode> element has a <code>collation</code> attribute,
                  then the strings are compared according to the rules for the named <termref def="dt-collation">collation</termref>: that is, they are compared using the
                  XPath function call <code>compare($a, $b, $collation)</code>.</p><p>If the <termref def="dt-effective-value">effective value</termref> of the
                     <code>collation</code> attribute of <elcode>xsl:sort</elcode> is a relative
                  URI, then it is resolved against the base URI of the <elcode>xsl:sort</elcode>
                  element.</p><p>
                  <error spec="XT" type="dynamic" class="DE" code="1035"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the <code>collation</code> attribute of
                           <elcode>xsl:sort</elcode> (after resolving against the base URI) is not a
                        URI that is recognized by the implementation as referring to a
                        collation.</p></error>
               </p><note><p>It is entirely for the implementation to determine whether it recognizes a
                     particular collation URI. For example, if the implementation allows collation
                     URIs to contain parameters in the query part of the URI, it is the
                     implementation that determines whether a URI containing an unknown or invalid
                     parameter is or is not a recognized collation URI. The fact that this error is
                     described as non-recoverable thus does not prevent an implementation applying a
                     fallback collation if it chooses to do so.</p></note><p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a
                     <code>collation</code> attribute is present. But in the absence of a
                     <code>collation</code> attribute, these attributes provide input to an <termref def="dt-implementation-defined">implementation-defined</termref> algorithm to
                  locate a suitable collation:</p><imp-def-feature>The algorithm used by <elcode>xsl:sort</elcode> to locate a
                  collation, given the values of the <code>lang</code> and <code>case-order</code>
                  attributes, is implementation-defined.</imp-def-feature><ulist><item><p>The <code>lang</code> attribute indicates that a collation suitable for a
                        particular natural language <rfc2119>should</rfc2119> be used. The <termref def="dt-effective-value">effective value</termref> of the attribute
                           <rfc2119>must</rfc2119> be a value that would be valid for the
                           <code>xml:lang</code> attribute (see <bibref ref="REC-xml"/>).</p></item><item><p>The <code>case-order</code> attribute indicates whether the desired
                        collation <rfc2119>should</rfc2119> sort upper-case letters before
                        lower-case or vice versa. The <termref def="dt-effective-value">effective
                           value</termref> of the attribute <rfc2119>must</rfc2119> be either
                           <code>lower-first</code> (indicating that lower-case letters precede
                        upper-case letters in the collating sequence) or <code>upper-first</code>
                        (indicating that upper-case letters precede lower-case).</p><!--Text inserted by erratum E26 change 1"--><p>When <code>lower-first</code> is requested, the returned collation
                           <rfc2119>should</rfc2119> have the property that when two strings differ
                        only in the case of one or more characters, then a string in which the first
                        differing character is lower-case should precede a string in which the
                        corresponding character is title-case, which should in turn precede a string
                        in which the corresponding character is upper-case. When upper-first is
                        requested, the returned collation <rfc2119>should</rfc2119> have the
                        property that when two strings differ only in the case of one or more
                        characters, then a string in which the first differing character is
                        upper-case should precede a string in which the corresponding character is
                        title-case, which should in turn precede a string in which the corresponding
                        character is lower-case.</p><p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are
                        sorted with <code>case-order="upper-first"</code> and <code>a A b B</code>
                        are sorted with <code>case-order="lower-first"</code>.</p><p>As a further example, if lower-first is requested, then a sorted sequence
                        might be "MacAndrew, macintosh, macIntosh, Macintosh, MacIntosh,
                        macintoshes, Macintoshes, McIntosh". If upper-first is requested, the same
                        sequence would sort as "MacAndrew, MacIntosh, Macintosh, macIntosh,
                        macintosh, MacIntoshes, macintoshes, McIntosh".</p><!--End of text inserted by erratum E26--></item></ulist><p>If none of the <code>collation</code>, <code>lang</code>, or
                     <code>case-order</code> attributes is present, the collation is chosen in an
                     <termref def="dt-implementation-defined"/> way.
                  It is not <rfc2119>required</rfc2119> that the default collation for sorting
                  should be the same as the <termref def="dt-default-collation">default
                     collation</termref> used when evaluating XPath expressions, as described in
                     <specref ref="static-context"/> and <specref ref="default-collation-attribute"/>.</p><note><p>It is usually appropriate, when sorting, to use a strong collation, that is,
                     one that takes account of secondary differences (accents) and tertiary
                     differences (case) between strings that are otherwise equal. A weak collation,
                     which ignores such differences, may be more suitable when comparing strings for
                     equality.</p><p>Useful background information on international sorting is provided in <bibref ref="UNICODE-TR10"/>. The <code>case-order</code> attribute may be
                     interpreted as described in section 6.6 of <bibref ref="UNICODE-TR10"/>.</p></note></div3></div2><div2 id="creating-sorted-sequence"><head>Creating a Sorted Sequence</head><e:element-syntax name="perform-sort"><e:in-category name="instruction"/><e:attribute name="select" required="no"><e:data-type name="expression"/></e:attribute><e:sequence><e:element repeat="one-or-more" name="sort"/><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:perform-sort</elcode> instruction is used to return a <termref def="dt-sorted-sequence">sorted sequence</termref>.</p><p>The <termref def="dt-initial-sequence">initial sequence</termref> is obtained either
               by evaluating the <code>select</code> attribute or by evaluating the contained
               sequence constructor (but not both). If there is no <code>select</code> attribute and
               no sequence constructor then the <termref def="dt-initial-sequence">initial
                  sequence</termref> (and therefore, the <termref def="dt-sorted-sequence">sorted
                  sequence</termref>) is an empty sequence.</p><p>
               <error spec="XT" type="static" class="SE" code="1040"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:perform-sort</elcode> instruction with a <code>select</code>
                     attribute has any content other than <elcode>xsl:sort</elcode> and
                        <elcode>xsl:fallback</elcode> instructions.</p></error>
            </p><p>The result of the <elcode>xsl:perform-sort</elcode> instruction is the result of
               sorting its <termref def="dt-initial-sequence">initial sequence</termref> using its
               contained <termref def="dt-sort-key-specification">sort key
               specification</termref>.</p><example><head>Sorting a Sequence of Atomic Values</head><p>The following stylesheet function sorts a sequence of atomic values using the
                  value itself as the sort key.</p><eg xml:space="preserve">&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</eg></example><example><head>Writing a Function to Perform a Sort</head><p>The following example defines a function that sorts books by price, and uses this
                  function to output the five books that have the lowest prices:</p><eg xml:space="preserve">&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 </eg></example></div2><div2 id="sorted-iteration"><head>Processing a Sequence in Sorted Order</head><p>When used within <elcode>xsl:for-each</elcode> or
                  <elcode>xsl:apply-templates</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates that the sequence of items selected by
               that instruction is to be processed in sorted order, not in the order of the supplied
               sequence.</p><example><head>Processing Elements in Sorted Order</head><p>For example, suppose an employee database has the form</p><eg xml:space="preserve">&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</eg><p>Then a list of employees sorted by name could be generated using:</p><eg xml:space="preserve">&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</eg></example><p>When used within <elcode>xsl:for-each-group</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates the
               order in which the groups are to be processed. For the effect of
                  <elcode>xsl:for-each-group</elcode>, see <specref ref="grouping"/>. </p></div2></div1><div1 id="grouping"><head>Grouping</head><p>The facilities described in this section are designed to allow items in a sequence to be
            grouped based on common values; for example it allows grouping of elements having the
            same value for a particular attribute, or elements with the same name, or elements with
            common values for any other <termref def="dt-expression">expression</termref>. Since
            grouping identifies items with duplicate values, the same facilities also allow
            selection of the distinct values in a sequence of items, that is, the elimination of
            duplicates.</p><note><p>Simple elimination of duplicates can also be achieved using the function
                  <xfunction>distinct-values</xfunction> in the <termref def="dt-core-function">core
                  function</termref> library: see <bibref ref="xpath-functions-30"/>.</p></note><p>In addition these facilities allow grouping based on sequential position, for example
            selecting groups of adjacent <code>para</code> elements. The facilities also provide an
            easy way to do fixed-size grouping, for example identifying groups of three adjacent
            nodes, which is useful when arranging data in multiple columns.</p><p>For each group of items identified, it is possible to evaluate a <termref def="dt-sequence-constructor">sequence constructor</termref> for the group. Grouping
            is nestable to multiple levels so that groups of distinct items can be identified, then
            from among the distinct groups selected, further sub-grouping of distinct items in the
            current group can be done. </p><p>It is also possible for one item to participate in more than one group.</p><div2 id="xsl-for-each-group"><head>The <code>xsl:for-each-group</code> Element</head><e:element-syntax name="for-each-group"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="group-by" required="no"><e:data-type name="expression"/></e:attribute><e:attribute name="group-adjacent" required="no"><e:data-type name="expression"/></e:attribute><e:attribute name="group-starting-with" required="no"><e:data-type name="pattern"/></e:attribute><e:attribute name="group-ending-with" required="no"><e:data-type name="pattern"/></e:attribute><e:attribute name="bind-group" required="no"><e:data-type name="eqname"/></e:attribute><e:attribute name="bind-grouping-key" required="no"><e:data-type name="eqname"/></e:attribute><e:attribute name="composite"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="collation"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:sequence><e:element repeat="zero-or-more" name="sort"/><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>This element is an <termref def="dt-instruction">instruction</termref> that may be
               used anywhere within a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p><p>
               <termdef id="dt-group" term="group">The <elcode>xsl:for-each-group</elcode>
                  instruction allocates the items in an input sequence into <term>groups</term> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <termref def="dt-pattern">pattern</termref> that
                  the initial or final <phrase diff="chg" at="C">item</phrase> in a group must
                  match.</termdef> The <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that forms the content of the
                  <elcode>xsl:for-each-group</elcode> instruction is evaluated once for each of
               these groups.</p><p>
               <termdef id="dt-population" term="population">The sequence of items to be grouped,
                  which is referred to as the <term>population</term>, is determined by evaluating
                  the XPath <termref def="dt-expression">expression</termref> contained in the
                     <code>select</code> attribute.</termdef>
            </p><p>
               <termdef id="dt-population-order" term="population order">The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <term>population order</term>
               </termdef>.</p><p>A group is never empty. If the population is empty, the number of groups will be
            zero.</p><p>The assignment of items to groups depends on the <code>group-by</code>,
                  <code>group-adjacent</code>, <code>group-starting-with</code>, and
                  <code>group-ending-with</code> attributes. </p><p>
               <error spec="XT" type="static" class="SE" code="1080"><p>These four attributes <error.extra>the <code>group-by</code>,
                           <code>group-adjacent</code>, <code>group-starting-with</code>, and
                           <code>group-ending-with</code> attributes of
                           <elcode>xsl:for-each-group</elcode>
                     </error.extra> are mutually exclusive: it is a <termref def="dt-static-error">static error</termref> if none of these four attributes is present or if
                     more than one of them is present.</p></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="1090"><p>It is a <termref def="dt-static-error">static error</termref> to specify the <code>collation</code> attribute 
                     <phrase diff="add" at="G">or the <code>composite</code> attribute</phrase> if neither the
                        <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is
                     specified.</p></error>
            </p><p diff="chg" at="F">
               <termdef id="dt-grouping-key" term="grouping key">If either of the
                  <code>group-by</code> or <code>group-adjacent</code> attributes is
                  present, then for each item in the
                     <termref def="dt-population">population</termref> 
                     a set of <term>grouping keys</term> is calculated, as follows: the expression contained
                     in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated;
                     the result is atomized; and any <code>xs:untypedAtomic</code> values are cast to
                     <code>xs:string</code>. <phrase diff="chg" at="G">If <code>composite="yes"</code> is specified, there is
                  a single grouping key whose value is the resulting sequence; otherwise, there is a set of
                  grouping keys, consisting of the distinct atomic values present in the result
                     sequence.</phrase>
                     </termdef>
            </p><p>When calculating grouping keys for an item in the population, the <termref def="dt-expression">expression</termref> contained in the <code>group-by</code> or
                  <code>group-adjacent</code> attribute is evaluated with that item as the <termref def="dt-context-item">context item</termref>, with its position in <termref def="dt-population-order">population order</termref> as the <termref def="dt-context-position">context position</termref>, and with the size of the
               population as the <termref def="dt-context-size">context size</termref>.<phrase diff="del" at="F"> The
               resulting sequence is <termref def="dt-atomization">atomized</termref>, and each
               atomic value in the atomized sequence acts as a <termref def="dt-grouping-key">grouping key</termref> for that item in the population.</phrase></p><p>If the <code>group-by</code> attribute is present, <phrase diff="add" at="G">and if the <code>composite</code> attribute
               is omitted or takes the value <code>no</code>,</phrase> then an item in the population <rfc2119>may</rfc2119>
               have multiple grouping keys: that is, the <code>group-by</code> expression evaluates
               to a sequence<phrase diff="add" at="G">, and each item in the sequence is treated as a separate grouping key. </phrase>
               The item is included in as many groups as there are distinct grouping
               keys (which may be zero).</p><p>f the <code>group-adjacent</code> attribute is used, 
               <phrase diff="add" at="G">and if the <code>composite</code> attribute
               is omitted or takes the value <code>no</code>,</phrase> then
               each item in the population <rfc2119>must</rfc2119> have exactly one grouping key
               value.</p><p>
               <error spec="XT" type="type" class="TE" code="1100" diff="chg" at="F"><p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>group-adjacent</code> expression is an empty sequence
                     or a sequence containing more than one item, 
                     <phrase diff="add" at="G">unless <code>composite="yes"</code> is specified.</phrase></p></error>
            </p><p>
               <termref def="dt-grouping-key">Grouping keys</termref> are compared using the rules
               for the <phrase diff="chg" at="G"><xfunction>deep-equal</xfunction> function. 
               This means that values of type
                  <code>xs:untypedAtomic</code> will be cast to <code>xs:string</code> before the
               comparison, and that items that are not comparable using the <code>eq</code> operator are
               considered to be not equal, that is, they are allocated to different groups. 
               It also means that the value <code>NaN</code> is considered equal to
               itself.</phrase> If the
               values are strings, or untyped atomic values, then if there is a
                  <code>collation</code> attribute the values are compared using the collation
               specified as the <termref def="dt-effective-value">effective value</termref> of the
                  <code>collation</code> attribute, resolved if relative against the base URI of the
                  <elcode>xsl:for-each-group</elcode> element. If there is no <code>collation</code>
               attribute then the <termref def="dt-default-collation">default collation</termref> is
               used.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="1110"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the collation URI specified to
                        <elcode>xsl:for-each-group</elcode> (after resolving against the base URI)
                     is a collation that is not recognized by the implementation. (For notes,
                        <errorref class="DE" code="1035"/>.)</p></error>
            </p><p>For more information on collations, see <specref ref="collating-sequences"/>.</p><p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="1120"><p>When the <code>group-starting-with</code> or <code>group-ending-with</code>
                     attribute <error.extra>of the <elcode>xsl:for-each-group</elcode>
                        instruction</error.extra> is used, it is a <termref def="dt-type-error">type
                        error</termref> if the result of evaluating the <code>select</code>
                     expression contains an item that is not a node.</p></error>
            </p><p diff="add" at="F">The way in which an <elcode>xsl:for-each-group</elcode> element is evaluated
               depends on which of the four group-defining attributes is present:</p><ulist><item><p>If the <code>group-by</code> attribute is present, the items in the <termref def="dt-population">population</termref> are examined, in population order.
                     For each item <var>J</var>, the expression in the <code>group-by</code>
                     attribute is evaluated to produce a sequence of zero or more <termref def="dt-grouping-key">grouping key</termref> values. 
                     <phrase diff="add" at="G">If <code>composite="yes"</code> is specified, there will be a single
                     grouping key, which will in general be a sequence of zero or more atomic values; otherwise, there
                     will be zero or more grouping keys, each of which will be a single atomic value.</phrase>
                     For each one of these
                        <termref def="dt-grouping-key">grouping keys</termref>, if there is already
                     a group created to hold items having that grouping key value, <var>J</var> is
                        <phrase diff="chg" at="D">appended</phrase> to that group; otherwise a new
                     group is created for items with that grouping key value, and <var>J</var>
                     becomes its first member.</p><!--</p>					
						<p>If the <code>group-by</code> attribute is present, then  
all items that have the same <termref def="dt-grouping-key">grouping key</termref> are assigned to 
the same group, and the--><p>An item in the population may thus be <phrase diff="chg" at="D">appended</phrase> to zero, one, or many groups. An item will never be
                        <phrase diff="chg" at="D">appended</phrase> more than once to the same
                     group; if two or more grouping keys for the same item are equal, then the
                     duplicates are ignored. An <emph>item</emph> here means the item at a
                     particular position within the population—<!--em dash-->if the
                     population contains the same node at several different positions in the
                     sequence then a group may indeed contain duplicate nodes.</p><p>The number of groups will be the same as the number of distinct grouping key
                     values present in the <termref def="dt-population">population</termref>. </p><!--Text inserted by erratum E25 change 2"--><p>If the population contains values of different numeric types that differ from
                     each other by small amounts, then the <code>eq</code> operator is not
                     transitive, because of rounding effects occurring during type promotion. The
                     effect of this is described in <specref ref="non-transitivity"/>.</p><!--End of text inserted by erratum E25--></item><item><p>If the <code>group-adjacent</code> attribute is present, the items in the
                        <termref def="dt-population">population</termref> are examined, in
                     population order. If an item has the same value for the <termref def="dt-grouping-key">grouping key</termref> as its preceding item within
                     the <termref def="dt-population">population</termref> (in <termref def="dt-population-order">population order</termref>), then it is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding item;
                     otherwise a new group is created and the item becomes its first member.</p></item><item><p>If the <code>group-starting-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">pattern</nt>. <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p><p>The <phrase diff="chg" at="C">items</phrase> in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an <phrase diff="chg" at="C">item</phrase> matches the pattern, or is the first <phrase diff="chg" at="C">item</phrase> in the population, then a new group is
                     created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p></item><item><p>If the <code>group-ending-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">pattern</nt>. <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p><p>The <phrase diff="chg" at="C">items</phrase> in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an <phrase diff="chg" at="C">item</phrase> is the first <phrase diff="chg" at="C">item</phrase> in the population, or if the previous <phrase diff="chg" at="C">item</phrase> in the population matches the pattern, then a new group
                     is created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p></item></ulist><p diff="add" at="D">In all cases the order of items within each group is predictable,
               and reflects the original <termref def="dt-population-order">population
                  order</termref>, in that the items are processed in population order and each item
               is appended at the end of zero or more groups.</p><note diff="add" at="D"><p>As always, a different algorithm may be used if it achieves the same effect.</p></note><p>
               <termdef id="dt-initial-item" term="initial item">For each <termref def="dt-group">group</termref>, the item within the group that is first in <termref def="dt-population-order">population order</termref> is known as the
                     <term>initial item</term> of the group.</termdef>
            </p><p>The <termref def="dt-sequence-constructor"/> contained
               in the <elcode>xsl:for-each-group</elcode> element is evaluated once for each of the
               <termref def="dt-group">groups</termref>, in <termref def="dt-processing-order">processing order</termref>. The sequences that result are concatenated, in
               <termref def="dt-processing-order">processing order</termref>, to form the result
               of the <elcode>xsl:for-each-group</elcode> element. Within the <termref def="dt-sequence-constructor">sequence constructor</termref>, the <termref def="dt-context-item">context item</termref> is the <termref def="dt-initial-item">initial item</termref> of the relevant group, the <termref def="dt-context-position">context position</termref> is the position of this <phrase diff="chg" at="F">group
               in the <termref def="dt-processing-order">processing order</termref> of the groups</phrase>, and the <termref def="dt-context-size">context size</termref> is the number of groups<phrase diff="del" at="K">, the <termref def="dt-current-group">current group</termref> is the <termref def="dt-group">group</termref> being processed, and the <termref def="dt-current-grouping-key">current grouping key</termref> is the grouping key for that group. If the
               <elcode>xsl:for-each-group</elcode> instruction uses the
               <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
                  then the current grouping key is the empty sequence.</phrase> This has the effect that within
               the <termref def="dt-sequence-constructor"/>, a call on
               <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p></div2><div2 id="information-about-group" diff="add" at="K"><head>Accessing Information about the Current Group</head><p>Two pieces of information are available during the processing of each group 
               (that is, while evaluating the sequence constructor
               contained in the <elcode>xsl:for-each-group</elcode> instruction, and also while evaluating
               the sort key of a group as expressed by the <code>select</code> attribute or sequence constructor
               of an <elcode>xsl:sort</elcode> child of the <elcode>xsl:for-each-group</elcode> element):</p><ulist><item><p>the <termref def="dt-group">group</termref> itself, as a sequence of items</p></item><item><p>the <termref def="dt-grouping-key">grouping-key</termref>, which is a single atomic value,
                  or in the case of a composite key, a sequence of atomic values.</p></item></ulist><p>There are two ways of getting this information. The preferred way in XSLT 3.0 is to bind
               variables using the <code>bind-group</code> and <code>bind-grouping-key</code> attributes
               of the <elcode>xsl:for-each-group</elcode> instruction.</p><p>If the <code>bind-group</code> attribute is present, then its value must be an 
               <termref def="dt-eqname">EQName</termref>, and
               this causes a local variable binding for this name to be visible within the sequence constructor
               forming the body of the <elcode>xsl:for-each-group</elcode> instruction, and also within
               any <elcode>xsl:sort</elcode> element child of the <elcode>xsl:for-each-group</elcode> element. 
               The type of the variable
               is <code>item()*</code> (any sequence of items), and its value is the content of the 
               <termref def="dt-group">group</termref> being processed.</p><p>If the <code>bind-grouping-key</code> attribute is present, then its value must be a 
               <termref def="dt-eqname">EQName</termref>, and
               this causes a local variable binding for this name to be present within the sequence constructor
               forming the body of the <elcode>xsl:for-each-group</elcode> instruction and also within
               any <elcode>xsl:sort</elcode> element child of the <elcode>xsl:for-each-group</elcode> element. 
               The type of the variable
               is <code>anyAtomicType*</code> (any sequence of atomic values), and its value is the 
               <termref def="dt-grouping-key">grouping key</termref> of the 
               <termref def="dt-group">group</termref> being processed.</p><p>If the variable names bound in the <code>bind-group</code> or <code>bind-grouping-key</code>
            attributes are used in the <code>select</code> attribute or the sequence constructor within an
            <elcode>xsl:sort</elcode> child of the <elcode>xsl:for-each-group</elcode> instruction,
            then they act as references to the group whose sort key is being computed, or the grouping key
            of that group, respectively.</p><p diff="add" at="E">
               <error spec="XT" type="static" class="SE" code="3220"><p>It is a <termref def="dt-static-error">static error</termref> if a variable
                  bound in the <code>bind-group</code> or <code>bind-grouping-key</code> attribute
                  of an <elcode>xsl:for-each-group</elcode> instruction is referenced within an expression
                  in the <code>lang</code>, <code>order</code>, <code>collation</code>, <code>stable</code>,
                  <code>case-order</code>, or <code>data-type</code> attributes of an <elcode>xsl:sort</elcode>
                  child of that <elcode>xsl:for-each-group</elcode> instruction.</p></error>
            </p><p><error spec="XT" type="static" class="SE" code="3230"><p>It is a 
               <termref def="dt-static-error"/> if the <code>bind-grouping-key</code> attribute is present
               on an <elcode>xsl:for-each-group</elcode> instruction unless either the <code>group-by</code>
               or <code>group-adjacent</code> attribute is present.</p></error></p><p>For backwards compatibility, XSLT 3.0 also allows information about the group
               and the grouping key to be obtained using the <function>current-group</function> and
               <function>current-grouping-key</function> functions respectively. The difference between
               using bound variables and using these functions is that the variables have static scope (they
               can only be used lexically within the <elcode>xsl:for-each-group</elcode> element), whereas the
               functions have dynamic scope (they are available in called templates — though not in called functions —
               as well as within the lexical body of <elcode>xsl:for-each-group</elcode>). The fact that the
               functions have dynamic scope makes certain optimizations difficult, and in particular it makes
               it impossible to satisfy the rules for streamability. When streamed processing is required,
               therefore, it is necessary to bind variables to the group and grouping key rather than using
               the <function>current-group</function> and
               <function>current-grouping-key</function> functions.</p><p>An added benefit of using the <code>bind-group</code> and <code>bind-grouping-key</code>
               variables is apparent when <elcode>xsl:for-each-group</elcode> elements are nested: the grouping
               variables for the outer instruction remain in scope when processing the inner instruction.</p><p>If the <code>bind-group</code> attribute is present on the <elcode>xsl:for-each-group</elcode>
               instruction, then the <termref def="dt-current-group">current group</termref> (the value accessed
               by the <function>current-group</function> function) is set to 
               <termref def="dt-absent">absent</termref> during the processing of the instruction, which has the
               effect that any call on <function>current-group</function> results in a dynamic error.</p><p>If the <code>bind-grouping-key</code> attribute is present on the <elcode>xsl:for-each-group</elcode>
               instruction, or if neither the <code>group-by</code> nor <code>group-adjacent</code> attribute
               is present, then the <termref def="dt-current-grouping-key">current grouping key</termref> (the value accessed
               by the <function>current-grouping-key</function> function) is set to 
               <termref def="dt-absent">absent</termref> during the processing of the instruction, which has the
               effect that any call on <function>current-grouping-key</function> results in a dynamic error.</p><p>The variable bindings established by the <code>bind-group</code> and <code>bind-grouping-key</code>
            attributes, if present, are visible within all descendant elements of the <elcode>xsl:for-each-group</elcode>
            instruction on which they are declared, other than elements where the variable binding is
            <termref def="dt-shadows">shadowed</termref> by another variable binding. 
               For more information see <specref ref="scope-of-variables"/>.</p><div3 id="func-current-group"><head><?function fn:current-group?></head><p><termdef id="dt-current-group" term="current group" role="placemarker"/></p></div3><div3 id="func-current-grouping-key"><head><?function fn:current-grouping-key?></head><p><termdef id="dt-current-grouping-key" term="current grouping-key" role="placemarker"/></p></div3></div2><div2 id="order-of-groups"><head>Ordering among Groups</head><p>
               <termdef id="dt-first-appearance" term="order of first appearance">There is a
                  <phrase diff="add" at="F">total</phrase> ordering among <termref def="dt-group">groups</termref> referred to as the
                     <term>order of first appearance</term>. A group <var>G</var> is defined to
                  precede a group <var>H</var> in order of first appearance if the <termref def="dt-initial-item">initial item</termref> of <var>G</var> precedes the
                  initial item of <var>H</var> in population order. If two groups <var>G</var> and
                     <var>H</var> have the same initial item (because the item is in both groups)
                  then <var>G</var> precedes <var>H</var> if the <termref def="dt-grouping-key">grouping key</termref> of <var>G</var> precedes the grouping key of
                     <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.</termdef>
            </p><p>
               <termdef id="dt-processing-order" term="processing order">There is another 
                  <phrase diff="add" at="F">total</phrase> ordering
                  among groups referred to as <term>processing order</term>. If group <var>R</var>
                  precedes group <var>S</var> in processing order, then in the result sequence
                  returned by the <elcode>xsl:for-each-group</elcode> instruction the items
                  generated by processing group <var>R</var> will precede the items generated by
                  processing group <var>S</var>.</termdef>
            </p><p>If there are no <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element, the <termref def="dt-processing-order">processing order</termref> of the <termref def="dt-group">groups</termref> is the <termref def="dt-first-appearance">order of
                  first appearance</termref>.</p><!--Text replaced by erratum E8 change 1"--><p>Otherwise, the <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element define the processing order of the
                  <termref def="dt-group">groups</termref> (see <specref ref="sorting"/>). They do
               not affect the order of items within each group. Multiple <termref def="dt-sort-key-component">sort key components</termref> are allowed, and are
               evaluated in major-to-minor order. If two groups have the same values for all their
               sort key components, they are processed in <termref def="dt-first-appearance"/> if the <termref def="dt-sort-key-specification">sort key specification</termref> is <termref def="dt-stable">stable</termref>, otherwise in an <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p><!--End of text replaced by erratum E8--><p>The <code>select</code>
               <termref def="dt-expression">expression</termref> of an <elcode>xsl:sort</elcode>
               element is evaluated once for each <termref def="dt-group">group</termref>. During
               this evaluation, the <termref def="dt-context-item">context item</termref> is the
                  <termref def="dt-initial-item">initial item</termref> of the group, the <termref def="dt-context-position">context position</termref> is the position of this item
               within the set of initial items (that is, one item for each group in the <termref def="dt-population">population</termref>) in <termref def="dt-population-order">population order</termref>, the <termref def="dt-context-size">context
                  size</termref> is the number of groups, the <termref def="dt-current-group">current group</termref> is the group whose <termref def="dt-sort-key-value">sort
                  key value</termref> is being determined, and the <termref def="dt-current-grouping-key">current grouping key</termref> is the grouping key
               for that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
                  <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
               then the current grouping key is the empty sequence.</p><example><head>Sorting Groups</head><p>For example, this means that if the <termref def="dt-grouping-key">grouping
                     key</termref> is <code>@category</code>, you can sort the groups in order of
                  their grouping key by writing <code>&lt;xsl:sort
                     select="current-grouping-key()"/&gt;</code>; or you can sort the groups in
                  order of size by writing <code>&lt;xsl:sort
                     select="count(current-group())"/&gt;</code>
               </p></example></div2><div2 id="grouping-examples"><head>Examples of Grouping</head><p>These examples all use the <code>bind-group</code> and <code>bind-grouping-key</code>
            attributes introduced in XSLT 3.0. For equivalent examples using the 
            <function>current-group</function> and <function>current-grouping-key</function>
            functions, see the XSLT 2.0 specification.</p><example><head>Grouping Nodes based on Common Values</head><p>The following example groups a list of nodes based on common values. The resulting
                  groups are numbered but unsorted, and a total is calculated for each group. </p><p>Source XML document:</p><eg xml:space="preserve">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</eg><p>More specifically, the aim is to produce a four-column table, containing one row
                  for each distinct country. The four columns are to contain first, a sequence
                  number giving the number of the row; second, the name of the country, third, a
                  comma-separated alphabetical list of the city names within that country, and
                  fourth, the sum of the <code>pop</code> attribute for the cities in that
                  country.</p><p>Desired output:</p><eg xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</eg><p>Solution:</p><eg xml:space="preserve">&lt;table xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country" 
       bind-group="cities" bind-grouping-key="country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="$country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="$cities/@name" separator=", "/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum($cities/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</eg></example><!--
				<example>
					<p>The following example uses the same source document, this time
	 grouping the cities according to the initial letter of the city name. The groups
	 are sorted, and the result includes a count of the nodes within the group.
	 The heading contains a count of the number of groups:</p>
					<p>Desired output:</p>
					<eg><![CDATA[<html>
  <body>
    <h2>L (1)</h2><p>Lyon</p>
    <h2>M (2)</h2><p>Milano</p><p>München</p>
    <h2>P (1)</h2><p>Paris</p>
    <h2>V (1)</h2><p>Venezia</p>
  </body>
    </html>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<html xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <body>
    <xsl:for-each-group select="cities/city" group-by="substring(@name,1,1)"
         bind-group="cities" bind-grouping-key="initial-letter">
      <xsl:sort select="$initial-letter"/>
      <h2>
        <xsl:value-of select="upper-case($initial-letter)"/>
        <xsl:text> (</xsl:text>
        <xsl:value-of select="count($cities)"/>
        <xsl:text>)</xsl:text>
      </h2>
      <xsl:for-each select="$cities">
        <p><xsl:value-of select="@name"/></p>
      </xsl:for-each>
    </xsl:for-each-group>
  </body>
</html>]]></eg>
				</example>
--><example diff="chg" at="K"><head>A Composite Grouping Key</head><p>Sometimes it is necessary to use a composite grouping key: for example, suppose
                  the source document is similar to the one used in the previous examples, but
                  allows multiple entries for the same country and city, such as:</p><eg xml:space="preserve">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;</eg><p>Now suppose we want to list the average value of <code>@pop</code> for each
                  (country, name) combination. One way to handle this is to concatenate the parts of
                  the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/',
                     @name)"&gt;</code>. A second solution is to nest one
                     <elcode>xsl:for-each-group</elcode> element directly inside another. XSLT 3.0
               introduces a third option, which is to define the grouping key as composite:</p><eg xml:space="preserve">
&lt;xsl:for-each-group select="cities/city" 
                    group-by="@name, @country" 
                    composite="yes"
                    bind-group="group" 
                    bind-grouping-key="key"&gt;
  &lt;p&gt;&lt;xsl:value-of select="$key[1] || ', ' || $key[2] || ': ' || 
                           avg($group/@pop)"/&gt;&lt;/p&gt;
                           &lt;/xsl:for-each-group&gt;</eg><note><p>The string concatenation operator <code>||</code> is new in XPath 3.0.</p></note></example><example><head>Identifying a Group by its Initial Element</head><p>The next example identifies a group not by the presence of a common value, but
                  rather by adjacency in document order. A group consists of an <code>h2</code>
                  element, followed by all the <code>p</code> elements up to the next
                     <code>h2</code> element.</p><p>Source XML document:</p><eg xml:space="preserve">&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</eg><p>Desired output:</p><eg xml:space="preserve">&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</eg><p>Solution:</p><eg xml:space="preserve">&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
	&lt;xsl:for-each-group select="*" group-starting-with="h2"
                       bind-group="h2-et-seq"	&gt;
	  &lt;section title="{self::h2}"&gt;
	    &lt;xsl:for-each select="$h2-et-seq[self::p]"&gt;
	      &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
	    &lt;/xsl:for-each&gt; 
	  &lt;/section&gt;
	&lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</eg><p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
                  to handle the case where the first element is not an <code>h2</code> element.</p></example><example><head>Identifying a Group by its Final Element</head><p>The next example illustrates how a group of related elements can be identified by
                  the last element in the group, rather than the first. Here the absence of the
                  attribute <code>continued="yes"</code> indicates the end of the group.</p><p>Source XML document:</p><eg xml:space="preserve">&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</eg><p>Desired output:</p><eg xml:space="preserve">&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</eg><p>Solution:</p><eg xml:space="preserve">&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"
                      bind-group="pageset"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="$pageset"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Adding an Element to Several Groups</head><p>The next example shows how an item can be added to multiple groups. Book titles
                  will be added to one group for each indexing term marked up within the title.</p><p>Source XML document:</p><eg xml:space="preserve">&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;</eg><p>Desired output:</p><eg xml:space="preserve">&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;</eg><p>Solution:</p><eg xml:space="preserve">&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"
                        bind-group="group" bind-grouping-key="key"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="$key"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="$group"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg></example><example><head>Grouping Alternating Sequences of Elements</head><p>In this example, the membership of a node within a group is based both on
                  adjacency of the nodes in document order, and on common values. In this case, the
                  grouping key is a boolean condition, true or false, so the effect is that a
                  grouping establishes a maximal sequence of nodes for which the condition is true,
                  followed by a maximal sequence for which it is false, and so on.</p><p>Source XML document:</p><eg xml:space="preserve">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</eg><p>Desired output:</p><eg xml:space="preserve">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</eg><p>Solution:</p><p>This requires creating a <code>p</code> element around the maximal sequence of
                  sibling nodes that does not include a <code>ul</code> or <code>ol</code>
                  element.</p><p>This can be done by using <code>group-adjacent</code>, with a grouping key that is
                  true if the element is a <code>ul</code> or <code>ol</code> element, and false
                  otherwise:</p><eg xml:space="preserve">&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"
            bind-group="group" bind-grouping-key="is-list"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="$is-list"&gt;
                &lt;xsl:copy-of select="$group"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="$group"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg></example></div2><!--Text inserted by erratum E25 change 3"--><div2 id="non-transitivity"><head>Non-Transitivity</head><p>If the population contains values of different numeric types that differ from each
               other by small amounts, then the <code>eq</code> operator is not transitive, because
               of rounding effects occurring during type promotion. It is thus possible to have
               three values <var>A</var>, <var>B</var>, and <var>C</var> among the grouping keys of
               the population such that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne
                  C</code>.</p><p>For example, this arises when computing</p><eg xml:space="preserve">
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001'),
             xs:double('1.00000000001')"&gt;</eg><p>because the values of type <code>xs:float</code> and <code>xs:double</code> both
               compare equal to the value of type <code>xs:decimal</code> but not equal to each
               other.</p><p>In this situation the results <rfc2119>must</rfc2119> be equivalent to the results
               obtained by the following algorithm:</p><ulist><item><p>For each item <var>J</var> in the <termref def="dt-population">population</termref> in <termref def="dt-population-order">population
                        order</termref>, for each of the <termref def="dt-grouping-key">grouping
                        keys</termref>
                     <var>K</var> for that item in sequence, the processor identifies those existing
                     groups <var>G</var> such that the grouping key of the <termref def="dt-initial-item">initial item</termref> of <var>G</var> is equal to
                        <var>K</var>.</p></item><item><p>If there is exactly one group <var>G</var>, then <var>J</var> is added to this
                     group, unless <var>J</var> is already a member of this group.</p></item><item><p>If there is no group <var>G</var>, then a new group is created with
                        <var>J</var> as its first item.</p></item><item><p>If there is more than one group <var>G</var> (which can only happen in
                     exceptional circumstances involving non-transitivity), then one of these groups
                     is selected in an implementation-dependent way, and <var>J</var> is added to
                     this group, unless <var>J</var> is already a member of this group.</p></item></ulist><p>The effect of these rules is that (a) every item in a non-singleton group has a
               grouping key that is equal to that of at least one other item in that group, (b) for
               any two distinct groups, there is at least one pair of items (one from each group)
               whose grouping keys are not equal to each other.</p></div2><!--End of text inserted by erratum E25--></div1><div1 id="merging" diff="chg" at="C"><head>Merging</head><p>The <elcode>xsl:merge</elcode> instruction allows a sorted sequence of items to be
            constructed by merging several input sequences, each of which is already sorted. Each
            input sequence <rfc2119 diff="chg" at="F">must</rfc2119> have a merge key (one or more
            atomic values that can be computed as a function of the items in the sequence); the
            input sequence <rfc2119 diff="chg" at="F">must</rfc2119> be pre-sorted on the value of its merge
            keys; and the merge keys for the different input sequences <rfc2119 diff="chg" at="F">must</rfc2119> be compatible in the sense that <phrase diff="chg" at="F">key values from
               an item in one sequence are always comparable with key values from an item in a
               different sequence</phrase>.</p><p>For example, if two log files contain details of events sorted by date and time, then
            the <elcode>xsl:merge</elcode> instruction can be used to combine these into a single
            sequence that is also sorted by date and time.</p><p>The data written to the output sequence can be computed in an arbitrary way from the
            data in the input sequences, provided it follows the ordering of the input sequences.</p><!--<p>The <elcode>xsl:merge</elcode> instruction checks that the input sequences are correctly
            sorted and signals a dynamic error if they are not. It does not actually perform the
            sorting.</p>--><p>The <elcode>xsl:merge</elcode> instruction can be used to merge several sequences of
            items that all have the same structure (more precisely, sequences whose merge keys are
            computed in the same way): for example, log files created by the same application
            running on different machines in a server farm. Alternatively,
               <elcode>xsl:merge</elcode> can be used to merge sequences that have different
            structure (sequences whose merge keys are computed in different ways), provided that the
            computed merge keys are compatible: an example might be two log files created by
            different applications, using different XML vocabularies, that both contain timestamped
            events but represent the timestamp in different ways. The
               <elcode>xsl:merge-source</elcode> element represents a <phrase diff="chg" at="F">set
               of input sequences that follow common rules</phrase>, including the rules for
            computing the merge key. The <elcode>xsl:merge</elcode> operation may take any number of
               <elcode>xsl:merge-source</elcode> elements representing different <phrase diff="chg" at="F">rules for</phrase> input sequences, and each <elcode>xsl:merge-source</elcode>
            element may describe any number (zero or more) of input sequences. The number of input
            sequences to the merging operation is thus <phrase diff="chg" at="F">fixed only at the
               time the <elcode>xsl:merge</elcode> instruction is evaluated, and
                  <rfc2119>may</rfc2119> vary from one evaluation to another</phrase>.</p><p>The following examples illustrate some of the possibilities. The detailed explanation of
            the constructs used follows later in this section.</p><example><head>Merging All the Files in a Collection</head><p>This example takes as input a homogeneous collection of XML log files each of which
               contains a sorted sequence of <code>event</code> elements with a
                  <code>timestamp</code> attribute validated as an instance of
                  <code>xs:dateTime</code>. It merges the events from the input files into a single
                  sorted output file.</p><eg xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge bind-group="group"&gt;
      &lt;xsl:merge-source for-each="collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="$group"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg><p>The example assumes that there are <phrase diff="chg" at="F">several input files each of which has</phrase> a structure similar to the
               following, in which the <code>timestamp</code> attribute has a typed value that is an instance of
                  <code>xs:dateTime</code>:</p><eg xml:space="preserve">
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</eg><p>The output file will have the same structure, and will contain copies of all the
                  <code>event</code> elements from all of the input files, in sorted order. <phrase diff="chg" at="F">Note that
               multiple events with the same timestamp can occur either within a single file or
               across multiple files: the order of appearance of these events in the output file corresponds
               to the order of the log files within the collection (which might or might not be predictable,
               depending on the implementation).</phrase></p></example><example><head>Merging Two Heterogeneous Files</head><p>This example takes as input two log files with different structure, producing a
            single merged output in which the entries have a common structure:</p><eg xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge bind-group="grp"&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="$grp" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg><p>Here the first input file has a structure similar to that shown in the previous
               example, while the second input has a different structure, of the form: <eg xml:space="preserve">
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</eg></p><p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a
               common output format, for example:</p><eg xml:space="preserve">
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</eg></example><note><p>The <elcode>xsl:merge</elcode> instruction is designed to enable streaming
               of data, so that there is no need to allocate memory to hold the input sequences.
               However, there is no requirement that an implementation should actually use streaming to perform the
               processing.</p></note><div2 id="merge-terminology"><head>Terminology for Merging</head><p><termdef id="dt-merge-source-definition" term="merge source definition">A <term>merge
                     source definition</term> is the definition of one kind of input to the merge
                  operation. It selects zero or more <termref def="dt-merge-input-sequence">merge
                     input sequences</termref>, and it includes a <termref def="dt-merge-key-specification">merge key specification</termref> to define
                  how the <phrase diff="chg" at="F"><termref def="dt-merge-key-value">merge key values</termref></phrase> 
               are computed for each such merge input sequence.</termdef> A
               merge source definition corresponds to an <elcode>xsl:merge-source</elcode> element
               in the stylesheet.</p><p><termdef id="dt-merge-input-sequence" term="merge input sequence">A <term>merge input
                     sequence</term> is an arbitrary <xtermref spec="DM30" ref="dt-sequence">sequence</xtermref> of items which is already sorted according to the <termref def="dt-merge-key-specification">merge key specification</termref> for the
                  corresponding <termref def="dt-merge-source-definition">merge source
                     definition</termref>.</termdef></p><p><termdef id="dt-merge-key-specification" term="merge key specification">A <term>merge
                     key specification</term> consists of one or more adjacent
                     <elcode>xsl:merge-key</elcode> elements which together define how the <termref def="dt-merge-input-sequence">merge input sequences</termref> selected by a
                     <termref def="dt-merge-source-definition">merge source definition</termref> are
                  sorted. Each <elcode>xsl:merge-key</elcode> element defines one <termref def="dt-merge-key-component">merge key component</termref>.</termdef> For
               example, a merge key specification for a log file might specify two merge key
               components, <code>date</code> and <code>time</code>.</p><p><termdef id="dt-merge-key-component" term="merge key component">A <term>merge key
                     component</term> specifies one component of a <termref def="dt-merge-key-specification">merge key specification</termref>; it
                  corresponds to a single <elcode>xsl:merge-key</elcode> element in the
                  stylesheet.</termdef></p><p><termdef id="dt-merge-key-value" term="merge key value"> For each item in a <termref def="dt-merge-input-sequence">merge input sequence</termref>, a value is
                  computed for each <termref def="dt-merge-key-component">merge key
                     component</termref> within the <termref def="dt-merge-key-specification">merge
                     key specification</termref>. The value computed for an item by using the
                     <var>N</var>th <termref def="dt-merge-key-component"/> is referred to as the <var>N</var>th
                     <term>merge key value</term> of that item.</termdef></p><p><termdef id="dt-composite-merge-key-value" term="composite merge key value"> The
                  ordered collection of <termref def="dt-merge-key-value">merge key values</termref>
                  computed for one item in a <termref def="dt-merge-input-sequence">merge input
                     sequence</termref> (one for each <termref def="dt-merge-key-component">merge
                     key component</termref> within the <termref def="dt-merge-key-specification">merge key specification</termref>) is referred to as a <term>composite merge
                     key value</term>.</termdef></p><p><termdef id="dt-merge-activation" term="merge activation">A <term>merge activation</term>
            is a single evaluation of the sequence constructor contained within the
               <elcode>xsl:merge-action</elcode> element, which occurs once for each distinct 
               <termref def="dt-composite-merge-key-value">composite merge key value</termref>.</termdef></p></div2><div2 id="merge-instruction"><head>The <elcode>xsl:merge</elcode> Instruction</head><e:element-syntax name="merge" diff="chg" at="C"><e:in-category name="instruction"/><e:attribute name="bind-group" required="no"><e:data-type name="eqname"/></e:attribute><e:attribute name="bind-key" required="no"><e:data-type name="eqname"/></e:attribute><e:sequence><e:element repeat="one-or-more" name="merge-source"/><e:element name="merge-action"/><e:element repeat="zero-or-more" name="fallback"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The effect of the <elcode>xsl:merge</elcode> instruction is to produce a sorted
               result sequence from a number of input sequences.</p><p>The input sequences to the merge operation are defined by the
                  <elcode>xsl:merge-source</elcode> child elements, as described in the next
               section.</p><p diff="chg" at="C">The sequence constructor contained in the
                  <elcode>xsl:merge-action</elcode> element is evaluated once for each distinct
               <termref def="dt-composite-merge-key-value"/> to form a partial result sequence. 
               The result of the <elcode>xsl:merge</elcode> instruction is the concatenation
               of these partial result sequences. For example,
               the action might be to copy the items from all the input sequences to the result
               sequence without change; or it might be to select the items from one input sequence
               in preference to the others. In the general case, the items in the partial result
               sequence are produced by an arbitrary computation that has access to the items (from
               the various input sequences) that share the same value for the composite merge key.</p><p diff="chg" at="C">The <elcode>xsl:merge-source</elcode> and
                  <elcode>xsl:merge-action</elcode> elements are described in the following
                  sections.</p><p diff="add" at="K">The <code>bind-group</code> attribute establishes the name of
            a variable which is available for reference within the <elcode>xsl:merge-action</elcode>
            element, and whose value is a sequence of items, from all input sources, that share a common
            <termref def="dt-composite-merge-key-value"/>.</p><p diff="add" at="K">The <code>bind-key</code> attribute establishes the name of
               a variable which is available for reference within the <elcode>xsl:merge-action</elcode>
               element, and whose value is the
               <termref def="dt-composite-merge-key-value"/> of these items.</p><p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:merge</elcode>
               instruction are ignored by an XSLT 3.0 processor, but are used by an XSLT 1.0 or XSLT
               2.0 processor to <phrase diff="chg" at="F">perform fallback processing</phrase>.</p><note><p>An <elcode>xsl:merge</elcode> instruction that has no input sequences returns an
                  empty sequence. An <elcode>xsl:merge</elcode> instruction with a single input
                  sequence performs processing that is very similar in concept to
                     <elcode>xsl:for-each-group</elcode> with the <code>group-adjacent</code>
                  attribute, except that it requires the input to be sorted on the grouping key.</p></note></div2><div2 id="merge-input-sequences"><head>Selecting the Sequences to be Merged</head><e:element-syntax name="merge-source"><e:attribute name="for-each" required="no"><e:data-type name="expression"/></e:attribute><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="bind-source" required="no"><e:data-type name="eqname"/></e:attribute><e:attribute name="streamable" required="no"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="sort-before-merge" required="no"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:element repeat="one-or-more" name="merge-key"/><e:allowed-parents><e:parent name="merge"/></e:allowed-parents></e:element-syntax><p>Each <elcode>xsl:merge-source</elcode> element defines one or more <termref def="dt-merge-input-sequence">merge input sequences</termref>.</p><p diff="chg" at="K">In the absence of the <code>for-each</code> attribute,
               the <elcode>xsl:merge-source</elcode> element defines a single merge input
               sequence. This sequence is the result of evaluating the expression in the <code>select</code>
               attribute. This is evaluated using the dynamic context of the containing
               <elcode>xsl:merge</elcode> instruction.</p><p diff="chg" at="K">When the <code>for-each</code> attribute is present, the
            <elcode>xsl:merge-source</elcode> element defines a collection of merge input
            sequences. 
               The selection of
               items in these input sequences is a two-stage process: the <code>for-each</code>
               attribute of the <elcode>xsl:merge-source</elcode> element is an expression that
               selects a sequence of <emph>anchor items</emph>, and for each anchor item, the
                  <code>select</code> attribute is evaluated
               to select the items that make up one merge input sequence.
               The <code>for-each</code> expression is
               evaluated with the dynamic context of the containing <elcode>xsl:merge</elcode>
               instruction, while the <code>select</code> attribute is evaluated with the
               <termref def="dt-focus">focus</termref> for the evaluation as
               follows:</p><ulist><item><p>The <termref def="dt-context-item">context item</termref> is the anchor
                     item</p></item><item><p>The <termref def="dt-context-position">context position</termref> is the
                     position of the anchor item within the sequence of anchor items</p></item><item><p>The <termref def="dt-context-size">context size</termref> is the number of
                     anchor items.</p></item></ulist><p diff="add" at="K">The <code>bind-source</code> attribute establishes the name of
               a variable which is available for reference within the <elcode>xsl:merge-action</elcode>
               element, and whose value is a sequence of items, from this source only, that share
               the <termref def="dt-composite-merge-key-value"/> for this activation of the
               <elcode>xsl:merge-action</elcode>.</p><p diff="add" at="K">If the <code>sort-before-merge</code> attribute is absent
            or has the value <code>no</code>, then each input sequence <rfc2119>must</rfc2119>
            already be in the correct order for merging (a dynamic error occurs if it is not).
            If the attribute is present with the value <code>yes</code>, then each input sequence
            will first be sorted to ensure that it is in the correct order.</p><example><head>Merging Several Documents with the Same Structure</head><p>The following <elcode>xsl:merge-source</elcode> element selects two anchor items
                  (the root nodes of two documents), and for each of these it selects an input
                  sequence consisting of selected <code>event</code> elements within the relevant
                  document.</p><eg xml:space="preserve">
&lt;xsl:merge-source for-each="doc('log-A.xml'), doc('log-B.xml')"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg><p>This example can be extended to merge any number of input documents with the same
                  structure:</p><eg xml:space="preserve">
&lt;xsl:merge-source for-each="collection('log-collection')"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg><p>In both the above examples the anchor items are document nodes, and the items in
                  the input sequence are elements within the document that is rooted at this node.
                  This is a common usage pattern, but by no means the only way in which the
                  construct can be used.</p></example><p>The number of anchor items selected by an <elcode>xsl:merge-source</elcode> element,
               and therefore the number of input sequences, is variable, but the input sequences
               selected by one <elcode>xsl:merge-source</elcode> element must all use the same
               expressions to select the items in the input sequence and to compute their merge
               keys. If different expressions are needed for different input sequences, then
               multiple <elcode>xsl:merge-source</elcode> elements can be used.</p><example><head>Merging Two Documents with Different Structure</head><p>The following code merges two log files having different internal structure:</p><eg xml:space="preserve">
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;</eg><p>Although the merge keys are computed in different ways for the two input
                  sequences, the keys must be compatible across the two sequences: in this case they
                  are both atomic values of type <code>xs:dateTime</code>.</p></example><p>In the common case where there is only one input sequence of a particular kind, the
                  <code>for-each</code> attribute of <elcode>xsl:merge-source</elcode> may be omitted;
                  the <code>select</code> expression is
               then evaluated relative to the <termref def="dt-focus">focus</termref> of the
                  <elcode>xsl:merge</elcode> instruction itself.</p><example><head>Sorting before Merging</head><p>Where one or more of the inputs to the merging process is not pre-sorted, 
                  a sort can be requested using the <code>sort-before-merge</code> attribute. For example:</p><eg xml:space="preserve">
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;                           
&lt;/xsl:merge-source&gt;
</eg></example><!--<p diff="chg" at="I">An <elcode>xsl:merge-source</elcode> element has an optional
                  <code>name</code> attribute, whose value is an <termref def="dt-expanded-qname"
                  >NCName</termref>. This name, if specified, may be used while evaluating the
                  <elcode>xsl:merge-action</elcode> element to identify from which source a particular item
               was read. If the <code>name</code> attribute is omitted then the system allocates
               a name formed by concatenating the string <code>"source"</code> with the integer
               position of the <elcode>xsl:merge-source</elcode> element among its siblings: thus
               the first is named <code>source1</code>, the second <code>source2</code>, and so on.
               For details of how the names are used, see <specref ref="selective-processing-of-merge-inputs"/></p>--><p diff="add" at="E">
               <error spec="XT" type="static" class="SE" code="3190"><p>It is a <termref def="dt-static-error">static error</termref> if two sibling
                        <elcode>xsl:merge-source</elcode> elements have the same name, whether
                  explicit or implicit.</p></error>
            </p></div2><div2 id="streamable-merging" diff="add" at="L"><head>Streamable Merging</head><p>Any (zero or more) of the inputs to a merging operation may be designated as streamable by
            including the attribute <code>streamable="yes"</code> on the <elcode>xsl:merge-source</elcode>
            element.</p><p>If any <elcode>xsl:merge-source</elcode> element is designated as streamable, then in order for
            streamed processing to be guaranteed, the following conditions must be met:</p><olist><item><p>The <code>for-each</code> attribute must be present on that <elcode>xsl:merge-source</elcode>
               element, and its value must be a function call that calls the <function>document</function>,
               <xfunction>doc</xfunction>, or <xfunction>collection</xfunction> function;</p></item><item><p>The expression in the <code>select</code> attribute of that <elcode>xsl:merge-source</elcode>
               element must be an <termref def="dt-incrementally-consuming"/> expression;</p></item><item><p>The <code>sort-before-merge</code> attribute of that <elcode>xsl:merge-source</elcode>
               element must either be absent or take its default value of <code>no</code>;</p></item><item><p>The <code>select</code> expression of each merge key in that <elcode>xsl:merge-source</elcode>
               element must be a <termref def="dt-motionless"/> expression;</p></item><item><p>The <termref def="dt-sequence-constructor"/> in the <elcode>xsl:merge-action</elcode>
               element must be either <termref def="dt-motionless"/> or <termref def="dt-group-consuming"/>.</p></item></olist><example><head>Streamed Merging</head><p>The following example merges two log files, processing each of them using streaming.</p><eg xml:space="preserve">
&lt;events&gt;
   &lt;xsl:merge bind-group="grp" bind-key="key"&gt;
      &lt;xsl:merge-source for-each="doc('log-file-1.xml')" 
                        select="events/event" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source for-each="doc('log-files-2.xml')" 
                        select="log/day/record/snapshot()" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;events time="{$key}"&gt;
            &lt;xsl:copy-of select="$grp"/&gt;
         &lt;/events&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;</eg></example><p>Note the use of the <function>snapshot</function> function. This is needed because the merge key for the second
            merge source includes data from a child element of the selected element (making it non-motionless) and also
            from an attribute of the parent element (making it inaccessible if <function>copy-of</function> were
            used in place of <function>snapshot</function>).</p></div2><div2 id="merge-keys"><head>Defining the Merge Keys</head><p>The keys on which the input sequences are sorted are referred to as merge keys.
            If the attribute <code>sort-before-merge</code> has the value <code>yes</code>,
            the input sequences will be sorted into the correct sequence before the merge
            operation takes place (alternatively, the processor <rfc2119>may</rfc2119> use an algorithm that has
            the same effect as sorting followed by merging). If the attribute is absent or has
            the value <code>no</code>, then the input sequences <rfc2119>must</rfc2119>
            already be in the correct order.</p><p>The merge key for each type of input sequence (that is, for each
                  <elcode>xsl:merge-source</elcode> element) is defined by a sequence of
                  <elcode>xsl:merge-key</elcode> element children of the
                  <elcode>xsl:merge-source</elcode> element. Each <elcode>xsl:merge-key</elcode>
               element defines one merge key component. The syntax and semantics of an
                  <elcode>xsl:merge-key</elcode> element are closely based on the rules for the
                  <elcode>xsl:sort</elcode> element (the only exception being the absence of the
                  <code>stable</code> attribute); the difference is that
                  <elcode>xsl:merge-key</elcode> elements do not cause a sort to take place, they
               merely declare the existing sort order of the input sequence.</p><e:element-syntax name="merge-key"><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="lang"><e:attribute-value-template><e:data-type name="language"/></e:attribute-value-template></e:attribute><e:attribute name="order"><e:attribute-value-template><e:constant value="ascending"/><e:constant value="descending"/></e:attribute-value-template></e:attribute><e:attribute name="collation"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="case-order"><e:attribute-value-template><e:constant value="upper-first"/><e:constant value="lower-first"/></e:attribute-value-template></e:attribute><e:attribute name="data-type"><e:attribute-value-template><e:constant value="text"/><e:constant value="number"/><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="merge-source"/></e:allowed-parents></e:element-syntax><p>The <code>select</code> attribute and the contained <termref def="dt-sequence-constructor">sequence constructor</termref> are mutually
               exclusive:</p><p>
               <error spec="XT" type="static" class="SE" code="3200"><p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:merge-key</elcode> element with a <code>select</code> attribute
                     has non-empty content.</p></error>
            </p><p>The effect of the <elcode>xsl:merge-key</elcode> elements is defined in terms of the
               rules for an equivalent sequence of <elcode>xsl:sort</elcode> elements: if the rules
               for sorting (see <specref ref="sorting-process"/>) with <code>stable="yes"</code>
               would place an item <var>A</var> before an item <var>B</var> in the <termref def="dt-sorted-sequence">sorted sequence</termref> produced by the sorting
               process, then <var>A</var> must precede <var>B</var> in the input sequence to the
               merging process.</p><p>The merge keys of the various input sequences to a merge operation must be compatible
               with each other, since the merge operation will decide the ordering of the result
               sequence by comparing merge key values across input sequences. This means that across
               all the <elcode>xsl:merge-source</elcode> children of an <elcode>xsl:merge</elcode>
               instruction:</p><ulist><item><p>Each <elcode>xsl:merge-source</elcode> element <rfc2119>must</rfc2119> have the
                     same number of <elcode>xsl:merge-key</elcode> child elements; let this
                     number be <var>N</var>.</p></item><item><p>For each integer <var>J</var> in 1..<var>N</var>, consider the set of
                        <elcode>xsl:merge-key</elcode> elements that are in position <var>J</var>
                     among the <elcode>xsl:merge-key</elcode> children of their parent
                        <elcode>xsl:merge-source</elcode> element. All the
                        <elcode>xsl:merge-key</elcode> elements in this set <rfc2119>must</rfc2119>
                     have the same <termref def="dt-effective-value">effective value</termref> for
                     their <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, and <code>data-type</code> attributes, where having
                     the same effective value in this case means that either both attributes must be
                     absent, or both must be present and evaluate to the same value; and in addition
                     in the case of <code>collation</code> the absolute URI must be the same after
                     resolving against the base URI. </p></item></ulist><p>If any of the attributes <code>lang</code>, <code>order</code>,
                  <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are
                  <termref def="dt-attribute-value-template">attribute value templates</termref>,
               then their <termref def="dt-effective-value">effective values</termref> are evaluated
               using the <termref def="dt-focus">focus</termref> of the containing
                  <elcode>xsl:merge</elcode> instruction.</p><p>
               <error spec="XT" type="static" class="SE" code="2200"><p>It is a <termref def="dt-static-error">static error</termref> if the number of
                        <elcode>xsl:merge-key</elcode> children of a
                        <elcode>xsl:merge-source</elcode> element is not equal to the number of
                        <elcode>xsl:merge-key</elcode> children of another
                        <elcode>xsl:merge-source</elcode> child of the same
                        <elcode>xsl:merge</elcode> instruction.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="2210"><p diff="chg" at="I">It is a <termref def="dt-dynamic-error">dynamic error</termref> if there are two
                        <elcode>xsl:merge-key</elcode> elements that occupy corresponding positions
                     among the <elcode>xsl:merge-key</elcode> children of two different
                        <elcode>xsl:merge-source</elcode> elements and that have differing <termref def="dt-effective-value">effective values</termref> for any of the
                     attributes <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, or <code>data-type</code>. Values are considered to differ
                     if the attribute is present on one element and not on the other, or if
                     it is present on both elements with <termref def="dt-effective-value">effective
                        values</termref> that are not equal to each other. In the case of the
                        <code>collation</code> attribute, the values are compared as absolute URIs
                        after resolving against the base URI.</p><p>The error <rfc2119>may</rfc2119> be reported statically if it is detected statically.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="2220"><p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if any input
                     sequence to an <elcode>xsl:merge</elcode> instruction contains two items that
                     are not correctly sorted according to the merge key values defined on the
                        <elcode>xsl:merge-key</elcode> children of the corresponding
                        <elcode>xsl:merge-source</elcode> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <elcode>xsl:merge-key</elcode> children of the <elcode>xsl:merge</elcode>
                     instruction, unless the attribute <code>sort-before-merge</code> is present
                  with the value <code>yes</code>.</p></error>
            </p><p>
               <error spec="XT" type="type" class="TE" code="2230"><p>It is a <termref def="dt-type-error">type error</termref> if some item selected
                     by a particular merge key in one input sequence is not comparable using the
                     XPath <code>le</code> operator with some item selected by the corresponding
                     sort key in another input sequence.</p></error>
            </p></div2><div2 id="merge-action"><head>The <elcode>xsl:merge-action</elcode> Element</head><p>The <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode>
               instruction defines the processing to be applied for each distinct 
               <termref def="dt-composite-merge-key-value"/> 
               found in the input sequences to the <elcode>xsl:merge</elcode>
               instruction.</p><e:element-syntax name="merge-action"><e:sequence><e:model name="sequence-constructor"/></e:sequence><e:allowed-parents><e:parent name="merge"/></e:allowed-parents></e:element-syntax><p>The merge key values for each item in an input sequence are calculated based on the
               corresponding <elcode>xsl:merge-key</elcode> elements, in the same way as <termref def="dt-sort-key-value">sort key values</termref> are calculated using a sequence
               of <elcode>xsl:sort</elcode> elements (see <specref ref="sorting-process"/>). If
               several items from the same or from different input sequences have the same values
               for all their merge keys (comparing pairwise), then they are considered to form a
               group. The sequence constructor contained in the <elcode>xsl:merge-action</elcode>
               element is evaluated once for each such group of items, and the result of the
                  <elcode>xsl:merge</elcode> instruction is the concatenation of the results
               obtained by processing each group in turn.</p><p><phrase diff="chg" at="F">The groups are processed one by one, based on the values of the merge keys for
               the group.</phrase> If group <var>G</var> has a set of merge key values <var>M</var>,
               while group <var>H</var> has a set of merge key values <var>N</var>, then in the
               result of the <elcode>xsl:merge</elcode> instruction, the result of processing group
                  <var>G</var> will precede the result of processing <var>H</var> if and only if
                  <var>M</var> precedes <var>N</var> in the sort order defined by the
                  <code>lang</code>, <code>order</code>, <code>collation</code>,
                  <code>case-order</code>, and <code>data-type</code> attributes of the merge key
               definitions.</p><p>Generally, two sets of sort key values are distinct if any corresponding items in the
               two sets of values do not compare equal under the rules for the XPath <code>eq</code>
               operator, under the collating rules for the corresponding merge key definition. In
               rare cases, when considering more than two sets of sort key values, ambiguities may
               arise because of the non-transitivity of the <code>eq</code> operator when applied
               across different numeric types. In this situation, the partitioning of items into
               sets having distinct key values is handled in the same way as for
                  <elcode>xsl:for-each-group</elcode> (see <specref ref="non-transitivity"/>), and
               is to some extent <termref def="dt-implementation-dependent">implementation-dependent</termref>. </p><p diff="chg" at="L">The static context for the sequence constructor contained
            within the <elcode>xsl:merge-action</elcode> element includes the variables declared
            using the <code>bind-group</code> and <code>bind-key</code> attributes of the containing
            <elcode>xsl:merge</elcode> instruction and the <code>bind-source</code> attributes of
            the <elcode>xsl:merge-source</elcode> children of this <elcode>xsl:merge</elcode>
            instruction.</p><p><error spec="XT" type="static" class="SE" code="3270"><p>It is a <termref def="dt-static-error">static error</termref> if the set of
               variable names declared
               using the <code>bind-group</code> and <code>bind-key</code> attributes of an
               <elcode>xsl:merge</elcode> instruction and the <code>bind-source</code> attributes of
               its <elcode>xsl:merge-source</elcode> children contains any duplicates.</p></error></p><p diff="chg" at="L">The variable defined in the <code>bind-key</code> attribute, if any,
               is bound to the value of the <termref def="dt-composite-merge-key-value"/>. 
               There may be several input items having merge keys that are equal but
               distinguishable (for example the number 1.0 as a float and as a double, or the strings "A"
               and "a" under a case-blind collation); in this case the value of the
                  variable is the value of the merge key
               computed for the first item in the current group, after atomization and casting of
                  <code>xs:untypedAtomic</code> to <code>xs:string</code>.</p><p diff="chg" at="L">The variable defined in the <code>bind-group</code> attribute,
               if any, is bound to the set of items (zero or
               more from each input sequence) that have this set of values as their merge key value.
               The value of this variable is referred to as the <term>current group</term>.</p><p>Within the current group, the ordering of
               items from the input sequences is as follows, in major-to-minor order:</p><ulist><item><p>Items are first ordered by the <elcode>xsl:merge-source</elcode> element that
                     defined the input sequence from which the item was taken; items from
                        <elcode>xsl:merge-source</elcode>
                     <var>A</var> precede items from <elcode>xsl:merge-source</elcode>
                     <var>B</var> if <var>A</var> precedes <var>B</var> in document order within the
                     stylesheet.</p></item><item><p>Items from different input sequences selected by the same
                        <elcode>xsl:merge-source</elcode> element are then ordered based on the
                     order of the anchor items in the sequence selected by evaluating the
                        <code>select</code> attribute of the <elcode>xsl:merge-source</elcode>
                     element.</p></item><item><p>Finally, duplicate items from the same input sequence retain their order from
                     the input sequence.</p></item></ulist><p diff="add" at="L">Duplicates are not eliminated: for example, if the same node is selected
            in more than one input sequence, it may appear twice in the current group.</p><p diff="chg" at="L">The variable defined in the <code>bind-source</code> attribute
               of an <elcode>xsl:merge-source</elcode> element,
               if any, is bound to the current group, filtered to include only those items that
               originate from the merge source in question.</p><p>The <termref def="dt-focus">focus</termref> for evaluation of the sequence
               constructor contained in the <elcode>xsl:merge-action</elcode> element is as
               follows:</p><ulist><item><p>The <termref def="dt-context-item">context item</termref> is the first item in
                     the current group, that is <code>current-group()[1]</code></p></item><item><p>The <termref def="dt-context-position">context position</termref> is the
                     position of the current group within the sequence of groups (so the first
                     evaluation of <elcode>xsl:merge-action</elcode> has <code>position()=1</code>,
                     the second has <code>position()=2</code>, and so on).</p></item><item><p>The <termref def="dt-context-size">context size</termref> is the number of
                     groups, that is, the number of distinct sets of merge key values.</p></item></ulist><example><head>Selective Processing of Merge Inputs</head><p>Consider a situation where there are two merge sources, named "master" and
                  "update"; the master source identifies a single merge input file (the master
                  file), while the update source identifies a set of <var>N</var> update files, perhaps one for
                  each day of the week. The required logic is that if a merge key is present only in
                  the master file, then the corresponding item should be copied to the output; if it
                  is present in a single update file then that item replaces the corresponding item
                  from the master file; if it is present in several update files, then an error is
                  raised. This can be achieved as follows:</p><eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source bind-source="master" 
                    for-each="doc('master.xml')"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source bind-source="updates" 
                    for-each="collection('updates')"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty($master)"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty($updates)"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count($updates) = 1"&gt;
        &lt;xsl:copy-of select="$updates"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            </eg><p>Some words of explanation:</p><ulist><item><p diff="chg" at="H">Error messages are produced if there is an update element
                        whose key does not correspond to any element in the master source, or if there
                        is more than one update element corresponding to the same master element.</p></item><item><p diff="chg" at="H">In the absence of errors, if there is a single update element then it is copied
                     to the output; if there is none, then the master element is copied.</p></item></ulist></example></div2><div2 id="merge-examples"><head>Examples of xsl:merge</head><p>Previous sections introduced examples designed to illustrate some specific features
               of the <elcode>xsl:merge</elcode> instruction. This section provides some further
               examples to illustrate different ways in which the instruction can be used.</p><example><head>Applying Transactions to a Master File</head><p>This example applies transactions from a transaction file to a master file.
                  Records in the master file for which there is no corresponding transaction are
                  copied unchanged. The transaction file contains instructions to delete, replace,
                  or insert records identified by an ID value. The master file is known to be sorted
                  on the ID value; the transaction file is unsorted.</p><p>Master file document structure:</p><eg xml:space="preserve">&lt;data&gt;
  &lt;record ID="A0001"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0002"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0003"&gt;&lt;...&gt;&lt;/record&gt;
&lt;/data&gt;</eg><p>Transaction file document structure:</p><eg xml:space="preserve">&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;&lt;...&gt;&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;&lt;...&gt;&lt;/update&gt;
&lt;/transactions&gt;</eg><p>Solution:</p><eg xml:space="preserve">
 &lt;xsl:merge bind-key="merge-key"&gt;
  &lt;xsl:merge-source bind-source="master"
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source bind-source="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty($updates)"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$updates/@action=('insert', 'replace')"&gt;
        &lt;record ID="{$merge-key}"&gt;
          &lt;xsl:copy-of select="$update/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$updates/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;</eg></example><example><head>Merging Two Sequences of Numbers</head><p>The <elcode>xsl:merge</elcode> instruction can be used to determine the union,
                  intersection, or difference of two sequences of numbers (or other atomic values).
                  This code gives the union:</p><eg xml:space="preserve">&lt;xsl:merge bind-key="k"&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:value-of select="$k"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg><p>While this gives the intersection:</p><eg xml:space="preserve">&lt;xsl:merge bind-key="k" bind-group="g"&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count($g) eq 2"&gt;
      &lt;xsl:value-of select="$k"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg></example></div2></div1><div1 id="splitting" diff="add" at="B"><head>Splitting</head><div2 id="splitting-introduction"><head>Introduction</head><p>Sometimes it is convenient to be able to compute multiple results during a single
               scan of the input data. For example, a transformation may wish to rename selected
               elements, and also to output a count of how many elements have been renamed.
               Traditionally in a functional language this means computing two separate functions of
               the input sequence, which (in the absence of sophisticated optimization) will result
               in the input being scanned twice. This is inconsistent with streaming, where the
               input is only available to be scanned once, and it can also lead to poor performance
               in non-streaming applications.</p><p>To meet this requirement, XSLT 3.0 introduces the instruction
                  <elcode>xsl:fork</elcode>. The content of this instruction is a 
               <phrase diff="add" at="L">restricted form of</phrase>
               <termref def="dt-sequence-constructor">sequence constructor</termref>, and in a formal
               sense the effect of the instruction is simply to return the result of evaluating the
               sequence constructor. However, the presence of the instruction affects the analysis
               of streamability (see <specref ref="streamability"/>). In particular, when
                  <elcode>xsl:fork</elcode> is used in a context where streaming is required, each
               independent instruction within the sequence constructor must be streamable, but the
               analysis assumes that these instructions can all be evaluated during a single pass of
               the streamed input document.</p><note><p>The semantics of the instruction require a number of result sequences to be
                  computed during a single pass of the input. A processor <rfc2119>may</rfc2119>
                  interpret this as a request to use multiple threads. However, implementations
                  using a single thread are feasible, and this instruction is not intended primarily
                  as a means for stylesheet authors to express their intentions with regard to
                  multi-threaded execution.</p></note><note><p>Because multiple results are computed during a single pass of the input, and then
                  concatenated into a single sequence, this instruction will generally involve some
                  buffering of results. The amount of memory used <rfc2119>should not</rfc2119>
                  exceed that needed to hold the results of the instruction. However, within this
                  principle, implementations may adopt a variety of strategies for evaluation; for
                  example, there may be cases where buffering of the input is more efficient than
                  buffering of output.</p><p>Generally, stylesheet authors indicate that buffering of input is the preferred
                  strategy by using the <function>copy-of</function> or <function>snapshot</function>
                  functions, and indicate that buffering of output is preferred by using
                     <elcode>xsl:fork</elcode>. However, conformant processors are not constrained
                  in their choice of evaluation strategies.</p></note><example><head>Splitting a Transaction File</head><p>Consider a transaction file that contains a sequence of debits and credits:</p><eg xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;</eg><p>where the requirement is to split this into two separate files containing credits
                  and debits respectively.</p><p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as follows:</p><eg xml:space="preserve">
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value ge 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value lt 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;
            </eg><p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because the sequence constructor includes two <termref def="dt-consuming"/> instructions. 
                  With the addition of the
                     <elcode>xsl:fork</elcode> instruction, however, each
                     <elcode>xsl:result-document</elcode> instruction is allowed to make a downwards
                  selection. </p><p>One possible implementation model for this is as follows: a single thread reads
                  the source document, and sends parsing events such as start-element and
                  end-element to two other threads, each of which is writing one of the two result
                  documents. Each of these implements the downwards-selecting path expression using
                  a process that waits until the next <code>transaction</code> start-element event
                  is received; when this event is received, the process examines the
                     <code>@value</code> attribute to determine whether or not this transaction is
                  to be copied; if it is, then all events until the matching
                     <code>transaction</code> end-element event are copied to the serializer for the
                  result document; otherwise, these events are discarded.</p></example><p diff="del" at="L">The <elcode>xsl:sequence</elcode> instruction may be used as a
               child of <elcode>xsl:fork</elcode> to break the instructions within
                  <elcode>xsl:fork</elcode> into a number of separate groups, each of which is
               considered as (and indeed is) a separate instruction operating in a single pass over
               the data.</p><p>The following section describes the <elcode>xsl:fork</elcode> instruction more
               formally.</p></div2><div2 id="fork-instruction" diff="chg" at="K"><head>The <code>xsl:fork</code> Instruction</head><e:element-syntax name="fork"><e:in-category name="instruction"/><e:sequence repeat="one-or-more"><e:choice><e:element name="sequence"/><e:element name="fallback"/></e:choice></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The result of the <elcode>xsl:fork</elcode> instruction is the sequence formed
               by concatenating the results of evaluating each of 
               its contained <elcode>xsl:sequence</elcode> instructions, in order.
               That is, the result can be determined by treating the content as a <termref def="dt-sequence-constructor">sequence
               constructor</termref> and evaluating it as such.</p><note><p>Any <elcode>xsl:fallback</elcode> children will be ignored by an
            XSLT 3.0 processor.</p></note><p>By using the <elcode>xsl:fork</elcode> instruction, the stylesheet author is
               suggesting to the <termref def="dt-processor">processor</termref> that it would be
               beneficial to evaluate the contained <elcode>xsl:sequence</elcode> 
               instructions during a single pass of a streamed input document. The
               processor is not <rfc2119>required</rfc2119> to take any notice of this
               suggestion.</p><p>The presence of an <elcode>xsl:fork</elcode> instruction affects the analysis of
               streamability, as described in <specref ref="streamability"/>.</p><example diff="add" at="L"><head>Using <elcode>xsl:fork</elcode> when Streaming</head><p>The rules for streamability do not allow two instructions in a sequence constructor to both
               read child or descendant elements of the context node. This restriction can be avoided by using
               <elcode>xsl:fork</elcode>, as shown below, where each of the two branches of the <elcode>xsl:fork</elcode>
               instruction selects children of the context node.</p><eg xml:space="preserve">
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;</eg><p>A possible implementation strategy here is for events from the XML parser to be sent to
               two separate agents (perhaps but not necessarily running in different threads), one of which computes
               <code>xs:decimal(price)</code> and the other <code>xs:decimal(discount)</code>; on completion the results
               computed by the two agents are appended to the sequence that forms the value of the variable.</p><p>With this strategy, the processor would require sufficient memory to hold the results of evaluating
                  each branch of the fork. If these results (unlike this example) are large, this could defeat the purpose of streaming by requiring
                  large amounts of memory; nevertheless, this code is treated as streamable.</p></example></div2><div2 id="splitting-examples"><head>Examples of Splitting with Streamed Data</head><p>This section gives examples of how splitting using <elcode>xsl:fork</elcode> can be
               used to enable streaming of input documents in cases where several results
               need to be computed during a single pass over the input data.</p><example><head>Deleting Elements, and Counting Deletions</head><p>In this example the input is a narrative document containing <code>note</code>
                  elements at any level of nesting. The requirement is to output a copy of the input
                  document in which (a) the <code>note</code> elements have been removed, and (b) a
                     <code>footnote</code> is added at the end indicating how many <code>note</code>
                  elements have been deleted.</p><eg xml:space="preserve">&lt;xsl:mode on-no-match="deep-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               </eg><p>The <elcode>xsl:fork</elcode> instruction contains two independent branches.
                  These can therefore be evaluated in the same pass over
                  the input data. The first branch (the <elcode>xsl:apply-templates</elcode>
                  instruction) causes everything except the <code>note</code> elements to be copied
                  to the result; the second instruction (the literal result element
                     <code>footnote</code>) outputs a count of the number of descendant
                     <code>note</code> elements.</p><p>Note that although the processing makes a single pass over the input stream, there
                  is some buffering of results required, because the results of the instructions
                  within the <elcode>xsl:fork</elcode> instruction need to be concatenated. In this
                  case an intelligent implementation might be able to restrict the buffered data to
                  a single integer.</p><p>In a formal sense, however, the result is exactly the same as if the
                     <elcode>xsl:fork</elcode> element were not there.</p><p diff="add" at="K">An alternative way of solving this example problem would be to count the number
               of <code>note</code> elements using an accumulator: see <specref ref="accumulators"/>.</p></example></div2></div1><div1 id="regular-expressions"><head>Regular Expressions</head><p>The <termref def="dt-core-function">core function</termref> library for XPath 3.0
            defines three <phrase diff="add" at="D">basic</phrase> functions that make use of
            regular expressions:</p><ulist><item><p>
                  <xfunction>matches</xfunction> returns a boolean result that indicates whether or
                  not a string matches a given regular expression.</p></item><item><p>
                  <xfunction>replace</xfunction> takes a string as input and returns a string
                  obtained by replacing all substrings that match a given regular expression with a
                  replacement string.</p></item><item><p>
                  <xfunction>tokenize</xfunction> returns a sequence of strings formed by breaking a
                  supplied input string at any separator that matches a given regular
                  expression.</p></item></ulist><p>These functions are described in <bibref ref="xpath-functions-30"/>.</p><p>For more complex string processing than is possible using these functions, XSLT provides
            an instruction <elcode>xsl:analyze-string</elcode>, which is defined in this
            section.</p><p>The regular expressions used by this instruction, and the flags that control the
            interpretation of these regular expressions, <rfc2119>must</rfc2119> conform to the
            syntax defined in <bibref ref="xpath-functions-30"/> (see <xspecref spec="FO30" ref="regex-syntax"/>), which is itself based on the syntax defined in <bibref ref="xmlschema-2"/>.</p><note diff="add" at="C"><p>XPath 3.0 adds a fourth function, <xfunction>analyze-string</xfunction>, whose
               functionality is closely modeled on the <elcode>xsl:analyze-string</elcode>
               instruction described in this section, repackaging the facilities in the form of a
               function.</p></note><div2 id="analyze-string"><head>The <code>xsl:analyze-string</code> Instruction</head><e:element-syntax name="analyze-string"><e:in-category name="instruction"/><e:attribute name="select" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="regex" required="yes"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="flags" required="no"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:sequence><e:element repeat="zero-or-one" name="matching-substring"/><e:element repeat="zero-or-one" name="non-matching-substring"/><e:element repeat="zero-or-more" name="fallback"/></e:sequence><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><e:element-syntax name="matching-substring"><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="analyze-string"/></e:allowed-parents></e:element-syntax><e:element-syntax name="non-matching-substring"><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="analyze-string"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:analyze-string</elcode> instruction takes as input a string (the
               result of evaluating the expression in the <code>select</code> attribute) and a
               regular expression (the effective value of the <code>regex</code> attribute).</p><p>If the result of evaluating the <code>select</code> expression 
               <phrase diff="add" at="G"><!--bug 7676-->is an empty sequence, it is treated as a zero-length
               string. If the value </phrase>is not a string, it is
               converted to a string by applying the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p><p>The <code>flags</code> attribute may be used to control the interpretation of the
               regular expression. If the attribute is omitted, the effect is the same as supplying
               a zero-length string. This is interpreted in the same way as the <code>$flags</code>
               attribute of the functions <xfunction>matches</xfunction>,
                  <xfunction>replace</xfunction>, and <xfunction>tokenize</xfunction>. Specifically,
               if it contains the letter <code>m</code>, the match operates in multiline mode. If it
               contains the letter <code>s</code>, it operates in dot-all mode. If it contains the
               letter <code>i</code>, it operates in case-insensitive mode. If it contains the
               letter <code>x</code>, then whitespace within the regular expression is ignored. For
               more detailed specifications of these modes, see <bibref ref="xpath-functions-30"/>
                  (<xspecref ref="flags" spec="FO30"/>).</p><note><p>Because the <code>regex</code> attribute is an attribute value template, curly
                  brackets within the regular expression must be doubled. For example, to match a
                  sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For
                  regular expressions containing many curly brackets it may be more convenient to
                  use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
                  to use a variable.</p></note><p>The <elcode>xsl:analyze-string</elcode> instruction may have two child elements:
                  <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode>. Both elements are optional, and
               neither may appear more than once. At least one of them must be present. If both are
               present, the <elcode>xsl:matching-substring</elcode> element must come first.</p><p>The content of the <elcode>xsl:analyze-string</elcode> instruction must take one of
               the following forms:</p><olist><item><p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by zero
                     or more <elcode>xsl:fallback</elcode> instructions</p></item><item><p>A single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p></item><item><p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by a
                     single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p></item></olist><p>
               <error spec="XT" type="static" class="SE" code="1130"><p>It is a <termref def="dt-static-error">static error</termref> if the
                        <elcode>xsl:analyze-string</elcode> instruction contains neither an
                        <elcode>xsl:matching-substring</elcode> nor an
                        <elcode>xsl:non-matching-substring</elcode> element.</p></error>
            </p><p>Any <elcode>xsl:fallback</elcode> elements among the children of the
                  <elcode>xsl:analyze-string</elcode> instruction are ignored by an XSLT 2.0 <phrase diff="add" at="A">or 3.0</phrase> processor, but allow fallback behavior to be
               defined when the stylesheet is used with an XSLT 1.0 processor operating with
               forwards-compatible behavior.</p><p>This instruction is designed to process all the non-overlapping substrings of the
               input string that match the regular expression supplied.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="1140"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> does not
                     conform to the <rfc2119>required</rfc2119> syntax for regular expressions, as
                     specified in <bibref ref="xpath-functions-30"/>. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="1145"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>flags</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> has a value
                     other than the values defined in <bibref ref="xpath-functions-30"/>. If the value
                     of the attribute is known statically (for example, if the attribute does not
                     contain any <termref def="dt-expression">expressions</termref> enclosed in
                     curly brackets) then the processor <rfc2119>may</rfc2119> signal the error as a
                        <termref def="dt-static-error">static error</termref>. </p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="1150"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> is a
                     regular expression that matches a zero-length string: or more specifically, if
                     the regular expression <code>$r</code> and flags <code>$f</code> are such that
                        <code>matches("", $r, $f)</code> returns true. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p></error>
            </p><p>The <elcode>xsl:analyze-string</elcode> instruction starts at the beginning of the
               input string and attempts to find the first substring that matches the regular
               expression. If there are several matches, the first match is defined to be the one
               whose starting position comes first in the string. If several alternatives within the
               regular expression both match at the same position in the input string, then the
               match that is chosen is the first alternative that matches. For example, if the input
               string is <code>The quick brown fox jumps</code> and the regular expression is
                  <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. </p><p>Having found the first match, the instruction proceeds to find the second and
               subsequent matches by repeating the search, starting at the first character that was
               not included in the previous match.</p><p>The input string is thus partitioned into a sequence of substrings, some of which
               match the regular expression, others which do not match it. Each substring will
               contain at least one character. This sequence of substrings is processed using the
               <phrase diff="chg" at="F">instructions within the contained <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode> elements</phrase>. A matching
               substring is processed using the <elcode>xsl:matching-substring</elcode> element, a
               non-matching substring using the <elcode>xsl:non-matching-substring</elcode> element.
               Each of these elements takes a <termref def="dt-sequence-constructor"/> as its content. If the element is
               absent, the effect is the same as if it were present with empty content. In
               processing each substring, the contents of the substring will be the <termref def="dt-context-item">context item</termref> (as a value of type
                  <code>xs:string</code>); the position of the substring within the sequence of
               matching and non-matching substrings will be the <termref def="dt-context-position">context position</termref>; and the number of matching and non-matching
               substrings will be the <termref def="dt-context-size">context size</termref>.</p><p>If the input is a zero-length string, the number of substrings will be zero, so
               neither the <elcode>xsl:matching-substring</elcode> nor
                  <elcode>xsl:non-matching-substring</elcode> elements will be evaluated.</p></div2><div2 id="func-regex-group"><head><?function fn:regex-group?></head><p><termdef id="dt-current-captured-substrings" term="current captured substrings" role="placemarker"/></p></div2><div2 id="regex-examples"><head>Examples of Regular Expression Matching</head><example><head>Replacing Characters by Elements</head><p>Problem: replace all newline characters in the <code>abstract</code> element by
                  empty <code>br</code> elements:</p><p>Solution:</p><eg xml:space="preserve">&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg></example><example><head>Recognizing non-XML Markup Structure</head><p>Problem: replace all occurrences of <code>[...]</code> in the <code>body</code> by
                     <code>cite</code> elements, retaining the content between the square brackets
                  as the content of the new element.</p><p>Solution:</p><eg xml:space="preserve">&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg><p>Note that this simple approach fails if the <code>body</code> element contains
                  markup that needs to be retained. In this case it is necessary to apply the
                  regular expression processing to each text node individually. If the
                     <code>[...]</code> constructs span multiple text nodes (for example, because
                  there are elements within the square brackets) then it probably becomes necessary
                  to make two or more passes over the data.</p></example><example><head>Parsing a Date</head><p>Problem: the input string contains a date such as <code>23 March 2002</code>.
                  Convert it to the form <code>2002-03-23</code>.</p><p>Solution (with no error handling if the input format is incorrect):</p><eg xml:space="preserve">&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg><p>Note the use of <code>normalize-space</code> to simplify the work done by the
                  regular expression, and the use of doubled curly brackets because the
                     <code>regex</code> attribute is an attribute value template.</p></example></div2></div1><div1 id="accumulators" diff="add" at="K"><head>Accumulators</head><p>Accumulators are introduced in XSLT 3.0 to enable data that is read during streamed
         processing of a document to be accumulated, processed or retained for later use. However,
         they may equally be used with non-streamed processing.</p><p>An accumulator defines a value that is computed progressively while processing
         the nodes of a document in document order. The value for a given node is available
         via a pair of functions, one giving the value for a node before processing its descendants,
         and one given the value for the same node after processing its descendants.</p><p>The following sections give first, the syntax rules for defining an accumulator; secondly,
         and informal description of the semantics; then a more formal definition; and finally, examples.
         But to illustrate the concept intuitively, the following simple example shows how an accumulator
         can be used for numbering of nodes</p><example><head>Numbering Figures within a Chapter</head><p>This example assumes document input in which <code>figure</code> elements can
               appear within <code>chapter</code> elements (which we assume are not nested), and the requirement
               is to render the figures with a caption that includes the figure number within its containing
               chapter.</p><p>When the document is processed using streaming, the <elcode>xsl:number</elcode>
               instruction is not available, so a solution using accumulators is needed.</p><p>The required accumulator can be defined and used like this:</p><eg xml:space="preserve">
   &lt;xsl:accumulator name="f:figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" new-value="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" new-value="$value + 1"/&gt;
   &lt;/xsl:accumulator&gt;
   
   &lt;xsl:mode streamable="yes"/&gt;
   &lt;xsl:template match="figure"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure &lt;xsl:value-of select="f:figNr()"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;  
                  </eg></example><div2 id="accumulator-declaration"><head>Declaring an Accumulator</head><e:element-syntax name="accumulator"><e:in-category name="declaration"/><e:attribute name="name"><e:data-type name="eqname"/></e:attribute><e:attribute name="post-descent" required="no"><e:data-type name="eqname"/></e:attribute><e:attribute name="initial-value"><e:data-type name="expression"/></e:attribute><e:attribute name="as"><e:data-type name="sequence-type"/></e:attribute><e:attribute name="visibility" required="no"><e:constant value="public"/><e:constant value="private"/><e:constant value="final"/><e:constant value="abstract"/></e:attribute><e:attribute name="streamable"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:element name="accumulator-rule" repeat="one-or-more"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><e:element-syntax name="accumulator-rule"><e:attribute name="match" required="yes"><e:data-type name="pattern"/></e:attribute><e:attribute name="phase" required="no"><e:constant value="start"/><e:constant value="end"/></e:attribute><e:attribute name="new-value" required="yes"><e:data-type name="expression"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="accumulator"/></e:allowed-parents></e:element-syntax><p>An <elcode>xsl:accumulator</elcode> element is a <termref def="dt-declaration">declaration</termref>
         that declares one or two functions, each of arity zero. The first function, called the pre-descent function,
         has the name given by the <code>name</code> attribute, and the second, called the post-descent function,
         has the name given by the <code>post-descent</code> attribute if present; if absent, the post-descent
         function is not available. Both names follow the same rules as the <code>name</code> attribute on 
            the <elcode>xsl:function</elcode> attribute, which means they must be namespace-qualified.
         In the event of a conflict with the names of other functions, the same rules apply as for
         an <elcode>xsl:function</elcode> declaration. The visibility of the two functions is determined by the
         <code>visibility</code> attribute in the same way as for other functions.</p><p diff="add" at="L"><termdef id="dt-accumulator-function" term="accumulator function">The functions declared in 
         an <elcode>xsl:accumulator</elcode> declaration are referred to as <term>accumulator functions</term>.</termdef></p><p diff="add" at="L">It is a <termref def="dt-static-error">static error</termref> [Error code TBA] if
            neither of the attributes <code>name</code> nor <code>post-descent</code> is present.</p><p>The two functions return, respectively,
         the value of the accumulator before visiting the descendants of a given node, and the value after visiting
         the descendants of a node. For each of these functions, the arity is zero (there are no arguments), and the
         function applies implicitly to the context node. The type of the return value (for both functions) is
         given by the <code>as</code> attribute of the <elcode>xsl:accumulator</elcode> element.</p><p diff="add" at="L">Because (when streaming) <termref def="dt-accumulator-function">accumulator functions</termref> 
            can only be called in specific
         circumstances, it is not permitted to make dynamic calls on these functions. Therefore, accumulator
         functions cannot be bound to function items using the 
            <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="doc-xpath30-NamedFunctionRef" xlink:type="simple">NamedFunctionRef</xnt> syntax (<code>qname#arity</code>); they cannot
         be partially applied (by using <code>?</code> in place of a function argument); they cannot be discovered
         dynamically using <xfunction>function-lookup</xfunction>; a call on <function>function-available</function>
         returns <code>false</code>; and they are not available for use in XPath
         expressions executed using <elcode>xsl:evaluate</elcode>. [Error conditions TBA]</p><p>The initial value of the accumulator is obtained by evaluating the expression in the <code>initial-value</code>
         attribute. The values for individual nodes in a tree are obtained by applying the rules contained within
         the <elcode>xsl:accumulator</elcode> declaration, as described in subsequent sections.</p><p>The expression in the <code>initial-value</code> attribute is evaluated with the same static and
         dynamic context as the expression in the <code>select</code> attribute of a global variable declaration,
         except that no function declared by any <elcode>xsl:accumulator</elcode> declaration, including this one,
         is available.</p><p>The expression in the <code>new-value</code> attribute of <elcode>xsl:accumulator-rule</elcode>
            is evaluated with the a static context that follows the normal rules for expressions in stylesheets, 
            except that:</p><ulist><item><p>An additional variable is present in the context. The name of this variable is
               <code>value</code> (in no namespace), and its type is the type that appears in the <code>as</code>
               attribute of the <elcode>xsl:accumulator</elcode> declaration.</p></item><item><p>No function declared by any <elcode>xsl:accumulator</elcode> declaration, including this one,
            is available.</p></item><item><p>The context item for evaluation of the expression will always be a node that matches
               the <termref def="dt-pattern">pattern</termref> in the <code>match</code> attribute.</p></item></ulist><p>The result of both the <code>initial-value</code> and <code>new-value</code> expressions
         is converted to the type declared in the <code>as</code> attribute by applying the
         <termref def="dt-function-conversion-rules"/>. A <termref def="dt-type-error">type error</termref> occurs if conversion is not
         possible. The <code>as</code> attribute defaults to <code>item()*</code>.a</p><p>If the <code>streamable</code> attribute is present with the value <code>yes</code>, 
            then in every contained <elcode>xsl:accumulator-rule</elcode>,
            the <termref def="dt-pattern">pattern</termref> in the <code>match</code> attribute
            must be a <termref def="dt-motionless"/> pattern,
            and the <termref def="dt-expression">expression</termref> in the <code>new-value</code> attribute
            must be a <termref def="dt-motionless"/> expression. The two functions that comprise the value of the accumulator
            variable will be <termref def="dt-motionless"/> expressions; the second (returning the post-descent value)
            is constrained to be used only in a <termref def="dt-post-descent-instruction">post-descent instruction</termref>
            of a streamable template.</p></div2><div2 id="accumulator-informal-rules"><head>Informal Model for Accumulators</head><p>Informally, an accumulator is evaluated by traversing a document in tree-walking order. Each node is visited
            twice, once before processing its descendants, and once after processing its descendants. For consistency, this
            applies even to leaf nodes: each is visited twice. Attribute and namespace nodes, however, are not visited.</p><p>Before the traversal starts, a variable (called the accumulator variable) is initialized to the value of 
               the expression given as the <code>initial-value</code> attribute.</p><p>On each node visit, the <elcode>xsl:accumulator-rule</elcode> elements are examined to see if there is a matching
            rule. For a match to occur, the pattern in the <code>match</code> attribute must match the node, and the
            <code>phase</code> attribute must be <code>start</code> if this is the first visit, and <code>end</code>
            if it is the second visit. If there is a matching rule, then a new value is computed for the
            accumulator variable using the expression contained in that rule's <code>new-value</code> attribute.
            If there is more than one matching rule, the last in document order is used. If there is no matching rule,
            the value of the accumulator variable does not change.</p><p>Each node is labeled with a pre-descent value for the accumulator, which is the value of the accumulator
               variable immediately <emph>after</emph> processing the first visit to that node, and with a post-descent value
            for the accumulator, which is the value of the accumulator variable immediately <emph>before</emph>
            processing the second visit.</p><p>Although this description is expressed in procedural terms, it can be seen that the two values of the accumulator
            for any given node depend only on the node and its preceding and (in the case of the post-descent
            value) descendant nodes. Calculation of both values is therefore deterministic and free of side-effects;
            moreover, it is clear that the values can be computed during a streaming pass of a document, provided
            that the rules themselves use only information that is available without repositioning the input stream.</p></div2><div2 id="accumulator-formal-rules"><head>Formal Model for Accumulators</head><p><termdef id="dt-traversal" term="traversal">A <term>traversal</term> of a tree
            is a sequence of <termref def="dt-traversal-event">traversal events</termref>.</termdef></p><p><termdef id="dt-traversal-event" term="traversal-event">a <term>traversal event</term>
            (shortened to <term>event</term> in this section)   
            is a pair comprising a phase (start or end) and a node.</termdef> It is modelled as a 
            map with two entries: <code>map{"phase" := p, "node" := n}</code> where p is the string
            <code>"start"</code> or <code>"end"</code> and <code>n</code> is a node.</p><p>The traversal of a document contains two traversal events for each node in the tree,
            other than attribute and namespace nodes. One of these events (the "start event")
            has phase = "start", the other (the "end event") has phase = "end".</p><p>The order of traversal events within a traversal is such that, given any two nodes 
               <var>M</var> and <var>N</var> with start/end events denoted by <var>M0</var>, 
               <var>M1</var>, <var>N0</var>, and <var>N1</var>, :</p><ulist><item><p>For any node <var>N</var>, <var>N0</var> precedes <var>N1</var>;</p></item><item><p>If <var>M</var> is an ancestor of <var>N</var> then 
                  <var>M0</var> precedes <var>N0</var> and <var>N1</var> precedes <var>M1</var>;</p></item><item><p>If <var>M</var> is on the preceding axis of <var>N</var> then
                  <var>M1</var> precedes <var>N0</var>.</p></item></ulist><p>The accumulator defines a (private) delta function <var>Δ</var>. The delta function 
               computes the value of the accumulator for one traversal event in terms of its value for the previous
               traversal event. The function is defined as follows:</p><olist><item><p>The signature of <var>Δ</var> is <code>function ($value as T, $event as map(*)) as T</code>,
               where <var>T</var> is the sequence type declared in the <code>as</code> attribute of the
               accumulator declaration;</p></item><item><p>The implementation of the function is equivalent to the following algorithm:</p><olist><item><p>Let <var>R</var> be the set of <elcode>xsl:accumulator-rule</elcode> elements
                  among the children of the accumulator declaration whose <code>phase</code> attribute
                  equals <code>$event.get("phase")</code> and whose <code>match</code> attribute is a
                  <termref def="dt-pattern">pattern</termref> that matches <code>$event.get("node")</code></p></item><item><p>If <var>R</var> is empty, return <code>$value</code></p></item><item><p>Let <var>Q</var> be the <elcode>xsl:accumulator-rule</elcode>
                  in <var>R</var> that is last in document order</p></item><item><p>Return the value of the expression in the <code>next-value</code> attribute
                  of <code>Q</code>, evaluating the expression with a 
                     <termref def="dt-singleton-focus">singleton focus</termref> set to <code>$event.get("node")</code>
                  and with a dynamic context that binds the variable whose name is the accumulator name to the
                  value <code>$value</code></p></item></olist></item></olist><p>For every node <var>N</var>, other than attribute and namespace nodes, 
               the accumulator defines a pre-descent value <var>B(N)</var> and a post-descent
               value <var>A(N)</var> whose values are as follows:</p><olist><item><p>Let <var>T</var> be the <termref def="dt-traversal">traversal</termref>
                  of the tree rooted at <code>fn:root(N)</code></p></item><item><p>Let <var>SB</var> be the subsequence of <var>T</var> 
                  starting at the first event in <var>T</var> and ending
                  with the start event for node <var>N</var> (that is, the event <code>map{ "phase":="start",
                  "node":=N }</code>)</p></item><item><p>Let <var>SA</var> be the subsequence of <var>T</var> starting at the first event in <var>T</var>, 
                  and ending with the event that immediately precedes the end event for node <var>N</var> (that is, the 
                  event <code>map{ "phase":="end", "node":=N }</code>)</p></item><item><p>Let <var>Z</var> be the result of evaluating the expression contained in the
               <code>initial-value</code> attribute of the <elcode>xsl:accumulator</elcode> declaration,
               using the same context as is used for evaluating global variables</p></item><item><p>Then the pre-descent value <var>B(N)</var> is the value of <code>fn:fold-left(Δ, Z, SB)</code>,
                  and the post-descent value <var>A(N)</var> is the value of <code>fn:fold-left(Δ, Z, SA)</code></p></item></olist></div2><div2 id="accumulator-examples"><head>Examples of Accumulators</head><example><head>Remember the Title of a Document</head><p>Consider an XHTML document in which the title of the document is represented by the content
                  of the first <code>title</code> element appearing as a child of the <code>head</code> element,
                  which in turn appears as a child of the <code>html</code> element. Suppose that we want to 
                  process the document in streaming mode, and that we want to avoid outputting the content of the
                  <code>h1</code> element if it is the same as the document title.</p><p>This can be achieved by remembering the value of the title in an accumulator variable.</p><eg xml:space="preserve">
  &lt;xsl:accumulator name="f:title" as="xs:string?" initial-value="()"&gt;
    &lt;xsl:accumulator-rule match="html/head/title" new-value="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg><p>Subsequently, while processing an <code>h1</code> element appearing later in the document, 
               the value can be referenced:</p><eg xml:space="preserve">
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:if test="string(.) ne f:title()"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:apply-templates/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;</eg><note><p>This example assumes that in streaming mode, <code>string(.)</code> is permitted
               for a leaf node (requiring some lookahead). This is not currently the case.</p></note></example><example><head>Keep a Word Count</head><p>Suppose that there is a requirement to output, at the end of the HTML rendition
               of a document, a paragraph giving the total number of words in the document.</p><p>An accumulator can be used to maintain the word count:</p><eg xml:space="preserve">
  &lt;xsl:accumulator name="f:word-count" 
                   post-descent="f:final-word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         new-value="$value + count(tokenize(string(.), '\W+'))"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg><p>The final value can be output at the end of the document:</p><eg xml:space="preserve">
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="f:final-word-count()"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;</eg></example><example><head>Output Hierarchic Section Numbers</head><p>Consider a document in which <code>section</code> elements are nested
               within <code>section</code> elements to arbitrary depth, and there is a requirement
               to render the document with hierarchic section numbers of the form <code>3.5.1.4</code>.</p><p>The current section number can be maintained in an accumulator in the form of a sequence
               of integers, managed as a stack. The number of integers represents the current level of nesting,
               and the value of each integer represents the number of preceding sibling sections encountered
               at that level. For convenience the first item in the sequence represents the top of thenstack.</p><eg xml:space="preserve">
&lt;xsl:accumulator name="f:section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 new-value="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 new-value="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;  
</eg><p>To illustrate this, consider the values after processing a series of
               start and end tags:</p><table border="1" summary="example data illustrating the effect of parsing events on an accumulator"><thead><tr><th rowspan="1" colspan="1">events</th><th rowspan="1" colspan="1">accumulator value</th><th rowspan="1" colspan="1">required section number</th></tr></thead><tbody><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 1</code></td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 1, 1</code></td><td rowspan="1" colspan="1">1.1</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>1, 1</code></td></tr><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 2, 1</code></td><td rowspan="1" colspan="1">1.2</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>2, 1</code></td></tr><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 3, 1</code></td><td rowspan="1" colspan="1">1.3</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 1, 3, 1</code></td><td rowspan="1" colspan="1">1.3.1</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>1, 3, 1</code></td></tr><tr><td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td><td rowspan="1" colspan="1"><code>0, 2, 3, 1</code></td><td rowspan="1" colspan="1">1.3.2</td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>2, 3, 1</code></td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>3, 1</code></td></tr><tr><td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td><td rowspan="1" colspan="1"><code>1</code></td></tr></tbody></table><p>The section number for a section can thus be generated as:</p><eg xml:space="preserve">
       &lt;xsl:template match="section"&gt;
         &lt;p&gt;&lt;xsl:value-of select="reverse(tail(f:section-nr()))" separator="."/&gt;&lt;/p&gt;
         &lt;xsl:apply-templates/&gt;
       &lt;/xsl:template&gt;
                  </eg></example><example><head>Compute a Histogram showing the Number of Books, by Publisher</head><eg xml:space="preserve">
 &lt;xsl:accumulator name="a:histogram" as="map(xs:string, xs:integer)"
    initial-value="map{}"&gt;
    &lt;xsl:accumulator-rule match="book"
       new-value="if ($value.contains(@publisher)) 
                  then $value.put(@publisher, $a:histogram.get(@publisher)+1)
                  else $value.put(@publisher, 1)"/&gt;
 &lt;/xsl:accumulator&gt;</eg><p>The <code>new-value</code> expression is evaluated with the variable 
                  <code>$value</code> set to the current value, and with the context node as the
                  node being visited.</p></example></div2></div1><div1 id="streaming" diff="add" at="K"><head>Streaming</head><p>This specification provides a number of facilities designed to enable <termref def="dt-streaming">streaming</termref>: that is, transformation of a source
            document on-the-fly, as it is parsed, without constructing a complete tree
            representation of the document in memory.</p><p>These facilities include:</p><ulist><item><p>The <elcode>xsl:stream</elcode> instruction, which reads an external document
                  (identified by URI) and initiates streaming of that document.</p></item><item><p>Streaming templates, which allow rule-based invocation of template rules applied
                  to the nodes in a <termref def="dt-streamed-document">streamed
                  document</termref>.</p></item><item><p>A number of additional functions, such as <code>attributes</code>, designed
               to ensure that stylesheets can be analyzed for streamability. (Unlike the attribute
               axis, <code>@*</code>, the <function>attributes</function> function returns atomized
               attribute values, which cannot be used as the base for uncontrolled navigation around
               the document.)</p></item></ulist><p>These facilities impose constraints on the stylesheet code to ensure that a streamable
            evaluation is possible. Much of this section is concerned with the definition of the
            rules for streamability.</p><p><termdef id="dt-guaranteed-streamable" term="guaranteed-streamable">A 
            <term>guaranteed-streamable</term> construct is a <termref def="dt-construct">construct</termref>
               that follows the rules given in <specref ref="streamability"/>. Every <termref def="dt-processor">processor</termref> that claims conformance as a <termref def="dt-streaming-feature">streaming processor</termref>
               <rfc2119 at="F" diff="chg">must</rfc2119> be able to process such a construct using
               streaming, that is, by processing the contents of the source document on the fly 
               as it is read, without the need to buffer the entire document or any
               entire element in memory. </termdef>
         </p><p>In certain contexts, in particular the <elcode>xsl:stream</elcode> instruction and a
               <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-mode">mode</termref> is declared with <code>streamable="yes"</code>, the stylesheet author
            has the opportunity to request that evaluation should using streaming. In this case the rules are as
            follows:</p><p>For a streaming processor:</p><ulist><item><p>If the construct conforms to the rules for being <termref def="dt-guaranteed-streamable"/> then it <rfc2119 at="F" diff="chg">must</rfc2119> be processed using streaming.</p></item><item><p>If the construct is not <termref def="dt-guaranteed-streamable"/> then it <rfc2119 at="F" diff="chg">must</rfc2119> still be
                  processed: the specification imposes no rules on how it is processed (it might or
                  might not use streaming). <phrase diff="add" at="K">However, a processor that claims conformance
                  as a streaming processor <rfc2119>must</rfc2119> at user option notify the user that streaming has been
                  requested for a construct that is not guaranteed streamable, and indicate whether or not
                  the implementation is able to process it in a streaming manner.</phrase></p></item><item><p>If the evaluation does not use streaming (which will only happen if the construct is not
                     <termref def="dt-guaranteed-streamable"/>) then
                  the processor <rfc2119>should</rfc2119> signal a warning indicating that streaming
                  was not possible; the processor <rfc2119>may</rfc2119> provide a user
                  option to abandon processing in this case.</p></item></ulist><p>For a non-streaming processor, the processor <rfc2119 at="F" diff="chg">must</rfc2119>
            evaluate the <phrase diff="chg" at="F">construct</phrase> delivering the same results as if execution used streaming, but
            with no constraints on the evaluation strategy. (Processing <rfc2119 at="F" diff="chg">may</rfc2119>, of course, fail due to insufficient memory being available, or for
            other reasons.)</p><note><p>This specification does not attempt to legislate precisely what constitutes
               evaluation "using streaming". The most important test is that the amount of
               memory needed should be for practical purposes independent of the size of the source
               document, and in particular that the finite size of memory available should not
               impose a limit on the size of source document that can be processed.</p><p>The rules are designed to ensure that streaming processors can analyze streamability
               using rules different from those in this specification, provided that all constructs
               that are <termref def="dt-guaranteed-streamable"/> according to this specification are actually
               streamable by the implementation. Furthermore, non-streaming processors are not
               required to analyze streamability at all.</p><p diff="add" at="K">The rules in this version of the specification are deliberately restrictive
            in order to keep the rules simple. In particular, the rules have been chosen so that they can
            be assessed by simple syntactic examination of the source code, without recourse to static type
            analysis or dataflow analysis. Implementations may well be able to relax the rules, and are permitted
            to do so.</p></note><div2 id="stream-instruction"><head>The <code>xsl:stream</code> Instruction</head><e:element-syntax name="stream"><e:in-category name="instruction"/><e:attribute name="href" required="yes"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:stream</elcode> instruction reads a source document whose URI is
               supplied, and processes the content of the document using streaming by evaluating the
               contained <termref def="dt-sequence-constructor"/>.</p><p>For example, if a document represents a book holding a sequence of chapters, then the
               following code can be used to split the book into multiple XML files, one per
               chapter, without allocating memory to hold the entire book in memory at one time:</p><eg xml:space="preserve">&lt;xsl:stream href="book.xml"&gt;
  &lt;xsl:for-each select="book"&gt;             
    &lt;xsl:for-each select="chapter"&gt;
      &lt;xsl:result-document href="chapter{position()}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;  
&lt;/xsl:stream&gt;</eg><p>The document to be read is determined by the <termref def="dt-effective-value">effective value</termref> of the <code>href</code> attribute (which is defined as
               an <termref def="dt-attribute-value-template">attribute value template</termref>).
               <phrase diff="chg" at="F">This <rfc2119>must</rfc2119> be a valid URI reference. 
                  If it is an absolute URI reference,
               it is used as is; if it is a relative URI reference, it is
               made absolute by resolving it against the base URI of the <elcode>xsl:stream</elcode> element</phrase>. The process
               of obtaining a document node given a URI is the same as for the
                  <xfunction>doc</xfunction> function. However, unlike the
                  <xfunction>doc</xfunction> function, the <elcode>xsl:stream</elcode> instruction
               offers no guarantee that the resulting document will be stable (that is, that
               multiple calls specifying the same URI will return the same document).</p><p>Specifically, if the <elcode>xsl:stream</elcode> instruction is evaluated several
               times (or if different <elcode>xsl:stream</elcode> instructions are evaluated) with
               the same URI (<phrase diff="chg" at="F">after making it absolute</phrase>) as the value of the <code>href</code> attribute,
               it is <termref def="dt-implementation-dependent">implementation-dependent</termref>
               whether the same nodes or different nodes are returned on each occasion; it is also
               possible that the actual document content will be different.</p><p>The result of the <elcode>xsl:stream</elcode> instruction is the same as the result
               of the following (non-streaming) process:</p><olist><item><p>The source document is read from the supplied URI and parsed to form an
                     instance of the XDM data model. This is the <termref def="dt-streamed-document">streamed document</termref>.</p></item><item><p>The contained sequence constructor is evaluated with the <phrase diff="chg" at="F">document</phrase> node of the
                        <termref def="dt-streamed-document">streamed document</termref> as the
                     context item, and with the context position and context size set to one, and
                     the resulting sequence is returned as the result of the
                        <elcode>xsl:stream</elcode> instruction.</p></item></olist><note><p>The rules for streamability ensure that the sequence constructor (and therefore
                  the <elcode>xsl:stream</elcode> instruction) cannot return any nodes from the
                     <termref def="dt-streamed-document">streamed document</termref>. For example,
                  it cannot contain the instruction <code>&lt;xsl:sequence
                     select="//chapter"/&gt;</code>. If nodes from this document are to be returned,
                  they must first be copied, for example by <phrase diff="add" at="F">using the
                        <elcode>xsl:copy-of</elcode> instruction or by </phrase>calling the
                     <function>copy-of</function> or <function>snapshot</function> functions.</p><p>Because the <elcode>xsl:stream</elcode> instruction cannot return nodes from the
                  streamed document, any nodes it does return will be conventional (unstreamed)
                  nodes that can be processed without restriction. For example, if
                     <elcode>xsl:stream</elcode> is invoked within a <termref def="dt-stylesheet-function">stylesheet function</termref>
                  <code>f:firstChapter</code>, and the sequence constructor consists of the
                  instruction <code>&lt;xsl:copy-of select="//chapter"/&gt;</code>, then the calling
                  code can manipulate the resulting <code>chapter</code> elements as ordinary trees
                  rooted at parentless element nodes.</p></note><div3 id="stream-examples"><head>Examples of <code>xsl:stream</code>
               </head><p>The <elcode>xsl:stream</elcode> instruction can be used to initiate processing of
                  a document using streaming with a variety of coding styles, illustrated in
                  the examples below.</p><p diff="add" at="K">These examples no longer work; it is no longer possible to
               compute an aggregate over descendant values using a path expression. Instead,
               traversal using templates is required.</p><example><head>Using <elcode>xsl:stream</elcode> with Aggregate Functions</head><p>The following example computes the number of transactions in a transaction
                     file</p><p>Input:</p><eg xml:space="preserve">
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;</eg><p>Stylesheet code:</p><eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:for-each select="transactions"&gt;
      &lt;xsl:iterate select="transaction"&gt;
        &lt;xsl:param name="count" select="0" as="xs:decimal"/&gt;
        &lt;xsl:next-iteration&gt;
          &lt;xsl:with-param name="count" select="$count+1"/&gt;
        &lt;/xsl:next-iteration&gt;
        &lt;xsl:on-completion&gt;
          &lt;xsl:value-of select="$count"/&gt;
        &lt;/xsl:on-completion&gt;
      &lt;/xsl:iterate&gt;
    &lt;/xsl:for-each&gt;
  &lt;/count&gt;
&lt;/xsl:stream&gt;</eg><p>Result:</p><eg xml:space="preserve">&lt;count&gt;2&lt;/count&gt;</eg><p>The following example computes the highest-value transaction in the same input
                     file:</p><eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:for-each select="transactions"&gt;
      &lt;xsl:iterate select="transaction"&gt;
        &lt;xsl:param name="max" select="()"  as="xs:decimal?"/&gt;
        &lt;xsl:variable name="this" as="xs:decimal" 
                      select="data(@value)"/&gt;
        &lt;xsl:variable name="newMax" as="xs:decimal" 
                      select="if ($this gt $max) then $this else $max"/&gt;
        &lt;xsl:next-iteration&gt;
          &lt;xsl:with-param name="max" select="$newMax"/&gt;
        &lt;/xsl:next-iteration&gt;
        &lt;xsl:on-completion&gt;
          &lt;xsl:value-of select="$newMax"/&gt;
        &lt;/xsl:on-completion&gt;
      &lt;/xsl:iterate&gt;
    &lt;/xsl:for-each&gt;
  &lt;/maxValue&gt;
&lt;/xsl:stream&gt;</eg><p>Result:</p><eg xml:space="preserve">&lt;maxValue&gt;12.51&lt;/maxValue&gt;</eg><p>To compute both the count and the maximum value in a single pass over the
                     input, it is possible to use two variables.</p></example><example><head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:for-each</elcode> to
                     Process a Collection of Input Documents </head><p>This example displays a list of the chapter titles extracted from each book in
                     a collection of books.</p><p>Each input document is assumed to have a structure such as:</p><eg xml:space="preserve">&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg><p>Stylesheet code:</p><eg xml:space="preserve">&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:stream href="{.}"&gt;
      &lt;xsl:for-each select="book"&gt;
        &lt;xsl:for-each select="chapter"&gt;
           &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:stream&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;</eg><p>Output:</p><eg xml:space="preserve">&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;</eg><note><p>This example uses the function <xfunction>uri-collection</xfunction> to obtain
                        the document URIs of all the documents in a collection, so that each one can
                        be processed in turn using <elcode>xsl:stream</elcode>.</p></note></example><example><head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:iterate</elcode>
                  </head><p>This example assumes that the input is a book with multiple chapters, as shown
                     in the previous example, with the page count for each chapter given as an
                     attribute of the chapter. The transformation determines the starting page
                     number for each chapter by accumulating the page counts for previous chapters,
                     and rounding up to an odd number if necessary.</p><eg xml:space="preserve">&lt;chapter-start-page&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:stream&gt;
&lt;/chapter-start-page&gt;
</eg><p>Output:</p><eg xml:space="preserve">&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     </eg></example><example><head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:for-each-group</elcode>
                  </head><p>This example assumes that the input is a book with multiple chapters, and that
                     each chapter belongs to a part, which is present as an attribute of the chapter
                     (for example, chapters 1-4 might constitute Part 1, the next three chapters
                     forming Part 2, and so on):</p><eg xml:space="preserve">&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg><p>The transformation copies the full text of the chapters, creating an extra
                     level of hierarchy for the parts.</p><eg xml:space="preserve">&lt;book&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:for-each select="book"&gt;
         &lt;xsl:for-each-group select="chapter" group-adjacent="data(@part)"&gt;
            &lt;part number="{current-grouping-key()}"&gt;
               &lt;xsl:copy-of select="current-group()"/&gt;
            &lt;/part&gt;
         &lt;/xsl:for-each-group&gt;
      &lt;/xsl:for-each&gt;
   &lt;/xsl:stream&gt;
&lt;/book&gt;
</eg><p>Output:</p><eg xml:space="preserve">&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter title="The first chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter title="The second chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter title="The fifth chapter of book A" part="2"&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    </eg></example><example><head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:apply-templates</elcode>
                  </head><p>This example copies an XML document while deleting all the <code>ednote</code>
                     elements at any level of the tree, together with their descendants. This
                     example is a complete stylesheet, which is intended to be evaluated by
                     nominating <code>main</code> as the <termref def="dt-initial-template">initial
                        template</termref>. The use of <code diff="chg" at="F">on-no-match="deep-copy"</code> in the <elcode>xsl:mode</elcode> declaration
                     means that the built-in template rule copies nodes unchanged, except where
                     overridden by a user-defined template rule.</p><eg xml:space="preserve">&lt;xsl:transform version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streamable="yes" on-no-match="deep-copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:stream&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;</eg><p>Additional template rules could be added to process other elements and
                     attributes in the same pass through the data: for example, to modify the value
                     of a <code>last-updated</code> attribute (wherever it appears) to the current
                     date and time, the following rule suffices:</p><eg xml:space="preserve">
&lt;xsl:template match="@last-updated"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;</eg></example><!--              <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:merge</elcode>
                  </head>
                  <p>This example builds a file representing the index of a book from files
                     containing the index for each chapter. The chapter-level index files contain
                     entries of the form <code>&lt;entry term="XML" page="27"/></code> sorted first
                     alphabetically by term and then numerically by page number; the sort order for
                     the combined index is the same.</p>
                  <eg xml:space="preserve"><![CDATA[<index>
   <xsl:merge>
     <xsl:merge-source select="uri-collection('chapter-indexes')">
         <xsl:stream href="{.}">
           <xsl:copy-of select="index/entry"/>
         </xsl:stream>
         <xsl:merge-key select="string(@term)"/>
         <xsl:merge-key select="xs:integer(@page)"/>
    </xsl:merge-source>
    <xsl:merge-action>
       <xsl:copy-of select="current-group()[1]"/>
    </xsl:merge-action>
  </xsl:merge>
</index>]]></eg>

                  <p>In cases where two chapter indexes contain entries for the same term, they will
                     normally have different page numbers, and will therefore go in separate groups.
                     Their order in the output is based on the ordering of the merge keys, which
                     means entries with the same term appear in page number order. In the unlikely
                     case that two files contain entries where both the term and the page number are
                     the same (or, perhaps more plausibly, where such duplicates occur within a
                     single input file), the <elcode>xsl:merge-action</elcode> ensures that only the
                     first of the duplicates will be copied. </p>
               </example>--></div3></div2><div2 id="streamable-templates"><head>Streamable Templates</head><p><termdef id="dt-guaranteed-streamable-template" term="guaranteed streamable template">If any of the
                     <termref def="dt-mode">modes</termref> to which a <termref def="dt-template-rule">template rule</termref> is applicable is a <termref def="dt-streamable-mode">streamable mode</termref>, then the template rule
                     <rfc2119>must</rfc2119> satisfy certain rules to ensure that it can be
                  evaluated using streaming. A template that satisfies these rules is referred
                  to as a <term>guaranteed-streamable template</term>.</termdef> Specifically:</p><ulist><item><p>The <termref def="dt-pattern">pattern</termref> defined in the
                        <code>match</code> attribute of the <elcode>xsl:template</elcode> element
                     must be a <termref def="dt-motionless"/> pattern as defined in <specref ref="classifying-patterns"/>.</p></item><item><p>The <termref def="dt-sequence-constructor"/>
                     contained in the body of the <elcode>xsl:template</elcode> element
                        <rfc2119>must</rfc2119> be either a <termref def="dt-motionless"/>
                     or <termref def="dt-consuming"/> sequence constructor, as defined in
                        <specref ref="streamability"/>.</p></item><item><p>Every <termref def="dt-expression">expression</termref> and
                  contained <termref def="dt-sequence-constructor"/>
                  in a contained <elcode>xsl:param</elcode> element (the construct that provides
                  the default value of the parameter) must be <termref def="dt-motionless"/>.</p></item></ulist></div2><div2 id="streamability"><head>Streamability Analysis</head><p>This section describes the rules that determine whether the contents of a 
               template within a streamable mode are
               <termref def="dt-guaranteed-streamable">guaranteed streamable</termref>,
               which ensures that the template will be streamable using any conformant streaming processor.
            </p><note><p>The rules in this section operate on the expression tree that is typically output by the 
               XSLT and XPath parser. For the most part, the rules depend only on identifying the syntactic
            constructs that are present. However, the analysis does require as a pre-condition that function calls have
            been resolved to the extent that the corresponding function signature is known, and that variable references
            referring to grouping variables (those declared in a <code>bind-XXX</code> attribute of an <elcode>xsl:for-each-group</elcode>,
            <elcode>xsl:merge</elcode>, or <elcode>xsl:merge-source</elcode> element) have been identified as such.</p></note><p><termdef id="dt-construct" term="construct">The term <term>construct</term> refers to the union of the following: 
               a <termref def="dt-sequence-constructor"/>,
            an <termref def="dt-instruction">instruction</termref>, 
               an <termref def="dt-attribute-set">attribute set</termref>,
               an  <termref def="dt-attribute-value-template">attribute value template</termref>, 
               an <termref def="dt-expression">expression</termref>, 
               or a <termref def="dt-pattern">pattern</termref>.</termdef></p><p><termdef id="dt-sweep" term="sweep">Every construct has a <term>sweep</term>, which is a measure of the extent to which the current
            position in the input stream moves during the evaluation of the expression. The sweep is one of:
            <termref def="dt-motionless"/>, <termref def="dt-group-consuming"/>, <termref def="dt-consuming"/>, or <termref def="dt-free-ranging"/>.</termdef>
               This list of values is ordered, for example
            a <termref def="dt-free-ranging"/> expression has <term>wider sweep</term> than a <term>consuming</term> expression,
               and so on.
            </p><p><termdef id="dt-motionless" term="motionless">A <term>motionless</term> construct
            is any <termref def="dt-construct"/> deemed motionless by the rules in this section (<specref ref="streamability"/>).</termdef>
               Informally, a motionless construct is one that can be evaluated without changing the current position
               in the input stream. The classification of a construct as motionless depends on the context in which
               the expression appears; a construct such as <code>.</code> that returns a node in a <termref def="dt-streamed-document"/> will not
               be classified as motionless unless the context ensures that the node will not be used as the origin for
               further navigation of the source tree.</p><p><termdef id="dt-group-consuming" term="group-consuming">A <term>group-consuming</term> construct
               is any <termref def="dt-construct"/> deemed group-consuming by the rules in this section (<specref ref="streamability"/>).</termdef>
               Informally, a group-consuming construct is one whose evaluation requires
               repositioning of the input stream from the
               start of the first node in the current group (always a contiguous sequence of children of the context node)
               to the end of the last node in the current group.</p><p><termdef id="dt-consuming" term="consuming">A <term>consuming</term> construct
               is any <termref def="dt-construct"/> deemed consuming by the rules in this section (<specref ref="streamability"/>).</termdef>
               Informally, a consuming construct is one whose evaluation requires repositioning
               of the input stream from the start of the current node to the end of the current node.</p><p><termdef id="dt-free-ranging" term="free-ranging">A <term>free-ranging</term> construct
               is any <termref def="dt-construct"/> deemed free-ranging by the rules in this section (<specref ref="streamability"/>).</termdef>
               Informally, a free-ranging construct is one whose evaluation may require access to information
               that is not available from the subtree rooted at the current node, together with information
               about ancestors of the current node and their attributes.</p><p>The following
            sections describe this categorization for each kind of construct:</p><ulist><item><p>Sequence constructors: see <specref ref="classifying-sequence-constructors"/></p></item><item><p>Instructions: see <specref ref="classifying-instructions"/></p></item><item><p>Attribute sets: see <specref ref="classifying-attribute-sets"/></p></item><item><p>Attribute value templates: see <specref ref="classifying-avts"/></p></item><item><p>Expressions: see <specref ref="classifying-expressions"/></p></item><item><p>Patterns: see <specref ref="classifying-patterns"/></p></item></ulist><div3 id="syntactic-context"><head>Syntactic Context</head><p><termdef id="dt-syntactic-context" term="syntactic context">The classification of a 
                  <termref def="dt-construct"/> depends on some cases on the <term>syntactic context</term> in which it 
                  appears. This is determined by the kind of construct in which it is immediately contained, and its role
                  within the containing construct.</termdef></p><example><head>The Effect of Syntactic Context on Streamability</head><p>Consider the expression <code>.</code>, which returns the context item.</p><p>The expression <code>name(.)</code> is <termref def="dt-motionless"/>, because
                  it is possible to determine the name of the context node without advancing the input stream. To achieve this
                  result, the first argument of <xfunction>name</xfunction> is classified as an inspection context, and
                  the context item expression appearing in an inspection context is classified as motionless.</p><p>The expression <code>data(.)</code> is classified as <termref def="dt-consuming"/>, because
                  in order to determine the typed value of an element it is necessary to read the subtree rooted at that element.
                  This is achieved by classifying the first argument of <xfunction>data</xfunction> as a node-value context;
                  the context item expression appearing in a node-value context is classified as consuming.</p><p>The streamability of the expression <code>. intersect $x</code> cannot be determined without knowing where it appears:
                  while <code>exists(. intersect $x)</code> is motionless, <code>data(. intersect $x)</code> is consuming. The syntactic
                  context of the operands of <code>intersect</code> is therefore classified as an inherited context, which means that the
                  context of the operands is the same as the context of the <code>intersect</code> expression itself.</p><p>In the expression <code>$f(.)</code> (a dynamic function call),
                  the streamability analysis has no way of determining what the called function will do with the context item,
                  and it therefore concludes that the expression is not dynamically streamable. To achieve this, the argument of a dynamic
                  function call is classified as a navigational context (meaning that if a node is supplied, the callee may perform arbitrary
                  navigation within the tree containing this node), and when <code>.</code> appears in a navigational context, it is
                  classified as <termref def="dt-free-ranging"/>.</p></example><p>This is relevant in cases where the result of the expression
                  delivers one or more nodes. There are four kinds of syntactic context, based on how the
                  containing expression uses the returned nodes: inspection contexts, value contexts, 
                  inherited contexts, and navigation contexts. These are defined as follows:</p><ulist><item><p><termdef id="dt-inspection-context" term="inspection context">An 
                     <term>inspection context</term> has the characteristic that when the value of the
                     expression is a node, the containing expression can be evaluated without
                     consuming the subtree rooted at that node.</termdef> Inspection contexts are: 
                     <olist><item><p>all contexts that use the 
                           <xtermref spec="XP30" ref="dt-ebv">effective boolean value</xtermref>
                           of the expression, specifically:</p><olist><item><p>the argument to the functions <xfunction>boolean</xfunction>, 
                                 <xfunction>not</xfunction>, <xfunction>empty</xfunction>, and <xfunction>exists</xfunction>; </p></item><item><p>the operands of the <code>and</code> and <code>or</code> operators; </p></item><item><p>the condition expression in an XPath <code>if/then/else</code> expression; </p></item><item><p>the expression appearing in the <code>satisfies</code>
                                 clause of a <code>QuantifiedExpr</code>; </p></item><item><p>the expression appearing in the <code>test</code>
                                 attribute of <elcode>xsl:if</elcode> or <elcode>xsl:when</elcode>.</p></item></olist></item><item><p>an expression used as a predicate in an <code>AxisStep</code>
                           or <code>FilterExpression</code></p></item><item><p>the operands of the operators <code>is</code>, <code>&lt;&lt;</code>,
                           and <code>&gt;&gt;</code></p></item><item><p>the first argument to the functions <xfunction>name</xfunction>,
                           <xfunction>node-name</xfunction>, <xfunction>namespace-uri</xfunction>, 
                           <xfunction>local-name</xfunction>, 
                           <xfunction>generate-id</xfunction>, <xfunction>base-uri</xfunction>, 
                           <xfunction>document-uri</xfunction>, <xfunction>nilled</xfunction>,
                           <xfunction>path</xfunction>, <function>attributes</function>, <xfunction>has-children</xfunction>, 
                           <xfunction>in-scope-prefixes</xfunction>, and <xfunction>count</xfunction></p></item><item><p>the first operand of the operator <code>/</code>
                           or <code>!</code> if the second operand is a call to one of the above functions with
                           <code>.</code> as the explicit or implicit argument; </p></item><item><p>the operand of <code>instance of</code>; </p></item><item><p>the second argument of the function
                           <xfunction>namespace-uri-for-prefix</xfunction>; </p></item><item><p>the second argument of the function <xfunction>resolve-QName</xfunction>;</p></item><item><p>the second argument of the function <xfunction>lang</xfunction>;</p></item><item><p>an expression used in a context where a function is required, specifically
                           (a) the expression <code>E</code> in a dynamic function call <code>E(args...)</code>,
                           (b) an argument in a function call where the required type of the relevant argument
                           has the <code>ItemType</code> <code>function(*)</code> or a subtype thereof.</p></item></olist>
                     
                  </p></item><item><p><termdef id="dt-node-value-context" term="node value context">In a
                     <term>node value context</term>, the containing expression needs access to
                     information obtained from the subtree rooted at the returned node.</termdef></p><p>This includes cases where the containing expression uses the typed value or
                        string value of the returned node, as well as cases where the returned node is
                        copied.</p><p>Node value contexts are:
                        <olist><item><p>the argument to any <code>FunctionCall</code>
                              where the type of the corresponding parameter in the function signature has an atomic
                              <code>ItemType</code>;</p></item><item><p>an operand of an atomizing operator (<code>+</code>, <code>-</code>, <code>*</code>, 
                              <code>div</code>, <code>idiv</code>, <code>mod</code>, <code>=</code>, <code>!=</code>, 
                              <code>&gt;</code>, <code>&lt;</code>,
                              <code>&gt;=</code>, <code>&lt;=</code>, <code>eq</code>, <code>ne</code>, <code>gt</code>, 
                              <code>lt</code>, <code>ge</code>, <code>le</code>, <code>||</code>, <code>to</code>); </p></item><item><p>the operand of a <code>cast</code> 
                              or <code>castable</code> expression; </p></item><item><p>the first argument of the functions <xfunction>data</xfunction> and <xfunction>string</xfunction>;</p></item><item><p>the first argument of the operator <code>/</code>
                              or <code>!</code> if the second argument is a call to one of the above functions with
                              <code>.</code> as the explicit or implicit argument;</p></item><item><p>the <code>select</code> attribute of one of the instructions
                              <elcode>xsl:analyze-string</elcode>,
                              <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>, <elcode>xsl:copy</elcode>, 
                              <elcode>xsl:copy-of</elcode>, <elcode>xsl:namespace</elcode>, <elcode>xsl:processing-instruction</elcode>,
                              <elcode>xsl:value-of</elcode></p></item><item><p>the <code>group-adjacent</code> attribute of <elcode>xsl:for-each-group</elcode>;</p></item><item><p>an expression embedded within an 
                              <termref def="dt-attribute-value-template">attribute value template</termref>
                              of an XSLT instruction or a <termref def="dt-literal-result-element">literal result element</termref></p></item></olist>
                        
                     </p></item><item><p><termdef id="dt-inherited-context" term="inherited context">In an <term>inherited context</term>,
                        the syntactic context of an expression is the same as
                        the syntactic context of its containing expression.</termdef></p><p>The following are inherited contexts:</p><olist><item><p>The operand of a <code>union</code>, <code>intersect</code>,
                           or <code>except</code> operator;</p></item><item><p>The operand of a comma (<code>,</code>) operator;</p></item><item><p>The operand of a <code>treat as</code> expression;</p></item><item><p>The expressions in the <code>then</code> and <code>else</code>
                           branches of a conditional expression;</p></item><item><p>The expressions in the <code>return</code> clause of a <code>for</code>
                           or <code>let</code> expression;</p></item><item><p>An expression contained within parentheses;</p></item><item><p>The last <code>StepExpr</code> operand within a <code>RelativePathExpr</code>;</p></item><item><p>The expression <var>E</var> in a filter expression or axis expression
                           of the form <code>E[P]</code>;</p></item><item><p>The first argument of the functions <xfunction>subsequence</xfunction>,
                           <xfunction>insert-before</xfunction>, <xfunction>remove</xfunction>, 
                           <xfunction>head</xfunction>,
                           <xfunction>tail</xfunction>, <xfunction>exactly-one</xfunction>,
                           <xfunction>zero-or-one</xfunction>, <xfunction>one-or-more</xfunction>,
                           <xfunction>unordered</xfunction>, <xfunction>innermost</xfunction>, or <xfunction>outermost</xfunction>.</p></item></olist><note><p>The distinguishing feature of the above contexts is that the value of the
                        subexpression forms the result, or part of the result, of the containing expression.</p></note></item><item><p><termdef id="dt-navigation-context" term="navigation context">In a <term>navigation context</term>, the
                        containing expression potentially performs arbitrary navigation from the returned
                        node to other nodes in the same tree, or reordering of the nodes in a supplied node sequence,
                        which is therefore incompatible with
                        streaming.</termdef></p><p>Any context not included in one of the categories listed above is classified
                        as a navigation context. Examples include:</p><olist><item><p>The <code>select</code> attribute of <elcode>xsl:variable</elcode>,
                           <elcode>xsl:param</elcode>, or <elcode>xsl:with-param</elcode>;</p></item><item><p>The <code>select</code> attribute of <elcode>xsl:sequence</elcode>;</p></item><item><p>An argument to a call on a user-defined function where the corresponding function signature
                           does not cause the node to be atomized;</p></item><item><p>The left-hand operand of the operators <code>/</code>, <code>//</code>,
                           and <code>!</code>;</p></item><item><p>The first argument to the <xfunction>reverse</xfunction> function;</p></item><item><p>An argument to a dynamic function call.</p></item></olist></item></ulist></div3><div3 id="general-streamability-rules" diff="add" at="L"><head>General Rules for Streamability</head><p>Many <termref def="dt-construct">constructs</termref> share the same streamability rules. 
               A construct is classified as a first-order construct if it satisfies two conditions:</p><olist><item><p>Its semantics can be described as a simple
               function of the values obtained by evaluating each of its sub-constructs exactly once with the same 
               dynamic context as the containing construct.</p></item><item><p>If any of the sub-constructs may deliver a sequence of multiple nodes, then the result
                  of the construct can be determined by processing those nodes one at a time in order, that is, without
                  retaining the entire sequence in memory.</p></item></olist><p>Examples of first-order constructs are: an
               arithmetic expression, an attribute value template, a sequence constructor, and the 
               <elcode>xsl:value-of</elcode> instruction. By contrast, an <elcode>xsl:for-each</elcode> instruction
               or a filter expression are not first-order because in both cases one of the sub-constructs is evaluated
               repeatedly, with a different dynamic context; and a conditional expression is not first-order because
               some of the sub-constructs are not evaluated. An <elcode>xsl:perform-sort</elcode> or a 
                  call on the <xfunction>reverse</xfunction> function are not first-order because they need to consider
               the input sequence as a whole, rather than processing it one item at a time.</p><p>The <termref def="dt-sweep">sweep</termref> of a first-order construct depends on the 
                  <termref def="dt-sweep">sweep</termref> of its sub-constructs as follows:</p><olist><item><p>If the construct has no sub-constructs, then it is <termref def="dt-motionless"/>.</p></item><item><p>If all immediately contained sub-constructs are 
                     <termref def="dt-motionless"/>, the construct is <termref def="dt-motionless"/>.</p></item><item><p>If exactly one immediately contained sub-construct is <termref def="dt-group-consuming"/> 
                     and all others
                     are <termref def="dt-motionless"/>, then the construct is <termref def="dt-group-consuming"/>.</p></item><item><p>If exactly one immediately contained sub-construct is <termref def="dt-consuming"/> and all others
                     are <termref def="dt-motionless"/>, then the construct is <termref def="dt-consuming"/>.</p></item><item><p>Otherwise, the construct is <termref def="dt-free-ranging"/>.</p></item></olist><note><p>Informally: the sweep of the construct is the maximum sweep of any of its sub-constructs,
               except that if more than one sub-construct consumes the input stream, then the construct is classified
               as free-ranging to indicate that it cannot be streamed.</p></note></div3><div3 id="classifying-sequence-constructors"><head>Classifying Sequence Constructors</head><p>A <termref def="dt-sequence-constructor"/> is a first-order construct whose sub-constructs are the
                  contained <termref def="dt-instruction">instructions</termref>. It is classified according to the
               general rules for streamability given in <specref ref="general-streamability-rules"/>.</p><note><p>Informally, this rule states that a sequence constructor is not streamable if it contains more than
               one instruction that moves the position of the input stream.</p></note><p>Instructions within a sequence constructor are further classified to control the use of
               <termref def="dt-accumulator-function">accumulator functions:</termref></p><olist><item><p><termdef id="dt-pre-descent-instruction" term="pre-descent instruction">A <termref def="dt-motionless"/> 
                  <termref def="dt-instruction">instruction</termref> having no <termref def="dt-consuming"/> instruction 
                  as a preceding sibling is referred to as a <term>pre-descent instruction</term>.</termdef></p></item><item><p><termdef id="dt-post-descent-instruction" term="post-descent instruction">A <termref def="dt-motionless"/> 
                  <termref def="dt-instruction">instruction</termref> having a <termref def="dt-consuming"/> instruction 
                  as a preceding sibling is referred to as a <term>post-descent instruction</term>.</termdef></p></item><item><p>In addition, the following are classified as <termref def="dt-post-descent-instruction">post-descent instructions</termref>:
                  <olist><item><p>Any instruction whose parent is an <elcode>xsl:if</elcode> instruction, if the
                        <code>test</code> expression is a <termref def="dt-consuming"/> expression;</p></item><item><p>Any instruction whose parent is an <elcode>xsl:when</elcode> instruction, if the
                        <code>test</code> expression of the parent <elcode>xsl:when</elcode>
                        or of any preceding sibling of the parent <elcode>xsl:when</elcode> 
                        is a <termref def="dt-consuming"/> expression</p></item></olist></p></item></olist><note><p>The above definitions mean that when a sequence constructor is non-consuming, 
                  all its instructions are considered to be pre-descent instructions; this has the effect that
                  none of the instructions can reference a post-descent accumulator function. If this is inconvenient,
                  a workaround is to add a dummy consuming instruction to the sequence constructor, for example:</p><eg xml:space="preserve">
   &lt;xsl:template match="text()"&gt;
     &lt;xsl:value-of select="acc:before-descent()"/&gt;
     &lt;xsl:copy-of select="child::node()"/&gt;
     &lt;xsl:value-of select="acc:after-descent()"/&gt;
   &lt;/xsl:template&gt;</eg></note></div3><div3 id="classifying-instructions"><head>Classifying Instructions</head><p>This section describes how <termref def="dt-instruction">instructions</termref> are 
               classified with respect to their streamability.</p><p>The list that follows describes the rules for each instruction individually.</p><p><termref def="dt-instruction">Instructions</termref> are classified as follows:</p><glist><gitem><label>Literal result elements</label><def><p>A <termref def="dt-literal-result-element"/> is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in  
                              <termref def="dt-attribute-value-template">attribute value templates</termref>
                              among the literal result element's attributes.</p></item><item><p>The <termref def="dt-attribute-set">attribute sets</termref>
                           named in the <code>xsl:use-attribute-sets</code> attribute, if present.</p></item></olist><p>The <termref def="dt-sweep"/> of the <termref def="dt-literal-result-element"/>
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:analyze-string</elcode></label><def><p>If all expressions contained in the <code>regex</code>
                     attribute value template are <termref def="dt-motionless"/>, and if the sequence constructors
                     contained in the <elcode>xsl:matching-substring</elcode>
                        and <elcode>xsl:non-matching-substring</elcode> sequence constructors
                        are not <termref def="dt-group-consuming"/>, then the sweep of the instruction is the
                     sweep of the <code>select</code> expression.</p><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:apply-imports</elcode></label><def><p>The <termref def="dt-sweep"/> of the instruction is the 
                           first of the following that applies:</p><olist><item><p>If there is a child <elcode>xsl:with-param</elcode> element that has a <code>select</code>
                           expression which is not <termref def="dt-motionless"/> or a contained sequence constructor which is not <termref def="dt-motionless"/>,
                           the instruction is <termref def="dt-free-ranging"/>.</p></item><item><p>Otherwise, then the instruction is <termref def="dt-consuming"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:apply-templates</elcode></label><def><p>The <termref def="dt-sweep"/> of the instruction is the 
                           first of the following that applies:</p><olist><item><p>If there is a child <elcode>xsl:with-param</elcode> element that has a <code>select</code>
                           expression which is not <termref def="dt-motionless"/> or a contained sequence constructor which is not <termref def="dt-motionless"/>,
                           then <termref def="dt-free-ranging"/>.</p></item><item><p>If there is a child <elcode>xsl:sort</elcode> element that has a <code>select</code>
                              expression which is <termref def="dt-group-consuming"/> or a contained sequence constructor which is <termref def="dt-group-consuming"/>,
                              then <termref def="dt-free-ranging"/>.</p></item><item><p>If all the following conditions are satisfied, then the instruction is <termref def="dt-motionless"/>:</p><olist><item><p>The <code>select</code> expression is <termref def="dt-motionless"/>;</p></item><item><p>Any expressions contained in <termref def="dt-attribute-value-template">attribute value templates</termref>
                                    among the attributes of any <elcode>xsl:sort</elcode> children are <termref def="dt-motionless"/>;</p></item></olist></item><item><p>If all the following conditions are satisfied, then <termref def="dt-group-consuming"/>:</p><olist><item><p>the explicit or implicit mode is streamable (if <code>mode="#current"</code>
                                    is specified, then all possible modes are streamable)</p></item><item><p>there are no <elcode>xsl:sort</elcode> children;</p></item><item><p>the <code>select</code> expression is a variable reference
                                    to a variable declared in the <code>bind-group</code> attribute of
                                    the innermost ancestor <elcode>xsl:for-each-group</elcode>
                                    instruction;</p></item></olist></item><item><p>If all the following conditions are satisfied, then <termref def="dt-consuming"/>:</p><olist><item><p>the explicit or implicit mode is streamable (if <code>mode="#current"</code>
                                 is specified, then all possible modes are streamable);</p></item><item><p>there are no <elcode>xsl:sort</elcode> children;</p></item><item><p>the <code>select</code> expression is 
                                    <termref def="dt-incrementally-consuming">incrementally consuming</termref>.</p></item></olist></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:assert</elcode></label><def><p>The <elcode>xsl:assert</elcode> instruction is a first-order construct whose
                        sub-constructs are: </p><olist><item><p diff="del" at="M">The <code>enabled</code> expression, if present;</p></item><item><p>The <code>test</code> expression;</p></item><item><p>The <code>select</code> expression, if present;</p></item><item><p>The contained sequence constructor.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:assert</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:attribute</elcode></label><def><p>The <elcode>xsl:attribute</elcode> instruction is a first-order construct
                           whose sub-constructs are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in the <code>name</code>
                               <code>namespace</code>, and <code>separator</code> 
                              <termref def="dt-attribute-value-template">attribute value templates</termref>.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:attribute</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:break</elcode></label><def><p>If the <code>select</code> expression and the contained <termref def="dt-sequence-constructor"/>
                        (where present) are <termref def="dt-motionless"/>, the instruction is <termref def="dt-motionless"/>.</p><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:call-template</elcode></label><def><p>The first of the following that applies:</p><olist><item><p>If there is a child <elcode>xsl:with-param</elcode> element that has a <code>select</code>
                              expression which is not <termref def="dt-motionless"/> or a contained sequence constructor which is not <termref def="dt-motionless"/>,
                              the instruction is <termref def="dt-free-ranging"/>.</p></item><item><p>If the referenced template has a child <elcode>xsl:context-item</elcode>
                                    element with the attribute <code>use="prohibited"</code>, then <termref def="dt-motionless"/>.</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:choose</elcode></label><def><p>The first of the following that applies:</p><olist><item><p>If all <code>test</code> conditions are <termref def="dt-motionless"/>,
                              then the sweep of the instruction is the 
                              maximum sweep of the sequence constructors
                              contained in child <elcode>xsl:when</elcode>
                              and <elcode>xsl:otherwise</elcode> elements.</p></item><item><p>If every sequence constructor contained in a child <elcode>xsl:when</elcode>
                              or <elcode>xsl:otherwise</elcode> element is <termref def="dt-motionless"/>,
                              and if there is at most one <code>test</code> condition that is not <termref def="dt-motionless"/>,
                              then the sweep of the instruction is the sweep of that <code>test</code> condition.</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:comment</elcode></label><def><p>The <elcode>xsl:comment</elcode> instruction is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:comment</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:copy</elcode></label><def><p>The sub-constructs of <elcode>xsl:copy</elcode> are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor;</p></item><item><p>The <termref def="dt-attribute-set">attribute-sets</termref>
                           named in the <code>use-attribute-sets</code> attribute, if present.</p></item></olist><p>The <termref def="dt-sweep"/> of the instruction is the first of the following that applies:</p><olist><item><p>If all sub-constructs are <termref def="dt-motionless"/>, then <termref def="dt-motionless"/>;</p></item><item><p>If the <code>select</code> attribute is absent, or is <code>.</code>, then
                              the first of the following that applies:</p><olist><item><p>If all sub-constructs other than the <code>select</code> expression 
                                    are <termref def="dt-motionless"/>, then <termref def="dt-motionless"/>;</p></item><item><p>If the contained sequence constructor is <termref def="dt-group-consuming"/> and
                                    all referenced attribute sets are <termref def="dt-motionless"/>, then 
                                 <termref def="dt-group-consuming"/></p></item><item><p>If the contained sequence constructor is <termref def="dt-consuming"/> and
                                    all referenced attribute sets are <termref def="dt-motionless"/>, then 
                                    <termref def="dt-consuming"/>.</p></item></olist></item><item><p>If the <code>select</code> attribute is present and is <termref def="dt-motionless"/>, then
                              the first of the following that applies:</p><olist><item><p>If all referenced attribute sets are <termref def="dt-motionless"/>, then 
                                    <termref def="dt-motionless"/>.</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:copy-of</elcode></label><def><p>The <elcode>xsl:copy-of</elcode> instruction is a first-order
                        construct whose only sub-construct is its <code>select</code> expression.</p><p>The <termref def="dt-sweep"/> of the <elcode>xsl:copy-of</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>
                           (in practice, this means that the sweep of the instruction is the same as the
                           sweep of the <code>select</code> expression).</p></def></gitem><gitem><label>Instruction <elcode>xsl:document</elcode></label><def><p>The <elcode>xsl:document</elcode> instruction is a first-order
                        construct whose only sub-construct is its contained <termref def="dt-sequence-constructor"/>.</p><p>The <termref def="dt-sweep"/> of the <elcode>xsl:document</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>
                           (in practice, this means that the sweep of the instruction is the same as the
                           sweep of the contained sequence constructor).</p></def></gitem><gitem><label>Instruction <elcode>xsl:element</elcode></label><def><p>The <elcode>xsl:element</elcode> instruction is a first-order
                           construct whose sub-constructs are:</p><olist><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in the <code>name</code>
                              and <code>namespace</code> 
                              <termref def="dt-attribute-value-template">attribute value templates</termref>;</p></item><item><p>The <termref def="dt-attribute-set">attribute sets</termref>
                              named in the <code>use-attribute-sets</code> attribute, if present.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:element</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/></p></def></gitem><gitem><label>Instruction <elcode>xsl:evaluate</elcode></label><def><p>If the expressions contained in the <code>xpath</code>,
                     <code>context-item</code>, <code>namespace-context</code>,
                     <code>base-uri</code>, and <code>schema-aware</code> attributes, as well
                     as the <code>select</code> attributes and contained sequence constructors
                     of any child <elcode>xsl:with-param</elcode> elements, are all 
                     <termref def="dt-motionless"/>, then the <termref def="dt-sweep"/> of the
                        instruction is <termref def="dt-motionless"/>.</p><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:for-each</elcode></label><def><p>The <termref def="dt-sweep"/> of the instruction is the first of the following that applies:</p><olist><item><p>If any of the following conditions is true, then <termref def="dt-free-ranging"/>:
                              <olist><item><p>The sequence constructor contained in the instruction is 
                                    <termref def="dt-group-consuming"/>;</p></item><item><p>The <code>select</code> expression of an <elcode>xsl:sort</elcode> child element is 
                                    <termref def="dt-group-consuming"/>;</p></item><item><p>The sequence constructor contained in an <elcode>xsl:sort</elcode> child element is 
                                    <termref def="dt-group-consuming"/>.</p></item></olist>
                           </p></item><item><p>If all the following conditions are true, then <termref def="dt-motionless"/>:
                              <olist><item><p>The <code>select</code> expression is <termref def="dt-motionless"/>;</p></item><item><p>All expressions contained in attribute value templates in child <elcode>xsl:sort</elcode>
                                    elements are <termref def="dt-motionless"/>;</p></item><item><p>The instruction does not contain (at any depth) a reference to a variable
                                 declared in the <code>bind-group</code> attribute of an <elcode>xsl:for-each-group</elcode>
                                 element that is an ancestor of the <elcode>xsl:for-each</elcode> instruction.</p></item></olist>
                           </p></item><item><p>If all the following conditions are true, then <termref def="dt-group-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/>;</p></item><item><p>there is no <elcode>xsl:sort</elcode> child element;</p></item><item><p>the <code>select</code> expression is a variable reference
                                    to a variable declared in the <code>bind-group</code> attribute of
                                    the innermost ancestor <elcode>xsl:for-each-group</elcode>
                                    instruction;</p></item></olist></item><item><p>If all the following conditions are true, then <termref def="dt-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item><item><p>there is no <elcode>xsl:sort</elcode> child element</p></item><item><p>the <code>select</code> expression is 
                                    <termref def="dt-incrementally-consuming">incrementally consuming</termref>.</p></item></olist></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:for-each-group</elcode></label><def><p>The sub-constructs of the <elcode>xsl:for-each-group</elcode> instruction are 
                        divided into two groups, as follows.</p><p>The outer-focus sub-constructs are all of the following that are not absent (these
                           are all evaluated with the same focus as the <elcode>xsl:for-each-group</elcode> 
                           instruction itself):</p><ulist><item><p>The <code>select</code> expression</p></item><item><p>Any expressions in the <code>collation</code> attribute value template</p></item><item><p>Any expressions in attribute value templates of child <elcode>xsl:sort</elcode> element</p></item></ulist><p>The inner-focus sub-constructs are all of the following that are not absent (these
                           are all evaluated with a focus based on the selected <termref def="dt-population"/>):</p><ulist><item><p>The <code>group-by</code> expression</p></item><item><p>The <code>group-adjacent</code> expression</p></item><item><p>The <code>group-starting-with</code> pattern</p></item><item><p>The <code>group-ending-with</code> pattern</p></item><item><p>The contained <termref def="dt-sequence-constructor"/></p></item><item><p>Every <code>select</code> expression of a child <elcode>xsl:sort</elcode> elements</p></item><item><p>Every <termref def="dt-sequence-constructor"/> appearing as the content of a 
                              child <elcode>xsl:sort</elcode> element</p></item></ulist><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the first of the following that applies:</p><olist><item><p>If all outer-focus sub-constructs are <termref def="dt-motionless"/>, and if no
                              inner focus sub-construct contains (at any depth) a reference to a variable declared
                              in the <code>bind-group</code> attribute of an <elcode>xsl:for-each-group</elcode>
                              instruction that is an ancestor of this <elcode>xsl:for-each-group</elcode> instruction,
                              then <termref def="dt-motionless"/>.</p></item><item><p>If there is a <code>group-by</code> attribute, then <termref def="dt-free-ranging"/>.</p></item><item><p>If there is no <code>bind-group</code> attribute, then <termref def="dt-free-ranging"/>.</p></item><item><p>If there is a <code>group-adjacent</code> attribute but 
                              no <code>bind-grouping-key</code> attribute, then <termref def="dt-free-ranging"/>.</p></item><item><p>If all the following conditions are satisfied, then <termref def="dt-group-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item><item><p>the <code>select</code> expression is a variable reference
                                    to a variable declared in the <code>bind-group</code> attribute of
                                    the innermost ancestor <elcode>xsl:for-each-group</elcode>
                                    instruction.</p></item><item><p>there is no <elcode>xsl:sort</elcode> child element.</p></item><item><p>all other sub-constructs are <termref def="dt-motionless"/>.</p></item></olist></item><item><p>If all the following conditions are satisfied, then <termref def="dt-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item><item><p>the <code>select</code> expression is 
                                    <termref def="dt-incrementally-consuming">incrementally consuming</termref>.</p></item><item><p>there is no <elcode>xsl:sort</elcode> child element.</p></item><item><p>all other sub-constructs are <termref def="dt-motionless"/>.</p></item></olist></item><item><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:fork</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the maximum 
                         sweep of the <elcode>xsl:sequence</elcode> child instructions.</p></def></gitem><gitem><label>Instruction <elcode>xsl:if</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the first of the following that applies:</p><olist><item><p>If the <code>test</code> condition is <termref def="dt-motionless"/>,
                              then the sweep of the contained sequence constructor.</p></item><item><p>If the contained sequence constructor is <termref def="dt-motionless"/>,
                              then the sweep of the <code>test</code> condition.</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:iterate</elcode></label><def><p>The sub-constructs of the <elcode>xsl:iterate</elcode> instruction are 
                           divided into three groups, as follows.</p><olist><item><p>The outer-focus sub-constructs are all of the following that are not absent (these
                           are all evaluated with the same focus as the <elcode>xsl:iterate</elcode> 
                           instruction itself):</p><ulist><item><p>The <code>select</code> expression</p></item><item><p>Every <code>select</code> expression of a child 
                              <elcode>xsl:param</elcode> element</p></item><item><p>Every <termref def="dt-sequence-constructor"/> appearing as the content of a 
                              child <elcode>xsl:param</elcode> element</p></item></ulist></item><item><p>The inner-focus sub-constructs of the <elcode>xsl:iterate</elcode> instruction are all of the
                           following that are not absent (these are all evaluated with a focus based on the sequence
                           selected by the <code>select</code> expression):</p><ulist><item><p>The contained <termref def="dt-sequence-constructor"/>
                           (including any contained <elcode>xsl:break</elcode> instructions)</p></item></ulist></item><item><p>The no-focus sub-constructs of the <elcode>xsl:iterate</elcode> instruction are all of the
                        following that are not absent (these are all evaluated with an absent focus):</p><ulist><item><p>The <code>select</code> expression of any child 
                              <elcode>xsl:on-completion</elcode> element</p></item><item><p>The <termref def="dt-sequence-constructor"/> appearing as the content of any 
                              child <elcode>xsl:on-completion</elcode> element</p></item></ulist></item></olist><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the
                        first of the following that applies:</p><olist><item><p>If all outer-focus sub-constructs are <termref def="dt-motionless"/>, and if no sub-construct
                              contains (at any level) a reference to a variable declared in the <code>bind-group</code>
                              attribute of an <elcode>xsl:for-each-group</elcode> instruction that is an ancestor of this
                              <elcode>xsl:iterate</elcode> instruction, then <termref def="dt-motionless"/>.</p></item><item><p>If all the following conditions are satisfied, then <termref def="dt-group-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item><item><p>the <code>select</code> expression is a variable reference
                                    to a variable declared in the <code>bind-group</code> attribute of
                                    the innermost ancestor <elcode>xsl:for-each-group</elcode>
                                    instruction.</p></item><item><p>all other inner-focus and outer-focus sub-constructs are <termref def="dt-motionless"/>.</p></item></olist></item><item><p>If all the following conditions are satisfied, then <termref def="dt-consuming"/>:</p><olist><item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item><item><p>the <code>select</code> expression is 
                                    <termref def="dt-incrementally-consuming">incrementally consuming</termref>.</p></item><item><p>all other inner-focus and outer-focus sub-constructs are <termref def="dt-motionless"/>.</p></item></olist></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist><note><p>It is a consequence of the rules given that if an <elcode>xsl:iterate</elcode>
                        instruction is to be streamable, then all related <elcode>xsl:param</elcode>, 
                        <elcode>xsl:on-completion</elcode>,
                        <elcode>xsl:break</elcode>, and <elcode>xsl:next-iteration</elcode> elements
                        must be <termref def="dt-motionless"/>.</p></note></def></gitem><gitem><label>Instruction <elcode>xsl:merge</elcode></label><def><p>If all <elcode>xsl:merge-source</elcode> children are <termref def="dt-motionless"/>
                     then the instruction is <termref def="dt-motionless"/>.</p><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p><note><p>The <elcode>xsl:merge</elcode> instruction will often process its input
                        using streaming, but the rule here is concerned with the <termref def="dt-sweep"/> of
                        the instruction with respect to the document containing the context node,
                        which will not usually be one of the primary inputs to the merging process. A merge
                        operation that processes several input documents in a streaming manner might thus be
                        classified as free-ranging with respect to the principal source document of the transformation.</p><p>A more ambitious implementation might attempt to recognize the case where one of the
                           merge sources involves consuming a subtree of the principal source document: that is,
                     the case where one merge source is a <termref def="dt-consuming"/> expression and the other
                     sources are <termref def="dt-motionless"/>.</p></note></def></gitem><gitem><label>Instruction <elcode>xsl:message</elcode></label><def><p>The <elcode>xsl:message</elcode> instruction is a first-order construct whose
                     sub-constructs are: </p><olist><item><p>The <code>terminate</code>
                              attribute value template;</p></item><item><p>The <code>select</code> expression, if present, 
                              is <termref def="dt-motionless"/>;</p></item><item><p>The contained sequence constructor 
                              is <termref def="dt-motionless"/>.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:message</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:namespace</elcode></label><def><p>The <elcode>xsl:namespace</elcode> instruction is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in the <code>name</code>
                              <termref def="dt-attribute-value-template">attribute value template</termref>.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:namespace</elcode> instruction
                              is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:next-iteration</elcode></label><def><p>If the <code>select</code> expression and the contained <termref def="dt-sequence-constructor"/>
                           of every child <elcode>xsl:with-param</elcode> element (where present) are <termref def="dt-motionless"/>, 
                           the instruction is <termref def="dt-motionless"/>.</p><p>Otherwise, the instruction is <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:next-match</elcode></label><def><p>The <termref def="dt-sweep"/> of the instruction is the 
                           first of the following that applies:</p><olist><item><p>If there is a child <elcode>xsl:with-param</elcode> element that has a <code>select</code>
                                 expression which is not <termref def="dt-motionless"/> or a contained sequence constructor which is not <termref def="dt-motionless"/>,
                                 the instruction is <termref def="dt-free-ranging"/>.</p></item><item><p>Otherwise, the instruction is <termref def="dt-consuming"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:number</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the
                           first of the following that applies:</p><olist><item><p>If there is a <code>value</code> attribute, and if all expressions
                           appearing in attributes of the <elcode>xsl:number</elcode> element other than the 
                              <code>value</code> attribute are <termref def="dt-motionless"/>, then the sweep of the
                           <code>value</code> expression.</p></item><item><p>If there is a <code>select</code> attribute, and if all expressions
                              appearing in attributes of the <elcode>xsl:number</elcode> element including the 
                              <code>select</code> attribute are <termref def="dt-motionless"/>, then <termref def="dt-motionless"/>.</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:perform-sort</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the
                           first of the following that applies:</p><olist><item><p>If all the following conditions are true, then <termref def="dt-motionless"/>:</p><olist><item><p>The <code>select</code> expression is <termref def="dt-motionless"/>;</p></item><item><p>All expressions in attribute value templates of contained
                                 <elcode>xsl:sort</elcode> elements are <termref def="dt-motionless"/>.</p></item></olist></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist><note><p>The <code>select</code> expression of a contained <elcode>xsl:sort</elcode> does
                        not need to be motionless, because it is evaluated with a different context.</p></note></def></gitem><gitem><label>Instruction <elcode>xsl:processing-instruction</elcode></label><def><p>The <elcode>xsl:processing-instruction</elcode> instruction is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in the <code>name</code>
                              <termref def="dt-attribute-value-template">attribute value template</termref>.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:processing-instruction</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:result-document</elcode></label><def><p>The <elcode>xsl:result-document</elcode> instruction is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in 
                              <termref def="dt-attribute-value-template">attribute value templates</termref>
                              among the attributes of the instruction.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:result-document</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:sequence</elcode></label><def><p>The <elcode>xsl:sequence</elcode> instruction is a first-order construct whose
                           sub-constructs are the <code>select</code> expression (if present) and the
                        contained sequence constructor.</p><p>The <termref def="dt-sweep"/> of the <elcode>xsl:sequence</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:stream</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is the sweep
                     of the <termref def="dt-attribute-value-template"/> in its <code>href</code> attribute.</p><note><p><elcode>xsl:stream</elcode> starts a new streaming process on a new document, but in most cases
                           it will be <termref def="dt-motionless"/> with respect to the context item of the template in which it appears.</p></note></def></gitem><gitem><label>Instruction <elcode>xsl:text</elcode> and text nodes</label><def><p>The instruction is <termref def="dt-motionless"/></p></def></gitem><gitem><label>Instruction <elcode>xsl:try</elcode></label><def><p>The <termref def="dt-sweep">sweep</termref> of the instruction is 
                        the first of the following that applies:</p><olist><item><p>If the <code>select</code> expression and/or sequence constructor
                              of the <elcode>xsl:catch</elcode> element are <termref def="dt-motionless"/>,
                              then the <termref def="dt-sweep">sweep</termref> of the
                              <code>select</code> expression and/or sequence constructor
                              of the <elcode>xsl:try</elcode> element (whichever is present);</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>Instruction <elcode>xsl:value-of</elcode></label><def><p>The <elcode>xsl:value-of</elcode> instruction is a first-order construct whose
                           sub-constructs are:</p><olist><item><p>The expression in the <code>select</code> attribute, if present;</p></item><item><p>The contained sequence constructor;</p></item><item><p>Any expressions contained in the <code>separator</code>
                              <termref def="dt-attribute-value-template">attribute value template</termref>.</p></item></olist><p>The <termref def="dt-sweep"/> of the <elcode>xsl:value-of</elcode> instruction
                           is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>Instruction <elcode>xsl:variable</elcode></label><def><p>If there is a <code>select</code> expression, 
                        then the <termref def="dt-sweep"/> of the instruction is the 
                        sweep of the select expression.</p><p>Otherwise (there is a sequence constructor, possibly empty),
                              the <termref def="dt-sweep"/> of the instruction is the sweep of the 
                              sequence constructor.</p></def></gitem></glist></div3><div3 id="classifying-attribute-sets"><head>Classifying Attribute Sets</head><p>An <termref def="dt-attribute-set">attribute set</termref> is a first-order construct whose
                  sub-constructs are:</p><olist><item><p>Any <elcode>xsl:attribute</elcode> instruction contained in the attribute set.</p></item><item><p>Any attribute set referenced by the attribute set in its
                     <code>use-attribute-sets</code> attribute.</p></item></olist><p>The <termref def="dt-sweep"/> of an attribute set
                  is determined using the general rules in <specref ref="general-streamability-rules"/>.</p><note><p>Attribute sets will usually be <termref def="dt-motionless"/>, unless they access the context item, in which case
               they will typically be <termref def="dt-consuming"/>.</p></note></div3><div3 id="classifying-avts"><head>Classifying Attribute Value Templates</head><p>An <termref def="dt-attribute-value-template">attribute value template</termref>
                  is a first-order construct whose sub-constructs are the expressions contained within curly braces.</p><p>The <termref def="dt-sweep"/> of an attribute value template
                  is determined using the general rules in <specref ref="general-streamability-rules"/>.</p></div3><div3 id="classifying-expressions"><head>Classifying Expressions</head><p>Given these syntactic contexts, expressions are classified using the rules in this section.</p><p>In the analysis that follows, <termref def="dt-expression">expressions</termref> 
                  are classified according to the most specific
                  production rule that they match for which there is an entry in this section. 
                  For example, the expression <code>3</code> satisfies
                  the productions <code>NumericLiteral</code>, <code>Literal</code>, and <code>ArithmeticExpression</code>;
                  the most specific of these for which there is an entry in this section is <code>Literal</code>. A production
                  <var>P</var> is considered more specific than a production <var>Q</var> (<var>Q</var> ≠ <var>P</var>) 
                  if every expression that matches <var>P</var> also matches <var>Q</var>.
               </p><p>Th production rules
                  for different kinds of expression are listed (with their names and numbers) in the order in which they appear
                  in Appendix A.1 of the XPath 3.0 specification.</p><glist><gitem><label>Expr [6]</label><def><note><p>Because of the rules given above, this entry applies only to an expression
                        that contains one or more comma (<code>,</code>) operators.</p></note><p>The <termref def="dt-sweep">sweep</termref> of an <code>Expr</code> 
                           is the maximum sweep of any of its contained <code>ExprSimple</code> operands,
                           except that if more than one of these operands is <termref def="dt-consuming"/> or <termref def="dt-group-consuming"/>, then the sweep 
                           of the expression is <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>ForExpr [8]</label><def><p>If all immediately contained subexpressions are <termref def="dt-motionless"/>, 
                        then <termref def="dt-motionless"/>; otherwise <termref def="dt-free-ranging"/>.</p><note><p>The analysis does not enable guaranteed streamed processing of expressions of the form
                        <code>for $x in child::section return $x/para</code>, because this requires data flow
                        analysis (tracing from the binding of a variable to its usages), rather than purely syntactic
                        analysis. Some implementations may be able to stream such constructs.</p><p>As a workaround, the above expression can be rewritten as a path expression, or
                         as an <elcode>xsl:for-each</elcode> instruction.</p></note></def></gitem><gitem><label>LetExpr [11]</label><def><p>A <code>LetExpr</code> is a first-order expression, and
                        follows the general rule given in <specref ref="general-streamability-rules"/>.
                        Writing the expression as <code>let $v := S return A</code>,
                        the two sub-constructs of a <code>LetExpr</code> are <var>S</var>
                        and <var>A</var>.</p><note><p>So, for example <code>let $x := 3 return abs($x)</code> is motionless,
                        while <code>let $x := . return name($x)</code> is free-ranging; this is because the
                        analysis makes no attempt to examine the ways in which the variable <code>$x</code>
                        is actually used.</p></note></def></gitem><gitem><label>QuantifiedExpr [14]</label><def><p>If all immediately contained subexpressions are <termref def="dt-motionless"/>, 
                        then <termref def="dt-motionless"/>; otherwise <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>IfExpr [15]</label><def><p>Writing the expression as 
                     <code>if (C) then T else E</code>, 
                     the <termref def="dt-sweep"/> of the expression is the first of the following
                     that applies:</p><olist><item><p>If <var>C</var> is <termref def="dt-motionless"/> (in an
                           <termref def="dt-inspection-context"/>), then the maximum sweep of 
                           <var>T</var> and <var>E</var>;</p></item><item><p>If <var>T</var> and <var>E</var> are both motionless, then the sweep of 
                           <var>C</var>;</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist></def></gitem><gitem><label>OrExpr [16]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>AndExpr [17]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>ComparisonExpr [18]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>StringConcatExpr [19]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>RangeExpr [20]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>AdditiveExpr [21]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>MultiplicativeExpr [22]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>UnionExpr [23]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>IntersectExceptExpr [24]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>InstanceOfExpr [25]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>TreatExpr [26]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>CastableExpr [27]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>CastExpr [28]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>UnaryExpr [29]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>GeneralComp [31]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>ValueComp [32]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>NodeComp [33]</label><def><p>See general rule in <specref ref="general-streamability-rules"/>.</p></def></gitem><gitem><label>PathExpr [34]</label><def><p>If the <code>PathExpr</code> is not a <code>RelativePathExpr</code>,
                     then the <termref def="dt-sweep"/> of the expression is 
                     <termref def="dt-free-ranging"/>.</p></def></gitem><gitem><label>RelativePathExpr [35]</label><def><p>The rules that follow are applied after expanding any <code>//</code> pseudo-operator
                        to <code>/descendant-or-self::node()/</code>.</p><p>The <termref def="dt-sweep"/> of the expression is the first of the following that
                        applies:</p><olist><item><p>If the first <code>StepExpr</code> is <termref def="dt-motionless"/>,
                           then motionless;</p><note><p>Examples are expressions such as <code>doc('x')//a</code> or 
                           <code>$e/salary</code> which reference data in unstreamed documents.</p></note></item><item diff="add" at="L"><p>If the syntactic context is an <termref def="dt-inspection-context"/>
                              and the <code>RelativePathExpr</code> takes the form of a
                              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt> 
                              that itself conforms to the rules for a motionless pattern 
                              (see <specref ref="classifying-patterns"/>), then <termref def="dt-consuming"/>;</p><note><p>Example: <code>exists(descendant::section)</code></p><p>The rationale for this rule is that with such a construct is possible to process the 
                                 descendants of the context node one at a time, in document order, testing
                                 each one to see whether it matches the corresponding pattern, and if it does,
                                 performing the inspection action while the input stream is positioned at the start 
                                 of the node.
                              </p></note></item><item diff="add" at="L"><p>If the syntactic context is an <termref def="dt-node-value-context"/>
                              and the expression is <termref def="dt-incrementally-consuming"/>, 
                              then <termref def="dt-consuming"/>;</p><note><p>Examples are <code>&lt;xsl:value-of select="tbody/tr[1]/td[2]"/&gt;</code> or
                                 <code>&lt;xsl:value-of select="outermost(.//table)/caption"/&gt;</code>; but not
                                 <code>&lt;xsl:value-of select=".//table/caption"/&gt;</code>, 
                                 because of the possibility that this will select elements
                                 that are nested inside one another.</p></note></item><item><p>If the expression is an <termref def="dt-inherited-attribute-expression"/>,
                           then the first of the following that applies:</p><olist><item><p>If the syntactic context is an <termref def="dt-inspection-context"/> or
                              a <termref def="dt-node-value-context"/>, then <termref def="dt-motionless"/>;</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist><note><p>An example is <code>&lt;xsl:value-of select="../@status"/&gt;</code></p></note></item><item><p>Otherwise, <termref def="dt-free-ranging"/></p></item></olist></def></gitem><gitem><label>AxisStep [37]</label><def><p>The <termref def="dt-sweep"/> of the expression is the first of the following that applies:</p><olist><item><p>If the <code>PredicateList</code> contains a <code>Predicate</code>
                           that is not <termref def="dt-motionless"/>, then <termref def="dt-free-ranging"/>;</p></item><item><p>If the axis is <code>attribute</code> or <code>namespace</code> and the syntactic context is a  
                           <termref def="dt-node-value-context">node value context</termref> or 
                           <termref def="dt-inspection-context">inspection context</termref>, 
                           then <termref def="dt-motionless"/>;</p></item><item><p>If the axis is <code>self</code>, then:</p><olist><item><p>If the syntactic context
                              is an <termref def="dt-inspection-context">inspection context</termref>, 
                              then <termref def="dt-motionless"/>;</p></item><item><p>If the syntactic context
                              is a <termref def="dt-node-value-context">node value context</termref>, 
                              then <termref def="dt-consuming"/>;</p></item></olist></item><item><p>If the axis is <code>parent</code>, <code>ancestor</code>, 
                           or <code>ancestor-or-self</code>, and the syntactic context
                           is an <termref def="dt-inspection-context">inspection context</termref>, 
                           then <termref def="dt-motionless"/>;</p></item><item><p>If the axis is <code>child</code>, and the syntactic context is a  
                           <termref def="dt-node-value-context">node value context</termref> or 
                           <termref def="dt-inspection-context">inspection context</termref>, 
                           then <termref def="dt-consuming"/>;</p></item><item><p>If the axis is <code>descendant</code> 
                           or <code>descendant-or-self</code>, and the syntactic context
                           is an <termref def="dt-inspection-context">inspection context</termref>, 
                           then <termref def="dt-consuming"/>;</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist><note><p>This analysis does not attempt to classify <code>para[title]</code> as a consuming
                     expression; an implementation might choose to do so.</p></note><note><p>When an <code>AxisStep</code> appears as part of a path expression, the
                        classification of the path expression does not necessarily depend on how the <code>AxisStep</code>
                        is classified.</p></note></def></gitem><gitem><label>ForwardStep [38]</label><def><p>A <code>ForwardStep</code> is analyzed as an <code>AxisStep [37]</code>
                     with an empty <code>PredicateList</code>.</p></def></gitem><gitem><label>AbbrevForwardStep [40]</label><def><p>The expression is expanded so that it explicitly uses the <code>child</code>
                     or <code>attribute</code> axis, and is then analyzed according to the rules for a
                     <code>ForwardStep</code>.</p></def></gitem><gitem><label>ReverseStep [41]</label><def><p>A <code>ReverseStep</code> is analyzed as an <code>AxisStep [37]</code>
                     with an empty <code>PredicateList</code>.</p></def></gitem><gitem><label>AbbrevReverseStep [43]</label><def><p>The expression is expanded to <code>parent::node()</code> and is then
                        analyzed according to the rules for a
                        <code>ReverseStep [41]</code>.</p></def></gitem><gitem><label>PostfixExpr [47]</label><def><p>A <code>PostFixExpr</code> can be classified as either
                     a filter expression or a dynamic function call depending on whether the
                     last subexpression is a <code>Predicate</code> (in square brackets)
                     or an <code>ArgumentList</code> (in parentheses).</p><p>For a filter expression of the form <code>B[P]</code> (where <var>B</var>
                     might itself be a filter expression), the <termref def="dt-sweep"/> is the first
                     of the following that applies:</p><olist><item><p>If <var>P</var> is <termref def="dt-motionless"/>, then
                           the <termref def="dt-sweep"/> of <var>B</var>;</p></item><item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item></olist><p>For a dynamic function call, the general rule in <specref ref="general-streamability-rules"/> applies.</p></def></gitem><gitem><label>Literal [52]</label><def><p>A <code>Literal</code> is <termref def="dt-motionless"/>.</p></def></gitem><gitem><label>VarRef [54]</label><def><p>If the variable reference is a reference to a variable declared in a
                           <code>bind-group</code> attribute of a containing <elcode>xsl:for-each-group</elcode>
                           instruction, then:
                           <olist><item><p>If all the following conditions are true then the 
                              <termref def="dt-sweep"/> of the expression is <termref def="dt-group-consuming"/>:</p><olist><item><p>The syntactic context is an <termref def="dt-inspection-context"/>
                                    or <termref def="dt-node-value-context"/>;</p></item><item><p>The <elcode>xsl:for-each-group</elcode> element in question is
                                    the nearest ancestor <elcode>xsl:for-each-group</elcode></p></item></olist></item><item><p>Otherwise, the <termref def="dt-sweep"/> of 
                                 the expression is <termref def="dt-free-ranging"/></p></item></olist>
                        </p><p>Otherwise, the <termref def="dt-sweep"/> of 
                           the expression is <termref def="dt-motionless"/>.</p></def></gitem><gitem><label>ParenthesizedExpr [56]</label><def><p>If there is no contained expression (the expression is <code>()</code>),
                        the sweep is <termref def="dt-motionless"/>.</p><p>Otherwise, the <termref def="dt-sweep">sweep</termref> of the expression is the sweep 
                        of the contained expression</p></def></gitem><gitem><label>ContextItemExpr [57]</label><def><p>The <termref def="dt-sweep"/> of the expression is the first of the following that applies:</p><olist><item><p>If the expression appears in an <termref def="dt-inspection-context">inspection context</termref>: <termref def="dt-motionless"/></p></item><item><p>If the expression appears in a <termref def="dt-node-value-context">node value context</termref>: <termref def="dt-consuming"/></p></item><item><p>Otherwise: <termref def="dt-free-ranging"/></p></item></olist></def></gitem><gitem><label>FunctionCall [58]</label><def><p>Where a function takes the context item as the default value of an argument, and the
                     argument is omitted, the analysis given here treats the expression as if <code>.</code>
                     were supplied as an explicit argument.</p><note><p>The classification of the argument expressions is sensitive to their
                        syntactic context: for example the argument to <code>name(.)</code> has a different
                        <termref def="dt-sweep"/> from the argument to <code>format-number(.)</code>, which differs again from
                        <code>my:user-function(.)</code>.</p></note><p>If the function call is a partial function application (that is, one or more of the arguments is given as
                        <code>?</code>), then the <termref def="dt-sweep"/> is <termref def="dt-free-ranging"/>.</p><p>Otherwise, the <termref def="dt-sweep"/> is determined as follows:</p><olist><item><p>If the function is <xfunction>root#0</xfunction>, <xfunction>last#0</xfunction>,
                           <function>current#0</function>, <function>current-group#0</function>,
                           then <termref def="dt-free-ranging"/>;</p></item><item><p>Otherwise, the function call is a first-order construct, and the general rule
                           in <specref ref="general-streamability-rules"/> applies.</p></item></olist></def></gitem><gitem><label>NamedFunctionRef [62]</label><def><p>A <code>NamedFunctionRef</code> is <termref def="dt-motionless"/>.</p></def></gitem><gitem><label>InlineFunctionExpr [63]</label><def><p>The <termref def="dt-sweep"/> of the expression is the first of the following that
                        applies:</p><olist><item><p>If the body of the inline function is <code>group-consuming</code>
                           (that is, it contains a reference to a variable defined in the <code>bind-group</code>
                           attribute of an <elcode>xsl:for-each-group</elcode> element external to the
                           inline function), then <termref def="dt-free-ranging"/>.</p></item><item><p>Otherwise, <termref def="dt-motionless"/>.</p></item></olist></def></gitem></glist></div3><div3 id="incrementally-consuming"><head>Incrementally Consuming Expressions</head><p>In certain contexts, such as the <code>select</code> attribute of
                  an <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>,
                  <elcode>xsl:apply-templates</elcode>,
                  or <elcode>xsl:for-each-group</elcode> instruction within a streaming template,
                  an expression is required that satisfies the following
                  conditions:</p><ulist><item><p>The expression returns a sequence of nodes;</p></item><item><p>The nodes must be within the subtree rooted at the context node;</p></item><item><p>The nodes must be in document order;</p></item><item><p>The nodes must have disjoint sub-trees (which implies that
                     no node in the sequence may have another node in the sequence as an
                     ancestor or descendant);</p></item><item><p>A streaming processor can determine that a node is a member
                     of the sequence on its first visit to the node, that is, when processing
                     the start tag of an element.</p></item></ulist><p>An expression that can be statically guaranteed to deliver such a sequence
                  of nodes is referred to as an incrementally consuming expression. To define
                  this concept, we first introduce a subsidiary definition:</p><p><termdef id="dt-child-selection-expression" term="child selection expression">An expression is a <term>child-selection expression</term> 
                  if it is any of the following:</termdef></p><olist><item><p>a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="doc-xpath30-ForwardStep" xlink:type="simple">ForwardStep</xnt> 
                        using the child axis</p></item><item><p>a filter expression or axis step (see <xspecref spec="XP30" ref="id-filter-expression"/>) 
                        comprising a base expression that is a child-selection 
                        expression followed by one or more predicates each of which is <termref def="dt-motionless"/></p></item><item><p>a <code>union</code>, <code>except</code>, or <code>intersect</code> 
                        expression (see <xspecref spec="XP30" ref="combining_seq"/>) whose operands are 
                        both child-selection expressions</p></item></olist><p><termdef id="dt-incrementally-consuming" term="incrementally consuming">An 
                     expression is <term>incrementally consuming</term> if it satisfies
                  <phrase diff="chg" at="L">any</phrase> of the following conditions:</termdef></p><olist><item><p>The expression is a <termref def="dt-child-selection-expression">child-selection expression</termref>.</p></item><item><p>The expression is a path expression (<xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="doc-xpath30-RelativePathExpr" xlink:type="simple">RelativePathExpr</xnt>)
                        each of whose steps is an incrementally consuming expression, and each of whose operators
                     is either <code>/</code> or <code>!</code> (not <code>//</code>).</p><note><p>When applied to incrementally consuming expressions, the two operators 
                        <code>/</code> and <code>!</code> are equivalent. The operator <code>//</code>
                     is not allowed because it is capable of selecting two nodes one of which is an
                     ancestor of the other.</p></note></item><item diff="add" at="L"><p>The expression is a call on the <xfunction>outermost</xfunction> function with an argument
                     that is a <termref def="dt-consuming"/> expression.</p><note><p>In the case of an instruction such as <code>&lt;xsl:apply-templates select="outermost(.//section)"/&gt;</code> where the path
                     expression would otherwise select nodes whose subtrees are not disjoint, this selects the
                     outermost sections for processing; the template rule for processing a section can then apply itself recursively to the next level of
                     sections, and so on.</p><p>Calling <xfunction>outermost</xfunction> can also be useful in cases where the selected nodes are not in fact
                        nested. For example the call <code>outermost(.//section/title)</code> will in all likelihood select
                     exactly the same elements as the expression <code>.//section/title</code>; but the former expression is streamable
                     because the processor can determine statically that the selected elements have disjoint subtrees.</p></note></item></olist><note><p>Implementations <rfc2119>may</rfc2119> recognize other kinds of expression
                  as incrementally consuming, for example by making use of schema information.</p></note><p>Some examples of incrementally consuming expressions follow:</p><ulist><item><p><code>*</code></p></item><item><p><code>child::node()[not(self::comment())]</code></p></item><item><p><code>title</code></p></item><item><p><code>div/head</code></p></item><item><p><code>div/para[1]</code></p></item><item><p><code>(chap|appendix)/head</code></p></item><item><p><code>table[@class='data']!tbody!tr[1]!th</code></p></item><item><p><code>schema-element(div)[@class='para']</code></p></item></ulist></div3><div3 id="inherited-attributes"><head>Inherited Attribute Expressions</head><p>During a streaming pass of a document, a processor is expected to retain
                  in memory the attributes of the current node and of all its ancestors, and to
                  make this information available when expressions of the form
                  <code>../@status</code> or <code>ancestor::div[last()]/@id</code> are used</p><p>However, the use of such expressions is restricted because further navigation
                  from an ancestor node (for example, to its children) is not possible when
                  streaming.</p><p>This restriction is achieved by defining this class of expression to be
                  <termref def="dt-motionless"/> provided that it appears in an node-value or inspection
                  context.</p><p><termdef id="dt-inherited-attribute-expression" term="inherited attribute expression">
                    An <term>inherited attribute expression</term> is an expression that satisfies all
                     of the following conditions:
                  </termdef></p><olist><item><p>The expression is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="doc-xpath30-RelativePathExpr" xlink:type="simple">RelativePathExpr</xnt>
                     consisting of one or more steps, in which every operator is <code>/</code> or <code>!</code>
                     (not <code>//</code>).</p></item><item><p>The last step is an axis step using the attribute axis, in which every predicate
                     is <termref def="dt-motionless"/>.</p></item><item><p>Every step before the last is an axis step using one of the axes parent, ancestor,
                     ancestor-or-self, or self, and every predicate in such a step is <termref def="dt-motionless"/>.</p></item></olist><p>Some examples of inherited attribute expressions follow:</p><ulist><item><p><code>@status</code></p></item><item><p><code>../@status</code></p></item><item><p><code>../../@*</code></p></item><item><p><code>ancestor::*[@xml:lang][1]/@xml:lang</code></p></item></ulist><note><p>Implementations <rfc2119>may</rfc2119> recognize other kinds of expression
                     as inherited attribute expressions, for example expressions that use the
                     <code>union</code>, <code>intersect</code>, or <code>except</code>
                     operators.</p></note></div3><div3 id="classifying-patterns"><head>Classifying Patterns</head><p>The <termref def="dt-pattern">patterns</termref> used as match patterns in streaming
                  templates and for the <code>group-starting-with</code> and <code>group-ending-with</code>
                  instructions in an
                  <elcode>xsl:for-each-group</elcode> instruction within a streaming template are 
                  required to be <termref def="dt-motionless"/> patterns.</p><p diff="chg" at="K">Informally, a <termref def="dt-motionless"/> pattern is a pattern that can be evaluated by a streaming processor
                  when the input stream is positioned at the start tag of an element, without advancing the input
                  stream.</p><p>A pattern is <termref def="dt-motionless"/> if it conforms to all the following restrictions:</p><olist><item><p>If it is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RootedPattern" xlink:type="simple">RootedPattern</nt> then it must start with
                  <code>/</code> or <code>//</code> (not with a function call).</p></item><item><p>Every <code>Predicate</code> in the pattern must satisfy all of the following constraints:</p><olist><item><p>The expression in the predicate must be <termref def="dt-motionless"/>.</p></item><item><p>The predicate must not contain a call on either of the functions 
                     <xfunction>position</xfunction> or <xfunction>last</xfunction>.</p></item><item><p>The expression in the predicate must be guaranteed to return a single boolean.
                        Specifically, it must be one of the following:</p><olist><item><p>A function call on a function whose declared return type is <code>xs:boolean</code> with
                        occurrence indicator either <code>?</code> or absent.</p></item><item><p>A <code>QuantifiedExpr</code></p></item><item><p>A non-trivial <code>AndExpr</code> or <code>OrExpr</code></p></item><item><p>A non-trivial <code>ComparisonExpr</code></p></item><item><p>A non-trivial <code>InstanceofExpr</code> or <code>CastableExpr</code></p></item><item><p>A <code>ParenthesizedExpr</code> that immediately contains one of the kinds of expression
                        in this list.</p></item></olist><p>The term <term>non-trivial</term> is used here in the sense that an expression must match
                        the production and must contain the operator that distinguishes it as belonging to this production
                        and not to a more specific production: thus <code>@status = 'live'</code> is a non-trivial <code>ComparisonExpr</code>,
                           unlike <code>pqr</code> and <code>'live'</code> both of which match the <code>ComparisonExpr</code>
                           production but lack the distinguishing operator.</p></item></olist></item></olist><p>A pattern that is not <termref def="dt-motionless"/> is classified as <termref def="dt-free-ranging"/>.</p></div3></div2><div2 id="func-copy-of"><head><?function fn:copy-of?></head></div2><div2 id="func-snapshot"><head><?function fn:snapshot?></head></div2><div2 id="func-point-copy"><head><?function fn:point-copy?></head></div2><div2 id="func-attributes"><head><?function fn:attributes?></head></div2><div2 id="func-look-ahead"><head><?function fn:look-ahead?></head></div2></div1><div1 id="add-func"><head>Additional Functions</head><p>This section describes XSLT-specific additions to the <termref def="dt-core-function">core function</termref> library. Some of these additional functions also make use of
            information specified by <termref def="dt-declaration">declarations</termref> in the
            stylesheet; this section also describes these declarations.</p><div2 id="func-document"><head><?function fn:document?></head></div2><div2 id="key"><head>Keys</head><p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p><div3 id="xsl-key"><head>The <elcode>xsl:key</elcode> Declaration</head><e:element-syntax name="key"><e:in-category name="declaration"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="match" required="yes"><e:data-type name="pattern"/></e:attribute><e:attribute name="use"><e:data-type name="expression"/></e:attribute><e:attribute name="composite"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="collation" required="no"><e:data-type name="uri"/></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:key</elcode>
                  <termref def="dt-declaration">declaration</termref> is used to declare <termref def="dt-key">keys</termref>. The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is an 
                  <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as described in <specref ref="qname"/>. The <code>match</code> attribute is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>; an <elcode>xsl:key</elcode> element applies to all nodes that
                  match the pattern specified in the <code>match</code> attribute.</p><p>
                  <termdef id="dt-key" term="key">A <term>key</term> is defined as a set of
                        <elcode>xsl:key</elcode> declarations in the <phrase diff="chg" at="I">same <termref def="dt-package">package</termref></phrase> that share the same name.</termdef>
               </p><p diff="add" at="I">The key name is scoped to the containing <termref def="dt-package">package</termref>,
               and is available for use in calls to the <function>key</function> function within that package.</p><p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p><p>
                  <error spec="XT" type="static" class="SE" code="1205"><p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p></error>
               </p><p>If the <code>use</code> attribute is present, its value is an <termref def="dt-expression">expression</termref> specifying the values of the key. The
                  expression will be evaluated with <phrase diff="chg" at="D">a <termref def="dt-singleton-focus">singleton focus</termref> based on the node that
                     matches the pattern</phrase>. The result of evaluating the expression is
                     <termref def="dt-atomization">atomized</termref>. </p><p>Similarly, if a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <termref def="dt-atomization">atomized</termref>.</p><p>
                  <termdef id="dt-key-specifier" term="key specifier">The expression in the
                        <code>use</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> within an <elcode>xsl:key</elcode>
                     declaration are referred to collectively as the <term>key specifier</term>. The
                     key specifier determines the values that may be used to find a node using this
                        <termref def="dt-key">key</termref>.</termdef>
               </p><p diff="add" at="G">When evaluation of the <termref def="dt-key-specifier">key specifier</termref>
               results in a sequence (after atomization) containing more than one atomic value, the effect
               depends on the value of the <code>composite</code> attribute:</p><ulist diff="add" at="G"><item><p>When the attribute is absent or has the value <code>no</code>, each
                  atomic value in the sequence acts as an individual key. For example, if 
                  <code>match="book" use="author" composite="no"</code> is specified, then 
                  a <code>book</code> element may be located using the value of any <code>author</code>
                  element.</p></item><item><p>When the attribute is present and has the value <code>yes</code>, the sequence
                     of atomic values is treated as a composite key that must be matched in its entirety. 
                     For example, if 
                     <code>match="book" use="author" composite="yes"</code> is specified, then 
                     a <code>book</code> element may be located using the value of all its <code>author</code>
                     elements, supplied in the correct order.</p></item></ulist><p diff="add" at="G">If there are several <elcode>xsl:key</elcode> declarations in the 
                  <phrase diff="chg" at="I">same package</phrase> with the same
               key name, then they must all have the same effective value for their <code>composite</code>
               attribute. The effective value is the actual value of the attribute if present, or "no"
               if the attribute is absent.</p><note><p>There is no requirement that all the values of a key should have the same
                     type.</p></note><p>The presence of an <elcode>xsl:key</elcode> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if <phrase diff="del" at="G">any of</phrase> the values of the
                     <termref def="dt-key-specifier">key specifier</termref> (when applied to that
                  node) are known. It also provides a hint to the implementation that access to the
                  nodes by means of these values needs to be efficient (many implementations are
                  likely to construct an index or hash table to achieve this). <phrase diff="del" at="G">Note that the
                     <termref def="dt-key-specifier">key specifier</termref> in general returns a
                  sequence of values, and any one of these may be used to locate the node.</phrase></p><note><p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <function>key</function> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <function>key</function> function
                     searches one document only.</p></note><p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two key values
                     <code>$a</code> and <code>$b</code> are considered equal if the result of the
                  function call <phrase diff="chg" at="G"><code>deep-equal($a, $b, $collation)</code> is true</phrase>. The effective
                  collation for an <elcode>xsl:key</elcode> declaration is the collation specified
                  in its <code>collation</code> attribute if present, resolved against the base URI
                  of the <elcode>xsl:key</elcode> element, or the <termref def="dt-default-collation">default collation</termref> that is in scope for the
                     <elcode>xsl:key</elcode> declaration otherwise; the effective collation must be
                  the same for all the <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key">key</termref>.</p><p>
                  <error spec="XT" type="static" class="SE" code="1210"><p>It is a <termref def="dt-static-error">static error</termref> if the <elcode>xsl:key</elcode> declaration has a
                           <code>collation</code> attribute whose value (after resolving against the
                        base URI) is not a URI recognized by the implementation as referring to a
                        collation.</p></error>
               </p><p>
                  <error spec="XT" type="static" class="SE" code="1220"><p>It is a <termref def="dt-static-error">static error</termref> if there are several <elcode>xsl:key</elcode>
                        declarations in the 
                        <phrase diff="chg" at="I">same <termref def="dt-package">package</termref></phrase> with
                        the same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.</p></error>
               </p><p diff="add" at="G">
                  <error spec="XT" type="static" class="SE" code="1222"><p>It is a <termref def="dt-static-error">static error</termref> if there are several <elcode>xsl:key</elcode>
                        declarations in the <termref def="dt-stylesheet">stylesheet</termref> with
                        the same key name and different effective values for the <code>composite</code>
                        attribute.</p></error>
               </p><p>It is possible to have:</p><ulist><item><p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p></item><item><p>a node that matches the <code>match</code> patterns of several different
                           <elcode>xsl:key</elcode> declarations, whether these have the same key
                        name or different key names;</p></item><item><p>a node that returns more than one value from its <termref def="dt-key-specifier">key specifier</termref> 
                        <phrase diff="add" at="G">(which can be treated either as separate individual key
                        values, or as a single composite key value)</phrase>;</p></item><item><p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p></item></ulist><p>An <elcode>xsl:key</elcode> declaration with higher <termref def="dt-import-precedence">import precedence</termref> does not override
                  another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
                  in the stylesheet are effective regardless of their import precedence.</p></div3><div3 id="func-key"><head><?function fn:key?></head></div3></div2><div2 id="defining-decimal-format"><head>Defining a Decimal Format</head><p diff="chg" at="D">The definition of the <xfunction>format-number</xfunction>
               function is now in <bibref ref="xpath-functions-30"/>. What remains here is the definition of
            the <elcode>xsl:decimal-format</elcode> declaration, which provides the context
            for this function when used in an XSLT stylesheet.</p><e:element-syntax name="decimal-format"><e:in-category name="declaration"/><e:attribute name="name"><e:data-type name="eqname"/></e:attribute><e:attribute name="decimal-separator"><e:data-type name="char"/></e:attribute><e:attribute name="grouping-separator"><e:data-type name="char"/></e:attribute><e:attribute name="infinity"><e:data-type name="string"/></e:attribute><e:attribute name="minus-sign"><e:data-type name="char"/></e:attribute><e:attribute name="NaN"><e:data-type name="string"/></e:attribute><e:attribute name="percent"><e:data-type name="char"/></e:attribute><e:attribute name="per-mille"><e:data-type name="char"/></e:attribute><e:attribute name="zero-digit"><e:data-type name="char"/></e:attribute><e:attribute name="digit"><e:data-type name="char"/></e:attribute><e:attribute name="pattern-separator"><e:data-type name="char"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:decimal-format</elcode> element controls the interpretation of a
                  <termref def="dt-picture-string">picture string</termref> used by the
                  <xfunction>format-number</xfunction> function.</p><p><termdef id="dt-picture-string" term="picture string">The <term>picture string</term>
               is the string supplied as the second argument of the 
               <xfunction>format-number</xfunction> function.</termdef> </p><note diff="add" at="D"><p>The <xfunction>format-number</xfunction> function, previously defined in this
                  specification, is now a core function defined in <bibref ref="xpath-functions-30"/>.
               </p></note><p>A <phrase diff="chg" at="I"><termref def="dt-package">package</termref></phrase> may contain multiple
                  <elcode>xsl:decimal-format</elcode> declarations and may include or import
                  <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                  <elcode>xsl:decimal-format</elcode> declarations. The name of an
                  <elcode>xsl:decimal-format</elcode> declaration is the value of its
                  <code>name</code> attribute, if any.</p><p>
               <termdef id="dt-decimal-format" term="decimal format">All the
                     <elcode>xsl:decimal-format</elcode> declarations in a <phrase diff="chg" at="I">package</phrase> that share the
                  same name are grouped into a named <term>decimal format</term>; those that have no
                  name are grouped into a single unnamed decimal format.</termdef>
            </p><p diff="add" at="I">The scope of an <elcode>xsl:decimal-format</elcode> name is the
           package in which it is declared; the name is available for use only in calls to
           <xfunction>format-number</xfunction> that appear within the same package.</p><p>If a <termref def="dt-package">package</termref> does not contain a declaration
               of the unnamed decimal format, a declaration equivalent to an
                  <elcode>xsl:decimal-format</elcode> element with no attributes is implied.</p><p>The attributes of the <elcode>xsl:decimal-format</elcode> declaration establish
               values for a number of variables used as input to the algorithm followed by the
                  <xfunction>format-number</xfunction> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given <phrase diff="chg" at="D">as part of the specification of
                     <xfunction>format-number</xfunction></phrase>.</p><p>For any named <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p><p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p><p>
               <error spec="XT" type="static" class="SE" code="1290"><p>It is a <termref def="dt-static-error">static error</termref> if a named or
                     unnamed <termref def="dt-decimal-format">decimal format</termref> contains two
                     conflicting values for the same attribute in different
                        <elcode>xsl:decimal-format</elcode> declarations having the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another definition of the same attribute with higher import precedence.</p></error>
            </p><p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function, and also specify characters that may
               appear in the result of formatting the number. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p><ulist><item><p>
                     <code>decimal-separator</code> specifies the character used for the
                        <var>decimal-separator-sign</var>; the default value is the period character
                        (<code>.</code>)</p></item><item><p>
                     <code>grouping-separator</code> specifies the character used for the
                        <var>grouping-sign</var>, which is typically used as a thousands separator;
                     the default value is the comma character (<code>,</code>)</p></item><item><p>
                     <code>percent</code> specifies the character used for the
                        <var>percent-sign</var>; the default value is the percent character
                        (<code>%</code>)</p></item><item><p>
                     <code>per-mille</code> specifies the character used for the
                        <var>per-mille-sign</var>; the default value is the Unicode per-mille
                     character (#x2030)</p></item><item><p>
                     <code>zero-digit</code> specifies the character used for the
                        <var>digit-zero-sign</var>; the default value is the digit zero
                        (<code>0</code>). This character <rfc2119>must</rfc2119> be a digit
                     (category Nd in the Unicode property database), and it <rfc2119>must</rfc2119>
                     have the numeric value zero. This attribute implicitly defines the Unicode
                     character that is used to represent each of the values 0 to 9 in the final
                     result string: Unicode is organized so that each set of decimal digits forms a
                     contiguous block of characters in numerical sequence.</p></item></ulist><p>
               <error spec="XT" type="static" class="SE" code="1295"><p>It is a <termref def="dt-static-error">static error</termref> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. </p></error>
            </p><p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p><ulist><item><p>
                     <code>digit</code> specifies the character used for the <var>digit-sign</var>
                     in the <termref def="dt-picture-string">picture string</termref>; the default
                     value is the number sign character (<code>#</code>)</p></item><item><p>
                     <code>pattern-separator</code> specifies the character used for the
                        <var>pattern-separator-sign</var>, which separates positive and negative
                     sub-pictures in a <termref def="dt-picture-string">picture string</termref>;
                     the default value is the semi-colon character (<code>;</code>)</p></item></ulist><p>The following attributes specify characters or strings that may appear in the result
               of formatting the number:</p><ulist><item><p>
                     <code>infinity</code> specifies the string used for the
                        <var>infinity-symbol</var>; the default value is the string
                        <code>Infinity</code>
                  </p></item><item><p>
                     <code>NaN</code> specifies the string used for the <var>NaN-symbol</var>, which
                     is used to represent the value NaN (not-a-number); the default value is the
                     string <code>NaN</code>
                  </p></item><item><p>
                     <code>minus-sign</code> specifies the character used for the
                        <var>minus-symbol</var>; the default value is the hyphen-minus character
                        (<code>-</code>, #x2D). The value <rfc2119>must</rfc2119> be a single
                     character.</p></item></ulist><p>
               <error spec="XT" type="static" class="SE" code="1300"><p>It is a <termref def="dt-static-error">static error</termref> if, for any named
                     or unnamed decimal format, the variables representing characters used in a
                        <termref def="dt-picture-string">picture string</termref> do not each have
                     distinct values. These variables are <var>decimal-separator-sign</var>,
                        <var>grouping-sign</var>, <var>percent-sign</var>,
                     <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>,
                     and <var>pattern-separator-sign</var>.</p></error>
            </p><p diff="add" at="I">Every (named or unnamed) decimal format defined in a <termref def="dt-stylesheet">package</termref> is added to the <xtermref spec="XP30" ref="dt-static-decimal-formats">statically known decimal formats</xtermref> in the
                  <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> of every
               expression in the <termref def="dt-package">package</termref>, excluding
               expressions appearing in <code>[xsl:]use-when</code> attributes.</p></div2><div2 id="misc-func"><head>Miscellaneous Additional Functions</head><div3 id="func-current"><head><?function fn:current?></head></div3><div3 id="func-unparsed-entity-uri"><head><?function fn:unparsed-entity-uri?></head></div3><div3 id="func-unparsed-entity-public-id"><head><?function fn:unparsed-entity-public-id?></head></div3><div3 id="func-system-property"><head><?function fn:system-property?></head></div3></div2></div1><div1 id="additional-types" diff="add" at="G"><head>XPath Extensions</head><p>XSLT 3.0 extends the type system and data model of XPath 3.0 with additional datatypes and 
            associated functions and operators defined in this section.</p><div2 id="map"><head>Maps</head><p>A map is an additional kind of item.</p><p><termdef id="dt-map" term="map">A map comprises a collation and a set of entries. Each entry comprises a key 
               which is an arbitrary atomic value, and an arbitrary sequence called the associated value. Within a map, no two entries have the same key,
            when compared using the <code>eq</code> operator under the map's collation. It is not necessary that all the keys should be
            mutually comparable (for example, they can include a mixture of integers and strings). Key values will never be of type
               <code>xs:untypedAtomic</code>, and they will never be the <code>xs:float</code> or <code>xs:double</code> value <code>NaN</code>.</termdef></p><p>The function call <code>map:get($map, $key)</code> can be used to retrieve the value associated with a given key.</p><p>A <termref def="dt-map">map</termref> can also be viewed as a function from keys to associated values. To achieve this, a map is also a 
               function item. The function corresponding to the map has the signature 
               <code>function($key as xs:anyAtomicValue) as item()*</code>. Calling the function has the same effect as calling
               the <code>get</code> function: the expression
            <code>$map($key)</code> returns the same result as <code>get($map, $key)</code>. For example, if <code>$books-by-isbn</code>
            is a map whose keys are ISBNs and whose associated values are <code>book</code> elements, then the expression
               <code>$books-by-isbn("0470192747")</code> returns the <code>book</code> element with the given ISBN.
               The fact that a map is a function item allows it to be passed as an argument to higher-order functions 
            that expect a function item as one of their arguments.</p><p>Like all other values, <termref def="dt-map">maps</termref> are immutable. For example, the <function>map:remove</function> function creates a new map by removing an entry
            from an existing map, but the existing map is not changed by the operation.</p><p>Like sequences, <termref def="dt-map">maps</termref> have no identity. It is meaningful to compare the contents of two maps, but there is no way
            of asking whether they are "the same map": two maps with the same content are indistinguishable.</p><div3 id="map-type"><head>The Type of a Map</head><p>The syntax of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath30-ItemType" spec="XP30" xlink:type="simple">ItemType</xnt> as defined in XPath is extended as follows:</p><scrap headstyle="show"><head>MapType</head><prodgroup><prod id="NT-ItemType-2"><lhs>ItemType</lhs><rhs>... | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-MapType" xlink:type="simple">MapType</nt></rhs></prod><prod id="NT-MapType"><lhs>MapType</lhs><rhs>'map' '(' ( '*' | (<xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="doc-xpath30-AtomicOrUnionType" spec="XP30" xlink:type="simple">AtomicOrUnionType</xnt> ',' 
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath30-SequenceType" spec="XP30" xlink:type="simple">SequenceType</xnt>) ')'</rhs></prod></prodgroup></scrap><p>The <code>ItemType</code> <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a 
                  <termref def="dt-map">map</termref>, and (b) every
            entry in <var>M</var> has a key that matches <code>K</code> and an associated value that matches <code>V</code>. For example,
            <code>map(xs:integer, element(employee))</code> matches a map if all the keys in the map are integers, and all the associated
            values are <code>employee</code> elements. Note that a map (like a sequence) carries no intrinsic type information separate
            from the types of its entries, and the type of existing entries in a map does not constrain the type of new entries that can be
            added to the map.</p><p>The <code>ItemType</code> <code>map(*)</code> is equivalent to <code>map(xs:anyAtomicType, item()*)</code>, and matches
            any map regardless of its contents.</p><p>Because a <termref def="dt-map">map</termref> is a function, the type <code>map(K, V)</code> is derived from <code>function(K) as V</code>, and instances
               of <code>map(K, V)</code> can be used wherever the required type is <code>function(K) as V</code>.</p></div3><div3 id="map-functions"><head>Functions that Operate on Maps</head><p>The functions defined in this section use a conventional namespace prefix <code>map</code>, which
            is assumed to be bound to the namespace URI <code>http://www.w3.org/2011/xpath-functions/map</code>.</p><p>There is no operation to atomize a map or convert it to a string.</p><p>The number of entries in the map may be obtained as <code>count(map:keys($map))</code>.</p><div4 id="func-map-new"><head><?function map:new?></head></div4><div4 id="func-map-collation"><head><?function map:collation?></head></div4><div4 id="func-map-keys"><head><?function map:keys?></head></div4><div4 id="func-map-contains"><head><?function map:contains?></head></div4><div4 id="func-map-get"><head><?function map:get?></head></div4><div4 id="func-map-entry"><head><?function map:entry?></head></div4><div4 id="func-map-remove"><head><?function map:remove?></head></div4><div4 id="func-deep-equal2"><head><?function fn:deep-equal2?></head></div4></div3><div3 id="map-expressions"><head>Map Expressions</head><p>A new kind of expression is added to the syntax of XPath.</p><p>The syntax of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="doc-xpath30-PrimaryExpr" xlink:type="simple">PrimaryExpr</xnt> is extended to permit <code>MapExpr</code> as an 
               additional alternative.</p><p><code>MapExpr := "map" "{" (KeyExpr ":=" ValueExpr ("," KeyExpr ":=" ValueExpr )*)? "}"</code></p><p><code>KeyExpr := ExprSingle</code></p><p><code>ValueExpr := ExprSingle</code></p><note><p>Two variations on this syntax are under consideration: removing the leading keyword
               "map", and using the token ":" in place of ":=". This would bring the syntax closer to
               JavaScript and JSON notation. However, special lexical rules would be needed to disambiguate
               this use of ":" from other uses. Feedback is invited.</p></note><p>The value of the expression is a map whose entries correspond to the key-value pairs obtained
               by evaluating the successive <code>KeyExpr</code> and <code>ValueExpr</code> expressions.</p><p>Each <code>KeyExpr</code> expression is evaluated and atomized; a dynamic error occurs if
               the result is not a single atomic value. If the key value is of type <code>xs:untypedAtomic</code>
                  it is converted to <code>xs:string</code>. 
                  The associated value is the result of evaluating the
               corresponding <code>ValueExpr</code>. The collation of the new map is the default collation from
               the static context. If the key value is <code>NaN</code>
                  then the key/value pair is not added to the map.
                  If two or more keys are equal under the collation of the map then the last occurrence is added
                  to the map and the others are ignored.</p><p>For example, the following expression constructs a map with seven entries:</p><eg xml:space="preserve">
map {
  "Su" := "Sunday",
  "Mo" := "Monday",
  "Tu" := "Tuesday",
  "We" := "Wednesday",
  "Th" := "Thursday",
  "Fr" := "Friday",
  "Sa" := "Saturday"
}</eg><note><p>Unlike the <function>map:new</function>, the number of entries in a map that is constructed
                  using a map expression is known statically, except where duplicate keys or NaN values cause
                  some entries to be ignored.</p></note><note><p>An alternative syntax for map expressions is also under consideration: an example would be
               <code>{"Su" : "Sunday", "Mo" : "Monday"}</code>. Feedback is welcome.</p></note></div3><div3 id="map-examples"><head>Examples using Maps</head><p>This section gives some examples of where maps can be useful.</p><example id="maps-with-iterate"><head>Using Maps with xsl:iterate</head><p>This example uses maps in conjunction with the <elcode>xsl:iterate</elcode> instruction to find the highest-earning
               employee in each department, in a single streaming pass of an input document containing employee records.</p><eg xml:space="preserve">
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map:new()"/&gt;
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:new($highest-earners, 
                                      map:entry($this/department, $this))"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;
</eg></example><example id="example-complex-numbers"><head>Using Maps to Implement Complex Numbers</head><p>A complex number might be represented as a map with two entries, the keys being the 
                     <code>xs:boolean</code> value <code>true</code> for the real part, and the 
                     <code>xs:boolean</code> value <code>false</code> for the imaginary part. A library for manipulation
                     of complex numbers might include functions such as the following:</p><eg xml:space="preserve">
&lt;xsl:function name="i:complex" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ true() := $real, false() := $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex(true())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex(false())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</eg><note><p>This example demonstrates how useful it would be to allow 
                  user-defined type aliases, so that callers of this function library could write code that
               treats the value simply as a <code>complex-number</code>, not as a map. A proposal
               to introduce such type aliases is under consideration.</p></note></example><example id="map-as-index"><head>Using a Map as an Index</head><p>Given a set of <code>book</code> elements, it is possible to construct an index
               in the form of a map allowing the books to be retrieved by ISBN number.</p><p>Assume the book elements have the form:</p><eg xml:space="preserve">
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;</eg><p>An index may be constructed as follows:</p><eg xml:space="preserve">
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:new(for $b in //book return map{$b/isbn := $b})"/&gt;</eg><p>This index may then be used to retrieve the book for a given ISBN using either of the
                  expressions <code>map:get($isbn-index, "0470192747")</code> or <code>$isbn-index("0470192747")</code>.</p><p>In this simple form, this replicates the functionality available using <elcode>xsl:key</elcode>
               and the <function>key</function> function. However, it also provides capabilities not directly
                  available using the <function>key</function> function: for example, the index can include
                  <code>book</code> elements in multiple source documents. It also allows processing of all the
                  books using a construct such as <code>&lt;xsl:for-each select="map:keys($isbn-index)"&gt;</code></p></example><example id="map-as-class"><head>A Map containing Named Functions</head><p>As in JavaScript, a map whose keys are strings and whose associated values are function items can
               be used in a similar way to a class in object-oriented programming languages.</p><p>Suppose an application needs to handle customer order information that may arrive in three different
               formats, with different hierarchic arrangement:</p><olist><item><p>Flat structure:</p><eg xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;</eg></item><item><p>Orders within customer elements:</p><eg xml:space="preserve">
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;</eg></item><item><p>Orders within product elements:</p><eg xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;</eg></item></olist><p>An application can isolate itself from these differences by defining a set of functions
                  to navigate the relationships between customers, orders, and products:
                  <code>orders-for-customer</code>, <code>orders-for-product</code>, <code>customer-for-order</code>,
               <code>product-for-order</code>. These functions can be implemented in different ways for the
               three different input formats. For example, with the first format the implementation might be:</p><eg xml:space="preserve">
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map {
            'orders-for-customer' := 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' := 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' := 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' := 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;</eg><p>Having established which input format is in use, the application can bind the appropriate implementation
            of these functions to a variable such as <code>$input-navigator</code>, and can then process the
            input using XPath expressions such as the following, which selects all products for which there is
            no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code>            
         </p></example></div3></div2><!--<div2 id="arrays">
            <head>Arrays</head>
            
            <p>An array is a single item that encapsulates a sequence.
               Because an array is an item, it can be part of a sequence, 
               which can in turn be encapsulated by another array. Thus nested sequences become possible.
               For example, a polygon can be represented as a sequence containing the coordinates of its
               vertices, each coordinate being an array of two doubles.</p>
            
            <p>Like other XDM values, arrays are immutable and have no identity.</p>
            
            <proto class="xslt" name="array" return-type="array(*)">
               <arg name="seq" type="item()*"/>
            </proto>
            
            <p>The function call <code>array($seq)</code> returns an array that 
               encapsulates the sequence <code>$seq</code>. For example, <code>(array((0,0)), array((0,1)), 
               array((1,1)), array((1,0)))</code> represents the unit square: a sequence of four items,
               each of which is an array of two items.</p>
            
            
            <proto class="xslt" name="body" return-type="item()*">
               <arg name="array" type="array(*)"/>
            </proto>
            
            <p>The sequence encapsulated by an array is called its body. 
               The function <code>body($array)</code> returns the sequence encapsulated by <code>$array</code>.</p>
            
            <p>Thus <code>body(array($X))</code> returns <code>$X</code> for any sequence <code>$X</code>.</p>
            
            <proto class="xslt" name="length" return-type="xs:integer">
               <arg name="array" type="array(*)"/>
            </proto>
                       
            <p>The convenience function <code>length($array)</code> returns <code>count(body($array))</code>.</p>
            
            
            
            <div3 id="array-type">
               <head>The Type of an Array</head>
           
            <p>We introduce a new <code>ItemType</code> with the syntax</p>
            
            <p><code>"array" "(" ItemType ")"</code></p>
            
            <p>An array <code>$A</code> matches the item type <code>array(J)</code> if 
               <code>body($A)</code> matches <code>J*</code>, that is, if every item in the body of <code>$A</code> matches 
               <code>J</code>. For example, the array <code>array((1,2,3))</code> matches the <code>ItemType</code> 
               <code>array(xs:integer)</code>.</p>
               
              
            
            <p>The item type <code>array(*)</code> is equivalent to <code>array(item())</code>. 
               To test whether an item <code>$i</code> is an array, use 
               the expression <code>$i instance of array(*)</code>.</p>
            
            <p>The item type <code>array(S)</code> is a subtype of <code>array(T)</code> 
               if <code>S</code> is a subtype of <code>T</code>.</p>
            
            <p>The item type <code>array(*)</code> is a subtype of <code>function(xs:integer) as item()</code>. 
               So an array can be treated as a function from integers onto items. 
               Thus <code>$array(5)</code> returns the value of <code>body($array)[5]</code>.</p>
               
            <p>Because <code>array(*)</code> is an item type, it can be used with an occurrence indicator
            to form a sequence type. For example, <code>array(*)*</code> denotes a sequence of zero or more
            arrays.</p>
               
            </div3>
            <div3 id="operations-on-arrays">
               <head>Operations on Arrays</head>
          
            <p>Because an array is a function, it inherits operations applicable to functions.
            The arity of the function is one, and it has no name.</p>
            
                          
               <p>An array can be atomized if its body can be atomized. 
                  The function <code>data($array)</code> returns <code>data(body($array))</code>.
                  Atomization happens implicitly as part of the function calling rules if the required type is atomic.                  
                  This means, for example, that if the value of <code>$A</code> is <code>array((1,2,3))</code>, 
                  then the attribute value template <code>value="{$A}"</code> creates the attribute 
                  <code>value="1 2 3"</code>. It also means that for all operations that perform atomization
                  (for example, arithmetic, equality comparison, <code>sum()</code>, <code>distinct-values()</code>, etc) 
                  supplying an array is equivalent to supplying its body, and supplying a sequence that 
                  contains nested arrays is equivalent to supplying the "flattened" sequence in which the arrays 
                  are expanded recursively.</p>
               
               <p>The <xfunction>string()</xfunction> function can be applied to an array. The result of 
                  calling <code>string($array)</code> is the same as the result of 
                  <code>string-join(body($array)!string(), ' ')</code>: that is, it returns the 
                  result of applying the <code>string()</code> function to each item in the body 
                  of the array, and concatenating the results with a single space as separator.</p>
               
               <p>The <xfunction>deep-equal()</xfunction> function can be applied to two arrays. 
                  Two arrays are deep equal if their bodies are deep-equal; 
                  an array is not deep-equal to anything other than another array.</p>
            </div3>
            <div3 id="arrays-examples">
               <head>Examples using Arrays</head>
               <p>This section contains examples of problems that can be solved using arrays.</p>
               <example>
                  <head>Using Arrays to represent SVG Polygons</head>
                  <p>In SVG, a polygon is represented by an element of the form:</p>
                  <eg><![CDATA[<polygon points="220,100 300,210 170,250 123,234"/>]]></eg>
                  <p>That is, a quadrilateral is represented as a sequence of four points, each of which is
                     represented by a pair of integers. In XDM this can be represented as a sequence of four
                     items, each of which is an array whose body is a sequence of two integers. The SVG attribute
                     can be converted into this form by the following expression:</p>
                  <eg><![CDATA[for $p in tokenize(@points, '\s+') return array(tokenize($p, ','))]]></eg>
                  <p>This provides a convenient form for performing manipulations such as expanding or rotating the
                  polygon. For example, the area of the polygon can be calculated by the expression:</p>
                  <eg><![CDATA[
abs(sum(
  for $i in 1 to count($points) return
    let $j := ($i mod count($points)) + 1 return
      ($points[$i](1)*$points[$j](2) - $points[$j](1)*$points[$i](2))
   ) div 2)
]]></eg>
               </example>
               <example>
                  <head>Using Arrays to represent Complex Numbers</head>
                  <p>This example constructs the same function library as in the
                     example in <specref ref="map-examples"/>, but this time using
                     arrays in the implementation instead of maps. A complex number
                  is represented as an array whose body is a sequence of two items,
                  the real and imaginary parts of the number.</p>
                  <eg><![CDATA[
<xsl:function name="i:complex" as="array(xs:double)">
  <xsl:param name="real" as="xs:double"/>
  <xsl:param name="imaginary" as="xs:double"/>
  <xsl:sequence select="array(($real, $double))"/>
</xsl:function>

<xsl:function name="i:real" as="xs:double">
  <xsl:param name="complex" as="array(xs:double)"/>
  <xsl:sequence select="$complex(1)"/>
</xsl:function>

<xsl:function name="i:imaginary" as="xs:double">
  <xsl:param name="complex" as="array(xs:double)"/>
  <xsl:sequence select="$complex(2)"/>
</xsl:function>

<xsl:function name="i:add" as="array(xs:double)">
  <xsl:param name="arg1" as="array(xs:double)"/>
  <xsl:param name="arg2" as="array(xs:double)"/>
  <xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), i:imaginary($arg1)+i:imaginary($arg2)"/>
</xsl:function>

<xsl:function name="i:multiply" as="array(xs:double)">
  <xsl:param name="arg1" as="array(xs:double)"/>
  <xsl:param name="arg2" as="array(xs:double)"/>
  <xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/>
</xsl:function>
]]></eg></example>
 
            </div3>            
         </div2>--><!--<div2 id="tuples">
            <head>Tuples</head>
            
            <p>A tuple is a map whose keys are conventionally the consecutive 
               <code>xs:integer</code> values <code>1, 2, 3, 4</code>. </p>
            
            <p>The syntax of <xnt ref="prod-xpath30-SequenceType" spec="XP30">SequenceType</xnt> as defined in XPath is extended as follows:</p>
            <scrap headstyle="show">
               <head>StructType</head>
               <prodgroup>
                  <prod id="NT-SequenceType">
                     <lhs>SequenceType</lhs>
                     <rhs>... | <nt def="NT-StructType">StructType</nt></rhs>
                  </prod>
                  <prod id="NT-StructType">
                     <lhs>StructType</lhs>
                     <rhs>'struct' '(' <xnt ref="prod-xpath30-ItemType" spec="XP30">ItemType</xnt> 
                        ( ',' <xnt ref="prod-xpath30-ItemType" spec="XP30">ItemType</xnt> )* ')'</rhs>
                  </prod>
               </prodgroup>
            </scrap>   
            <p>For example, <code>struct(xs:integer, element())</code> represents a structure consisting of an <code>xs:integer</code>
               and an element node.</p>
            <p>Structured sequence types provide an additional way of describing and constraining values, but they do not introduce any
               new kinds of value or any new operations.</p>
            <p>A sequence <var>S</var> matches the type <emph>struct(T<sub>1</sub>, T<sub>2</sub>, ..., T<sub>n</sub>)</emph> if (a) the
               length of <var>S</var> is exactly <var>n</var>, and (b) for all <var>$i</var> in 1 to <var>n</var>, <var>S[$i]</var>
               matches <emph>T<sub>i</sub></emph>.</p>
            <p>Thus, for example, the sequence <code>(1, 2.0e0, "Paris")</code> matches the sequence type
               <code>struct(xs:integer, xs:double, xs:string)</code>.</p>
            <p>A structured sequence type <rfc2119>may</rfc2119> be used to describe the required type of variables, function or template parameters, or 
               function or template results. In such cases the supplied value <rfc2119>must</rfc2119> match the required type exactly; the function conversion
               rules have no effect. For example, if the required type is <code>struct(xs:double, xs:string)</code>, then supplying the
               expression <code>(12, @status)</code> will cause a type error: the supplied integer will not be promoted to an xs:double, and
               the supplied attribute node will not be atomized to an <code>xs:string</code>. It is of course possible to supply values that
               are instances of a type derived by restriction from the required type: the rule is the same as for an <code>instance of</code>
               test.</p>
            <p>Because the instances that match a structured sequence type are ordinary values (that is, sequences), no special operators or functions
               are provided to manipulate them. Values can be constructed using the comma operator (for example <code>(1, "Paris")</code>), and
               components of the value can be extracted using filter expressions (for example <code>$val[1]</code>). Values can be compared
               using functions such as <xfunction>deep-equal</xfunction>.</p>

         </div2>--><div2 id="json"><head>Processing JSON Data</head><p>JSON is a popular format for exchange of structured data on the web: it is specified in [JSON]. This section describes facilities
            allowing JSON data to be processed using XSLT.</p><div3 id="func-parse-json"><head><?function fn:parse-json?></head></div3><div3 id="func-serialize-json"><head><?function fn:serialize-json?></head></div3><div3 id="json-example"><head>Example: Converting JSON to Custom XML</head><p>The following example shows JSON data being converted to a user-defined XML format.</p><example id="processing-json"><head>Processing JSON Data</head><p>This example shows how XSLT can be used to convert a JSON data file to XML.</p><p>We assume the following input file:</p><eg xml:space="preserve">
{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  
</eg><p>This can be processed as follows:</p><eg xml:space="preserve">
&lt;xsl:template name="main"&gt;
  &lt;xsl:variable name="input" 
                as="map(xs:string, map(xs:string, xs:anyAtomicType)*)"
                select="parse-json(unparsed-text($inputfile))"/&gt;
  &lt;xsl:for-each select="map:keys($input)"&gt;
    &lt;department name="{.}"&gt;
      &lt;xsl:for-each select="$input(.)"&gt;
        &lt;employee&gt;
          &lt;firstName&gt;&lt;xsl:value-of select=".('firstName')"/&gt;&lt;/firstName&gt;
          &lt;lastName&gt;&lt;xsl:value-of select=".('lastName')"/&gt;&lt;/lastName&gt;
          &lt;age&gt;&lt;xsl:value-of select=".('age')"/&gt;&lt;/age&gt;
        &lt;/employee&gt;
      &lt;/xsl:for-each&gt;
    &lt;/department&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
                  </eg></example></div3></div2><!--<div2 id="function-chaining">
            <head>Function Chaining</head>
            <p>A new pseudo-operator <code>-></code> is added to the XPath grammar to allow chaining of function
            calls without deep nesting of parentheses. The expression <code>E -> f(x)</code> is treated as
               an abbreviation for <code>f(E, x)</code>. The expression <code>E -> f(x) -> g(y)</code> is thus equivalent
            to <code>g(f(E,x),y)</code>.</p>
            
            <p>This operator is added in the interests of legibility: it reduces the need for deeply-nested parentheses,
            it means that operations are written left-to-right in the order they are performed, and it mirrors
            the syntactic form of method invocation in many object-oriented languages.</p>
 
            <p>The symbol <code>-></code> (like <code>//</code>) is a pseudo-operator in the sense that it is a syntactic
            shorthand rather than a function applied to its operands. It parses as an operator, binding less tightly than
            unary plus or minus but more tightly than <code>cast as</code>. The expression to the right of the pseudo-operator
            must have the syntactic form of a <code>FunctionCall</code> <code>f(a1, a2, a3, ...)</code> with zero or more arguments,
            none of which is an <code>ArgumentPlaceHolder</code>. Multiple <code>-></code> operators associate left-to-right.</p>
            
            <note><p>If the token that precedes the <code>-></code> operator is a name, the operator must be separated
            from the name by whitespace, to avoid the hyphen being parsed as part of the name.</p></note>
            <p>The following examples illustrate the use of function chaining.</p>
            <table>
               <thead>
                  <tr>
                     <th>Example</th><th>Equivalent</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td><code>$x -> substring-before(':') -> substring-after('#') -> contains(' ')</code></td>
                     <td><code>contains(substring-after(substring-before($x, ':'),'#'), ' ')</code></td>               
                  </tr>
                  <tr>
                     <td><code>//employee -> count()</code></td>
                     <td><code>count(//employee</code>)</td>               
                  </tr>
                  <tr>
                     <td><code>//employee/@salary ! number() -> avg()</code></td>
                     <td><code>avg(//employee/@salary ! number())</code></td>               
                  </tr>
                  <tr>
                     <td><code>$map -> set('a', 1) -> set('b', 2)</code></td>
                     <td><code>set(set($map, 'b', 2), 'a', 1)</code></td>               
                  </tr>
                  <tr>
                     <td><code>$map -> get('employee') -> get('name') -> get('first')</code></td>
                     <td><code>get(get(get($map, 'employee'), 'name'), 'first')</code></td>               
                  </tr>
                  <tr>
                     <td><code>"a"->concat("b")->concat("c")</code></td>
                     <td><code>concat("a", "b", "c")</code></td>               
                  </tr>
                  <tr>
                     <td><code>book/author -> string-join()</code></td>
                     <td><code>string-join(book/author)</code></td>               
                  </tr>
                  <tr>
                     <td><code>//para/(tokenize(., '\s+') -> count()) -> max()</code></td>
                     <td><code>max(//para/count(tokenize(., '\s+')))</code></td>               
                  </tr>
               </tbody>
            </table>   
         </div2>--></div1><div1 id="diagnostics"><head>Diagnostics</head><div2 id="message"><head>Messages</head><e:element-syntax name="message"><e:in-category name="instruction"/><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="terminate"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="error-code"><e:attribute-value-template><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:message</elcode> instruction sends a message in an <termref def="dt-implementation-defined">implementation-defined</termref> way. The
               <elcode>xsl:message</elcode> instruction causes the creation of a new document, which
            is typically serialized and output to an <termref def="dt-implementation-defined">implementation-defined</termref> destination. The result of the
               <elcode>xsl:message</elcode> instruction is an empty sequence.</p><p>The content of the message may be specified by using either or both of the optional
               <code>select</code> attribute and the <termref def="dt-sequence-constructor">sequence
               constructor</termref> that forms the content of the <elcode>xsl:message</elcode>
            instruction.</p><p>If the <elcode>xsl:message</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>, then the sequence
            obtained by evaluating this sequence constructor is used to construct the content of the
            new document node, as described in <specref ref="constructing-complex-content"/>.</p><p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code> attribute,
            then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. The
            effect of the <elcode>xsl:message</elcode> instruction is then the same as if a single
               <elcode>xsl:copy-of</elcode> instruction with this <code>select</code> attribute were
            added to the start of the <termref def="dt-sequence-constructor">sequence
               constructor</termref>.</p><p>If the <elcode>xsl:message</elcode> instruction has no content and no
               <code>select</code> attribute, then an empty message is produced.</p><imp-def-feature>The destination and formatting of messages written using the
               <elcode>xsl:message</elcode> instruction are
            implementation-defined.</imp-def-feature><p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically a
               <termref def="dt-final-result-tree">final result tree</termref>. The tree has no URI
            and processors are not <rfc2119>required</rfc2119> to make the tree accessible to
            applications.</p><note><p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
               consist of a document node owning a single text node. However, it may contain a more
               complex structure.</p></note><note><p>An implementation might implement <elcode>xsl:message</elcode> by popping up an alert
               box or by writing to a log file. Because the order of execution of instructions is
               implementation-defined, the order in which such messages appear is not
               predictable.</p></note><p>The <code>terminate</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p><p>If the <termref def="dt-effective-value">effective value</termref> of the
               <code>terminate</code> attribute is <code>yes</code>, then the <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119>
            <phrase diff="chg" at="B">signal a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref></phrase> after sending the message.
               <phrase diff="add" at="B">This error may be caught in the same way as any other
               dynamic error using <elcode>xsl:catch</elcode>.</phrase> The default value is
               <code>no</code>. Note that because the order of evaluation of instructions is
               <termref def="dt-implementation-dependent">implementation-dependent</termref>, this
            gives no guarantee that any particular instruction will or will not be evaluated before
            processing terminates.</p><p>The optional <code>error-code</code> attribute may be used to indicate the error code
            associated with the message. This may be used irrespective of the value of
            <code>terminate</code>. The error code is an 
            <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>. If no error code
            is specified, or if the value is not a valid EQName, the error code will have local part
               <code>XTMM9000</code> and namespace URI
               <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
               <rfc2119>should</rfc2119> be in a namespace other than
               <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
               <code>terminate</code> is <code>yes</code>, the error code may be matched in an
               <elcode>xsl:catch</elcode> element to catch the error and cause processing to
            continue normally.</p><p>
            <error spec="XT" type="dynamic" class="MM" code="9000"><p>When a transformation is terminated by use of <code>xsl:message
                     terminate="yes"</code>, the effect is the same as when a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> occurs
                  during the transformation. <phrase diff="add" at="B">The default error code is
                        <code>XTMM9000</code>; this may be overridden using the
                        <code>error-code</code> attribute of the <elcode>xsl:message</elcode>
                     instruction.</phrase></p></error>
         </p><example><head>Localizing Messages</head><p>One convenient way to do localization is to put the localized information (message
               text, etc.) in an XML document, which becomes an additional input file to the
                  <termref def="dt-stylesheet">stylesheet</termref>. For example, suppose messages
               for a language <code>
                  <var>L</var>
               </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
               form:</p><eg xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</eg><p>Then a stylesheet could use the following approach to localize messages:</p><eg xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg></example><!--Text inserted by erratum E20 change 1"--><p>Any <termref def="dt-dynamic-error">dynamic error</termref> that occurs while evaluating
            the <code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and any <termref def="dt-serialization-error">serialization error</termref> that occurs while
            processing the result, is treated as a <termref def="dt-recoverable-error">recoverable
               error</termref> even if the error would not be recoverable under other circumstances.
            The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
               <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p><note><p>An example of such an error is the serialization error that occurs when processing
               the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds that
               free-standing attributes cannot be serialized). Making such errors recoverable means
               that it is implementation-defined whether or not they are signaled to the user and
               whether they cause termination of the transformation. If the processor chooses to
               recover from the error, the content of any resulting message is
               implementation-dependent.</p><p>One possible recovery action is to include a description of the error in the
               generated message text.</p></note><!--End of text inserted by erratum E20--></div2><div2 id="assertions" diff="add" at="L"><head>Assertions</head><p>The <elcode>xsl:assert</elcode> instruction is used to assert that the value of a particular
         expression is true; if the value of the expression is false, and assertions are enabled, then a dynamic
         error occurs.</p><e:element-syntax name="assert"><e:in-category name="instruction"/><e:attribute name="test" required="yes"><e:data-type name="expression"/></e:attribute><e:attribute name="select"><e:data-type name="expression"/></e:attribute><e:attribute name="error-code"><e:attribute-value-template><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>By default, assertions are enabled. Checking of assertions may be disabled in several ways:</p><olist><item><p>As with any other instruction, assertions may be disabled by use of the <code>use-when</code>
            attribute: see <specref ref="conditional-inclusion"/>.</p></item><item><p>An implementation <rfc2119>should</rfc2119> provide an external mechanism to disable assertion
            checking for the stylesheet as a whole (either statically or dynamically). The detail of such
            mechanisms is <termref def="dt-implementation-defined"/>.</p></item><item><p diff="del" at="M">The optional <code>enabled</code> attribute contains an expression which is evaluated
               to determine whether assertion checking is enabled. Checking is disabled if the attribute is present
               and the effective boolean value
               of the expression is false. This mechanism can be used, for example, to enable or disable a group of assertions
               by the setting of a <termref def="dt-stylesheet-parameter"/>.</p></item></olist><imp-def-feature>The detail of any external mechanism allowing a processor to disable checking
            of assertions is implementation-defined.</imp-def-feature><p>If assertion checking is enabled, the instruction is evaluated as follows:</p><olist><item><p>The expression in the <code>test</code> attribute is evaluated. If the effective boolean
            value of the result is <code>true</code>, the assertion succeeds, and no further action is taken.
            If the effective boolean value is false, or if a dynamic error occurs during evaluation of the expression,
            then the assertion fails.</p></item><item><p>If the assertion fails, then the effect of the instruction is governed by the rules for evaluation of an
            <elcode>xsl:message</elcode> instruction with the same <code>select</code> attribute, <code>error-code</code>
            attribute, and contained <termref def="dt-sequence-constructor"/>, and with the value <code>terminate="yes"</code>.
            However, the default error code if the <code>error-code</code> attribute is omitted is <code>XTMM9001</code>
            rather than <code>XTMM9000</code>.</p><note><p>To the extent that the behavior of <elcode>xsl:message</elcode> is 
               <termref def="dt-implementation-defined"/>, this rule does not prevent an implementation treating
            <elcode>xsl:assert</elcode> and <elcode>xsl:message</elcode> differently.</p></note></item></olist><p>
            <error spec="XT" type="dynamic" class="MM" code="9001"><p>When a transformation is terminated by use of <code>xsl:assert</code>, 
                  the effect is the same as when a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> occurs
                  during the transformation. The default error code is
                     <code>XTMM9001</code>; this may be overridden using the
                     <code>error-code</code> attribute of the <elcode>xsl:assert</elcode>
                     instruction.</p></error>
         </p><p>As with any other dynamic error, an error caused by an assertion failing may be trapped using
         <elcode>xsl:try</elcode>: see <specref ref="try-catch"/>.</p><p>The result of the <elcode>xsl:assert</elcode> instruction is an empty sequence.</p><example diff="add" at="M"><head>Using Assertions with Static Parameters</head><p>The following example shows a stylesheet function that checks that the value of its supplied
            argument is in range. The check is performed only if the <termref def="dt-static-parameter"/> <code>$DEBUG</code>
            is set to true.</p><eg xml:space="preserve">
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</eg></example><note><p>Implementations should avoid optimizing <elcode>xsl:assert</elcode> instructions away.
         As a guideline, if the result of a sequence constructor is required by the transformation, the
         implementation should ensure that all <elcode>xsl:assert</elcode> instructions in that sequence
         constructor are evaluated. Conversely, if the result of a sequence constructor is not required
         by the transformation, its <elcode>xsl:assert</elcode> instructions should not be evaluated.</p><p>This recommendation is not intended to prevent optimizations such as lazy evaluation, where
         evaluation of a sequence constructor may finish early, as soon as enough information is available
         to evaluate the containing instruction.</p></note><p>An implementation <rfc2119>may</rfc2119> provide a user option allowing a processor to treat
         assertions as being true without explicit checking. This option <rfc2119>must not</rfc2119> be
         enabled by default. If such an option is in force, the effect of any assertion not being true
         is <termref def="dt-implementation-dependent"/>.</p><note><p>For example, given the assertion <code>&lt;xsl:assert test="count(//title)=1"/&gt;</code>,
         a processor might generate code for the expression <code>&lt;xsl:value-of select="//title"/&gt;</code>
         that stops searching for <code>title</code> elements after finding the first one. In the event that the source document
         contains more than one <code>title</code>, execution of the stylesheet may fail in arbitrary ways, or it may produce
         incorrect output.</p></note></div2></div1><div1 id="extension"><head>Extensibility and Fallback</head><p>XSLT allows two kinds of extension, extension instructions and extension functions.</p><p>
            <termdef id="dt-extension-instruction" term="extension instruction">An <term>extension
                  instruction</term> is an element within a <termref def="dt-sequence-constructor">sequence constructor</termref> that is in a namespace (not the <termref def="dt-xslt-namespace">XSLT namespace</termref>) designated as an extension
               namespace.</termdef>
         </p><p>
            <termdef id="dt-extension-function" term="extension function">An <term>extension
                  function</term> is a function that is available for use within an XPath <termref def="dt-expression">expression</termref>, other than a <termref def="dt-core-function">core function</termref> defined in <bibref ref="xpath-functions-30"/>, an additional function defined in this XSLT
               specification, a constructor function named after an atomic type, or a <termref def="dt-stylesheet-function">stylesheet function</termref> defined using an
                  <elcode>xsl:function</elcode> declaration.</termdef>. </p><p>This specification does not define any mechanism for creating or binding implementations
            of <termref def="dt-extension-instruction">extension instructions</termref> or <termref def="dt-extension-function">extension functions</termref>, and it is not
               <rfc2119>required</rfc2119> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>. Therefore, an XSLT stylesheet that
               <rfc2119>must</rfc2119> be portable between XSLT implementations cannot rely on
            particular extensions being available. XSLT provides mechanisms that allow an XSLT
            stylesheet to determine whether the implementation makes particular extensions
            available, and to specify what happens if those extensions are not available. If an XSLT
            stylesheet is careful to make use of these mechanisms, it is possible for it to take
            advantage of extensions and still retain portability.</p><imp-def-feature>This specification does not define any mechanism for creating or binding
            implementations of <termref def="dt-extension-instruction">extension
               instructions</termref> or <termref def="dt-extension-function">extension
               functions</termref>, and it is not <rfc2119>required</rfc2119> that implementations
            support any such mechanism. Such mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature><div2 id="extension-functions"><head>Extension Functions</head><p>The set of functions that can be called from a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> may include one or more <termref def="dt-extension-function">extension functions</termref>. The <termref def="dt-expanded-qname">expanded QName</termref> of an extension function always
               has a non-null namespace URI.</p><div3 id="func-function-available"><head><?function fn:function-available?></head></div3><div3 id="calling-extension-functions"><head>Calling Extension Functions</head><p>If the function name used in a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> identifies an extension function, then to evaluate the
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt>, the
                  processor will first evaluate each of the arguments in the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt>. If the processor has
                  information about the datatypes expected by the extension function, then it
                     <rfc2119>may</rfc2119> perform any necessary type conversions between the XPath
                  datatypes and those defined by the implementation language. If multiple extension
                  functions are available with the same name, the processor <rfc2119>may</rfc2119>
                  decide which one to invoke based on the number of arguments, the types of the
                  arguments, or any other criteria. The result returned by the implementation is
                  returned as the result of the function call, again after any necessary conversions
                  between the datatypes of the implementation language and those of XPath. The
                  details of such type conversions are outside the scope of this specification.</p><p>
                  <error spec="XT" type="dynamic" class="DE" code="1420"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the arguments supplied to a call on an extension
                        function do not satisfy the rules defined for that particular extension
                        function, or if the extension function reports an error, or if the result of
                        the extension function cannot be converted to an XPath value.</p></error>
               </p><note><p>Implementations may also provide mechanisms allowing extension functions to
                     report recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p></note><p>
                  <error spec="XT" type="dynamic" class="DE" code="1425"><p><phrase diff="chg" at="D">When the containing element is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref>,</phrase> it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> to
                        evaluate an extension function call if no implementation of the extension
                        function is available.</p></error>
               </p><note><p>When <phrase diff="chg" at="D">XSLT 1.0 behavior</phrase> is not enabled, this
                     is a static error
                     <xerrorref spec="XP" class="ST" code="0017"/>.</p></note><note><p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p></note><p>Implementations are not <rfc2119>required</rfc2119> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <termref def="dt-implementation-defined">implementation-defined</termref>. The implementation <rfc2119>may</rfc2119>
                  raise an error, <rfc2119>may</rfc2119> convert the string to a string containing
                  valid characters only, or <rfc2119>may</rfc2119> treat the invalid characters as
                  if they were permitted characters.</p><imp-def-feature>The effect of an extension function returning a string containing
                  characters that are not permitted in XML is implementation-defined.</imp-def-feature><note><p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <termref def="dt-processor">processor</termref> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p></note><p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <termref def="dt-extension-instruction">extension instructions</termref>.</p></div3><div3 id="external-objects"><head>External Objects</head><p>An implementation <rfc2119>may</rfc2119> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic value, a node, <phrase diff="add" at="C">or a function
                     item</phrase>. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p><p>The way in which such objects are represented in the type system is <termref def="dt-implementation-defined">implementation-defined</termref>. They might be
                  represented by a completely new datatype, or they might be mapped to existing
                  datatypes such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p><imp-def-feature>The way in which external objects are represented in the type system
                  is implementation-defined.</imp-def-feature></div3><div3 id="func-type-available"><head><?function fn:type-available?></head></div3></div2><div2 id="extension-instruction"><head>Extension Instructions</head><p>
               <termdef id="dt-extension-namespace" term="extension namespace">The <termref def="dt-extension-instruction">extension instruction</termref> mechanism allows
                  namespaces to be designated as <term>extension namespaces</term>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, then the element is treated as an <termref def="dt-instruction">instruction</termref> rather than as a <termref def="dt-literal-result-element">literal result element</termref>.</termdef> The
               namespace determines the semantics of the instruction.</p><note><p>Since an element that is a child of an <elcode>xsl:stylesheet</elcode> element is
                  not occurring <emph>in a <termref def="dt-sequence-constructor">sequence
                        constructor</termref>
                  </emph>, <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p></note><div3 id="designating-extension-namespace"><head>Designating an Extension Namespace</head><p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <specref ref="standard-attributes"/>). The attribute
                     <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent element is
                     <emph>not</emph> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p><p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p><!-- TODO: should clarify whether "default namespace" here includes the null namespace --><p>
                  <error spec="XT" type="static" class="SE" code="1430"><p>It is a <termref def="dt-static-error">static error</termref> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.</p></error>
               </p><p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p></div3><div3 id="func-element-available"><head><?function fn:element-available?></head></div3><div3 id="fallback"><head>Fallback</head><e:element-syntax name="fallback"><e:in-category name="instruction"/><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The content of an <elcode>xsl:fallback</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, and when
                  performing fallback, the value returned by the <elcode>xsl:fallback</elcode>
                  element is the result of evaluating this sequence constructor.</p><p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element
                  returns an empty sequence: the content of the <elcode>xsl:fallback</elcode>
                  element is ignored.</p><p>There are two situations where a <termref def="dt-processor">processor</termref>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT <phrase diff="chg" at="A">3.0</phrase>, is evaluated within a region of the
                  stylesheet for which <termref def="dt-forwards-compatible-behavior"/> is enabled.</p><note><p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <function>system-property</function> and
                        <function>function-available</function> to decide what capabilities are
                     available.</p></note><p>
                  <error spec="XT" type="dynamic" class="DE" code="1450"><p>When a <termref def="dt-processor">processor</termref> performs fallback for
                        an <termref def="dt-extension-instruction">extension instruction</termref>
                        that is not recognized, if the instruction element has one or more
                           <elcode>xsl:fallback</elcode> children, then the content of each of the
                           <elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be
                        evaluated; it is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                           dynamic error</termref> if it has no <elcode>xsl:fallback</elcode>
                        children.</p></error>
               </p><note><p>This is different from the situation with unrecognized <termref def="dt-xslt-element">XSLT elements</termref>. As explained in <specref ref="forwards"/>, an unrecognized XSLT element appearing within a <termref def="dt-sequence-constructor">sequence constructor</termref> is a static
                     error unless (a) <termref def="dt-forwards-compatible-behavior"/> is enabled, and (b) the instruction
                     has an <elcode>xsl:fallback</elcode> child.</p></note></div3></div2></div1><div1 id="result-trees"><head>Final Result Trees</head><p>The output of a transformation is a set of one or more <termref def="dt-final-result-tree">final result trees</termref>.</p><p>A <termref def="dt-final-result-tree">final result tree</termref> can be created
            explicitly, by evaluating an <elcode>xsl:result-document</elcode> instruction. As
            explained in <specref ref="executing-a-transformation"/>, a final result tree is also
            created implicitly if no <elcode>xsl:result-document</elcode> instruction is evaluated,
            or if the result of evaluating the <termref def="dt-initial-template">initial
               template</termref> is a non-empty sequence. </p><p>The way in which a <termref def="dt-final-result-tree">final result tree</termref> is
            delivered to an application is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><imp-def-feature>The way in which a final result tree is delivered to an application is
            implementation-defined.</imp-def-feature><p>Serialization of <termref def="dt-final-result-tree">final result trees</termref> is
            described further in <specref ref="serialization"/>
         </p><div2 id="creating-result-trees"><head>Creating Final Result Trees</head><e:element-syntax name="result-document"><e:in-category name="instruction"/><e:attribute name="format"><e:attribute-value-template><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:attribute name="href"><e:attribute-value-template><e:data-type name="uri"/></e:attribute-value-template></e:attribute><e:attribute name="validation"><e:constant value="strict"/><e:constant value="lax"/><e:constant value="preserve"/><e:constant value="strip"/></e:attribute><e:attribute name="type"><e:data-type name="eqname"/></e:attribute><e:attribute name="method"><e:attribute-value-template><e:constant value="xml"/><e:constant value="html"/><e:constant value="xhtml"/><e:constant value="text"/><e:data-type name="eqname"/></e:attribute-value-template></e:attribute><e:attribute name="byte-order-mark"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="cdata-section-elements"><e:attribute-value-template><e:data-type name="eqnames"/></e:attribute-value-template></e:attribute><e:attribute name="doctype-public"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="doctype-system"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="encoding"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="escape-uri-attributes"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="include-content-type"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="indent"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="media-type"><e:attribute-value-template><e:data-type name="string"/></e:attribute-value-template></e:attribute><e:attribute name="normalization-form"><e:attribute-value-template><e:constant value="NFC"/><e:constant value="NFD"/><e:constant value="NFKC"/><e:constant value="NFKD"/><e:constant value="fully-normalized"/><e:constant value="none"/><e:data-type name="nmtoken"/></e:attribute-value-template></e:attribute><e:attribute name="omit-xml-declaration"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="standalone"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/><e:constant value="omit"/></e:attribute-value-template></e:attribute><e:attribute name="suppress-indentation"><e:attribute-value-template><e:data-type name="eqnames"/></e:attribute-value-template></e:attribute><e:attribute name="undeclare-prefixes"><e:attribute-value-template><e:constant value="yes"/><e:constant value="no"/></e:attribute-value-template></e:attribute><e:attribute name="use-character-maps"><e:data-type name="eqnames"/></e:attribute><e:attribute name="output-version"><e:attribute-value-template><e:data-type name="nmtoken"/></e:attribute-value-template></e:attribute><e:model name="sequence-constructor"/><e:allowed-parents><e:parent-category name="sequence-constructor"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:result-document</elcode> instruction is used to create a <termref def="dt-final-result-tree">final result tree</termref>. The content of the
                  <elcode>xsl:result-document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the document node of the tree. A document node is created, and the sequence obtained
               by evaluating the sequence constructor is used to construct the content of the
               document, as described in <specref ref="constructing-complex-content"/>. The tree
               rooted at this document node forms the final result tree.</p><p>The <elcode>xsl:result-document</elcode> instruction defines the URI of the result
               tree, and may optionally specify the output format to be used for serializing this
               tree.</p><p>The <termref def="dt-effective-value">effective value</termref> of the
                  <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be a <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>. The value is expanded using the
               namespace declarations in scope for the <elcode>xsl:result-document</elcode> element.
               The resulting <termref def="dt-expanded-qname">expanded QName</termref>
               <rfc2119>must</rfc2119> match the expanded QName of a named <termref def="dt-output-definition">output definition</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. This identifies the
                  <elcode>xsl:output</elcode> declaration that will control the serialization of the
                  <termref def="dt-final-result-tree">final result tree</termref> (see <specref ref="serialization"/>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <termref def="dt-output-definition">output definition</termref> is used to control
               serialization of the result tree.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="1460"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>format</code> attribute <error.extra>of an
                           <elcode>xsl:result-document</elcode> element</error.extra> is not a valid
                        <termref def="dt-eqname">EQName</termref>, or if it does not
                     match the <termref def="dt-expanded-qname">expanded QName</termref> of an
                        <termref def="dt-output-definition">output definition</termref> in the
                        <termref def="dt-stylesheet">stylesheet</termref>. If the processor is able
                     to detect the error statically (for example, when the <code>format</code>
                     attribute contains no curly brackets), then the processor
                        <rfc2119>may</rfc2119> optionally signal this as a <termref def="dt-static-error">static error</termref>.</p></error>
            </p><note><p>The only way to select the unnamed <termref def="dt-output-definition">output
                     definition</termref> is to omit the <code>format</code> attribute.</p></note><p>The attributes <code>method</code>, <code>byte-order-mark</code>
               <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
                  <code>escape-uri-attributes</code>, <code>indent</code>, <code>media-type</code>,
                  <code>normalization-form</code>, <code>omit-xml-declaration</code>,
                  <code>standalone</code>, <phrase diff="add" at="B"><code>suppress-indentation</code>,</phrase>
               <!-- see bug 6535 -->
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <termref def="dt-output-definition">output definition</termref>.</p><p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <termref def="dt-attribute-value-template">attribute value
                  templates</termref>, so their values may be set dynamically. For any of these
               attributes that is present on the <elcode>xsl:result-document</elcode> instruction,
               the <termref def="dt-effective-value">effective value</termref> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <elcode>xsl:output</elcode> declaration overrides
               another:</p><ulist><item><p>In the case of <code>cdata-section-elements</code>
                     <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition;</p></item><item><p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition;</p></item><item><p>In all other cases, the effective value of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p></item></ulist><note><p diff="chg" at="K">In the case of the attributes <code>method</code>,
                     <code>cdata-section-elements</code>, <phrase diff="add" at="B"><code>suppress-indentation</code></phrase>, and
                     <code>use-character-maps</code>, the <termref def="dt-effective-value">effective value</termref> of the attribute contains a space-separated list of 
                  <termref def="dt-eqname">EQNames</termref>. 
                  If any of these is a <termref def="dt-lexical-qname">lexical QName</termref>
                  with a prefix, the prefix is expanded using the in-scope namespaces for
                  the <code>xsl:result-document</code> element. In the case of
                     <code>cdata-section-elements</code>
                  <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, an
                  unprefixed element name is expanded using the default namespace. In the case
               of the <code>method</code> attribute, if the method is not one of the system-defined
               methods (xml, html, xhtml, text) then the expanded name must have a non-absent namespace.</p></note><p>The <code>output-version</code> attribute on the <elcode>xsl:result-document</elcode>
               instruction overrides the <code>version</code> attribute on
                  <elcode>xsl:output</elcode> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <specref ref="standard-attributes"/>). In all other cases, attributes correspond if they
               have the same name.</p><p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
                  <rfc2119>required</rfc2119> to do so.</p><p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <termref def="dt-effective-value">effective value</termref> of the
               attribute <rfc2119>must</rfc2119> be a <termref def="dt-uri-reference">URI
                  Reference</termref>, which may be absolute or relative. There
                  <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on the form of absolute URI that
               may be used, but the implementation is not <rfc2119>required</rfc2119> to enforce any
               restrictions. Any valid relative URI <phrase diff="add" at="F">reference</phrase> 
               <rfc2119>must</rfc2119> be accepted. Note that
               the zero-length string is a valid relative URI <phrase diff="add" at="F">reference</phrase>.</p><imp-def-feature>There <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on
               the form of absolute URI that may be used in the <code>href</code> attribute of the
                  <elcode>xsl:result-document</elcode> instruction.</imp-def-feature><p>The base URI of the document node at the root of the <termref def="dt-final-result-tree">final result tree</termref> is based on the <termref def="dt-effective-value">effective value</termref> of the <code>href</code>
               attribute. If the <termref def="dt-effective-value">effective value</termref> is a
               relative URI <phrase diff="add" at="F">reference</phrase>, then it is resolved relative to the <termref def="dt-base-output-uri">base output URI</termref>. If the implementation provides an API to access final
               result trees, then it <rfc2119>must</rfc2119> allow a final result tree to be
               identified by means of this base URI.</p><note><p>The base URI of the <termref def="dt-final-result-tree">final result
                     tree</termref> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p></note><note><p>It will often be the case that one <termref def="dt-final-result-tree">final
                     result tree</termref> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI <phrase diff="add" at="F">reference</phrase>. The mechanism of
                  associating a URI with a final result tree has been chosen to allow the integrity
                  of such links to be preserved when the trees are serialized.</p><p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p></note><p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:result-document</elcode> instruction to validate the contents of the
               new document, and to determine the <termref def="dt-annotation">type
                  annotation</termref> that elements and attributes within the <termref def="dt-final-result-tree">final result tree</termref> will carry. The permitted
               values and their semantics are described in <specref ref="validating-document-nodes"/>.</p><p>A <termref def="dt-processor">processor</termref>
               <rfc2119>may</rfc2119> allow a <termref def="dt-final-result-tree">final result
                  tree</termref> to be serialized. Serialization is described in <specref ref="serialization"/>. However, an implementation (for example, a <termref def="dt-processor">processor</termref> running in an environment with no access to
               writable filestore) is not <rfc2119>required</rfc2119> to support the serialization
               of <termref def="dt-final-result-tree">final result trees</termref>. An
               implementation that does not support the serialization of final result trees
                  <rfc2119>may</rfc2119> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <rfc2119>must</rfc2119> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p><p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <termref def="dt-final-result-tree">final result trees</termref> are processed. Such mechanisms
                  <rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the
                  <elcode>xsl:result-document</elcode> and/or <elcode>xsl:output</elcode> elements,
               or they <rfc2119>may</rfc2119> use additional elements or attributes in an <termref def="dt-implementation-defined">implementation-defined</termref> namespace.</p><imp-def-feature>Implementations <rfc2119>may</rfc2119> provide additional mechanisms
               allowing users to define the way in which <termref def="dt-final-result-tree">final
                  result trees</termref> are processed.</imp-def-feature><example><head>Multiple Result Documents</head><p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p><eg xml:space="preserve">&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg></example><p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <elcode>xsl:result-document</elcode> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p><p>
               <termdef id="dt-output-state" term="output state">Each instruction in the <termref def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible
                     <term>output states</term>: <termref def="dt-final-output-state">final output
                     state</termref> or <termref def="dt-temporary-output-state">temporary output
                     state</termref>
               </termdef>.</p><p>
               <termdef id="dt-final-output-state" term="final output state">The first of the two
                     <termref def="dt-output-state">output states</termref> is called <term>final
                     output</term> state. This state applies when instructions are writing to a
                     <termref def="dt-final-result-tree">final result tree</termref>.</termdef>
            </p><p>
               <termdef id="dt-temporary-output-state" term="temporary output state">The second of
                  the two <termref def="dt-output-state">output states</termref> is called
                     <term>temporary output</term> state. This state applies when instructions are
                  writing to a <termref def="dt-temporary-tree">temporary tree</termref> or any
                  other non-final destination.</termdef>
            </p><p>The instructions in the <termref def="dt-initial-template">initial template</termref>
               are evaluated in <termref def="dt-final-output-state">final output state</termref>.
               An instruction is evaluated in the same <termref def="dt-output-state">output
                  state</termref> as its calling instruction, except that
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
                  <elcode>xsl:with-param</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:comment</elcode>, <elcode>xsl:processing-instruction</elcode>,
                  <elcode>xsl:namespace</elcode>, <elcode>xsl:value-of</elcode>,
                  <elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>,
               <elcode>xsl:sort</elcode>, <elcode>xsl:message</elcode>, <phrase diff="add" at="L">and <elcode>xsl:assert</elcode></phrase> always evaluate the
               instructions in their contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref> in <termref def="dt-temporary-output-state">temporary output
                  state</termref>.</p><p>
               <error spec="XT" type="dynamic" class="DE" code="1480"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> to evaluate the <elcode>xsl:result-document</elcode>
                     instruction in <termref def="dt-temporary-output-state">temporary output
                        state</termref>.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="DE" code="1490"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> for a transformation to generate two or more <termref def="dt-final-result-tree">final result trees</termref> with the same
                     URI.</p></error>
            </p><note><p>Note, this means that it is an error to evaluate more than one
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute if an initial <termref def="dt-final-result-tree">final result tree</termref> is created implicitly.</p></note><p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
               instruction is an empty sequence. This means it does not contribute any nodes to the
               result of the sequence constructor it is part of.</p><p>
               <error spec="XT" type="dynamic" class="RE" code="1495"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     for a transformation to generate two or more <termref def="dt-final-result-tree">final result trees</termref> with URIs that
                     identify the same physical resource. The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
                        <termref def="dt-implementation-dependent">implementation-dependent</termref>, since it may be impossible for the
                     processor to detect the error.</p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="RE" code="1500"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     for a <termref def="dt-stylesheet">stylesheet</termref> to write to an external
                     resource and read from the same resource during a single transformation,
                     whether or not the same URI is used to access the resource in both cases.
                        <error.action>The <termref def="dt-optional-recovery-action">optional
                           recovery action</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>: implementations are not
                           <rfc2119>required</rfc2119> to detect the error condition. Note that if
                        the error is not detected, it is 
                           <termref def="dt-implementation-dependent"/> 
                           whether the document that is read
                        from the resource reflects its state before or after the result tree is
                        written.</error.action>
                  </p></error>
            </p></div2><div2 id="validation"><head>Validation</head><p>It is possible to control the <termref def="dt-annotation">type annotation</termref>
               applied to individual element and attribute nodes as they are constructed. This is
               done using the <code>type</code> and <code>validation</code> attributes of the
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <termref def="dt-literal-result-element">literal result element</termref>.</p><p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p><p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <rfc2119>must</rfc2119> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <code>default-validation</code> attribute of the containing
                  <elcode>xsl:stylesheet</elcode> element; if this is not specified, the effect is
               the same as specifying <code>validation="strip"</code>.</p><p>
               <error spec="XT" type="static" class="SE" code="1505"><p>It is a <termref def="dt-static-error">static error</termref> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                        <elcode>xsl:document</elcode>, or <elcode>xsl:result-document</elcode>
                     instructions, or on a <termref def="dt-literal-result-element">literal result
                        element</termref>.</p></error>
            </p><p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <specref ref="validating-constructed-nodes"/>, while those for document nodes are given in
                  <specref ref="validating-document-nodes"/>.</p><div3 id="validating-constructed-nodes"><head>Validating Constructed Elements and Attributes</head><div4 id="validating-using-validation-attribute"><head>Validation using the <code>[xsl:]validation</code> Attribute</head><p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <termref def="dt-annotation">type
                        annotation</termref> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p><p>In the paragraphs below, the term <emph>contained nodes</emph> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p><ulist><item><p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <termref def="dt-annotation">type
                              annotation</termref>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p></item><item><p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <termref def="dt-annotation">type annotations</termref>, but
                           nodes whose content is newly constructed will be annotated as
                              <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p><ulist><item><p>In the case of <elcode>xsl:element</elcode> and literal result
                                 elements, the new element has a <termref def="dt-annotation">type
                                    annotation</termref> of <code>xs:anyType</code>, and the type
                                 annotations of contained nodes are retained unchanged.</p></item><item><p>In the case of <elcode>xsl:attribute</elcode>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p></item><item><p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are
                                 copied will retain their type annotations unchanged.</p></item><item><p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the
                                 kind of node being copied.</p><olist><item><p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <termref def="dt-annotation">type
                                          annotation</termref>.</p></item><item><p>Where the node being copied is an element, the copied element
                                       will have a <termref def="dt-annotation">type
                                          annotation</termref> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <elcode>xsl:element</elcode>.</p></item></olist></item></ulist></item><item><p>The value <code>strict</code> indicates that <termref def="dt-annotation">type annotations</termref> are established by performing strict
                           schema validity assessment on the element or attribute node created by
                           this instruction as follows:</p><ulist><item><p>In the case of an element, a top-level element declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the element, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.3.4 <quote>Element Declaration Validation Rules</quote>,
                                 validation rule <quote>Schema-Validity Assessment
                                 (Element)</quote>, clauses 1.1 and 2, using the top-level element
                                 declaration as the "declaration stipulated by the processor", which
                                 is mentioned in clause 1.1.1.1). The element is considered valid if
                                 the result of the schema validity assessment is a PSVI in which the
                                 relevant element node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If there is no matching element
                                 declaration, or if the element is not considered valid, the
                                 transformation fails <errorref class="TE" code="1510"/>, <errorref class="TE" code="1512"/>. In effect this means that the element
                                 being validated <rfc2119>must</rfc2119> be declared using a
                                 top-level declaration in the schema, and <rfc2119>must</rfc2119>
                                 conform to its declaration. The process of validation applies
                                 recursively to contained elements and attributes to the extent
                                 required by the schema definition.</p><note><p>It is not an error if the identified type definition is a simple
                                    type, although <bibref ref="xmlschema-1"/> does not define
                                    explicitly that this case is permitted.</p></note></item><item><p>In the case of an attribute, a top-level attribute declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the attribute, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.2.4 <quote>Attribute Declaration Validation
                                    Rules</quote>, validation rule <quote>Schema-Validity Assessment
                                    (Attribute)</quote>). The attribute is considered valid if the
                                 result of the schema validity assessment is a PSVI in which the
                                 relevant attribute node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If the attribute is not considered
                                 valid, the transformation fails <errorref class="TE" code="1510"/>.
                                 In effect this means that the attribute being validated
                                    <rfc2119>must</rfc2119> be declared using a top-level
                                 declaration in the schema, and <rfc2119>must</rfc2119> conform to
                                 its declaration.</p></item><item><p>The schema components used to validate an element or attribute may
                                 be located in any way described by <bibref ref="xmlschema-1"/> (see
                                 section 4.3.2, <emph>How schema documents are located on the
                                    Web</emph>). The components in the schema constructed from the
                                 synthetic schema document (see <specref ref="import-schema"/>) will
                                 always be available for validating constructed nodes; if additional
                                 schema components are needed, they <rfc2119>may</rfc2119> be
                                 located in other ways, for example implicitly from knowledge of the
                                 namespace in which the elements and attributes appear, or using the
                                    <code>xsi:schemaLocation</code> attribute of elements within the
                                 tree being validated.</p></item><item><p>If no validation is performed for a node, which can happen when the
                                 schema specifies <code>lax</code> or <code>skip</code> validation
                                 for that node or for a subtree, then the node is annotated as
                                    <code>xs:anyType</code> in the case of an element, and
                                    <code>xs:untypedAtomic</code> in the case of an attribute.</p></item></ulist></item><item><p>The value <code>lax</code> has the same effect as the value
                              <code>strict</code>, except that whereas <code>strict</code>
                           validation fails if there is no matching top-level element declaration or
                           if the outcome of validity assessment is a <code>validity</code> property
                           of <code>invalid</code> or <code>notKnown</code>, <code>lax</code>
                           validation fails only if the outcome of validity assessment is a
                              <code>validity</code> property of <code>invalid</code>. That is,
                              <code>lax</code> validation does not cause a <termref def="dt-type-error">type error</termref> when the
                           outcome is <code>notKnown</code>.</p><p>In practice this means that the element or attribute being validated
                              <rfc2119>must</rfc2119> conform to its declaration if a top-level
                           declaration is available. If no such declaration is available, then the
                           element or attribute is not validated, but its attributes and children
                           are validated, again with lax validation. Any nodes whose validation
                           outcome is a <code>validity</code> property of <code>notKnown</code> are
                           annotated as <code>xs:anyType</code> in the case of an element, and
                              <code>xs:untypedAtomic</code> in the case of an attribute.</p><note><p>When the parent element lacks a declaration, the XML Schema
                              specification defines the recursive checking of children and
                              attributes as optional. For this specification, this recursive
                              checking is required.</p></note><note><p>If an element that is being validated has an <code>xsi:type</code>
                              attribute, then the value of the <code>xsi:type</code> attribute will
                              be taken into account when performing the validation. However, the
                              presence of an <code>xsi:type</code> attribute will not of itself
                              cause an element to be validated: if validation against a named type
                              is required, as distinct from validation against a top-level element
                              declaration, then it must be requested using the XSLT
                                 <code>[xsl:]type</code> attribute on the instruction that invokes
                              the validation, as described in section <specref ref="validation-xsl-type"/>
                           </p></note></item></ulist><p>
                     <error spec="XT" type="type" class="TE" code="1510"><p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and schema validity assessment
                           concludes that the validity of the element or attribute is invalid or
                           unknown, a <termref def="dt-type-error">type error</termref> occurs. As with other type errors, the error
                              <rfc2119>may</rfc2119> be signaled statically if it can be detected
                           statically. </p></error>
                  </p><p>
                     <error spec="XT" type="type" class="TE" code="1512"><p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and there is no matching
                           top-level declaration in the schema, then a <termref def="dt-type-error">type error</termref> occurs. As with
                           other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p></error>
                  </p><p>
                     <error spec="XT" type="type" class="TE" code="1515"><p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>lax</code>, and schema validity assessment
                           concludes that the element or attribute is invalid, a <termref def="dt-type-error">type error</termref> occurs.
                           As with other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p></error>
                  </p><note><p>No mechanism is provided to validate an element or attribute against a local
                        declaration in a schema. Such validation can usually be achieved by applying
                        validation to a containing element for which a top-level element declaration
                        exists.</p></note></div4><div4 id="validation-xsl-type"><head>Validation using the <code>[xsl:]type</code> Attribute</head><p>The <code>[xsl:]type</code> attribute takes as its value a <code>QName</code>.
                     This <rfc2119>must</rfc2119> be the name of a type definition included in the
                        <termref def="dt-in-scope-schema-component">in-scope schema
                        components</termref> for the stylesheet. If the QName has no prefix, it is
                     expanded using the default namespace established using the effective
                        <code>[xsl:]xpath-default-namespace</code> attribute if there is one;
                     otherwise, it is taken as being a name in no namespace.</p><p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute.</p><ulist><item><p>In the case of an element, schema-validity assessment is carried out
                           according to the rules defined in <bibref ref="xmlschema-1"/> (section
                           3.3.4 <quote>Element Declaration Validation Rules</quote>, validation
                           rule <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and
                           2), using this type definition as the <quote>processor-stipulated type
                              definition</quote>. The element is considered valid if the result of
                           the schema validity assessment is a PSVI in which the relevant element
                           node has a <code>validity</code> property whose value is
                              <code>valid</code>. </p></item><item><p>In the case of an attribute, the attribute is considered valid if (in the
                           terminology of XML Schema) the attribute's normalized value is locally
                           valid with respect to that type definition according to the rules for
                              <quote>String Valid</quote> (<bibref ref="xmlschema-1"/>, section
                           3.14.4). (Normalization here refers to the process of normalizing
                           whitespace according to the rules of the <code>whiteSpace</code> facet
                           for the datatype).</p></item><item><p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <errorref class="TE" code="1540"/>.</p></item></ulist><p>
                     <error spec="XT" type="static" class="SE" code="1520"><p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                              <elcode>xsl:document</elcode>, or <elcode>xsl:result-document</elcode>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in an in-scope namespace declaration, or if the QName is
                           not the name of a type definition included in the <termref def="dt-in-scope-schema-component">in-scope schema
                              components</termref> for the stylesheet.</p></error>
                  </p><p>
                     <error spec="XT" type="static" class="SE" code="1530"><p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:attribute</elcode> instruction refers to a complex type
                           definition</p></error>.</p><p diff="add" at="I">
                     <!-- see spec bug 13001 -->
                     <error spec="XT" type="type" class="TE" code="1535"><p>It is a <termref def="dt-type-error">type error</termref> if the
                           value of the <code>type</code> attribute of an
                           <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction 
                           refers to a complex type definition and one or more of the items being copied
                           is an attribute node.</p></error>.</p><p>
                     <error spec="XT" type="type" class="TE" code="1540"><p>It is a <termref def="dt-type-error">type error</termref> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.</p></error>
                  </p><note><p>Like other type errors, this error may be signaled statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being signaled. If the error is not signaled
                        statically, it will be signaled when the instruction is evaluated.</p></note></div4><div4 id="validation-process"><head>The Validation Process</head><p>As well as checking for validity against the schema, the validity assessment
                     process causes <termref def="dt-annotation">type annotations</termref> to be
                     associated with element and attribute nodes. If default values for elements or
                     attributes are defined in the schema, the validation process will where
                     necessary create new nodes containing these default values.</p><p>Validation of an element or attribute node only takes into account constraints
                     on the content of the element or attribute. Validation rules affecting the
                     document as a whole are not applied. Specifically, this means:</p><ulist><item><p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                           not applied. This means that validation will not fail if there are
                           non-unique ID values or dangling IDREF values in the subtree being
                           validated.</p></item><item><!--Text replaced by erratum E12 change 1"--><p>The validation rule <quote>Validation Rule: Identity-constraint
                              Satisfied</quote>
                           <rfc2119>should</rfc2119> be applied.</p><!--End of text replaced by erratum E12--></item><item><p>There is no check that the document contains unparsed entities whose
                           names match the values of nodes of type <code>xs:ENTITY</code> or
                              <code>xs:ENTITIES</code>. (XSLT <phrase diff="chg" at="A">3.0</phrase>
                           provides no facility to construct unparsed entities within a tree.)</p></item><item><p>There is no check that the document contains notations whose names match
                           the values of nodes of type <code>xs:NOTATION</code>. (The XDM data model
                           makes no provision for notations to be represented in the tree.)</p></item></ulist><p>With these caveats, validating a newly constructed element, using strict or lax
                     validation, is equivalent to the following steps:</p><olist><item><p>The element is serialized to textual XML form, according to the rules
                           defined in <bibref ref="xslt-xquery-serialization-30"/> using the XML output
                           method, with all parameters defaulted. Note that this process discards
                           any existing <termref def="dt-annotation">type annotations</termref>.</p></item><item><p>The resulting XML document is parsed to create an XML Information Set
                           (see <bibref ref="xml-infoset"/>.)</p></item><item><p>The Information Set produced in the previous step is validated according
                           to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
                           Post-Schema Validation Infoset (PSVI). If the validation process is not
                           successful (as defined above), a <termref def="dt-type-error">type error</termref> is raised.</p></item><item><p>The PSVI produced in the previous step is converted back into the XDM
                           data model by the mapping described in <bibref ref="xpath-datamodel-30"/>
                              (<xspecref spec="DM30" ref="PSVI2Types"/>). This process creates nodes
                           with simple or complex <termref def="dt-annotation">type
                              annotations</termref> based on the types established during schema
                           validation.</p></item></olist><p>Validating an attribute using strict or lax validation requires a modified
                     version of this procedure. A copy of the attribute is first added to an element
                     node that is created for the purpose, and namespace fixup (see <specref ref="namespace-fixup"/>) is performed on this element node. The name of this
                     element is of no consequence, but it must be the same as the name of a
                     synthesized element declaration of the form:</p><eg xml:space="preserve">&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</eg><p>where A is the name of the attribute being validated.</p><p>This synthetic element is then validated using the procedure given above for
                     validating elements, and if it is found to be valid, a copy of the validated
                     attribute is made, retaining its <termref def="dt-annotation">type
                        annotation</termref>, but detaching it from the containing element (and
                     thus, from any namespace nodes).</p><p>The XDM data model does not permit an attribute node with no parent to have a
                     typed value that includes a namespace-qualified name, that is, a value whose
                     type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This
                     restriction is imposed because these types rely on the namespace nodes of a
                     containing element to resolve namespace prefixes. Therefore, it is an error to
                     validate a parentless attribute against such a type. This affects the
                     instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode>.</p><p>
                     <error spec="XT" type="type" class="TE" code="1545"><p>A <termref def="dt-type-error">type error</termref> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p></error>
                  </p></div4></div3><div3 id="validating-document-nodes"><head>Validating Document Nodes</head><p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the instructions
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,
                     <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode>, and this
                  instruction has a <code>type</code> attribute, or a <code>validation</code>
                  attribute with the value <code>strict</code> or <code>lax</code>.</p><p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <elcode>xsl:document</elcode>: nodes within such trees retain their <termref def="dt-annotation">type annotation</termref>. Similarly, validation is not
                  applied to document nodes created using <elcode>xsl:message</elcode> 
                  <phrase diff="add" at="L">or <elcode>xsl:assert</elcode></phrase>. </p><p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <termref def="dt-annotation">type annotations</termref>. In the second case, elements
                  within the tree have their type annotation set to <code>xs:untyped</code>, while
                  attributes have their type annotation set to <code>xs:untypedAtomic</code>.</p><p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p><ulist><item><p>
                        <error spec="XT" type="type" class="TE" code="1550"><p>A <termref def="dt-type-error">type error</termref> occurs
                                 <error.extra>when a document node is validated</error.extra> unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.</p></error>
                     </p></item><item><p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <specref ref="validating-constructed-nodes"/>.</p><note><p>The <code>type</code> attribute on <elcode>xsl:document</elcode> and
                              <elcode>xsl:result-document</elcode>, and on <elcode>xsl:copy</elcode>
                           and <elcode>xsl:copy-of</elcode> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p></note></item><item><p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p></item><item><p>Identity constraints, as defined in section 3.11 of <bibref ref="xmlschema-1"/>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p></item><item><p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           <phrase diff="chg" at="A">3.0</phrase> to create unparsed entities in a
                           <termref def="dt-result-tree">result tree</termref>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p></item><item><p>There is no check that the document contains notations whose names match the
                        values of nodes of type <code>xs:NOTATION</code>. This is because notations
                        are not part of the XDM data model. It is possible to add notations to the
                        result document by referencing a suitable DOCTYPE during serialization.</p></item><item><p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p></item></ulist><p>
                  <error spec="XT" type="type" class="TE" code="1555"><p>It is a <termref def="dt-type-error">type error</termref> if, when
                        validating a document node, document-level constraints are not satisfied.
                        These constraints include identity constraints (<code>xs:unique</code>,
                           <code>xs:key</code>, and <code>xs:keyref</code>) and ID/IDREF
                        constraints.</p></error>
               </p></div3></div2></div1><div1 id="serialization"><head>Serialization</head><p>A <termref def="dt-processor">processor</termref>
            <rfc2119>may</rfc2119> output a <termref def="dt-final-result-tree">final result
               tree</termref> as a sequence of octets, although it is not
               <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>).
            Stylesheet authors can use <elcode>xsl:output</elcode> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <rfc2119>must</rfc2119> do so as specified by these declarations.</p><p>The rules governing the output of the serializer are defined in <bibref ref="xslt-xquery-serialization-30"/>. The serialization is controlled using a number of
            serialization parameters. The values of these serialization parameters may be set within
            the <termref def="dt-stylesheet">stylesheet</termref>, using the
               <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
               <elcode>xsl:character-map</elcode> declarations.</p><e:element-syntax name="output"><e:in-category name="declaration"/><e:attribute name="name"><e:data-type name="eqname"/></e:attribute><e:attribute name="method"><e:constant value="xml"/><e:constant value="html"/><e:constant value="xhtml"/><e:constant value="text"/><e:data-type name="eqname"/></e:attribute><e:attribute name="byte-order-mark"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="cdata-section-elements"><e:data-type name="eqnames"/></e:attribute><e:attribute name="doctype-public"><e:data-type name="string"/></e:attribute><e:attribute name="doctype-system"><e:data-type name="string"/></e:attribute><e:attribute name="encoding"><e:data-type name="string"/></e:attribute><e:attribute name="escape-uri-attributes"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="include-content-type"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="indent"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="media-type"><e:data-type name="string"/></e:attribute><e:attribute name="normalization-form"><e:constant value="NFC"/><e:constant value="NFD"/><e:constant value="NFKC"/><e:constant value="NFKD"/><e:constant value="fully-normalized"/><e:constant value="none"/><e:data-type name="nmtoken"/></e:attribute><e:attribute name="omit-xml-declaration"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="standalone"><e:constant value="yes"/><e:constant value="no"/><e:constant value="omit"/></e:attribute><e:attribute name="suppress-indentation"><!--see bug 6535--><e:data-type name="eqnames"/></e:attribute><e:attribute name="undeclare-prefixes"><e:constant value="yes"/><e:constant value="no"/></e:attribute><e:attribute name="use-character-maps"><e:data-type name="eqnames"/></e:attribute><e:attribute name="version"><e:data-type name="nmtoken"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:output</elcode> declaration is optional; if used, it
               <rfc2119>must</rfc2119> always appear as a <termref def="dt-top-level">top-level</termref> element within a stylesheet module.</p><p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
               <elcode>xsl:output</elcode> declarations and may include or import stylesheet modules
            that also contain <elcode>xsl:output</elcode> declarations. The name of an
               <elcode>xsl:output</elcode> declaration is the value of its <code>name</code>
            attribute, if any.</p><p>
            <termdef id="dt-output-definition" term="output definition">All the
                  <elcode>xsl:output</elcode> declarations 
               <phrase diff="chg" at="I">within a <termref def="dt-package">package</termref></phrase> that share the same name
               are grouped into a named <term>output definition</term>; those that have no name are
               grouped into a single unnamed output definition.</termdef>
         </p><p diff="add" at="I">An output definition is scoped to a package. If this is a library package
         the output definition applies only to <elcode>xsl:result-document</elcode> instructions within
            the same package. If it is the top-level package, the output definition applies to <elcode>xsl:result-document</elcode> instructions within
            the same package and also to the implicit <termref def="dt-final-result-tree">final result tree</termref>.</p><p>A stylesheet always includes an unnamed <termref def="dt-output-definition">output
               definition</termref>; in the absence of an unnamed <elcode>xsl:output</elcode>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <elcode>xsl:output</elcode> declaration having no
            attributes.</p><p>A named <termref def="dt-output-definition">output definition</termref> is used when its
            name matches the <code>format</code> attribute used in an
               <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
            when an <elcode>xsl:result-document</elcode> element omits the <code>format</code>
            attribute. It is also used when serializing the <termref def="dt-final-result-tree">final result tree</termref> that is created implicitly in the absence of an
               <elcode>xsl:result-document</elcode> element.</p><p>All the <elcode>xsl:output</elcode> elements making up an <termref def="dt-output-definition">output definition</termref> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
               <termref def="dt-expanded-qname">expanded QNames</termref>. For the
               <code>cdata-section-elements</code>
            <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase> attributes, the
            output definition uses the union of the values from all the constituent
               <elcode>xsl:output</elcode> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <termref def="dt-expanded-qname">expanded QNames</termref> values from all the constituent
               <elcode>xsl:output</elcode> declarations, taking them in order of increasing <termref def="dt-import-precedence">import precedence</termref>, or where several have the
            same import precedence, in <termref def="dt-declaration-order">declaration
               order</termref>. For other attributes, the <termref def="dt-output-definition">output
               definition</termref> uses the value of that attribute from the
               <elcode>xsl:output</elcode> declaration with the highest <termref def="dt-import-precedence">import precedence</termref>.</p><p>
            <error spec="XT" type="static" class="SE" code="1560"><p>It is a <termref def="dt-static-error">static error</termref> if two
                     <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code> and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <elcode>xsl:output</elcode> declaration within the
                  same <termref def="dt-output-definition">output definition</termref> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p></error>
         </p><p>If none of the <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p><p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
               <rfc2119>required</rfc2119> to do so.</p><p>An implementation <rfc2119>may</rfc2119> allow the attributes of the
               <elcode>xsl:output</elcode> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p><p>The location to which <termref def="dt-final-result-tree">final result trees</termref>
            are serialized (whether in filestore or elsewhere) is <termref def="dt-implementation-defined">implementation-defined</termref> (which in practice
               <rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined
            API). However, these locations <rfc2119>must</rfc2119> satisfy the constraint that when
            two <termref def="dt-final-result-tree">final result trees</termref> are both created
            (implicitly or explicitly) using relative URI <phrase diff="add" at="F">references</phrase>
            in the <code>href</code> attribute of the
            <elcode>xsl:result-document</elcode> instruction, then these relative URI 
            <phrase diff="add" at="F">references</phrase> may be
            used to construct references from one tree to the other, and such references
               <rfc2119>must</rfc2119> remain valid when both result trees are serialized. </p><imp-def-feature>If serialization is supported, then the location to which a <termref def="dt-final-result-tree">final result tree</termref> is serialized is
            implementation-defined, subject to the constraint that relative URI <phrase diff="add" at="F">references</phrase> used to reference
            one tree from another remain valid.</imp-def-feature><p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element identifies
            the overall method that is to be used for outputting the <termref def="dt-final-result-tree">final result tree</termref>.</p><p diff="chg" at="K">
            <error spec="XT" type="static" class="SE" code="1570"><p>The value <error.extra>of the <code>method</code> attribute on
                        <elcode>xsl:output</elcode>
                  </error.extra>
                  <rfc2119>must</rfc2119> (if present) be a valid <termref def="dt-eqname">EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical QName</termref> with no
                  a prefix, then it identifies a method specified in <bibref ref="xslt-xquery-serialization-30"/> and <rfc2119>must</rfc2119> be one of
                     <code>xml</code>, <code>html</code>, <code>xhtml</code>, or
                  <code>text</code>.</p></error> If it is a <termref def="dt-lexical-qname">lexical QName</termref> with a prefix, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded QName</termref> as described in <specref ref="qname"/>; the <termref def="dt-expanded-qname">expanded QName</termref> identifies the output method; the
            behavior in this case is not specified by this document.</p><p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <termref def="dt-final-result-tree">final result tree</termref> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p><ulist><item><p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, if the <code>version</code> attribute of the
                     <elcode>xsl:stylesheet</elcode> element of the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref> has
                  the value <code>1.0</code>, and if the result tree is generated implicitly (rather
                  than by an explicit <elcode>xsl:result-document</elcode> instruction), then the
                  default output method in this situation is <code>xml</code>.</p></item><item><p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p></item></ulist><p>In all other cases, the default output method is <code>xml</code>.</p><p>The default output method is used if the selected <termref def="dt-output-definition">output definition</termref> does not include a <code>method</code> attribute.</p><p>The other attributes on <elcode>xsl:output</elcode> provide parameters for the output
            method. The following attributes are allowed:</p><ulist><item><p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <termref def="dt-implementation-defined"/>, but
                  in the case of the <code>xml</code> and <code>xhtml</code> methods it
                     <rfc2119>must</rfc2119> be either <code>UTF-8</code> or <code>UTF-16</code>. </p><imp-def-feature>The default value of the <code>encoding</code> attribute of the
                     <elcode>xsl:output</elcode> element is
                  implementation-defined.</imp-def-feature></item><item><p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <termref def="dt-implementation-defined"/>, and
                  for all other encodings it is <code>no</code>. The value of the byte order mark
                  indicates whether high order bytes are written before or after low order bytes;
                  the actual byte order used is <termref def="dt-implementation-dependent">implementation-dependent</termref>, unless it is defined by the selected
                  encoding. </p></item><item><p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p><note><p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p></note></item><item><p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. By default,
                  the parameter is not supplied. </p></item><item><p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. By default,
                  the parameter is not supplied. </p><!--Text inserted by erratum E3 change 1"--><p>The value of <code>doctype-public</code> must conform to the rules for a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PubidLiteral" xlink:type="simple">PubidLiteral</xnt> (see <bibref ref="REC-xml"/>).</p><!--End of text inserted by erratum E3--></item><item><p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p></item><item><p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p></item><item><p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of the <code>xml</code> output method.
               </p></item><item><p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. </p></item><item><p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p></item><item><p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p></item><item><p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p></item><item diff="add" at="A"><p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p><note><p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p></note></item><item><p>The <code>undeclare-prefixes</code> attribute is relevant only when producing
                  output with <code>method="xml"</code> and <code>version="1.1"</code> (or later).
                  It defines whether namespace undeclarations (of the form
                  <code>xmlns:foo=""</code>) <rfc2119>should</rfc2119> be output when a child
                  element has no namespace node with the same name (that is, namespace prefix) as a
                  namespace node of its parent element. The default value is <code>no</code>: this
                  means that namespace undeclarations are not output, which has the effect that when
                  the resulting XML is reparsed, the new tree may contain namespace nodes on the
                  child element that were not there in the original tree before serialization.</p></item><item><p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <termref def="dt-output-definition">output definition</termref>. The way this attribute is used is described in
                     <specref ref="character-maps"/>. The default value is an empty list.</p></item><item><p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation.
                  <!--The default value depends on the output method: it is <code>1.0</code> for <code>xml</code>,
						<code>4.01</code> for <code>html</code>, and <code>1.0</code> for <code>xhtml</code>. The 
						parameter is not used by the text output method.-->
               </p></item></ulist><imp-def-feature>It is implementation-defined which versions of XML, HTML, and XHTML are
            supported in the <code>version</code> attribute of the <elcode>xsl:output</elcode>
            declaration.</imp-def-feature><imp-def-feature>The default value of the <code>byte-order-mark</code> serialization
            parameter is implementation-defined in the case of UTF-8 encoding.</imp-def-feature><p>If the processor performs serialization, then it must signal any non-recoverable
            serialization errors that occur. These have the same effect as <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic errors</termref>: that is, the
            processor must signal the error and must not finish as if the transformation had been
            successful.</p><div2 id="character-maps"><head>Character Maps</head><p>
               <termdef id="dt-character-map" term="character map">A <term>character map</term>
                  allows a specific character appearing in a text or attribute node in the <termref def="dt-final-result-tree">final result tree</termref> to be substituted by a
                  specified string of characters during serialization.</termdef> The effect of
               character maps is defined in <bibref ref="xslt-xquery-serialization-30"/>.</p><p>The character map that is supplied as a parameter to the serializer is determined
               from the <elcode>xsl:character-map</elcode> elements referenced from the
                  <elcode>xsl:output</elcode> declaration for the selected <termref def="dt-output-definition">output definition</termref>.</p><p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a
               child of the <elcode>xsl:stylesheet</elcode> element.</p><e:element-syntax name="character-map"><e:in-category name="declaration"/><e:attribute name="name" required="yes"><e:data-type name="eqname"/></e:attribute><e:attribute name="use-character-maps"><e:data-type name="eqnames"/></e:attribute><e:sequence><e:element repeat="zero-or-more" name="output-character"/></e:sequence><e:allowed-parents><e:parent name="stylesheet"/><e:parent name="transform"/></e:allowed-parents></e:element-syntax><p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <elcode>xsl:output-character</elcode> elements contained either directly within
               the <elcode>xsl:character-map</elcode> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p><p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <termref def="dt-output-definition">output definition</termref> or
               another character map, the character map with the highest <termref def="dt-import-precedence">import precedence</termref> is used.</p><p diff="add" at="I">The name of a character map is local to the <termref def="dt-package">package</termref>
            in which its declaration appears; it may be referenced only from within the same package.</p><p>
               <error spec="XT" type="static" class="SE" code="1580"><p>It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-stylesheet">stylesheet</termref> contains two or more character maps
                     with the same name and the same <termref def="dt-import-precedence">import
                        precedence</termref>, unless it also contains another character map with the
                     same name and higher import precedence.</p></error>
            </p><p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p><p>
               <error spec="XT" type="static" class="SE" code="1590"><p>It is a <termref def="dt-static-error">static error</termref> if a name in the
                        <code>use-character-maps</code> attribute of the <elcode>xsl:output</elcode>
                     or <elcode>xsl:character-map</elcode> elements does not match the
                        <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the
                        <termref def="dt-stylesheet">stylesheet</termref>.</p></error>
            </p><p>
               <error spec="XT" type="static" class="SE" code="1600"><p>It is a <termref def="dt-static-error">static error</termref> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p></error>
            </p><p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p><p>An <termref def="dt-output-definition">output definition</termref>, after recursive
               expansion of character maps referenced via its <code>use-character-maps</code>
               attribute, may contain several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p><ulist><item><p>Within a single <elcode>xsl:character-map</elcode> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <elcode>xsl:output-character</elcode> elements.</p></item><item><p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p></item><item><p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the
                     same <elcode>xsl:character-map</elcode> element are considered in document
                     order.</p></item></ulist><p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p><e:element-syntax name="output-character"><e:attribute name="character" required="yes"><e:data-type name="char"/></e:attribute><e:attribute name="string" required="yes"><e:data-type name="string"/></e:attribute><e:empty/><e:allowed-parents><e:parent name="character-map"/></e:allowed-parents></e:element-syntax><p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p><p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <specref ref="disable-output-escaping"/>.</p><p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p><example><head>Using Character Maps to Generate Non-XML Output</head><p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p><eg xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg><p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p><eg xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</eg><p>When this character map is referenced in the <elcode>xsl:output</elcode>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p><eg xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</eg><p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p></example><example><head>Constructing a Composite Character Map</head><p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p><eg xml:space="preserve">
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</eg></example></div2><div2 id="disable-output-escaping"><head>Disabling Output Escaping</head><p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p><p>This feature is <termref def="dt-deprecated">deprecated</termref>.</p><p>This is an optional feature: it is not <rfc2119>required</rfc2119> that a XSLT
               processor that implements the serialization option <rfc2119>should</rfc2119> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p><p>This feature requires an extension to the serializer described in <bibref ref="xslt-xquery-serialization-30"/>. Conceptually, the <termref def="dt-final-result-tree">final result tree</termref> provides an additional
               boolean property <code>disable-escaping</code> associated with every character in a
               text node. When this property is set, the normal action of the serializer to escape
               special characters such as <code>&amp;</code> and <code>&lt;</code> is
               suppressed.</p><p>An <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element
                  <rfc2119>should</rfc2119> have the <code>disable-output</code> property set.</p><example><head>Disable Output Escaping</head><p>For example,</p><eg xml:space="preserve">&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</eg><p>should generate the single character <code>&lt;</code>.</p></example><p>If output escaping is disabled for an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction evaluated when <termref def="dt-temporary-output-state">temporary output state</termref> is in effect, the
               request to disable output escaping is ignored.</p><p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p><example><head>Interaction of Output Escaping and CDATA</head><p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p><eg xml:space="preserve">&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</eg><p>should generate the output:</p><eg xml:space="preserve">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg></example><p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since it does not perform any
               output escaping.</p><p>A <termref def="dt-processor">processor</termref> will only be able to disable output
               escaping if it controls how the <termref def="dt-final-result-tree">final result
                  tree</termref> is output. This might not always be the case. For example, the
               result tree might be used as a <termref def="dt-source-tree">source tree</termref>
               for another XSLT transformation instead of being output. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether (and
               under what circumstances) disabling output escaping is supported.</p><p>
               <error spec="XT" type="dynamic" class="RE" code="1620"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction
                     specifies that output escaping is to be disabled and the implementation does
                     not support this. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the
                           <code>disable-output-escaping</code> attribute.</error.action>
                  </p></error>
            </p><p>
               <error spec="XT" type="dynamic" class="RE" code="1630"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction
                     specifies that output escaping is to be disabled when writing to a <termref def="dt-final-result-tree">final result tree</termref> that is not being
                     serialized. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the
                           <code>disable-output-escaping</code> attribute.</error.action>
                  </p></error>
            </p><imp-def-feature>It is implementation-defined whether, and under what circumstances,
               disabling output escaping is supported.</imp-def-feature><p>If output escaping is disabled for a character that is not representable in the
               encoding that the <termref def="dt-processor">processor</termref> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p><p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <rfc2119>should</rfc2119> be used only when
               there is no alternative.</p><note><p>The facility to define character maps for use during serialization, as described
                  in <specref ref="character-maps"/>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p></note></div2></div1><div1 id="conformance"><head>Conformance</head><p diff="chg" at="M">A <termref def="dt-processor">processor</termref> that claims conformance with this
            specification <rfc2119>must</rfc2119> satisfy the conformance requirements for a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and for each of the optional
            features with which it claims conformance.</p><p>The following optional features are defined:</p><olist><item><p>The schema-awareness feature, defined in <specref ref="schema-aware-conformance"/></p></item><item><p>The serialization feature, defined in <specref ref="serialization-feature"/></p></item><item><p>The backwards compatibility feature, defined in <specref ref="backwards-compatibility-feature"/></p></item><item><p>The streaming feature, defined in <specref ref="streaming-feature"/>.</p></item></olist><p diff="chg" at="M">A processor that does not claim conformance with an optional feature <rfc2119>must</rfc2119>
         satisfy the requirements for processors that do not implement that feature.</p><note><p>There is no conformance level or feature defined in this specification that requires
               implementation of the static typing features described in <bibref ref="xpath-30"/>.
               An XSLT processor may provide a user option to invoke static typing, but to be
               conformant with this specification it must allow a stylesheet to be processed with
               static typing disabled. The interaction of XSLT stylesheets with the static typing
               feature of <phrase diff="chg" at="F">XPath 3.0</phrase> has not been specified, so the results of using static typing,
               if available, are implementation-defined.</p></note><p>An XSLT processor takes as its inputs a stylesheet and 
            <phrase diff="chg" at="M">zero</phrase> or more XDM trees conforming
            to the data model defined in <bibref ref="xpath-datamodel-30"/>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            constructing XDM trees, but conformance can only be tested if it provides a mechanism
            that enables XDM trees representing the stylesheet and primary source document to be
            constructed and supplied as input to the processor.</p><p>The output of the XSLT processor consists of zero or more <termref def="dt-final-result-tree">final result trees</termref>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization <phrase diff="chg" at="M">feature</phrase>,
            conformance can only be tested if it provides some alternative mechanism that enables
            access to the results of the transformation.</p><p>Certain facilities in this specification are described as producing <termref def="dt-implementation-defined">implementation-defined</termref> results. A claim
            that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <specref ref="implementation-defined-features"/>.</p><p>A conforming <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119> signal any <termref def="dt-static-error">static error</termref>
            occurring in the stylesheet, or in any XPath <termref def="dt-expression">expression</termref>, except where specified otherwise either for individual error
            conditions or under the general provisions for <termref def="dt-forwards-compatible-behavior"/> (see
               <specref ref="forwards"/>). After signaling such an error, the processor
               <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors, but
               <rfc2119>must</rfc2119> terminate abnormally without performing any
            transformation.</p><p>When a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the course
            of a transformation, the action depends on whether the error is classified as a <termref def="dt-recoverable-error">recoverable error</termref>. If a non-recoverable error
            occurs, the processor <rfc2119>must</rfc2119> signal it and <rfc2119>must</rfc2119>
            eventually terminate abnormally. If a recoverable error occurs, the processor
               <rfc2119>must</rfc2119> either signal it and terminate abnormally, or it
               <rfc2119>must</rfc2119> take the defined recovery action and continue processing.</p><p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
               <rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static
               errors</termref> or <termref def="dt-dynamic-error">dynamic errors</termref> at the
            discretion of the processor.</p><p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p><div2 id="basic-conformance"><head>Basic XSLT Processor</head><p>
               <termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT
                     processor</term> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs 
                  explicitly associated with an optional feature.</termdef> These constructs are
               listed below.</p><p>The mandatory requirements of this specification are taken to include the mandatory
               requirements of <phrase diff="chg" at="F">XPath 3.0</phrase>, as described in <bibref ref="xpath-30"/>. A requirement is
               mandatory unless the specification includes wording (such as the use of the words
                  <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates that
               it is optional.</p><!--<p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
               <rfc2119>must</rfc2119> enforce the following restrictions. It
                  <rfc2119>must</rfc2119> signal a static or dynamic error when the restriction is
               violated, as described below.</p>--></div2><div2 id="schema-aware-conformance" diff="chg" at="M"><head>Schema-Awareness Conformance Feature</head><p>A conformant processor <rfc2119>must</rfc2119> either be a conformant <termref def="dt-schema-aware-xslt-processor"/> or
            a conformant <termref def="dt-non-schema-aware-processor"/>.</p><p>
               <termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A
                     <term>schema-aware XSLT processor</term> is an XSLT processor that 
                  implements the mandatory requirements of this specification connected with
                  the <elcode>xsl:import-schema</elcode> declaration, the <code>[xsl:]validation</code>
                  and <code>[xsl:]type attributes</code>, and the ability to handle input documents
                  whose nodes have type annotations other than <code>xs:untyped</code> and
                  <code>xs:untypedAtomic</code>.
                  The mandatory requirements of this specification are taken to
                  include the mandatory requirements of <phrase diff="chg" at="F">XPath 3.0</phrase>, as described in <bibref ref="xpath-30"/>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <rfc2119>should</rfc2119> or
                     <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef>
            </p><p diff="chg" at="M"><termdef id="dt-non-schema-aware-processor" term="non-schema-aware processor">A
            <term>non-schema-aware processor</term> is a processor that does not claim conformance with
            the schema-aware conformance feature. Such a processor <rfc2119>must</rfc2119> handle constructs associated with
            schema-aware processing as described in this section.</termdef></p><p>
               <error spec="XT" type="static" class="SE" code="1650"><p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if the <termref def="dt-stylesheet">stylesheet</termref>
                     includes an <elcode>xsl:import-schema</elcode> declaration.</p></error>
            </p><note><p>A processor that rejects an <elcode>xsl:import-schema</elcode> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <specref ref="built-in-types"/>.</p></note><p diff="add" at="B">A <termref def="dt-non-schema-aware-processor">non-schema-aware
               processor</termref> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <rfc2119>must</rfc2119>
               treat any <code>[xsl:]validation</code> or <code>default-validation</code> attribute
               with a value of <code>preserve</code> or <code>lax</code> as if the value were
               <code>strip</code>.</p><note diff="add" at="B"><p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                  <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p></note><p>
               <error spec="XT" type="static" class="SE" code="1660"><p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if the <termref def="dt-stylesheet">stylesheet</termref>
                     includes an <code>[xsl:]type</code> attribute, or an
                     <code>[xsl:]validation</code> or <code>default-validation</code> attribute
                     with a value other than <code>strip</code><phrase diff="add" at="B">,
                        <code>preserve</code>, or <code>lax</code></phrase>.</p></error>
            </p><p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref> constrains
               the data model as follows:</p><ulist><item><p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed
                     in <specref ref="built-in-types"/> (except as noted below).</p><p>An atomic value may also belong to an implementation-defined type that has been
                     added to the context for use with <termref def="dt-extension-function">extension functions</termref> or <termref def="dt-extension-instruction">extension instructions</termref>.</p><p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p><p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                     <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p></item><item><p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref def="dt-annotation">type annotation</termref>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                     <code>xs:untypedAtomic</code>.</p></item></ulist><p>
               <error spec="XT" type="dynamic" class="DE" code="1665"><p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
                     <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the input to the processor
                     includes a node with a <termref def="dt-annotation">type annotation</termref>
                     other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code>, or an
                     atomic value of a type other than those which a basic XSLT processor
                     supports.</p></error> This error will not arise if the <code>input-type-annotations</code>
               attribute is set to <code>strip</code>.</p><note><p>Although this is expressed in terms of a requirement to detect invalid input, an
                  alternative approach is for a non-schema-aware processor to prevent this error condition
                  occurring, by not providing any interfaces that would allow the situation to
                  arise. A processor might, for example, implement a mapping from the PSVI to the
                  data model that loses all non-trivial <termref def="dt-annotation">type
                     annotations</termref>; or it might not accept input from a PSVI at all.</p><p>The phrase <emph>input to the processor</emph> is deliberately wide: it includes
                  the tree containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, trees passed as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, trees accessed
                  using the <function>document</function>, <xfunction>doc</xfunction>, and
                  <xfunction>collection</xfunction> functions, and trees returned by <termref def="dt-extension-function">extension functions</termref> and <termref def="dt-extension-instruction">extension instructions</termref>.</p></note></div2><div2 id="serialization-feature"><head>Serialization Feature</head><p>
               <termdef id="dt-serialization-feature" term="serialization feature">A processor that
                  claims conformance with the <term>serialization feature</term>
                  <rfc2119>must</rfc2119> support the conversion of a <termref def="dt-final-result-tree">final result tree</termref> to a sequence of octets
                  following the rules defined in <specref ref="serialization"/>.</termdef> It
                  <rfc2119>must</rfc2119> respect all the attributes of the
                  <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode> declarations,
               and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <rfc2119>must</rfc2119> and
                  <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result
               tree in precisely the way described; in other cases it <rfc2119>may</rfc2119> use an
               alternative, equivalent representation.</p><p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>. </p><p>A processor that does not claim conformance with the serialization feature
                  <rfc2119>must not</rfc2119> signal an error merely because the <termref def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or
                  <elcode>xsl:character-map</elcode> declarations, or serialization attributes on
               the <elcode>xsl:result-document</elcode> instruction. Such a processor
                  <rfc2119>may</rfc2119> check that these declarations and attributes have valid
               values, but is not <rfc2119>required</rfc2119> to do so. Apart from optional
               validation, these declarations <rfc2119>should</rfc2119> be ignored.</p></div2><div2 id="backwards-compatibility-feature"><head>Compatibility Features</head><p>
               <termdef id="dt-1.0-compatibility-feature" term="XSLT 1.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 1.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-10-behavior" diff="chg" at="D">XSLT
                     1.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p><p>
               <termdef id="dt-2.0-compatibility-feature" term="XSLT 2.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 2.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-20-behavior" diff="chg" at="D">XSLT
                     2.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p><p>Note that a processor that does not claim conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an instruction is evaluated whose
                  <termref def="dt-effective-version"/> is 1.0; and similarly, a processor that does
               not claim conformance with the <termref def="dt-2.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an instruction is evaluated whose
                  <termref def="dt-effective-version"/> is 2.0. <errorref spec="XT" class="DE" code="0160"/>.</p><note><p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements <phrase diff="chg" at="D">XSLT 1.0, 2.0, or
                     3.0</phrase>. The selection of which path to use can be controlled by using the
                     <function>system-property</function> function to test the
                     <code>xsl:version</code> system property.</p></note><p>A processor that claims conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p><note><p>Currently, there are no incompatibilities between 3.0 and 2.0 that justify this
                  machinery. This will be reviewed at a later stage of development of the
                  specification.</p></note></div2><div2 id="streaming-feature" diff="chg" at="M"><head>Streaming Feature</head><p>
               <termdef id="dt-streaming-feature" term="streaming feature">A processor that claims
                  conformance with the <term>streaming feature</term>
                  <rfc2119>must</rfc2119> use streamed processing in cases where (a) streaming is requested
               (for example by using the attribute <code>streamable="yes"</code> on <elcode>xsl:mode</elcode>,
               or the <elcode>xsl:stream</elcode> instruction) and (b) the constructs in question are
               <termref def="dt-guaranteed-streamable"/> according to this specification.</termdef>
            </p><p>A processor that does not claim conformance with the streaming feature is not required
               to use streamed processing and is not required to determine whether any construct is guaranteed
               streamable. Such a processor must, however, implement the semantics of all constructs
               in the language provided that enough memory is available to perform the processing without
               streaming.</p><note><p>The term <emph>streamed processing</emph> as used here means the ability to process
               arbitrarily large input documents without ever-increasing memory requirements.</p></note><issue id="issue-streaming-conformance" status="open"><p>The requirement for non-streaming processors to implement all constructs of the language,
                     including for example <elcode>xsl:stream</elcode> and <elcode>xsl:accumulator</elcode>,
                     is not yet agreed by the WG.</p></issue></div2></div1></body><back><div1 id="references"><head>References</head><div2 id="normative-references"><head>Normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-30" key="Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-30" key="Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!--World Wide Web Consortium. 
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators.</emph>
W3C Working Draft. 
See <loc href="http://www.w3.org/TR/xpath-functions/"/>
					</bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-infoset" key="XML Information Set" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!--World Wide Web Consortium. 
					<emph>XML Information Set.</emph> W3C Recommendation. 
					See <loc href="http://www.w3.org/TR/xml-infoset/"/>
                    </bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO3166" key="ISO 3166-1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for
                  Standardization) <emph>Codes for the representation of names of countries and
                  their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997. 
                  Second edition, 2006-11-20. </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO8601" key="ISO 8601" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for
                  Standardization) <emph>Data elements and interchange formats - Information
                     interchange - Representation of dates and times.</emph> ISO 8601:2004,
                  Third edition, 2004-12-03. </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-30" key="XSLT and XQuery Serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!--<bibl id="UNICODE-NORMALIZATION" key="Unicode Normalization">Unicode Consortium.
					<emph>Unicode Normalization Forms</emph>. Unicode Standard Annex #15.
					See <loc href="http://www.unicode.org/unicode/reports/tr15/"/>
					</bibl>--><!--					<bibl id="XHTML10" key="XHTML 1.0">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml1/"/>. Note: a second edition of this
specification is in preparation.</bibl>--><!--					<bibl id="XHTML11" key="XHTML 1.1">World Wide Web Consortium. <emph>XHTML
1.1: Module-Based XHTML.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml11/"/>
</bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc4627" key="RFC 4627" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. 
               <emph>The application/json Media Type for JavaScript Object Notation (JSON).</emph>
               July 2006. See <loc href="http://www.ietf.org/rfc/rfc4627.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc4627.txt</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ECMA-262" key="ECMA-262" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> ECMA International. <emph>ECMAScript Language Specification</emph> June 2011. See <loc href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</loc>.
   
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>Extensible Markup Language (XML)
                     1.0. W3C Recommendation.</emph> See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</loc>.
                  The edition of XML 1.0 must be no earlier than the Third Edition; 
                  the edition used is <termref def="dt-implementation-defined"/>, 
                  but we recommend that implementations use the latest version.
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlbase" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-id" key="xml:id" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names" key="Namespaces in XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names11" key="Namespaces in XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="XML Schema Part 1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="XML Schema Part 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema11-1" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. 
<emph>XML Schema Definition Language (XSD) 1.1 Part 1: Structures</emph>. W3C Working Draft 3 December 2009.
See <loc href="http://www.w3.org/TR/xmlschema11-1/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
					</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-30" key="XPath 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT-Mime-Type" key="XSLT Media Type" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
                     <emph>Registration of MIME Media Type application/xslt+xml</emph>. In <loc href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Appendix B.1 of the XSLT 2.0 specification.</loc></bibl></blist></div2><div2 id="other-references"><head>Other References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CALCALC" key="Calendrical Calculations" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Edward M. Reingold and Nachum
                  Dershowitz. <emph>Calendrical Calculations Millennium edition (2nd
                  Edition)</emph>. Cambridge University Press, ISBN 0 521 77752 6</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM-Level-2-Core" key="DOM Level 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc2119" key="rfc2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. <emph>Key words for use in RFCs to
                     Indicate Requirement Levels</emph>. IETF RFC 2119. See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2376" key="RFC2376" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">E. Whitehead, M. Murata. <emph>XML Media
                     Types</emph>. IETF RFC 2376. See <loc href="http://www.ietf.org/rfc/rfc2376.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3023" key="RFC3023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Murata, S. St.Laurent, and D. Cohn. <emph>XML
                     Media Types</emph>. IETF RFC 3023. See <loc href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. References to RFC 3023 should be
                  taken to refer to any document that supersedes RFC 3023.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> T. Berners-Lee, R. Fielding, and L. Masinter.
                     <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986.
                  See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst, M. Suignard. <emph>Internationalized
                     Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="marian-simeon" key="Marian &amp; Siméon" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> Amélie Marian and Jérôme Siméon.
                     <emph>Projecting XML Documents</emph>. VLDB'2003, Berlin, Germany, September
                  2003. See <loc href="http://portal.acm.org/citation.cfm?id=1315471" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="STX" key="STX" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Petr Cimprich <emph>et al</emph>, <emph>Streaming
                     Transformations for XML (STX) Version 1.0</emph>. Working Draft 27 April 2007.
                  See <loc href="http://stx.sourceforge.net/documents/spec-stx-20070427.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UNICODE-TR10" key="UNICODE TR10" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode Consortium. <emph>Unicode
                     Technical Standard #10. Unicode Collation Algorithm</emph>. Unicode Technical
                  Report. See <loc href="http://www.unicode.org/reports/tr10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xinclude" key="XInclude" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xlink" key="XLink" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SCHEMA-AND-XML-1.1" key="XML Schema 1.0 and XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
                  Consortium. <emph>Processing XML 1.1 documents with XML Schema 1.0
                     processors</emph>. W3C Working Group Note 11 May 2005. See <loc href="http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-stylesheet" key="XML Stylesheet" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xptr-framework" key="XPointer Framework" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xsl11" key="XSL-FO" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt20" key="XSLT 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2></div1><inform-div1 id="glossary"><head>Glossary</head><?glossary?></inform-div1><inform-div1 id="element-syntax-summary"><head>Element Syntax Summary</head><?element-syntax-summary?></inform-div1><!--<inform-div1 id="expression-trees">
         <head></head>

               <p>The first stage in analyzing a <termref def="dt-construct">construct</termref>
                  (such as an <elcode>xsl:stream</elcode> instruction or a <termref
                     def="dt-template-rule">template rule</termref>) to determine whether it is
                  streamable is to create a representation of the construct in the form of an
                  expression tree. The expression tree (which might more accurately
                  be called a "construct tree") represents the syntactic structure of the
                  construct.</p>
               <p><termdef id="dt-e-node" term="e-node">To distinguish nodes in an expression tree
                     from other kinds of node in other kinds of tree, we refer to them as
                        <term>e-nodes</term>.</termdef></p>

               


           
                  <p>Many processors will build some kind of expression tree for purposes unrelated
                     to streamability analysis. In practice the same tree is likely to be used for
                     other operations such as type analysis and optimization.</p>
                  <p>The rules for streamability allow considerable variation in the way the
                  expression tree is constructed. This appendix describes some of the assumptions
                  that have been made about the structure and content of the expression tree.</p>
               


               <p>In principle an expression tree can be constructed for each <termref
                     def="dt-stylesheet-function">stylesheet function</termref>, <termref
                     def="dt-template">template</termref>, and <termref def="dt-attribute-set"
                     >attribute set</termref>: its root e-node represents the function, template, or
                  attribute set. In practice, however, expression trees are only needed for
                  constructs that are subject to streamability analysis: this includes the content
                  of <elcode>xsl:stream</elcode> instructions, <termref def="dt-template-rule"
                     >template rules</termref> that use a streamable <termref def="dt-mode"
                     >mode</termref>, and the templates, functions, and attribute sets that these
                  call, to any depth.</p>

               <p diff="add" at="J">The expression tree is built after performing the normalizations described
                  in the language semantics. For example, <code>//</code>
                  will have been replaced by <code>/descendant-or-self::node()/</code>, a free-standing <code>/</code>
                  will have been replaced by <code>root(.) treat as document-node()</code>, and a path expression
                  starting with <code>/</code> will have been prefixed with <code>root(.) treat as document-node()</code>.</p>
            
               <p diff="add" at="K">
                  In general the expression tree directly represents physical containment of one construct within
                  another in the source code of a stylesheet. For example, the e-node representing a sequence
                  constructor has as its children the e-nodes representing the instructions within the
                  sequence constructor, and the e-node representing an instruction has as children the
                  e-nodes representing its child instructions and any XPath expressions contained
                  in its attributes. Some exceptions to this principle are noted below:
               </p>
         
         <olist>
            <item><p>An <code>[xsl:]use-attribute-sets</code> attribute is replaced by the attribute sets
            that it references, so that the <elcode>xsl:attribute</elcode> instructions in the attribute
               set appear as children of the instruction containing the <code>[xsl:]use-attribute-sets</code>
               attribute.</p></item>
            <item><p>When <elcode>xsl:sort</elcode> elements appear as children of instructions such
            as <elcode>xsl:for-each</elcode>, the expression <var>S</var> in the
            <code>select</code> attribute is replaced by an e-node representing a function call
            <code>sort(S, K1, K2, ,,,)</code> where K1, K2, ... are the expressions appearing
               in the <elcode>xsl:sort</elcode> elements, including not only the sort keys
               but any expressions in attribute value templates such as <code>order</code>
               and <code>data-type</code>.</p></item>
            <item><p>The e-node corresponding to an <elcode>xsl:try</elcode> 
               instruction has two children, one for the <termref def="dt-sequence-constructor"/> or
               <code>select</code> expression defining the non-error result of the instruction, and one for the
               set of <elcode>xsl:catch</elcode> elements. If there are multiple <elcode>xsl:catch</elcode>
               elements, these are rewritten as if there were a single <elcode>xsl:catch</elcode> containing
               a conditional expression (or set of nested conditionals) performing tests on the value of the
               error code.</p></item>
            <item><p>An XPath expression that matches productions at several levels in the
               grammar only needs to be represented by a single e-node in the
               tree: for example <code>3</code> will be represented as an
               <code>IntegerLiteral</code>, despite being also a
               <code>PrimaryExpr</code>, a <code>FilterExpr</code>, a
               <code>StepExpr</code>, a <code>PathExpr</code>, and so
               on.</p>
               <p>Grammar productions that are not themselves expressions are not
                  represented by further child e-nodes. For example, the
                  expression <code>@price + 2</code> will be represented by an
                  e-node corresponding to the <code>+</code> operator, with two
                  children, representing the axis step
                  <code>attribute::price</code> and the numeric literal
                  <code>2</code> respectively. The expression <code diff="chg"
                     at="F">@price instance of xs:decimal</code> is represented by
                  an e-node corresponding to the operator <code>instance of
                     xs:decimal</code>, with a single child representing the axis
                  step <code>attribute::price</code>. This is because the <xnt
                     spec="XP30" ref="prod-xpath30-SequenceType"
                     >SequenceType</xnt>
                  <code>xs:decimal</code> is not itself an <termref
                     def="dt-expression">expression</termref> and plays no role in
                     the streamability analysis.</p></item>
            <item>
               <p>A parenthesized expression is not represented explicitly as an
                  e-node, since the tree structure directly captures all the
                  information conveyed by the parentheses. For example, the
                  expression <code>$a*($b+2)</code> is represented by a tree
                  consisting of an e-node representing the <code>*</code> operator
                  with two children, one representing the variable reference
                  <code>$a</code>, the other representing the <code>+</code>
                  operator, which in turn has two children representing the
                  operands <code>$b</code> and <code>2</code> respectively.</p>
            </item>
         </olist>
               
  
  

               <example>
                  <head>An expression tree</head>
                  <p>Consider the instruction:</p>
                  <eg xml:space="preserve"><![CDATA[<xsl:stream href="books.xml">
  <inventory date="{format-date(current-date(), '[D] [MNn] [Y]')}">
    <xsl:value-of select="count(descendant::book)"/>
  </inventory>
</xsl:stream>]]></eg>
                  <p>The expression tree for the <elcode>xsl:stream</elcode> instruction is shown
                     below:</p>
                  <note>
                     <p>Below this paragraph is an SVG diagram. To view it, you need a browser that
                        is capable of displaying SVG graphics.</p>
                  </note>


                  <g:graph>
                     <g:node label="xsl:stream">
                        <g:node label="&lt;inventory&gt;">
                           <g:node label="format-date()">
                              <g:node label="current-date()"/>
                              <g:node label="'[D] [MNn] [Y]'"/>
                           </g:node>
                           <g:node label="xsl:value-of">
                              <g:node label="count()">
                                 <g:node label="descendant::book"/>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                  </g:graph>


                  <note>
                     <p>This tree has been simplified slightly: as suggested in the rules above, the
                        e-nodes representing sequence constructors comprising a single instruction
                        have been elided. </p>
                     <p>In practice an implementation can simplify the tree further without
                        affecting the subsequent analysis. For example, leaf e-nodes representing
                        literal values can be stripped, and in many cases intermediate e-nodes
                        representing functions or operators can be elided.</p>
                  </note>
               </example>


      </inform-div1>--><inform-div1 id="error-summary"><head>Summary of Error Conditions</head><p diff="chg" at="E">This appendix provides a summary of error conditions that a processor
            may signal. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <rfc2119>must</rfc2119> signal errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily signal the same error code. Implementations
            are not <rfc2119>required</rfc2119> to signal errors using the descriptive text used
            here.</p><note><p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p></note><?error-summary?></inform-div1><inform-div1 id="implementation-defined-features"><head>Checklist of Implementation-Defined Features</head><p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <termref def="dt-implementation-defined"/>. The
            conformance rules (see <specref ref="conformance"/>) require vendors to provide
            documentation that explains how these choices have been exercised.</p><?implementation-defined-features?></inform-div1><inform-div1 id="XSLT-defined-functions" diff="add" at="E"><head>List of XSLT-defined functions</head><p>This appendix acts as an index of functions defined in this specification, to augment
            the set of functions defined in <bibref ref="xpath-functions-30"/>.</p><?xslt-defined-functions?></inform-div1><inform-div1 id="schema-for-xslt"><head>Schema for XSLT Stylesheets</head><p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. It does not
            define all the constraints that apply to a stylesheet (for example, it does not attempt
            to define a datatype that precisely represents attributes containing XPath <termref def="dt-expression">expressions</termref>). However, every valid stylesheet module
            conforms to this schema, unless it contains elements that invoke <termref def="dt-forwards-compatible-behavior"/>.</p><p>A copy of this schema is available at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2012/07/schema-for-xslt30.xsd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2012/07/schema-for-xslt30.xsd</loc>
         </p><note diff="add" at="L"><p>The schema as written uses a lax wildcard to permit literal result elements to appear
         in a sequence constructor. This assumes that the schema used for validation will not contain any global
         element declaration that matches the element name of a literal result element. The content model for an element such
         as <code>invoice</code> appearing within a stylesheet is not the same as the content model for the same element appearing
         within a source document (it is likely to contain XSLT instructions rather than other elements from the target vocabulary):
         therefore, including such declarations in the schema used for validating a stylesheet is inappropriate.</p><p>The reason that lax validation rather than skip validation is used is so that XSLT instructions appearing
         as children of the literal result element will themselves be validated, using the appropriate global element declaration.</p></note><note diff="add" at="L"><p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical constraints
         appearing in the specification, for example the rule that some elements can have either a <code>select</code>
         attribute or a contained sequence constructor, but not both. At this stage, no attempt has been made to
         represent every such constraint, even where it is not difficult to express the rule. There will always
         be some constraints that cannot be expressed at all, for example those that require access to multiple
         stylesheet modules, those that require access to the in-scope schema components, and those that involve 
         parsing a non-regular grammar, such as the grammar for patterns.</p><p>Apart from assertions, the only other significant use of XSD 1.1 features is that the elements
         <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> are in two substitution groups: one containing
         all instructions, and one containing all declarations. If the schema needs to be converted to an XSD 1.0
         schema, removing all assertions is straightforward; the other change needed is to remove 
            <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> from the substitution group for declarations,
         and instead permit them explicitly as children of <elcode>xsl:transform</elcode>.</p></note><?schema-for-xslt?></inform-div1><inform-div1 id="acknowledgements"><head>Acknowledgements</head><p>This specification was developed and approved for publication by the W3C XSL Working
            Group (WG). WG approval of this specification does not necessarily imply that all WG
            members voted for its approval.</p><p>The chair of the XSL WG is Sharon Adler. The members of the XSL WG
            who are engaged in creation of the XSLT 3.0 specification are:</p><glist><gitem><label>Sharon Adler</label><def><p>Invited expert</p></def></gitem><gitem><label>Anders Berglund</label><def><p>Invited expert</p></def></gitem><gitem><label>Oliver Becker</label><def><p>Invited expert</p></def></gitem><gitem><label>Carine Bournez</label><def><p>W3C</p></def></gitem><gitem><label>Abel Braaksma</label><def><p>Invited expert</p></def></gitem><gitem><label>Nikolay Fiykov</label><def><p>Nokia</p></def></gitem><gitem><label>Sandy Gao</label><def><p>IBM</p></def></gitem><gitem><label>Florent Georges</label><def><p>Invited expert</p></def></gitem><gitem><label>Michael Kay</label><def><p>Invited expert</p></def></gitem><gitem><label>Jirka Kosek</label><def><p>Invited expert</p></def></gitem><gitem><label>Dimitre Novatchev</label><def><p>Microsoft</p></def></gitem><gitem><label>Dmitriy Shabanov</label><def><p>Invited expert</p></def></gitem><gitem><label>C. Michael Sperberg-McQueen</label><def><p>Invited expert</p></def></gitem><gitem><label>Mohamed Zergaoui</label><def><p>Innovimax</p></def></gitem><gitem><label>Henry Zongaro</label><def><p>IBM</p></def></gitem></glist><p>The Working Group wishes to acknowledge the pioneering work of the developers of STX
            (see <bibref ref="STX"/>) which has formed an important intellectual input to the design
            of XSLT 3.0 and has demonstrated the feasibility of creating a streaming transformation
            language based on the core XSLT concept of recursive descent of the source tree using
            rule-based templates. In particular Petr Cimprich played in an important role during
            the process of formulating XSLT 3.0 streaming requirements.</p><p diff="add" at="F">The SVG diagrams in this specification are drawn using <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.graphviz.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">GraphViz</loc>
            from AT&amp;T Research, in conjunction with the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.martin-loetzsch.de/DOTML/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DotML</loc> 
            markup language developed by Martin Loetzsch. 
         </p></inform-div1><inform-div1 id="open-issues" diff="add" at="F"><head>Summary of Open Issues</head><?summary-of-open-issues?></inform-div1><inform-div1 id="changes-since-2.0" diff="add" at="B"><head>Changes since XSLT 2.0</head><div2 id="xslt-changes-since-2.0"><head>Changes in this Specification</head><olist><item><p>A stylesheet may now consist of multiple packages. The language specification
                  for packages has been designed with a view to allowing packages to be compiled
                  independently of each other. The specification provides control over the interface
                  offered by a package to other packages; in particular it allows functions, variables,
                  named templates and other components to be declared as public, private, final,
                  or abstract.</p></item><item><p>A new <elcode>xsl:iterate</elcode> instruction is added. This allows iterative
                  processing of a sequence, with the ability for the processing of one item to
                  depend on the results of processing of previous items, and with the ability to
                  terminate the iteration before all the items in the sequence have been
                  processed.</p></item><item><p>A new <elcode>xsl:mode</elcode> declaration is added.</p><olist><item><p>A mode may be declared to be
                     streamable, and rules are given that constrain what the template rules in a
                     streamable mode can do.</p></item><item><p>The <elcode>xsl:mode</elcode> declaration may contain an
                     <elcode>xsl:context-item</elcode> element to declare the expected type of the
                     <termref def="dt-initial-context-item"/> when this mode is the <termref def="dt-initial-mode"/>.</p></item><item><p>An <elcode>xsl:mode</elcode> declaration may define the action to be taken
                  when there is no matching template rule, and the action to be taken when there are
                  multiple matching template rules.</p></item><item><p>An <elcode>xsl:mode</elcode> declaration may indicate that the template rules
                     in a given mode are designed to process typed (schema-validated) nodes only,
                     or untyped nodes only. It may also indicate that element names appearing in match
                     patterns for the mode are only to match elements in the source document that have been
                     validated against the corresponding element declarations in the schema.</p></item></olist></item><item><p>A default mode can be declared for a stylesheet module,
               making it easier to reuse existing stylesheet modules to construct a composite
               stylesheet.</p></item><item><p>A new instruction <elcode>xsl:stream</elcode> is provided, to read and process an
                  input document using streaming</p></item><item><p>A new instruction <elcode>xsl:merge</elcode> is provided. This allows several
                  input sequences to be merged into a single output sequence, based on the value of
                  a merge key.</p></item><item><p>A new <termref def="dt-top-level"/> declaration <elcode>xsl:accumulator</elcode> is introduced.
               An accumulator represents information about a node in a document that can be
               computed during a streamed pass over the document, starting at the start and
               ending at that node.</p></item><item><p>New functions <function>copy-of</function> and <function>snapshot</function> are
                  provided, to enable streaming applications to operate in "windowing" mode, where
                  the input document is divided into a sequence of small subtrees processed one at a
                  time.</p></item><item><p>A new <elcode>xsl:try</elcode> instruction is provided, to allow recovery from
                  dynamic errors.</p></item><item><p>A new <elcode>xsl:evaluate</elcode> instruction is provided, to allow evaluation
                  of XPath expressions constructed dynamically from strings, or read from a source
                  document.</p></item><item><p>A new <elcode>xsl:fork</elcode> instruction is introduced to allow multiple
                  results to be computed during a single pass of a streamed input document.</p></item><item><p>The syntax of <termref def="dt-pattern">patterns</termref> has been generalized.
                  Patterns may now match any item (not only nodes). In consequence,
                     <elcode>xsl:apply-templates</elcode> can now process sequences of atomic values
                  as well as nodes, and <elcode>xsl:for-each-group</elcode> with the
                     <code>group-starting-with</code> and <code>group-ending-with</code> options can
                  also process atomic sequences. As a further consequence, the <termref def="dt-initial-context-item"/> supplied when initiating a transformation is no
                  longer required to be a node.</p></item><item><p>A new datatype, called a map, has been introduced, together with supporting
                  functions, operators, and type syntax. Maps allow more complex data structures
                  to be created than is possible using atomic values and nodes alone. This has particular
                  applications to streamed processing: since a streamed application can visit each node
                  of its primary input document only once, it often needs more advanced data structures
                  to retain what it has already seen in the document.</p></item><item><p>New functions are available to import and export data in JSON format.</p></item><item><p>The <elcode>xsl:copy</elcode> instruction now has a <code>select</code> attribute,
                  which is convenient when it is used inside a function where there is no context
                  item.</p></item><item><p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> now
                  recognizes all the built-in types defined in XML Schema.</p></item><item><p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> will now
                  accept the attribute <code>validation="lax"</code> and interpret it in the same
                  way as a schema-aware processor when there is no schema component available to
                  perform the validation.</p></item><item><p>Some functions, including <xfunction>generate-id</xfunction>, <xfunction>format-date</xfunction>,
                     <xfunction>format-dateTime</xfunction>, <xfunction>format-number</xfunction>, 
                     <xfunction>format-time</xfunction>, and <xfunction>unparsed-text</xfunction>
                  have been moved from this specification to the core
                  Functions and Operators specification, to make them available in other host
                  languages. </p></item><item><p diff="add" at="G">The rules for handling conflicts between <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> have changed. A conflict that can be detected statically
               is now signaled as a static error; a run-time conflict between two declarations having the same
               precedence and priority is now resolved by taking whichever comes last in declaration order.</p></item><item><p diff="add" at="G">A template may contain an <elcode>xsl:context-item</elcode> element
                  to declare the required type of the context item when the template is called.</p></item><item><p diff="add" at="G">Composite keys are supported in <elcode>xsl:key</elcode> and in
               <elcode>xsl:for-each-group</elcode>.</p></item><item><p diff="add" at="M">A new attribute on <elcode>xsl:message</elcode> allows specification
                  of the error code to be returned with <code>terminate="yes"</code> is specified.</p></item><item><p diff="add" at="L">An <elcode>xsl:assert</elcode> instruction is introduced.</p></item><item><p diff="add" at="L">An <code>[xsl:]on-empty</code> attribute is provided for <elcode>xsl:element</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:attribute</elcode>, and literal result elements,
                  to control their behavior when the content of the constructed node would otherwise be empty.</p></item><item><p diff="add" at="M">Static variables and parameters are introduced, to make the 
               <code>[xsl:]use-when</code> mechanism more useful, especially in conjunction with <elcode>xsl:assert</elcode>.</p></item><item><p diff="add" at="M">An empty <elcode>xsl:value-of</elcode> instruction with no <code>select</code> attribute
            is now permitted; its effect is to construct a zero-length text node.</p></item><item><p diff="add" at="M">The rule requiring <elcode>xsl:import</elcode> declarations to precede
            all other declarations in a stylesheet module has been removed.</p></item><item><p diff="add" at="M">The rule that effectively prevented references to external documents
               in <code>[xsl:]use-when</code> expressions has been removed.</p></item><item><p diff="add" at="M">A default value is defined for the named template to be used when initiating a transformation
               (specifically, <code>xsl:initial-template</code>).</p></item><item><p diff="add" at="M">The <code>override</code> attribute of <elcode>xsl:function</elcode> is
            renamed <code>override-extension-function</code>, retaining the old name as a deprecated synonym.</p></item></olist></div2><div2 id="xpath-changes-since-2.0"><head>Changes in Other Related Specifications</head><p>A number of changes affecting XSLT 2.0 have been made in other related specifications.
            Some of the more significant changes are as follows:</p><olist><item><p>A number of new functions have been defined whose aim is to facilitate streaming. These
            include <xfunction>unparsed-text-lines</xfunction>, <xfunction>innermost</xfunction>,
            <xfunction>outermost</xfunction>.</p></item><item><p>XPath 3.0 supports a subset of the <code>let</code> expression from XQuery.</p></item><item><p>XPath 3.0 supports function items as first-class values (functions can, for example, be
            bound to variables and passed as parameters to other functions.)</p></item><item><p>XPath 3.0 supports a new syntax for writing expanded names using the namespace URI
            and local part only, avoiding the need to create a static context that binds namespace
            prefixes. This is intended to be particularly useful when XPath expressions are software-generated.
            Complementing this, a new function <xfunction>path</xfunction> is available to generate
            a (namespace-context-independent) path to any node that can subsequently be evaluated
            using the <elcode>xsl:evaluate</elcode> instruction, or otherwise.</p></item></olist></div2></inform-div1><inform-div1 id="changes-since-july-2012" diff="add" at="M"><head>Changes since the Working Draft of 10 July 2012</head><p>This section lists all significant changes since the Working Draft published
         on 10 July 2012.</p><olist><item><p>An empty <elcode>xsl:value-of</elcode> instruction with no <code>select</code> attribute
            is now permitted; its effect is to construct a zero-length text node.</p></item><item><p>Static variables and parameters are introduced, to make the 
               <code>[xsl:]use-when</code> mechanism more useful, especially in conjunction with <elcode>xsl:assert</elcode>.</p></item><item><p>The rule requiring <elcode>xsl:import</elcode> declarations to precede
            all other declarations in a stylesheet module has been removed.</p></item><item><p>The rule that effectively prevented references to external documents
               in <code>[xsl:]use-when</code> expressions has been removed.</p></item><item><p>The <code>enabled</code> attribute of <elcode>xsl:assert</elcode> is removed; its
            effect can now be achieved more conveniently using a <code>use-when</code> attribute.</p></item><item><p>A default value is defined for the named template to be used when initiating a transformation
            (specifically, <code>xsl:initial-template</code>).</p></item><item><p>The <code>override</code> attribute of <elcode>xsl:function</elcode> is
               renamed <code>override-extension-function</code>, retaining the old name as a deprecated synonym.</p></item><item><p>The rules for conformance against optional features have been refactored.</p></item></olist></inform-div1><inform-div1 id="incompatibilities" diff="add" at="E"><head>Incompatibilities with XSLT 2.0</head><p>This section lists all known incompatibilities with XSLT 2.0, that is, situations where
            a stylesheet that is error-free according to the XSLT 2.0 specification and where all
            elements have an effective version of <code>2.0</code> or less, will produce different
            results depending on whether it is run under an XSLT 2.0 processor or an XSLT 3.0
            processor.</p><olist><item><p>XSLT 2.0 gave implementations freedom what to do when a node selected by
                     <elcode>xsl:apply-templates</elcode> matched more than one <termref def="dt-template-rule"/>. XSLT 3.0 is more prescriptive in this situation. The
                  behavior prescribed in XSLT 3.0 (selecting the template rule that is last in
                     <termref def="dt-declaration-order"/>) is compatible with the action of some
                  XSLT 2.0 processors but not necessarily others.</p></item><item><p>
                  It is now a static error if the same <code>NameTest</code> appears in both an
                  <elcode>xsl:strip-space</elcode> and an <elcode>xsl:preserve-space</elcode> declaration
                  with the same precedence and priority. Previously this was a dynamic error, and processors 
                  were allowed to recover from the error.
               </p></item><item><p diff="add" at="K">
                  The current group and current grouping key are now absent rather than empty when not in use,
                  which means that attempting to refer to them in this state gives a dynamic error.
               </p></item><item><p diff="add" at="L">
                  As a consequence of functions such as <xfunction>format-date</xfunction> moving from this
                  specification to <bibref ref="xpath-functions-30"/>, error codes associated with these functions
                  have changed.
               </p></item></olist></inform-div1></back></spec>