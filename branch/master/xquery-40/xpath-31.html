<!DOCTYPE HTML>

<!--{xml-fix} XSLT Processor: Saxonica SAXON HE 9.6.0.7-->
<!--This document was created at 20170316 1605--><html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
   <head>
      <title>XML Path Language (XPath) 3.1 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><style type="text/css">
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
                       
pre.small { font-size: small }                       
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   padding: 4px; margin: 0em }
                   
div.exampleInner table { border: 0;
                         border-spacing: 0;
                       }
                   
div.exampleInner td { vertical-align: baseline;
                      padding: 0;
                    }
                   
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
                    
div.proto { border: 0;
            border-spacing: 0; 
          }

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
	    border-bottom-width: 1pt;
	    margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xsl-query.xsl (B) */    
table.small                             { 
                                          font-size: x-small; 
                                          border-collapse: collapse;
                                        }
table.small td                          { 
                                          border: 1px solid #000000;
                                          padding: 5px;
                                        }
table.small th                          { 
                                          border: 1px solid #000000;
                                          padding: 5px;
                                          text-align: center;
                                        }

table.medium                            { 
                                          font-size: smaller;
                                          border-collapse: collapse; 
                                        }
table.medium td                         { 
                                          border: 1px solid #000000;
                                          padding: 5px;
                                        }
table.medium th                         { 
                                          border: 1px solid #000000;
                                          padding: 5px;
                                          text-align: center;
                                        }
                                        
table.no-code-break code {
  white-space: nowrap;
}

table.longlastcol td {
  vertical-align: baseline;
  text-align: left;
}

a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                              	          color: black; 
                              	          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                              		        text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }</style><link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/2016/W3C-REC.css">
   </head>
   <body>
      <div class="head">
         <p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p>
         
         <h1><a id="title"></a>XML Path Language (XPath) 3.1 
         </h1>
         
         <h2><a id="w3c-doctype"></a>W3C Recommendation 21 March 2017
         </h2>
         <dl>
            <dt>This version:</dt>
            <dd>
               <a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-31-20170321/</a>
               
            </dd>
            <dt>Latest version of XPath 3.1:</dt>
            <dd>
               <a href="https://www.w3.org/TR/xpath-31/">https://www.w3.org/TR/xpath-31/</a>
               
            </dd>
            <dt>Previous versions of XPath 3.1:</dt>
            <dd><a href="https://www.w3.org/TR/2017/PR-xpath-31-20170117/">https://www.w3.org/TR/2017/PR-xpath-31-20170117/</a><br><a href="https://www.w3.org/TR/2016/CR-xpath-31-20161213/">https://www.w3.org/TR/2016/CR-xpath-31-20161213/</a><br><a href="https://www.w3.org/TR/2015/CR-xpath-31-20151217/">https://www.w3.org/TR/2015/CR-xpath-31-20151217/</a><br><a href="https://www.w3.org/TR/2014/CR-xpath-31-20141218/">https://www.w3.org/TR/2014/CR-xpath-31-20141218/</a><br><a href="https://www.w3.org/TR/2014/WD-xpath-31-20141007/">https://www.w3.org/TR/2014/WD-xpath-31-20141007/</a><br><a href="https://www.w3.org/TR/2014/WD-xpath-31-20140424/">https://www.w3.org/TR/2014/WD-xpath-31-20140424/</a></dd>
            <dt>Most recent version of XPath 3:</dt>
            <dd>
               <a href="https://www.w3.org/TR/xpath-3/">https://www.w3.org/TR/xpath-3/</a>
               
            </dd>
            <dt>Most recent version of XPath:</dt>
            <dd>
               <a href="https://www.w3.org/TR/xpath/">https://www.w3.org/TR/xpath/</a>
               
            </dd>
            <dt>Most recent Recommendation of XPath:</dt>
            <dd>
               <a href="https://www.w3.org/TR/2014/REC-xpath-30-20140408/">https://www.w3.org/TR/2014/REC-xpath-30-20140408/</a>
               
               
            </dd>
            <dt>Editors:</dt>
            <dd>Jonathan Robie, 
               <span>
                  <a href="http://jonathanrobie.biblicalhumanities.org">biblicalhumanities.org</a>
                  </span>
               <a href="mailto:jonathan.robie@biblicalhumanities.org">&lt;jonathan.robie@biblicalhumanities.org&gt;</a></dd>
            <dd>Michael Dyck, Invited Expert <a href="mailto:jmdyck@ibiblio.org">&lt;jmdyck@ibiblio.org&gt;</a></dd>
            <dd>Josh Spiegel, Oracle Corporation <a href="mailto:josh.spiegel@oracle.com">&lt;josh.spiegel@oracle.com&gt;</a></dd>
         </dl>
         <p>Please check the <a href="https://www.w3.org/XML/2017/qt-errata/xpath-31-errata.html"><strong>errata</strong></a> for any errors or issues reported since publication.
         </p>
         <p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-31"><strong>translations</strong></a>.
         </p>
         <p>This document is also available in these non-normative formats: <a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/xpath-31.xml">XML</a> and&nbsp;<a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/xpath-31-diff.html">Change markings relative to previous edition</a>.
         </p>
         <p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2017&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
         </p>
         <hr>
      </div>
      <div>
         
         <h2><a id="abstract"></a>Abstract
         </h2>
         <p class="xpath">
            
            XPath 3.1 is an expression language that allows the processing of
            values conforming to the data model defined in
            <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. The name of the language derives
            from its most distinctive feature, the path expression, which provides
            a means of hierarchic addressing of the nodes in an XML tree.  As well
            as modeling the tree structure of XML, the data model also includes
            atomic values, function items, and sequences.  This version of XPath
            supports JSON as well as XML, adding maps and arrays to the data model
            and supporting them with new expressions in the
            language and new functions in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.  
            These are the most important new features in XPath 3.1:
            
            
         </p>
         <ol class="enumar">
            <li>
               <p>
                  <a href="#id-maps"><b>3.11.1 Maps</b></a>.
               </p>
            </li>
            <li>
               <p>
                  <a href="#id-arrays"><b>3.11.2 Arrays</b></a>.
               </p>
            </li>
         </ol>
         <p class="xpath">
            
            XPath 3.1 is a superset of <a href="#xpath-30">[XML Path Language (XPath) Version 3.0]</a>. A detailed list of changes
            made since XPath 3.0 can be found in <a href="#id-revision-log"><b>I Change Log</b></a>. 
            
         </p>
      </div>
      <div>
         
         <h2><a id="status"></a>Status of this Document
         </h2>
         <p>
            <em>This section describes the status of this
               document at the time of its publication.
               Other documents may supersede this document.
               A list of current W3C publications and the latest
               revision of this technical report can be found in the
               <a href="https://www.w3.org/TR/">W3C technical reports index</a>
               at https://www.w3.org/TR/.</em>
            
         </p>
         <p>This document is governed by the
            <a id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/">1 March 2017 W3C Process Document</a>. 
         </p>
         <p>This is a <a href="https://www.w3.org/2015/Process-20150901/#rec-publication">Recommendation</a> of the W3C. 
            It was jointly developed by the W3C 
            <a href="https://www.w3.org/XML/Query/">XML Query Working Group</a> and the W3C <a href="https://www.w3.org/Style/XSL/">XSLT Working Group</a>, each of which is part of the <a href="https://www.w3.org/XML/Activity">XML Activity</a>.
         </p>
         <p>This Recommendation specifies XPath
            version 3.1, a fully compatible extension of <a href="https://www.w3.org/TR/xpath-30/">XPath version 3.0</a>.
            
         </p>
         <p>This specification is designed to be referenced normatively from
            other specifications defining a host language for it; it is not
            intended to be implemented outside a host language.  The
            implementability of this specification has been tested in the context
            of its normative inclusion in host languages defined by the
            <a href="https://www.w3.org/TR/xquery-31/">XQuery 3.1</a>
            and
            XSLT 3.0 (expected in 2017) specifications;
            see the
            <a href="https://dev.w3.org/2011/QT3-test-suite/ReportingResults31/report.html">XQuery 3.1 implementation report</a>
            (and, in the future, the WGs expect that there will also be an
            XSLT 3.0 implementation report) for details.
         </p>
         <p>No substantive changes have been made to this specification
            since its publication as a Proposed Recommendation.
         </p>
         <p>Please report errors in this document using W3C's
            <a href="https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
            (instructions can be found at
            <a href="https://www.w3.org/XML/2005/04/qt-bugzilla">https://www.w3.org/XML/2005/04/qt-bugzilla</a>).
            If access to that system is not feasible, you may send your comments
            to the W3C XSLT/XPath/XQuery public comments mailing list,
            <a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
            It will be very helpful if you include the string 
            “[XPath31]”
            in the subject line of your report, whether made in Bugzilla or in email.
            Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
            if you have more than one comment to make.
            Archives of the comments and responses are available at
            <a href="https://lists.w3.org/Archives/Public/public-qt-comments/">https://lists.w3.org/Archives/Public/public-qt-comments/</a>. 
         </p>
         <p>This document has been reviewed by W3C Members, by
            software developers, and by other W3C groups and interested parties,
            and is endorsed by the Director as a W3C Recommendation. 
            It is a stable document and may be used as reference material or cited from
            another document. 
            W3C's role in making the Recommendation is to draw attention to
            the specification and to promote its widespread deployment. 
            This enhances the functionality and interoperability of
            the Web.
         </p>
         <p>This document was produced by groups operating under the
            <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>.
            W3C maintains a <a href="https://www.w3.org/2004/01/pp-impl/18797/status#disclosures" rel="disclosure">public list of any 
               patent disclosures (W3C XML Query Working Group)</a> and a <a href="https://www.w3.org/2004/01/pp-impl/19552/status#disclosures" rel="disclosure">public list of any patent 
               disclosures (W3C XSLT Working Group)</a> made in connection with the deliverables of 
            each group; these pages also include instructions for disclosing a patent.
            An individual who has actual knowledge of a patent which the individual believes contains
            <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>
            must disclose the information in accordance with
            <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>. 
         </p>
      </div>
      <nav id="toc">
         
         <h2><a id="contents"></a>Table of Contents
         </h2>
         <ol class="toc">
            <li><a href="#id-introduction"><span class="secno">1 </span><span class="content">Introduction</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#id-basics"><span class="secno">2 </span><span class="content">Basics</span></a>
               
               <ol class="toc">
                  <li><a href="#context"><span class="secno">2.1 </span><span class="content">Expression Context</span></a><ol class="toc">
                        <li><a href="#static_context"><span class="secno">2.1.1 </span><span class="content">Static Context</span></a></li>
                        <li><a href="#eval_context"><span class="secno">2.1.2 </span><span class="content">Dynamic Context</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-processing-model"><span class="secno">2.2 </span><span class="content">Processing
                           Model</span></a><ol class="toc">
                        <li><a href="#id-data-model-generation"><span class="secno">2.2.1 </span><span class="content">Data Model Generation</span></a></li>
                        <li><a href="#id-schema-import-processing"><span class="secno">2.2.2 </span><span class="content">Schema Import Processing</span></a></li>
                        <li><a href="#id-expression-processing"><span class="secno">2.2.3 </span><span class="content">Expression
                                 Processing</span></a><a href="#id-static-analysis"><span class="secno">2.2.3.1 </span><span class="content">Static Analysis Phase</span></a>
                           <a href="#id-dynamic-evaluation"><span class="secno">2.2.3.2 </span><span class="content">Dynamic Evaluation Phase</span></a>
                           
                        </li>
                        <li><a href="#id-consistency-constraints"><span class="secno">2.2.4 </span><span class="content">Consistency Constraints</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#errors"><span class="secno">2.3 </span><span class="content">Error Handling</span></a><ol class="toc">
                        <li><a href="#id-kinds-of-errors"><span class="secno">2.3.1 </span><span class="content">Kinds of Errors</span></a></li>
                        <li><a href="#id-identifying-errors"><span class="secno">2.3.2 </span><span class="content">Identifying and Reporting Errors</span></a></li>
                        <li><a href="#id-handling-dynamic"><span class="secno">2.3.3 </span><span class="content">Handling Dynamic Errors</span></a></li>
                        <li><a href="#id-errors-and-opt"><span class="secno">2.3.4 </span><span class="content">Errors and
                                 Optimization</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-important-concepts"><span class="secno">2.4 </span><span class="content">Concepts</span></a><ol class="toc">
                        <li><a href="#id-document-order"><span class="secno">2.4.1 </span><span class="content">Document Order</span></a></li>
                        <li><a href="#id-atomization"><span class="secno">2.4.2 </span><span class="content">Atomization</span></a></li>
                        <li><a href="#id-ebv"><span class="secno">2.4.3 </span><span class="content">Effective Boolean Value</span></a></li>
                        <li><a href="#id-input-sources"><span class="secno">2.4.4 </span><span class="content">Input Sources</span></a></li>
                        <li><a href="#id-uri-literals"><span class="secno">2.4.5 </span><span class="content">URI Literals</span></a></li>
                        <li><a href="#id-resolve-relative-uri"><span class="secno">2.4.6 </span><span class="content">Resolving a Relative URI Reference</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-types"><span class="secno">2.5 </span><span class="content">Types</span></a><ol class="toc">
                        <li><a href="#id-predefined-types"><span class="secno">2.5.1 </span><span class="content">Predefined Schema Types</span></a></li>
                        <li><a href="#id-namespace-sensitive"><span class="secno">2.5.2 </span><span class="content">Namespace-sensitive Types</span></a></li>
                        <li><a href="#id-typed-value"><span class="secno">2.5.3 </span><span class="content">Typed Value and String Value</span></a></li>
                        <li><a href="#id-sequencetype-syntax"><span class="secno">2.5.4 </span><span class="content">SequenceType Syntax</span></a></li>
                        <li><a href="#id-sequencetype-matching"><span class="secno">2.5.5 </span><span class="content">SequenceType Matching</span></a><a href="#id-matching-value"><span class="secno">2.5.5.1 </span><span class="content">Matching a SequenceType and a Value</span></a>
                           <a href="#id-matching-item"><span class="secno">2.5.5.2 </span><span class="content">Matching an ItemType and an Item</span></a>
                           <a href="#id-element-test"><span class="secno">2.5.5.3 </span><span class="content">Element Test</span></a>
                           <a href="#id-schema-element-test"><span class="secno">2.5.5.4 </span><span class="content">Schema Element Test</span></a>
                           <a href="#id-attribute-test"><span class="secno">2.5.5.5 </span><span class="content">Attribute Test</span></a>
                           <a href="#id-schema-attribute-test"><span class="secno">2.5.5.6 </span><span class="content">Schema Attribute Test</span></a>
                           <a href="#id-function-test"><span class="secno">2.5.5.7 </span><span class="content">Function Test</span></a>
                           <a href="#id-map-test"><span class="secno">2.5.5.8 </span><span class="content">Map Test</span></a>
                           <a href="#id-array-test"><span class="secno">2.5.5.9 </span><span class="content">Array Test</span></a>
                           
                        </li>
                        <li><a href="#id-sequencetype-subtype"><span class="secno">2.5.6 </span><span class="content">SequenceType Subtype Relationships</span></a><a href="#id-seqtype-subtype"><span class="secno">2.5.6.1 </span><span class="content">The judgement subtype(A, B)
                                 </span></a>
                           <a href="#id-itemtype-subtype"><span class="secno">2.5.6.2 </span><span class="content">The judgement subtype-itemtype(Ai, Bi) 
                                 </span></a>
                           
                        </li>
                        <li><a href="#id-xs-error"><span class="secno">2.5.7 </span><span class="content">xs:error</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#comments"><span class="secno">2.6 </span><span class="content">Comments</span></a></li>
               </ol>
            </li>
            <li><a href="#id-expressions"><span class="secno">3 </span><span class="content">Expressions</span></a>
               
               <ol class="toc">
                  <li><a href="#id-primary-expressions"><span class="secno">3.1 </span><span class="content">Primary Expressions</span></a><ol class="toc">
                        <li><a href="#id-literals"><span class="secno">3.1.1 </span><span class="content">Literals</span></a></li>
                        <li><a href="#id-variables"><span class="secno">3.1.2 </span><span class="content">Variable References</span></a></li>
                        <li><a href="#id-paren-expressions"><span class="secno">3.1.3 </span><span class="content">Parenthesized Expressions</span></a></li>
                        <li><a href="#id-context-item-expression"><span class="secno">3.1.4 </span><span class="content">Context Item Expression</span></a></li>
                        <li><a href="#id-function-calls"><span class="secno">3.1.5 </span><span class="content">Static Function Calls</span></a><a href="#id-eval-function-call"><span class="secno">3.1.5.1 </span><span class="content">Evaluating Static and Dynamic Function Calls</span></a>
                           <a href="#id-function-conversion-rules"><span class="secno">3.1.5.2 </span><span class="content">Function Conversion Rules</span></a>
                           <a href="#id-function-coercion"><span class="secno">3.1.5.3 </span><span class="content">Function Coercion</span></a>
                           
                        </li>
                        <li><a href="#id-named-function-ref"><span class="secno">3.1.6 </span><span class="content">Named Function References</span></a></li>
                        <li><a href="#id-inline-func"><span class="secno">3.1.7 </span><span class="content">Inline Function Expressions</span></a></li>
                        <li><a href="#id-enclosed-expr"><span class="secno">3.1.8 </span><span class="content">Enclosed Expressions</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-postfix-expression"><span class="secno">3.2 </span><span class="content">Postfix Expressions</span></a><ol class="toc">
                        <li><a href="#id-filter-expression"><span class="secno">3.2.1 </span><span class="content">Filter Expressions</span></a></li>
                        <li><a href="#id-dynamic-function-invocation"><span class="secno">3.2.2 </span><span class="content">Dynamic Function Calls</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-path-expressions"><span class="secno">3.3 </span><span class="content">Path Expressions</span></a><ol class="toc">
                        <li><a href="#id-relative-path-expressions"><span class="secno">3.3.1 </span><span class="content">Relative Path Expressions</span></a><a href="#id-path-operator"><span class="secno">3.3.1.1 </span><span class="content">Path operator (/)</span></a>
                           
                        </li>
                        <li><a href="#id-steps"><span class="secno">3.3.2 </span><span class="content">Steps</span></a><a href="#axes"><span class="secno">3.3.2.1 </span><span class="content">Axes</span></a>
                           <a href="#node-tests"><span class="secno">3.3.2.2 </span><span class="content">Node Tests</span></a>
                           
                        </li>
                        <li><a href="#id-predicate"><span class="secno">3.3.3 </span><span class="content">Predicates within Steps</span></a></li>
                        <li><a href="#unabbrev"><span class="secno">3.3.4 </span><span class="content">Unabbreviated Syntax</span></a></li>
                        <li><a href="#abbrev"><span class="secno">3.3.5 </span><span class="content">Abbreviated Syntax</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-sequence-expressions"><span class="secno">3.4 </span><span class="content">Sequence Expressions</span></a><ol class="toc">
                        <li><a href="#construct_seq"><span class="secno">3.4.1 </span><span class="content">Constructing Sequences</span></a></li>
                        <li><a href="#combining_seq"><span class="secno">3.4.2 </span><span class="content">Combining Node Sequences</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-arithmetic"><span class="secno">3.5 </span><span class="content">Arithmetic Expressions</span></a></li>
                  <li><a href="#id-string-concat-expr"><span class="secno">3.6 </span><span class="content">String Concatenation Expressions</span></a></li>
                  <li><a href="#id-comparisons"><span class="secno">3.7 </span><span class="content">Comparison Expressions</span></a><ol class="toc">
                        <li><a href="#id-value-comparisons"><span class="secno">3.7.1 </span><span class="content">Value Comparisons</span></a></li>
                        <li><a href="#id-general-comparisons"><span class="secno">3.7.2 </span><span class="content">General Comparisons</span></a></li>
                        <li><a href="#id-node-comparisons"><span class="secno">3.7.3 </span><span class="content">Node Comparisons</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-logical-expressions"><span class="secno">3.8 </span><span class="content">Logical Expressions</span></a></li>
                  <li><a href="#id-for-expressions"><span class="secno">3.9 </span><span class="content">For Expressions</span></a></li>
                  <li><a href="#id-let-expressions"><span class="secno">3.10 </span><span class="content">Let Expressions</span></a></li>
                  <li><a href="#id-maps-and-arrays"><span class="secno">3.11 </span><span class="content">Maps and Arrays</span></a><ol class="toc">
                        <li><a href="#id-maps"><span class="secno">3.11.1 </span><span class="content">Maps</span></a><a href="#id-map-constructors"><span class="secno">3.11.1.1 </span><span class="content">Map Constructors</span></a>
                           <a href="#id-map-lookup"><span class="secno">3.11.1.2 </span><span class="content">Map Lookup using Function Call Syntax</span></a>
                           
                        </li>
                        <li><a href="#id-arrays"><span class="secno">3.11.2 </span><span class="content">Arrays</span></a><a href="#id-array-constructors"><span class="secno">3.11.2.1 </span><span class="content">Array Constructors</span></a>
                           <a href="#id-array-lookup"><span class="secno">3.11.2.2 </span><span class="content">Array Lookup using Function Call Syntax</span></a>
                           
                        </li>
                        <li><a href="#id-lookup"><span class="secno">3.11.3 </span><span class="content">The Lookup Operator ("?") for Maps and Arrays</span></a><a href="#id-unary-lookup"><span class="secno">3.11.3.1 </span><span class="content">Unary Lookup</span></a>
                           <a href="#id-postfix-lookup"><span class="secno">3.11.3.2 </span><span class="content">Postfix Lookup</span></a>
                           
                        </li>
                     </ol>
                  </li>
                  <li><a href="#id-conditionals"><span class="secno">3.12 </span><span class="content">Conditional Expressions</span></a></li>
                  <li><a href="#id-quantified-expressions"><span class="secno">3.13 </span><span class="content">Quantified Expressions</span></a></li>
                  <li><a href="#id-expressions-on-datatypes"><span class="secno">3.14 </span><span class="content">Expressions on SequenceTypes</span></a><ol class="toc">
                        <li><a href="#id-instance-of"><span class="secno">3.14.1 </span><span class="content">Instance Of</span></a></li>
                        <li><a href="#id-cast"><span class="secno">3.14.2 </span><span class="content">Cast</span></a></li>
                        <li><a href="#id-castable"><span class="secno">3.14.3 </span><span class="content">Castable</span></a></li>
                        <li><a href="#id-constructor-functions"><span class="secno">3.14.4 </span><span class="content">Constructor Functions</span></a></li>
                        <li><a href="#id-treat"><span class="secno">3.14.5 </span><span class="content">Treat</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-map-operator"><span class="secno">3.15 </span><span class="content">Simple map operator (!)</span></a></li>
                  <li><a href="#id-arrow-operator"><span class="secno">3.16 </span><span class="content">Arrow operator (=&gt;)</span></a></li>
               </ol>
            </li>
            <li><a href="#id-conformance"><span class="secno">4 </span><span class="content">Conformance</span></a>
               
               <ol class="toc">
                  <li><a href="#id-xpath-static-typing"><span class="secno">4.1 </span><span class="content">Static Typing Feature</span></a></li>
               </ol>
            </li>
            <li><a href="#nt-bnf"><span class="secno">A </span><span class="content">XPath 3.1 Grammar</span></a>
               
               <ol class="toc">
                  <li><a href="#id-grammar"><span class="secno">A.1 </span><span class="content">EBNF</span></a><ol class="toc">
                        <li><a href="#EBNFNotation"><span class="secno">A.1.1 </span><span class="content">Notation</span></a></li>
                        <li><a href="#extra-grammatical-constraints"><span class="secno">A.1.2 </span><span class="content">Extra-grammatical Constraints</span></a></li>
                        <li><a href="#notes-on-parsing"><span class="secno">A.1.3 </span><span class="content">Grammar Notes</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#lexical-structure"><span class="secno">A.2 </span><span class="content">Lexical structure</span></a><ol class="toc">
                        <li><a href="#terminal-symbols"><span class="secno">A.2.1 </span><span class="content">Terminal Symbols</span></a></li>
                        <li><a href="#id-terminal-delimitation"><span class="secno">A.2.2 </span><span class="content">Terminal Delimitation</span></a></li>
                        <li><a href="#id-eol-handling"><span class="secno">A.2.3 </span><span class="content">End-of-Line Handling</span></a><a href="#id-xml10-eol-handling"><span class="secno">A.2.3.1 </span><span class="content">XML 1.0 End-of-Line Handling</span></a>
                           <a href="#id-xml11-eol-handling"><span class="secno">A.2.3.2 </span><span class="content">XML 1.1 End-of-Line Handling</span></a>
                           
                        </li>
                        <li><a href="#whitespace-rules"><span class="secno">A.2.4 </span><span class="content">Whitespace Rules</span></a><a href="#DefaultWhitespaceHandling"><span class="secno">A.2.4.1 </span><span class="content">Default Whitespace Handling</span></a>
                           <a href="#ExplicitWhitespaceHandling"><span class="secno">A.2.4.2 </span><span class="content">Explicit Whitespace Handling</span></a>
                           
                        </li>
                     </ol>
                  </li>
                  <li><a href="#id-reserved-fn-names"><span class="secno">A.3 </span><span class="content">Reserved Function Names</span></a></li>
                  <li><a href="#id-precedence-order"><span class="secno">A.4 </span><span class="content">Precedence Order (Non-Normative)</span></a></li>
               </ol>
            </li>
            <li><a href="#id-type-promotion-and-operator-mapping"><span class="secno">B </span><span class="content">Type Promotion and Operator Mapping</span></a>
               
               <ol class="toc">
                  <li><a href="#promotion"><span class="secno">B.1 </span><span class="content">Type Promotion</span></a></li>
                  <li><a href="#mapping"><span class="secno">B.2 </span><span class="content">Operator Mapping</span></a></li>
               </ol>
            </li>
            <li><a href="#id-xp-context-components"><span class="secno">C </span><span class="content">Context Components</span></a>
               
               <ol class="toc">
                  <li><a href="#id-xp-static-context-components"><span class="secno">C.1 </span><span class="content">Static Context
                           Components</span></a></li>
                  <li><a href="#id-xp-evaluation-context-components"><span class="secno">C.2 </span><span class="content">Dynamic Context Components</span></a></li>
               </ol>
            </li>
            <li><a href="#id-impl-defined-items"><span class="secno">D </span><span class="content">Implementation-Defined Items</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#id-references"><span class="secno">E </span><span class="content">References</span></a>
               
               <ol class="toc">
                  <li><a href="#id-normative-references"><span class="secno">E.1 </span><span class="content">Normative References</span></a></li>
                  <li><a href="#id-non-normative-references"><span class="secno">E.2 </span><span class="content">Non-normative References</span></a></li>
                  <li><a href="#id-background-material"><span class="secno">E.3 </span><span class="content">Background Material</span></a></li>
               </ol>
            </li>
            <li><a href="#id-errors"><span class="secno">F </span><span class="content">Error Conditions</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#id-glossary"><span class="secno">G </span><span class="content">Glossary</span></a> (Non-Normative)
               <ol class="toc"></ol>
            </li>
            <li><a href="#id-incompatibilities"><span class="secno">H </span><span class="content">Backwards Compatibility</span></a> (Non-Normative)
               <ol class="toc">
                  <li><a href="#d2e24209"><span class="secno">H.1 </span><span class="content">Incompatibilities relative to XPath 3.0</span></a></li>
                  <li><a href="#d2e24229"><span class="secno">H.2 </span><span class="content">Incompatibilities relative to XPath 2.0
                           </span></a></li>
                  <li><a href="#id-backwards-compatibility"><span class="secno">H.3 </span><span class="content">Incompatibilities relative to XPath 1.0</span></a><ol class="toc">
                        <li><a href="#id-incompat-in-true-mode"><span class="secno">H.3.1 </span><span class="content">Incompatibilities when Compatibility Mode is true</span></a></li>
                        <li><a href="#id-incompat-in-false-mode"><span class="secno">H.3.2 </span><span class="content">Incompatibilities when Compatibility Mode is false</span></a></li>
                        <li><a href="#id-incompat-when-using-schema"><span class="secno">H.3.3 </span><span class="content">Incompatibilities when using a Schema</span></a></li>
                     </ol>
                  </li>
               </ol>
            </li>
            <li><a href="#id-revision-log"><span class="secno">I </span><span class="content">Change Log</span></a> (Non-Normative)
               <ol class="toc">
                  <li><a href="#id-changes-since-2CR"><span class="secno">I.1 </span><span class="content">Changes since the Candidate Recommendation of 17 December 2015</span></a><ol class="toc">
                        <li><a href="#d2e24816"><span class="secno">I.1.1 </span><span class="content">Substantive Changes</span></a></li>
                        <li><a href="#d2e24900"><span class="secno">I.1.2 </span><span class="content">Editorial Changes</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#d2e25025"><span class="secno">I.2 </span><span class="content">Changes introduced in the Candidate Recommendation of 17 December 2015</span></a><ol class="toc">
                        <li><a href="#id-changes-2CR-substantive"><span class="secno">I.2.1 </span><span class="content">Substantive Changes</span></a></li>
                        <li><a href="#id-changes-PR-editorial"><span class="secno">I.2.2 </span><span class="content">Editorial Changes</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#d2e25263"><span class="secno">I.3 </span><span class="content">Changes introduced in the Candidate Recommendation of 18 December 2014</span></a><ol class="toc">
                        <li><a href="#id-changes-CR-substantive"><span class="secno">I.3.1 </span><span class="content">Substantive Changes</span></a></li>
                        <li><a href="#id-changes-CR-editorial"><span class="secno">I.3.2 </span><span class="content">Editorial Changes</span></a></li>
                     </ol>
                  </li>
                  <li><a href="#id-changes-prior-drafts"><span class="secno">I.4 </span><span class="content">Changes introduced in prior Working Drafts</span></a></li>
               </ol>
            </li>
         </ol>
      </nav>
      <hr>
      <div class="body">
         <div class="div1">
            
            <h2><a id="id-introduction"></a>1 Introduction
            </h2>
            <p class="xpath">The primary purpose of XPath is to address the nodes of <span>XML</span> trees <span>and JSON trees</span>. 
               		XPath gets its name from its use of a path notation for
               		navigating through the hierarchical structure of an XML document. XPath uses a compact,
               		non-XML syntax to facilitate use of XPath within URIs and XML attribute values.
               <span>XPath 3.1 adds a similar syntax for navigating JSON trees</span>. 
            </p>
            <p>
               		          [<a id="dt-datamodel" title="data model">Definition</a>: XPath 3.1 operates on the abstract, logical
               			structure of an XML document <span>or JSON object</span>, rather than its surface syntax. This logical structure,
               			known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>.]
               	        
            </p>
            <p class="xpath">
               XPath is designed to be embedded in a host language such as
               <a href="#xslt-30">[XSL Transformations (XSLT) Version 3.0]</a> or <a href="#xquery-31">[XQuery 3.1: An XML Query Language]</a>.
               [<a id="dt-host-language" title="host-language">Definition</a>: 
               A <b>host language</b> for XPath is a language or
               specification that incorporates XPath as a sublanguage and
               that defines how the static and dynamic context for
               evaluation of XPath expressions are to be
               established.]
               
            </p>
            <p>
               
               <span class="xpath">XPath 3.1 is a subset of XQuery 3.1.</span>
               
               In general, any expression that is
               		syntactically valid and executes successfully in both <span>XPath 3.1 and XQuery 3.1</span> will return
               		the same result in both languages. There are a few exceptions to this rule: 
            </p>
            <ul>
               <li>
                  <p>Because XQuery expands 
                     					<span class="xpath"> predefined entity references and character references
                        					</span> and XPath does not, expressions containing these produce different
                     					results in the two languages. For instance, the value of the string literal
                     						<code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery,
                     					and <code>&amp;amp;</code> in XPath. (XPath is often embedded in other
                     					languages, which may expand predefined entity references or character references
                     					before the XPath expression is evaluated.)
                  </p>
               </li>
               <li>
                  <p>If XPath 1.0 compatibility mode is enabled, XPath behaves differently from
                     					XQuery in a number of ways, <span class="xpath">which are noted throughout this
                        						document, and listed in <a href="#id-incompat-in-false-mode"><b>H.3.2 Incompatibilities when Compatibility Mode is false</b></a>.</span>
                     					             
                  </p>
               </li>
            </ul>
            <p>Because these languages are so closely related, their grammars and language descriptions
               are
               		generated from a common source to ensure consistency, and the editors of these
               		specifications work together closely.
            </p>
            <p>XPath 3.1 also depends on and is closely related to the following specifications:</p>
            <ul>
               <li>
                  <p>
                     <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> defines the data model that underlies all
                     				XPath 3.1 expressions.
                  </p>
               </li>
               <li>
                  <p>The type system of XPath 3.1 is based on XML Schema. It is implementation-defined
                     				whether the type system is based on <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.
                  </p>
               </li>
               <li>
                  <p>The built-in function library and the operators supported by XPath 3.1 are defined
                     				in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                  </p>
               </li>
            </ul>
            <p>This document specifies a grammar for XPath 3.1, using the same basic EBNF notation
               used in
               			<a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical structure</b></a>),
               		whitespace is not significant in <span class="xpath">expressions</span>. Grammar productions are introduced together with the features
               		that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A XPath 3.1 Grammar</b></a>]. The appendix is the normative version.
            </p>
            <p>In the grammar productions in this document, named symbols are underlined and literal
               text is
               		enclosed in double quotes. For example, the following productions describe the syntax
               of a
               		static function call:
            </p>
            <a id="d2e389"></a><table class="scrap">
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="noid_d3e390.doc-xpath31-FunctionCall"></a>[63]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code>FunctionCall</code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-EQName">EQName</a>  
                           <a href="#doc-xpath31-ArgumentList">ArgumentList</a>
                           </code></td>
                     <td><i>/* 
                           <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a>
                           */</i></td>
                  </tr>
                  <tr style="vertical-align:baseline;">
                     <td></td>
                     <td></td>
                     <td></td>
                     <td></td>
                     <td><i>/* 
                           <a href="#parse-note-parens">gn: parens</a>
                           */</i></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="noid_d3e391.doc-xpath31-ArgumentList"></a>[50]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code>ArgumentList</code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>"("  (<a href="#doc-xpath31-Argument">Argument</a>  (","  <a href="#doc-xpath31-Argument">Argument</a>)*)?  ")"</code></td>
                     <td></td>
                  </tr>
               </tbody>
            </table>
            <p>The productions should be read as follows: A function call consists of an <a href="#doc-xpath31-EQName">EQName</a> followed by an <a href="#doc-xpath31-ArgumentList">ArgumentList</a>. The
               		argument list consists of an opening parenthesis, an optional list of one or more
               arguments
               		(separated by commas), and a closing parenthesis.
            </p>
            <p>This document normatively defines the static and dynamic semantics of XPath 3.1. In
               this
               		document, examples and material labeled as "Note" are provided for explanatory purposes
               and
               		are not normative.
            </p>
            <p>Certain aspects of language processing are described in this specification as
               			<b>implementation-defined</b> or <b>implementation-dependent</b>.
            </p>
            <ul>
               <li>
                  <p>
                     				              [<a id="dt-implementation-defined" title="implementation defined">Definition</a>: 
                     <b>Implementation-defined</b> indicates an aspect that may differ
                     					between implementations, but must be specified by the implementor for each
                     					particular implementation.]
                     			            
                  </p>
               </li>
               <li>
                  <p>
                     				              [<a id="dt-implementation-dependent" title="implementation   dependent">Definition</a>: 
                     <b>Implementation-dependent</b> indicates an aspect that may differ
                     					between implementations, is not specified by this or any W3C specification, and
                     					is not required to be specified by the implementor for any particular
                     					implementation.]
                     			            
                  </p>
               </li>
            </ul>
            <p class="xpath">A language aspect described in this specification as
               			<b>implementation-defined</b> or <b>implementation dependent</b> may be
               		further constrained by the specifications of a host language in which XPath is embedded.
            </p>
         </div>
         <div class="div1">
            
            <h2><a id="id-basics"></a>2 Basics
            </h2>
            <p>The basic  building block of XPath 3.1 is the
               	 <b>expression</b>, which is a string of <a href="#Unicode">[Unicode]</a> characters; the version of Unicode to be used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
               	 The language provides several kinds of expressions which may be constructed
               	 from keywords, symbols, and operands. In general, the operands of an expression
               	 are other expressions. XPath 3.1 allows expressions to be nested with full
               generality. 
            </p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>This specification contains no
                  assumptions or requirements regarding the character set encoding of strings
                  of <a href="#Unicode">[Unicode]</a> characters.
               </p>
            </div>
            <p>Like XML, XPath 3.1 is a case-sensitive language. Keywords in
               	 XPath 3.1 use lower-case characters and are not reserved—that is, names in XPath
               3.1 expressions are allowed to be the same as language keywords, except for certain
               unprefixed function-names listed in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.
            </p>
            <p>
               [<a id="dt-value" title="value">Definition</a>: In the <a title="data model" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" href="#dt-sequence">sequence</a>.] 
               [<a id="dt-sequence" title="sequence">Definition</a>: A
               <b>sequence</b> is an ordered collection of zero or more
               <a title="item" href="#dt-item">items</a>.]
               [<a id="dt-item" title="item">Definition</a>: 
               An <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a>, a <a title="node" href="#dt-node">node</a>,
               or a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.]
               [<a id="dt-atomic-value" title="atomic value">Definition</a>: An <b>atomic
                  	 value</b> is a value in the value space of an <b>atomic
                  	 type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a>  or <a href="#XMLSchema11">[XML Schema 1.1]</a>.]
               [<a id="dt-node" title="node">Definition</a>: A <b>node</b> is an instance of one of the
               	  <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section 
                  
                  6 Nodes
                  </a><sup><small>DM31</small></sup>.]
               Each node has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some nodes have a <b>name</b>. The <b>typed value</b> of a node is a sequence
               	 of zero or more atomic values. The <b>string value</b> of a node is a
               	 value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.
            </p>
            <p>
               [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a
               	 <b>singleton</b>.] An item is identical to a singleton sequence
               	 containing that item. Sequences are never nested—for example, combining the
               	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
               	 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: A sequence containing zero items is called an <b>empty sequence</b>.]
               
            </p>
            <p>
               [<a id="dt-data-model-instance" title="XDM instance">Definition</a>: The term <b>XDM instance</b> is used,
               synonymously with the term <a title="value" href="#dt-value">value</a>, to denote an unconstrained
               <a title="sequence" href="#dt-sequence">sequence</a> of <a title="item" href="#dt-item">items</a>.]
               
               
            </p>
            <p>Element nodes have a property called <b>in-scope namespaces</b>. [<a id="dt-in-scope-namespaces" title="in-scope namespaces">Definition</a>: The <b>in-scope namespaces</b> property of an element node is a set of namespace bindings, each of which associates
               a namespace prefix with a URI.]
               For a given element, one namespace binding may have an empty prefix; the URI of this
               namespace binding is the default namespace within the scope of the element.
            </p>
            <p class="xpath">In <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>. 
               As of XPath 2.0, the namespace axis is deprecated and need not be supported by a host
               language. A host language that does not support the namespace axis need not represent
               namespace bindings in the form of nodes.
            </p>
            <p>
               [<a id="dt-expanded-qname" title="expanded QName">Definition</a>: An <b>expanded QName</b> is a
               triple: its components are a prefix, a local name, and a
               namespace URI. In the case of a name in no namespace, the
               namespace URI and prefix are both absent. In the case of a name
               in the default namespace, the prefix is absent.] When
               comparing two expanded QNames, the prefixes are ignored: the
               local name parts must be equal under the Unicode Codepoint
               Collation, and the namespace URI parts must either both be
               absent, or must be equal under the Unicode Codepoint
               Collation.
            </p>
            <p>In the 
               <span class="xpath">XPath</span> 
               grammar, QNames representing the names of
               elements, attributes, functions, variables, types, or other such
               constructs are written as instances of the grammatical
               production <a href="#doc-xpath31-EQName">EQName</a>.
            </p>
            <a id="d2e682"></a><table class="scrap">
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-EQName"></a>[112]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-QName">QName</a>  |  <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a>
                           </code></td>
                     <td></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-QName"></a>[122]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-QName">QName</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="https://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup>
                           </code></td>
                     <td><i>/* 
                           <a href="#parse-note-xml-version">xgc: xml-version</a>
                           */</i></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="noid_d3e655.doc-xpath31-NCName"></a>[123]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code>NCName</code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup>
                           </code></td>
                     <td><i>/* 
                           <a href="#parse-note-xml-version">xgc: xml-version</a>
                           */</i></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-URIQualifiedName"></a>[117]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a>  
                           <a href="#prod-xpath31-NCName">NCName</a>
                           </code></td>
                     <td><i>/* 
                           <a href="#ws-explicit">ws: explicit</a>
                           */</i></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-BracedURILiteral"></a>[118]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>"Q"  "{"  [^{}]*  "}"</code></td>
                     <td><i>/* 
                           <a href="#ws-explicit">ws: explicit</a>
                           */</i></td>
                  </tr>
               </tbody>
            </table>
            <p>The <a href="#doc-xpath31-EQName">EQName</a> production allows a QName to
               be written in one of three ways:
               
            </p>
            <ul>
               <li>
                  <p>local-name only (for example, <code>invoice</code>).
                  </p>
                  <p>A name written in this form has no prefix, and the rules
                     for determining the namespace depend on the context in which
                     the name appears. This form is a <a title="lexical QName" href="#dt-qname">lexical QName</a>.
                  </p>
               </li>
               <li>
                  <p>prefix plus local-name (for example, <code>my:invoice</code>).
                  </p>
                  <p>In this case the prefix and local name of the QName are as
                     written, and the namespace URI is inferred from the prefix by
                     examining the in-scope namespaces in the static context where
                     the QName appears; the context must include a binding for the
                     prefix. This form is a <a title="lexical QName" href="#dt-qname">lexical
                        QName</a>.
                  </p>
               </li>
               <li>
                  <p>URI plus local-name (for example,
                     <code>Q{http://example.com/ns}invoice)</code>.
                  </p>
                  <p>In this case the local name and namespace URI are as
                     written, and the prefix is absent. This way of writing a QName
                     is context-free, which makes it particularly suitable for use
                     in  
                     <span class="xpath">expressions</span>
                     that are generated by software. This
                     form is a <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a>.  
                     <span>If the <a href="#doc-xpath31-BracedURILiteral">
                           BracedURILiteral</a> has no content (for example, <code>Q{}invoice</code>) 
                        then the namespace URI of the QName is absent.</span>
                     
                  </p>
               </li>
            </ul>
            <p>
               <span>
                  
                  [<a id="dt-qname" title="lexical QName">Definition</a>: A
                  <b>lexical QName</b> is a name that conforms to the syntax of the
                  <a href="#doc-xpath31-QName">QName</a> production].
                  </span>
               
            </p>
            <p>
               	  The namespace URI value in a <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a> is whitespace normalized according
               	  to the rules for the <code>xs:anyURI</code> type in
               <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 
                  
                  3.2.17 anyURI
                  </a><sup><small>XS1-2</small></sup> or 
               <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 
                  
                  3.3.17 anyURI
                  </a><sup><small>XS11-2</small></sup>. 
               
               It is a <a title="static error" href="#dt-static-error">static
                  error</a> 
               [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>] if the
               namespace URI for an EQName is
               <code>http://www.w3.org/2000/xmlns/</code>.
               
            </p>
            <p>Here are some examples of <a href="#doc-xpath31-EQName">EQName</a>s:
            </p>
            <ul>
               <li>
                  <p>
                     <code>pi</code> is a <a title="lexical QName" href="#dt-qname">lexical QName</a> without a namespace prefix.
                  </p>
               </li>
               <li>
                  <p>
                     <code>math:pi</code> is a <a title="lexical QName" href="#dt-qname">lexical QName</a> with a namespace prefix.
                  </p>
               </li>
               <li>
                  <p>
                     <code>Q{http://www.w3.org/2005/xpath-functions/math}pi</code> specifies the namespace URI using a  <a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a>; it is not a  <a title="lexical QName" href="#dt-qname">lexical QName</a>.
                  </p>
               </li>
            </ul>
            <p>This document uses the following namespace prefixes to represent the namespace URIs
               with which they are listed. Although these prefixes are used within this specification
               to refer to the corresponding namespaces, not all of these bindings will necessarily
               be present in the static context of every expression, and authors are free to use
               different prefixes for these namespaces, or to bind these prefixes to different namespaces.
            </p>
            <ul>
               <li>
                  <p>
                     <code>xs = http://www.w3.org/2001/XMLSchema</code>
                     
                  </p>
               </li>
               <li>
                  <p>
                     <code>fn = http://www.w3.org/2005/xpath-functions</code>
                     
                  </p>
               </li>
               <li>
                  <p>
                     <code>map = http://www.w3.org/2005/xpath-functions/map</code>
                     
                  </p>
               </li>
               <li>
                  <p>
                     <code>array = http://www.w3.org/2005/xpath-functions/array</code>
                     
                  </p>
               </li>
               <li>
                  <p>
                     <code>math = http://www.w3.org/2005/xpath-functions/math</code>
                     
                  </p>
               </li>
               <li>
                  <p>
                     <code>err = http://www.w3.org/2005/xqt-errors</code> (see <a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting Errors</b></a>).
                  </p>
               </li>
            </ul>
            <p>
               [<a id="dt-URI" title="URI">Definition</a>: Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.]
               The term URI has been retained in preference to IRI to avoid introducing new names
               for concepts such as "Base URI" that are defined or referenced across the whole family
               of XML specifications.
            </p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>In most contexts, processors are not required to raise errors if a URI is not lexically
                  valid according to  <a href="#RFC3986">[RFC3986]</a> and  <a href="#RFC3987">[RFC3987]</a>. See <a href="#id-uri-literals"><b>2.4.5 URI Literals</b></a> for details.
               </p>
            </div>
            <div class="div2">
               
               <h3><a id="context"></a>2.1 Expression Context
               </h3>
               <p>
                  [<a id="dt-expression-context" title="expression context">Definition</a>: The <b>expression
                     		context</b> for a given expression consists of all
                  		the information that can affect the result of the
                  		expression.]
                  
               </p>
               <p>This information is organized into two categories
                  		called the <a title="static context" href="#dt-static-context">static
                     		context</a> and the <a title="dynamic context" href="#dt-dynamic-context">dynamic
                     		context</a>.
               </p>
               <div class="div3">
                  
                  <h4><a id="static_context"></a>2.1.1 Static Context
                  </h4>
                  <p>
                     [<a id="dt-static-context" title="static context">Definition</a>: The <b>static context</b> of an expression is
                     		  the information that is available during static analysis of the expression, prior
                     		  to its evaluation.] This information can be used to decide whether the
                     		  expression contains a <a title="static error" href="#dt-static-error">static error</a>. 
                  </p>
                  <p>The individual components of the <a title="static context" href="#dt-static-context">static context</a> are described below. 
                     <span class="xpath">A default initial value for each component must be specified by the host language.
                        
                        The scope of each component is specified in <a href="#id-xp-static-context-components"><b>C.1 Static Context
                              Components</b></a>.</span>
                     
                  </p>
                  <ul>
                     <li>
                        <p>
                           [<a id="dt-xpath-compat-mode" title="XPath 1.0 compatibility     mode">Definition</a>: 
                           <b>XPath 1.0 compatibility
                              			 mode.</b>  
                           <span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise
                              it is <code>false</code>.</span>
                           ]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-static-namespaces" title="statically known namespaces">Definition</a>: 
                           <b>Statically known namespaces.</b> 
                           This is a mapping from prefix to namespace URI that defines all the namespaces that
                           are known during static processing of a given expression.] The URI value is
                           whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 
                              
                              3.2.17 anyURI
                              </a><sup><small>XS1-2</small></sup> or 
                           <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 
                              
                              3.3.17 anyURI
                              </a><sup><small>XS11-2</small></sup>. Note the difference between <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-def-elemtype-ns" title="default element/type namespace">Definition</a>: 
                           <b>Default element/type namespace.</b> This is a
                           				namespace URI or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a
                           				position where an element or type name is expected.] The URI value is
                           whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 
                              
                              3.2.17 anyURI
                              </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 
                              
                              3.3.17 anyURI
                              </a><sup><small>XS11-2</small></sup>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-def-fn-ns" title="default function namespace">Definition</a>: 
                           <b>Default function namespace.</b> This is a
                           				namespace URI or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position
                           where a function name is expected.] The URI value is
                           whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 
                              
                              3.2.17 anyURI
                              </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 
                              
                              3.3.17 anyURI
                              </a><sup><small>XS11-2</small></sup>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-issd" title="in-scope schema definitions">Definition</a>: 
                           <b>In-scope schema
                              			 definitions.</b> This is a generic term
                           			 for all the element declarations, attribute declarations, and schema type
                           			 definitions that are in scope during
                           			 static analysis of an expression.] It includes the
                           			 following three
                           			 parts:
                        </p>
                        <ul>
                           <li>
                              <p>
                                 
                                 			                           [<a id="dt-is-types" title="in-scope schema type">Definition</a>: 
                                 <b>In-scope schema types.</b> Each schema type
                                 			        definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded
                                    			        QName</a> (for a <b>named type</b>)
                                 			        or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> type
                                 			        identifier (for an <b>anonymous
                                    			        type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
                                 
                                 
                                 
                                 ]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="dt-is-elems" title="in-scope element declarations">Definition</a>: 
                                 <b>In-scope element declarations.</b> Each element
                                 declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element
                                 declaration) or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a
                                 local element declaration). ] An element
                                 declaration includes information about the element's <a title="substitution group" href="#dt-substitution-group">substitution group</a> affiliation.
                              </p>
                              <p>
                                 [<a id="dt-substitution-group" title="substitution group">Definition</a>: 
                                 <b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class">Section 
                                    
                                    2.2.2.2 Element Substitution Group
                                    </a><sup><small>XS1-1</small></sup> and 
                                 <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class">Section 
                                    
                                    2.2.2.2 Element Substitution Group
                                    </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of  the set of elements that can be substituted for the head element without
                                 affecting the outcome of schema validation.]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="dt-is-attrs" title="in-scope attribute declarations">Definition</a>: 
                                 <b>In-scope attribute
                                    declarations.</b> Each attribute declaration is identified either
                                 by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an
                                 <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute
                                 declaration).  ]
                                 
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-in-scope-variables" title="in-scope variables">Definition</a>: 
                           <b>In-scope variables.</b> 
                           This is a mapping from <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> to type. It defines the
                           set of variables that are available for reference within an
                           expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the
                           <a title="static type" href="#dt-static-type">static type</a> of the
                           variable.]
                           
                        </p>
                        <p>
                           An expression that binds a variable extends the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>, within the scope of the variable, with the variable and its type. 
                           Within the body of an
                           <a title="inline function expression" href="#dt-inline-func">inline function expression</a>
                           , the
                           <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> are extended
                           by the names and types of the <b>function
                              parameters</b>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-context-item-static-type" title="context item static type">Definition</a>: 
                           <b>Context item static type.</b> This component defines the <a title="static type" href="#dt-static-type">static type</a> of the context item within the scope of a given expression.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-known-func-signatures" title="statically known function signatures">Definition</a>: 
                           <b>Statically known function signatures.</b>
                           This is a mapping from (expanded QName, arity) to 
                           <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function signature</a><sup><small>DM31</small></sup>. 
                           ]
                           The entries in this mapping define the <span>set of 
                              functions</span> that are available to be called from a 
                           <a title="static function call" href="#dt-static-function-call">static function call</a>,
                           or referenced from a 
                           <a title="named function reference" href="#dt-named-function-ref">named function reference</a>.
                           Each such function is uniquely identified by its 
                           <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>
                           and arity (number of parameters).
                           <span>Given a statically known function's expanded QName and arity,
                              this component supplies the function's 
                              <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">signature</a><sup><small>DM31</small></sup>,
                              which specifies</span> various static properties of the function,
                           including types. 
                           
                        </p>
                        <p>The <span>statically known</span> function signatures include the signatures of functions from a variety of sources,
                           including
                           <span class="xpath">the <a title="built-in function" href="#dt-built-in-function">built-in functions</a>.</span>
                           
                           
                           
                           <span class="xpath">Implementations must ensure that no two functions have the same <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and the same
                              arity (even if the signatures are consistent).</span>
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           [<a id="dt-static-collations" title="statically known collations">Definition</a>: 
                           <b>Statically known collations.</b> This is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                           mapping from URI to collation. It defines the names of the collations that are available
                           for
                           				use in processing  expressions.] 
                           [<a id="dt-collation" title="collation">Definition</a>: A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension,
                           ordered. For a more complete definition of collation, see 
                           <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 
                              
                              5.3 Comparison of strings
                              </a><sup><small>FO31</small></sup>.]
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           [<a id="dt-def-collation" title="default collation">Definition</a>: 
                           <b>Default
                              				collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the  collation to be
                           				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
                           				explicit collation is
                           				specified.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-static-base-uri" title="Static Base URI">Definition</a>: 
                           <b>Static Base URI.</b>
                           This is an absolute URI, used to resolve
                           
                           <span class="xpath">relative URI references.</span>
                           ]
                           
                           <span class="xpath">
                              If <var>E</var> is a subexpression of <var>F</var> then the Static 
                              Base URI of <var>E</var> is the same as the Static Base URI of <var>F</var>.
                              There are no constructs in XPath that require resolution of relative URI references
                              
                              during static analysis.
                              </span>
                           The Static Base URI is available during dynamic evaluation by use of the 
                           <code>fn:static-base-uri</code> function, and is used implicitly during dynamic 
                           evaluation by functions such as <code>fn:doc</code>. Relative URI references are 
                           resolved as described in <a href="#id-resolve-relative-uri"><b>2.4.6 Resolving a Relative URI Reference</b></a>.
                        </p>
                     </li>
                     <li>
                        <p> 
                           [<a id="dt-known-docs" title="statically known  documents">Definition</a>: 
                           <b>Statically known documents.</b> This is a mapping
                           from strings to types.  The string represents the absolute URI of a
                           resource that is potentially available using the <code>fn:doc</code>
                           function.  The type is the <a title="static type" href="#dt-static-type">static type</a> of a call to <code>fn:doc</code>  with the given URI as its
                           literal argument. ]
                           If the argument to <code>fn:doc</code> is a
                           string literal that is not present in <b>statically known documents</b>, then the
                           <a title="static type" href="#dt-static-type">static type</a> of
                           <code>fn:doc</code> is <code>document-node()?</code>.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The purpose of the <b>statically known
                                 documents</b> is to provide static type information, not to determine
                              which documents are available. A URI need not be found in the
                              <b>statically known documents</b> to be accessed using
                              <code>fn:doc</code>. 
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-known-collections" title="statically known  collections">Definition</a>: 
                           <b>Statically known collections.</b> This is a
                           mapping from strings to types.  The string represents the absolute
                           URI of a resource that is potentially available using the
                           <code>fn:collection</code> function.  The type is the type of the
                           sequence of 
                           <span>items</span> that would result from calling the
                           <code>fn:collection</code> function with this URI as its
                           argument.] If the argument to
                           <code>fn:collection</code> is a string literal that is not present in
                           <b>statically known collections</b>, then the <a title="static type" href="#dt-static-type">static type</a> of
                           <code>fn:collection</code> is 
                           <code>item()*</code>.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The purpose of the <b>statically known
                                 collections</b> is to provide static type information, not to determine
                              which collections are available. A URI need not be found in the
                              <b>statically known collections</b> to be accessed using
                              <code>fn:collection</code>.
                              
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-known-default-collection" title="statically known default collection type">Definition</a>: 
                           <b>Statically known default collection type.</b> This is the type of the sequence of 
                           
                           <span>items</span> that would result from calling the <code>fn:collection</code> function with no arguments.] Unless initialized to some other value by an implementation,
                           the value of <b>statically known default collection type</b> is  
                           <code>item()*</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-static-decimal-formats" title="statically known decimal formats">Definition</a>: 
                           <b>Statically known decimal
                              		      formats.</b> This is a mapping from QNames to decimal formats, with one default format that has
                           no visible name,
                           		      referred to as the unnamed decimal format. Each
                           		      format is available for use when formatting numbers using the <code>fn:format-number</code> function.] 
                           
                        </p>
                        <p>Each decimal format defines a set of properties, which control the interpretation
                           of characters
                           		        in the picture string supplied to the <code>fn:format-number</code>
                           		        function, and also specify characters to be used in the result
                           		        of formatting the number.
                        </p>
                        <p>The following properties specify characters used both in the picture string, and in
                           the formatted number. In each case the value is a single character:
                        </p>
                        <ul>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-decimal-separator" title="decimal-separator">Definition</a>: 
                                 <b>decimal-separator</b> is
                                 		          the character used to separate the integer part of the number from the
                                 fractional part, both in the picture
                                 		          string and in the formatted number; the default
                                 		          value is the period character (.)]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-exponent-separator" title="exponent-separator">Definition</a>: 
                                 <b>exponent-separator</b> is
                                 		          the character used to separate the mantissa from the exponent in
                                 		          scientific notation both in the picture string and in the
                                 		          formatted number; the default value is the character (e).]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-grouping-separator" title="grouping-separator">Definition</a>: 
                                 <b>grouping-separator</b>
                                 		          is the character typically used as a thousands separator, both in the
                                 picture string and in the formatted number; the default value is the
                                 		          comma character (,)]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-percent" title="percent">Definition</a>: 
                                 <b>percent</b>
                                 		          is the character used both in the picture string and in the formatted
                                 number to indicate that the number is written as a per-hundred fraction; the default
                                 		          value is the percent character (%)]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-per-mille" title="per-mille">Definition</a>: 
                                 <b>per-mille</b>
                                 		          is the character used both in the picture string and in the formatted
                                 number to indicate that the number is written as a per-thousand fraction; the default
                                 		          value is the Unicode per-mille character
                                 		          (#x2030)]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-zero-digit" title="zero-digit">Definition</a>: 
                                 <b>zero-digit</b>
                                 		          is the character used to represent the digit zero; the default
                                 		          value is the Western digit zero (#x30). This character must be a digit
                                 		          (category Nd in the Unicode property database), and it must have
                                 		          the numeric value zero. This property implicitly defines the
                                 		          ten Unicode characters that are used to represent the values 0
                                 		          to 9: Unicode is organized so that each
                                 		          set of decimal digits forms a contiguous block of characters in
                                 		          numerical sequence. Within the picture string any of these ten character
                                 
                                 		          can be used (interchangeably) as a place-holder for a mandatory digit.
                                 		          Within the final result string, these ten characters are used to represent
                                 		          the digits zero to nine.]
                                 
                              </p>
                           </li>
                        </ul>
                        <p>The following properties specify 
                           		        characters to be used in the picture string supplied to the <code>fn:format-number</code>
                           		        function, but not in the formatted number. In each case the value must be
                           a single character.
                           		      
                        </p>
                        <ul>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-digit" title="digit">Definition</a>: 
                                 <b>digit</b> 
                                 		          is a character used in the picture string to represent an optional digit;
                                 the default value is the number sign character (#)]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-pattern-separator" title="pattern-separator">Definition</a>: 
                                 <b>pattern-separator</b> is a character used
                                 		          to separate positive and negative sub-pictures
                                 		          in a picture string; the default value is the semi-colon character (;)]
                                 
                              </p>
                           </li>
                        </ul>
                        <p>The following properties specify characters or strings that
                           		        may appear in the result of formatting the number, but not in the picture
                           string:
                        </p>
                        <ul>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-infinity" title="infinity">Definition</a>: 
                                 <b>infinity</b> is the string used to represent the double value infinity (<code>INF</code>); the
                                 		          default value is the string "Infinity"]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-NaN" title="NaN">Definition</a>: 
                                 <b>NaN</b> is the string used to
                                 		          represent the double value NaN (not-a-number); the default value is the
                                 string "NaN"]
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 [<a id="id-static-decimal-format-minus-sign" title="minus-sign">Definition</a>: 
                                 <b>minus-sign</b> is the single character used to mark negative numbers; the
                                 		          default value is the hyphen-minus character (#x2D). ]
                                 
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="eval_context"></a>2.1.2 Dynamic Context
                  </h4>
                  <p>
                     [<a id="dt-dynamic-context" title="dynamic context">Definition</a>: The <b>dynamic
                        context</b> of an expression is defined as information that is needed for the dynamic evaluation
                     of an expression.] If
                     evaluation of an expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that 
                     is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
                        error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].
                  </p>
                  <p>The individual
                     components of the <a title="dynamic context" href="#dt-dynamic-context">dynamic
                        context</a> are described below. 
                     
                     <span class="xpath">Further rules governing the semantics of these components can be found in <a href="#id-xp-evaluation-context-components"><b>C.2 Dynamic Context Components</b></a>.</span>
                     
                  </p>
                  <p>The
                     <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> consists
                     of all the components of the <a title="static context" href="#dt-static-context">static
                        context</a>, and the additional components listed below.
                  </p>
                  <p>
                     [<a id="dt-focus" title="focus">Definition</a>: The first three components of
                     the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
                     (context item, context position, and context size) are called the
                     <b>focus</b> of the expression. ] The focus enables the
                     processor to keep track of which items are being processed by the
                     expression.
                     
                     
                     
                     <span class="xpath">If any component in the focus is defined, both the context item and context position
                        are known.</span> 
                     
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If any component in the focus is defined, context size is usually defined as well.
                        However, when streaming, 
                        the context size cannot be determined without lookahead, so it may be undefined. 
                        If so, expressions like <code>last()</code> will raise a dynamic error because the context size is undefined.
                     </p>
                  </div>
                  <p>
                     
                     [<a id="dt-singleton-focus" title="singleton focus">Definition</a>: A <b>singleton focus</b> is a focus that refers to a single item; in a singleton focus, context item is set
                     to the item, context position = 1 and context size = 1.]
                     
                  </p>
                  <p>Certain language constructs, notably the <a title="path expression" href="#dt-path-expression">path
                        operator</a> 
                     <code>E1/E2</code>, the <span>
                        <a href="#doc-xpath31-SimpleMapExpr">simple map operator</a> 
                        <code>E1!E2</code>
                        </span>, and the <a title="" href="#dt-predicate">predicate</a> 
                     <code>E1[E2]</code>, create a new focus
                     for the evaluation of a sub-expression. In these constructs, <code>E2</code> is evaluated once for each item in the
                     sequence that results from evaluating <code>E1</code>. Each time <code>E2</code> is evaluated, it is evaluated with a
                     different focus. The focus for evaluating <code>E2</code> is referred to below as the <b>inner
                        focus</b>, while the focus for evaluating <code>E1</code> is referred to as the <b>outer
                        focus</b>. The inner focus is used only for the evaluation of <code>E2</code>. Evaluation of E1 continues with its original focus unchanged.
                  </p>
                  <ul>
                     <li>
                        <p>
                           [<a id="dt-context-item" title="context item">Definition</a>: The <b>context item</b>
                           is the <a title="item" href="#dt-item">item</a> currently being processed.]
                           [<a id="dt-context-node" title="context node">Definition</a>: When the context item is a
                           node, it can also be referred to as the <b>context
                              node</b>.] The context item is returned by an expression
                           consisting of a single dot (<code>.</code>). When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, each item in the
                           sequence obtained by evaluating <code>E1</code>
                           becomes the context item in the inner focus for an evaluation of <code>E2</code>. 
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-context-position" title="context position">Definition</a>: The <b>context
                              position</b> is the position of the context item within the
                           sequence of items currently being processed.] It changes whenever the context item
                           changes. When the focus is defined, the value of the context position is an integer
                           greater than zero. The context
                           position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in
                           the inner focus for an evaluation of <code>E2</code>
                           is the position of the context item in the sequence obtained by
                           evaluating <code>E1</code>. The position of the
                           first item in a sequence is always 1 (one). The context position is
                           always less than or equal to the context size.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-context-size" title="context size">Definition</a>: The <b>context
                              size</b> is the number of items in the sequence of items currently
                           being processed.] Its value is always an
                           integer greater than zero. The context size is returned by the
                           expression <code>fn:last()</code>. When an expression
                           <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the
                           inner focus for an evaluation of <code>E2</code> is
                           the number of items in the sequence obtained by evaluating <code>E1</code>. 
                        </p>
                     </li>
                     <li>
                        <p> 
                           [<a id="dt-variable-values" title="variable values">Definition</a>: 
                           <b>Variable values</b>. 
                           This is a mapping from <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> to value. 
                           It contains the
                           				same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the
                           				<a title="static context" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which
                           includes its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-named-functions" title="named functions">Definition</a>: 
                           <b>Named functions</b>.
                           This is a mapping from (expanded QName, arity) to 
                           <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.
                           ]
                           It supplies a function for each signature in 
                           <a title="statically known function signatures" href="#dt-known-func-signatures">
                              statically known function signatures
                              </a>
                           and may supply other functions 
                           (see <a href="#id-consistency-constraints"><b>2.2.4 Consistency Constraints</b></a>).  Named functions can include 
                           
                           <span>
                              <a title="external function" href="#dt-external-function">external functions</a>.
                              [<a id="dt-external-function" title="external function">Definition</a>: 
                              <b>External functions</b> are functions that are implemented outside the query
                              environment.] For example, an implementation might provide a set of 
                              <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                              external functions in addition to the core function library described in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>. 
                              [<a id="dt-implementation-defined-function" title="implementation-defined function">Definition</a>: An <b>implementation-defined function</b> is an <a title="external function" href="#dt-external-function">external function</a> that is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                              ].
                              </span>
                           <span class="xpath">
                              [<a id="dt-host-language-function" title="host language function">Definition</a>: A <b>host language function</b> is an <a title="external function" href="#dt-external-function">external function</a> defined by the <a title="host-language" href="#dt-host-language">host language</a>.]
                              </span>
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           [<a id="dt-date-time" title="current dateTime">Definition</a>: 
                           <b>Current dateTime.</b> This information represents
                           				an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xpath">an expression</span>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <span class="xpath">an expression</span>,
                           				this function always returns the same result.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-timezone" title="implicit timezone">Definition</a>: 
                           <b>Implicit timezone.</b> This is the timezone to be used when a date,
                           time, or dateTime value that does not have a timezone is used in a
                           comparison or arithmetic operation. The implicit timezone is an  <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value of type
                           <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones">Section 
                              
                              3.2.7.3 Timezones
                              </a><sup><small>XS1-2</small></sup> or
                           <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime">Section 
                              
                              3.3.7 dateTime
                              </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-default-language" title="default language">Definition</a>: 
                           <b>Default language.</b>
                           This is the natural language used when creating human-readable output
                           (for example, by the functions <code>fn:format-date</code> and <code>fn:format-integer</code>)
                           if no other language is requested. 
                           The value is a language code as defined by the type <code>xs:language</code>.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-default-calendar" title="default calendar">Definition</a>: 
                           <b>Default calendar.</b>
                           This is the calendar used when formatting dates in human-readable output
                           (for example, by the functions <code>fn:format-date</code> and <code>fn:format-dateTime</code>)
                           if no other calendar is requested. 
                           The value is a string.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-default-place" title="default place">Definition</a>: 
                           <b>Default place.</b>
                           This is a geographical location used to identify the place where events happened (or
                           will happen) when
                           formatting dates and times using functions such as <code>fn:format-date</code> and <code>fn:format-dateTime</code>,
                           if no other place is specified. It is used when translating timezone offsets to civil
                           timezone names,
                           and when using calendars where the translation from ISO dates/times to a local representation
                           is dependent
                           on geographical location. Possible representations of this information are an ISO
                           country code or an
                           Olson timezone name, but implementations are free to use other representations from
                           which the above
                           information can be derived.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-available-docs" title="available documents">Definition</a>: 
                           <b>Available
                              documents.</b> This is a mapping of strings to document nodes.  Each string
                           represents the absolute URI of a resource. The document node is the root of a tree
                           that represents that resource 
                           using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> 
                           function when applied to that URI.] The set of available documents is not limited
                           to the set of 
                           <a title="statically known  documents" href="#dt-known-docs">statically known documents</a>, and it may be empty.
                        </p>
                        <p>If there are one or more 
                           URIs in <a title="available documents" href="#dt-available-docs">available documents</a> that map to a document
                           node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must
                           be one of these URIs.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This means that given a document node <code>$N</code>, the result of
                              <code>fn:doc(fn:document-uri($N)) is $N</code> will always be <code>true</code>, unless
                              <code>fn:document-uri($N)</code> is an empty sequence.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-available-text-resources" title="available text resources">Definition</a>: 
                           <b>Available text resources</b>. 
                           This is a mapping of strings to text resources. Each string
                           represents the absolute URI of a resource. The resource is returned
                           by the <code>fn:unparsed-text</code> function when applied to that
                           URI.] The set of available text resources is not limited to
                           the set of <a title="statically known  documents" href="#dt-known-docs">statically known
                              documents</a>, and it may be empty.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-available-collections" title="available item collections">Definition</a>: 
                           <b>Available
                              collections.</b> This is a mapping of
                           strings to sequences of 
                           <span>items</span>. Each string
                           represents the absolute URI of a
                           resource. The sequence of 
                           <span>items</span> represents
                           the result of the <code>fn:collection</code>
                           function when that URI is supplied as the
                           argument. ] The set of available
                           collections is not limited to the set of <a title="statically known  collections" href="#dt-known-collections">statically known
                              collections</a>, and it may be empty.
                        </p>
                        <p>For every document node <code>D</code> that is in the target of a mapping in <a title="available item collections" href="#dt-available-collections">available   collections</a>, or that is the root of a tree containing such a node, the document-uri property
                           of <code>D</code> must either be absent, or must be a
                           URI <code>U</code> such that <a title="available documents" href="#dt-available-docs">available documents</a> contains a mapping from <code>U</code> to <code>D</code>.
                           
                           
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This means that for any document node <code>$N</code> retrieved using the
                              <code>fn:collection</code> function, either directly or by navigating to the root of a
                              node that was returned, the result of <code>fn:doc(fn:document-uri($N)) is $N</code>
                              will always be <code>true</code>, unless <code>fn:document-uri($N)</code> is an empty sequence. This
                              implies a requirement for the <code>fn:doc</code> and <code>fn:collection</code> functions to be
                              consistent in their effect. If the implementation uses catalogs or
                              user-supplied URI resolvers to dereference URIs supplied to the <code>fn:doc</code>
                              function, the implementation of the <code>fn:collection</code> function must take these
                              mechanisms into account. For example, an implementation might achieve this
                              by mapping the collection URI to a set of document URIs, which are then
                              resolved using the same catalog or URI resolver that is used by the <code>fn:doc</code> function.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-default-collection" title="default collection">Definition</a>: 
                           <b>Default  collection.</b>
                           This is the sequence of 
                           <span>items</span>  that would result from calling the <code>fn:collection</code> function
                           with no arguments.] The value of <b>default   collection</b> may be initialized by the
                           implementation.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-available-uri-collections" title="available uri collections">Definition</a>: 
                           <b>Available
                              
                              <span>URI</span> collections.</b> This is a mapping of
                           strings to sequences of URIs. The string
                           represents the absolute URI of a
                           resource which can be interpreted as an aggregation of a number of individual resources
                           each of which
                           has its own URI. The sequence of URIs represents
                           the result of the <code>fn:uri-collection</code>
                           function when that URI is supplied as the
                           argument. ] There is no implication that the URIs in this sequence
                           can be successfully dereferenced, or that the resources they refer to have any particular
                           media type.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>An implementation <strong>may</strong> maintain some consistent relationship between the available
                              collections and the available 
                              <span>URI</span> collections, for example by ensuring that the result of
                              <code>fn:uri-collection(X)!fn:doc(.)</code> is the same as the result of <code>fn:collection(X)</code>.
                              However, this is not required. The <code>fn:uri-collection</code> function is more 
                              general than <code>fn:collection</code> in that it allows access to resources other 
                              than XML documents; at the same time, <code>fn:collection</code> allows access to 
                              nodes that might lack individual URIs, for example nodes corresponding 
                              to XML fragments stored in the rows of a relational database.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-default-uri-collection" title="default URI collection">Definition</a>: 
                           <b>Default 
                              <span>URI</span> collection.</b>
                           This is the sequence of URIs that would result from calling the <code>fn:uri-collection</code> function
                           with no arguments.] The value of <b>default 
                              <span>URI</span> collection</b> may be initialized by the
                           implementation.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-environment-variables" title="environment variables">Definition</a>: 
                           <b>Environment variables.</b>
                           This is a mapping from names to values. 
                           Both the names and the values are strings. The names are compared using an
                           <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables
                           is
                           <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> and <strong>may</strong> be empty.]
                           
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>A possible implementation is to provide the set of POSIX environment variables (or
                              their equivalent on other
                              operating systems) appropriate to the process in which the <span class="xpath">expression is evaluated</span>.
                           </p>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-processing-model"></a>2.2 Processing
                  Model
               </h3>
               <p>XPath 3.1 is defined in terms
                  of the <a title="data model" href="#dt-datamodel">data
                     model</a> and the <a title="expression context" href="#dt-expression-context">expression
                     context</a>.
               </p><img src="ProcMod-XPath.gif" alt="Processing                          Model Overview"><p>Figure 1:
                  Processing Model Overview
               </p>
               <p>Figure 1 provides a schematic overview of the processing steps that
                  are discussed in detail below. Some of these steps are completely
                  outside the domain of XPath 3.1; in Figure 1, these are depicted
                  outside the line that represents the boundaries of the language, an
                  area labeled <b>external processing</b>. The external processing
                  domain includes generation of <a title="XDM instance" href="#dt-data-model-instance">XDM instances</a> that represent the data to be queried (see <a href="#id-data-model-generation"><b>2.2.1 Data Model Generation</b></a>), schema import processing (see
                  <a href="#id-schema-import-processing"><b>2.2.2 Schema Import Processing</b></a>) and serialization. The area inside the boundaries of
                  the language is known as the <span class="xpath">
                     <b>XPath processing domain</b>
                     </span>, which includes the static
                  analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.2.3 Expression
                        Processing</b></a>).  Consistency constraints on the
                  <span class="xpath">XPath</span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.2.4 Consistency Constraints</b></a>.
               </p>
               <div class="div3">
                  
                  <h4><a id="id-data-model-generation"></a>2.2.1 Data Model Generation
                  </h4>
                  <p>The input data for <span class="xpath">an expression</span> must be represented as one or more <a title="XDM instance" href="#dt-data-model-instance">XDM instances</a>. This process occurs outside
                     the domain of XPath 3.1, which is why Figure 1 represents it in the
                     external processing domain. Here are some steps by which an XML
                     document might be converted to an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a>:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>A document may be parsed using an XML parser that
                           generates an <b>XML Information Set</b> (see <a href="#XINFO">[XML Infoset]</a>). The parsed document may then be validated against one
                           or more schemas. This process, which is described in <a href="http://www.w3.org/TR/xmlschema-1/">[XML Schema 1.0 Part 1]</a> or
                           <a href="http://www.w3.org/TR/xmlschema11-1/">[XML Schema 1.1 Part 1]</a>, results in an abstract information structure called
                           the <b>Post-Schema Validation Infoset</b> (PSVI). If a document
                           has no associated schema, its Information Set is preserved. (See DM1
                           in Fig. 1.)
                        </p>
                     </li>
                     <li>
                        <p>The Information Set or PSVI may be
                           transformed into an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a>
                           by a process described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. (See DM2 in
                           Fig. 1.)
                        </p>
                     </li>
                  </ol>
                  <p>The above steps provide an example of how an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a> might be constructed. An XDM instance might
                     also be synthesized directly from a relational database, or
                     constructed in some other way (see DM3 in Fig. 1.) XPath 3.1 is defined in terms
                     of the <a title="data model" href="#dt-datamodel">data model</a>,
                     but it does not place any constraints on how XDM instances are constructed.
                  </p>
                  <p>
                     [<a id="dt-type-annotation" title="type annotation">Definition</a>: Each element node and attribute node in an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 
                        
                        2.7 Schema Information
                        </a><sup><small>DM31</small></sup>). 
                     The type annotation of a node is a reference to an XML Schema type. 
                     ]  The <code>type-name</code> of a node is the name of the type referenced by its <a title="type annotation" href="#dt-type-annotation">type annotation</a>. 
                     If the <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a> was derived from a validated XML document as described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 
                        
                        3.3 Construction from a PSVI
                        </a><sup><small>DM31</small></sup>, the type annotations of the element and attribute nodes are derived from schema
                     validation. XPath 3.1 does
                     not provide a way to directly access the type annotation of an element
                     or attribute node.
                  </p>
                  <p>The value of an attribute is represented directly within the
                     attribute node. An attribute node whose type is unknown (such as might
                     occur in a schemaless document) is given the <a title="type annotation" href="#dt-type-annotation">type annotation</a>
                     <code>xs:untypedAtomic</code>.
                  </p>
                  <p>The value of an element is represented by the children of the
                     element node, which may include text nodes and other element
                     nodes. The <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node indicates how the values in
                     its child text nodes are to be interpreted. An element that has not been validated
                     (such as might occur in a schemaless document) is annotated
                     with the schema type <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated
                     with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <a title="type annotation" href="#dt-type-annotation">type annotation</a>.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-schema-import-processing"></a>2.2.2 Schema Import Processing
                  </h4>
                  <p class="xpath">The <a title="in-scope schema definitions" href="#dt-issd">in-scope schema
                        definitions</a> in the <a title="static context" href="#dt-static-context">static
                        context</a> are provided by the host language (see step SI1 in
                     Figure 1) and must satisfy the consistency constraints defined in
                     <a href="#id-consistency-constraints"><b>2.2.4 Consistency Constraints</b></a>.
                     
                     
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-expression-processing"></a>2.2.3 Expression
                     Processing
                  </h4>
                  <p>XPath 3.1 defines two phases of processing called
                     the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>
                     and the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
                        phase</a> (see Fig. 1).  During the static analysis phase, <a title="static error" href="#dt-static-error">static errors</a>,  <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, or <a title="type error" href="#dt-type-error">type errors</a> may be raised. During the dynamic evaluation phase, only <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> or <a title="type error" href="#dt-type-error">type errors</a> may be raised. These kinds of errors are defined in <a href="#id-kinds-of-errors"><b>2.3.1 Kinds of Errors</b></a>.  
                  </p>
                  <p>Within each phase, an implementation is free to use any
                     strategy or algorithm whose result conforms to the
                     specifications in this document.
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-static-analysis"></a>2.2.3.1 Static Analysis Phase
                     </h5>
                     <p>
                        [<a id="dt-static-analysis" title="static analysis phase">Definition</a>: The
                        <b>static analysis phase</b> depends on the expression itself
                        and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does
                        not depend on input data (other than schemas).]
                        
                     </p>
                     <p>During the static analysis phase, the <span class="xpath">XPath expression</span> is parsed into an
                        internal representation called the <b>operation tree</b> (step
                        SQ1 in Figure 1).  A parse error is raised as a <a title="static error" href="#dt-static-error">static error</a> 
                        [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]. The <a title="static context" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2).  The <a title="static context" href="#dt-static-context">static context</a> is used to resolve schema type names, function names, namespace prefixes, and variable
                        names (step
                        SQ4).
                        If a name of one of these kinds in the <b>operation tree</b> is
                        not found in the <a title="static context" href="#dt-static-context">static context</a>, a <a title="static error" href="#dt-static-error">static error</a> ([<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]) is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>2.5.5.3 Element Test</b></a> and <a href="#id-attribute-test"><b>2.5.5.5 Attribute Test</b></a>.)
                     </p>
                     <p>The <b>operation tree</b> is then
                        <b>normalized</b> by making explicit the implicit operations
                        such as <a title="atomization" href="#dt-atomization">atomization</a> and extraction of <a title="effective boolean value" href="#dt-ebv">Effective Boolean Values</a> (step SQ5).
                     </p>
                     <p>During the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                           phase</a>, a processor may perform type analysis. The
                        effect of type analysis is to assign a <a title="static type" href="#dt-static-type">static type</a> to each expression in the
                        operation tree. [<a id="dt-static-type" title="static type">Definition</a>: The
                        <b>static type</b> of an expression is the best inference that
                        the processor is able to make statically about the type of the result
                        of the expression.] This specification does not define the
                        rules for type analysis nor the static types that are assigned to
                        particular expressions: the only constraint is that the inferred type
                        must match all possible values that the expression is capable of
                        returning.
                     </p>
                     <p>Examples of inferred static types might be:</p>
                     <ul>
                        <li>
                           <p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>For the expression <code>$s[exp]</code> the inferred static
                              type has the same item type as the static type of <code>$s</code>,
                              but a cardinality that allows the empty sequence even if the
                              static type of <code>$s</code> does not allow an empty
                              sequence.
                           </p>
                        </li>
                        <li>
                           <p>The inferred static type of the expression <code>data($x)</code> (whether written
                              explicitly or inserted into the operation tree in places where atomization
                              is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code>
                              has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.
                           </p>
                        </li>
                     </ul>
                     <p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published
                        normatively in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were allowed to
                        refine these rules to infer a more precise type where possible. In
                        <span>XQuery 3.1 and XPath 3.1</span>, the rules for static type inferencing are entirely implementation-dependent.
                     </p>
                     <p>Every kind of expression also imposes requirements on the type of its
                        operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be
                        of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the
                        function calling rules), while <code>$b</code> and <code>$c</code> must be of type <code>xs:double</code>.
                     </p>
                     <p>If the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is in effect, a processor must raise a
                        type error during static analysis if the inferred static type of an
                        expression is not subsumed by the required type of the context where the
                        expression is used. For example, the call of substring above would cause a
                        type error if the inferred static type of <code>$a</code> is <code>xs:integer</code>; equally, a type
                        error would be reported during static analysis if the inferred static type
                        is <code>xs:anyAtomicType</code>.
                     </p>
                     <p>If the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is not in effect, a processor may raise a type
                        error during static analysis only if the inferred static type of an
                        expression has no overlap (intersection) with the required type: so for the
                        first argument of substring, the processor may raise an error if the
                        inferred type is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>.
                        Alternatively, if the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is not in effect, the processor
                        may defer all type checking until the dynamic evaluation phase.
                     </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase
                     </h5>
                     <p>
                        [<a id="dt-dynamic-evaluation" title="dynamic evaluation phase">Definition</a>: The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.] It is dependent
                        on successful completion of the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.
                     </p>
                     <p>The dynamic evaluation phase can occur only if no errors were detected during the
                        <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. If the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is in effect, all <a title="type error" href="#dt-type-error">type errors</a> are detected during static analysis and serve to inhibit the dynamic evaluation phase.
                     </p>
                     <p>The dynamic evaluation phase depends on the <b>operation
                           tree</b> of the expression being evaluated (step DQ1), on the input
                        data (step DQ4), and on the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn draws information from  the external environment (step
                        DQ3) and the <a title="static context" href="#dt-static-context">static context</a> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4)
                        and it may extend the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5)—for example, by binding values to variables.
                     </p>
                     <p>
                        [<a id="dt-dynamic-type" title="dynamic type">Definition</a>: A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may
                        be more specific than the <a title="static type" href="#dt-static-type">static type</a> of the expression that computed it (for example, the  static type of an expression
                        might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may
                        have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)]
                        
                     </p>
                     <p> If an operand of an expression is found
                        to have a <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not appropriate for that operand, a
                        <a title="type error" href="#dt-type-error">type error</a> is
                        raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                     </p>
                     <p>Even though static typing can catch many <a title="type error" href="#dt-type-error">type errors</a> before an expression is executed, it is possible for an expression to raise an error
                        during evaluation that was not detected by static  analysis. For example, an expression
                        may contain a cast of a string into an integer, which is statically valid. However,
                        if the actual value of the string at run time cannot be cast into an integer, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> will result. Similarly, an expression may apply an arithmetic operator to a value
                        whose <a title="static type" href="#dt-static-type">static type</a> is <code>xs:untypedAtomic</code>. This is not a <a title="static error" href="#dt-static-error">static error</a>, but at run time, if the value cannot be successfully cast to a <a title="numeric" href="#dt-numeric">numeric</a> type, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> will be raised.
                     </p>
                     <p>When the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is in effect, it is also possible for static analysis of an expression to raise a
                        <a title="type error" href="#dt-type-error">type error</a>, even though execution of the expression on certain inputs would be successful. For
                        example, an expression might contain a function that requires an element as its parameter,
                        and the static analysis phase might infer the <a title="static type" href="#dt-static-type">static type</a> of the function parameter to be an optional element. This case is treated as a <a title="type error" href="#dt-type-error">type error</a> and inhibits evaluation, even though the function call would have been successful
                        for input data in which the optional element is present.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-consistency-constraints"></a>2.2.4 Consistency Constraints
                  </h4>
                  <p>In order for XPath 3.1 to
                     be well defined, the input <a title="XDM instance" href="#dt-data-model-instance">XDM instances</a>, the <a title="static context" href="#dt-static-context">static context</a>, and the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> must be mutually
                     consistent. The consistency constraints listed below are prerequisites
                     for correct functioning of an XPath 3.1 implementation. Enforcement
                     of these consistency constraints is beyond the scope of this
                     specification. This specification does not
                     define the result of   <span class="xpath">an expression</span> under any condition in which one
                     or more of these constraints is not satisfied.
                  </p>
                  <ul>
                     <li>
                        <p>For every  node that has a type annotation, if that type annotation is found in the
                           <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be equivalent to its definition in the
                           type annotation.
                           
                        </p>
                     </li>
                     <li>
                        <p>Every element name, attribute name, or schema type name referenced in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> or <a title="statically known function signatures" href="#dt-known-func-signatures">statically known function signatures</a> must be in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, unless it is an element name referenced as part of an <a href="#doc-xpath31-ElementTest">ElementTest</a> or an attribute name referenced as part of an <a href="#doc-xpath31-AttributeTest">AttributeTest</a>.
                        </p>
                     </li>
                     <li>
                        <p>Any reference to a global element, attribute, or type name in
                           the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> must have a corresponding element, attribute or type
                           definition in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>.
                        </p>
                     </li>
                     <li>
                        <p> For each mapping of a string to a
                           document node in <a title="available documents" href="#dt-available-docs">available
                              documents</a>, if there exists a mapping of the same string to a document type in <a title="statically known  documents" href="#dt-known-docs">statically known documents</a>, the document node must match the document type, using the matching rules in <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>For each mapping of a string to a sequence of  
                           <span>items</span> in
                           <a title="available item collections" href="#dt-available-collections">available   
                              collections</a>, if there exists a mapping of the same string to
                           a type in <a title="statically known  collections" href="#dt-known-collections">statically known collections</a>, the sequence of 
                           <span>items</span>  must match the type, using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>The sequence of 
                           <span>items</span> in the <a title="default collection" href="#dt-default-collection">default collection</a> must match the <a title="statically known default collection type" href="#dt-known-default-collection">statically known default collection type</a>, using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>The value of the <a title="context item" href="#dt-context-item">context item</a> must match the <a title="context item static type" href="#dt-context-item-static-type">context item static type</a>, using the
                           matching rules in <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>For each (variable, type) pair in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> and the corresponding (variable, value) pair in <a title="variable values" href="#dt-variable-values">variable values</a> such that the variable names are equal, the value must match the type, using the
                           matching rules in  <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>In the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.
                           The prefix <code>xmlns</code> must not be bound to any namespace URI, and no prefix may be bound to the namespace
                           URI <code>http://www.w3.org/2000/xmlns/</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           For each 
                           <code>(expanded QName, arity) -&gt; FunctionTest</code>
                           entry in 
                           <a title="statically known function signatures" href="#dt-known-func-signatures">statically known function signatures</a>,
                           there must exist an 
                           <code>(expanded QName, arity) -&gt; function</code>
                           entry in 
                           <a title="named functions" href="#dt-named-functions">named functions</a>
                           such that the function's 
                           <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">signature</a><sup><small>DM31</small></sup>
                           is 
                           <code>FunctionTest</code>. 
                           
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="errors"></a>2.3 Error Handling
               </h3>
               <div class="div3">
                  
                  <h4><a id="id-kinds-of-errors"></a>2.3.1 Kinds of Errors
                  </h4>
                  <p>
                     As described in <a href="#id-expression-processing"><b>2.2.3 Expression
                           Processing</b></a>, XPath 3.1
                     defines a <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, which does not depend on input
                     data, and a <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
                        phase</a>, which does depend on input
                     data.  Errors may be raised during each phase.
                  </p>
                  <p>
                     [<a id="dt-static-error" title="static error">Definition</a>: 
                     An error that can be detected during the static analysis phase, and is not a type
                     error, is a <b>static error</b>.] A syntax error is an example of a <a title="static error" href="#dt-static-error">static error</a>.
                  </p>
                  <p>
                     [<a id="dt-dynamic-error" title="dynamic error">Definition</a>: A <b>dynamic
                        error</b> is an error that
                     must be detected during the dynamic evaluation phase and may be detected
                     during the static analysis phase.
                     Numeric overflow is an example of a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.]
                     
                  </p>
                  <p>
                     [<a id="dt-type-error" title="type error">Definition</a>: A <b>type
                        error</b> may be raised during the static analysis phase or the dynamic evaluation phase.
                     During the static analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
                     when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type
                     of the context in which the expression occurs.
                     During the dynamic evaluation phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
                     when the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of
                     the context in which the value occurs.]
                     
                  </p>
                  <p>The outcome of the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                        phase</a> is either success or one or more <a title="type error" href="#dt-type-error">type errors</a>, <a title="static error" href="#dt-static-error">static errors</a>, or statically-detected <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. The result of the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
                        phase</a> is either a result value, a <a title="type error" href="#dt-type-error">type
                        error</a>, or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.
                  </p>
                  <p>If more than one error is present, or if an error condition comes within the
                     scope of more than one error defined in this specification, then any non-empty
                     subset of these errors may be reported.
                  </p>
                  <p> During the <a title="static analysis phase" href="#dt-static-analysis">static
                        analysis phase</a>, if the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is in effect and the <a title="static type" href="#dt-static-type">static type</a> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0005" title="err:XPST0005">err:XPST0005</a>]. This catches cases in which a query refers to an element or attribute that is not
                     present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, possibly because of a spelling error.
                  </p>
                  <p>Independently of whether the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is in effect, if an implementation can determine during the
                     <a title="static analysis phase" href="#dt-static-analysis">static
                        analysis phase</a> that <span class="xpath">an XPath expression</span>, if evaluated, would necessarily
                     raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> or that an expression, if evaluated, would necessarily raise a <a title="type error" href="#dt-type-error">type error</a>, the implementation may (but is not required to) report that
                     error during the <a title="static analysis phase" href="#dt-static-analysis">static
                        analysis phase</a>.
                  </p>
                  <p>An implementation can raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for <span class="xpath">an XPath expression</span> statically only if the <span class="xpath">expression</span> can never execute without raising that error, as in the following example:
                  </p>
                  <div class="exampleInner"><pre>
error()
</pre></div>
                  <p>The following example contains a type error, which can be reported statically even
                     if the implementation can not prove that the expression will actually be evaluated.
                  </p>
                  <div class="exampleInner"><pre>
if (empty($arg))
then
  "cat" * 2
else
  0
</pre></div>
                  <p>
                     [<a id="dt-warning" title="warning">Definition</a>: In addition to <a title="static error" href="#dt-static-error">static errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" href="#dt-type-error">type
                        errors</a>, an XPath 3.1
                     implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                        phase</a> or the
                     <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
                        phase</a>. The circumstances in which warnings are raised, and
                     the ways in which warnings are handled, are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.]
                     
                  </p>
                  <p>In addition to the errors defined in this
                     specification, an implementation may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for a reason beyond the scope of this specification. For
                     example, limitations may exist on the maximum
                     numbers or sizes of various objects. 
                     <span>An error must be raised if such a limitation is exceeded  [<a href="#ERRXPDY0130" title="err:XPDY0130">err:XPDY0130</a>].</span>
                     
                     
                     
                     
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-identifying-errors"></a>2.3.2 Identifying and Reporting Errors
                  </h4>
                  <p>The errors defined in this specification are identified by QNames that have the form
                     <code>err:XPYYnnnn</code>, where:
                  </p>
                  <ul>
                     <li>
                        <p>
                           <code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>XP</code> identifies the error as an XPath error (some errors, originally defined by XQuery
                           and later added to XPath, use the code <code>XQ</code> instead).
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>YY</code> denotes the error category, using the following encoding:
                        </p>
                        <ul>
                           <li>
                              <p>
                                 <code>ST</code> denotes a static error.
                              </p>
                           </li>
                           <li>
                              <p>
                                 <code>DY</code> denotes a dynamic error.
                              </p>
                           </li>
                           <li>
                              <p>
                                 <code>TY</code> denotes a type error.
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>
                           <code>nnnn</code> is a unique numeric code.
                        </p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The namespace URI for  XPath and XQuery errors is not expected to
                        change from one version of <span class="xpath">XPath</span> to another. However, the contents of this
                        namespace may be extended to include additional error definitions.
                     </p>
                  </div>
                  <p>The method by which an XPath 3.1 processor reports error information to the external
                     environment is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                  </p>
                  <p>An error can be represented by a URI reference that is derived from the error QName
                     as follows: an error with namespace URI <em>
                        <code>NS</code>
                        </em> and local part <em>
                        <code>LP</code>
                        </em> can be represented as the URI reference <em>
                        <code>NS</code>
                        </em>
                     <code>#</code>
                     <em>
                        <code>LP</code>
                        </em>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Along with a code identifying an error, implementations may wish to return additional
                        information, such
                        as the location of the error or the processing phase in which it was detected. If
                        an implementation chooses to do so, then the mechanism that
                        it uses to return this information is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-handling-dynamic"></a>2.3.3 Handling Dynamic Errors
                  </h4>
                  <p>Except as noted in this document, if any operand of an expression
                     raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, the expression also raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.
                     If an expression can validly return a value or raise a dynamic
                     error, the implementation may choose to return the value or raise
                     the dynamic error (see <a href="#id-errors-and-opt"><b>2.3.4 Errors and
                           Optimization</b></a>).  For example, the logical expression
                     <code>expr1 and expr2</code> may return the value <code>false</code>
                     if either operand returns <code>false</code>,
                     or may raise a dynamic error if either operand raises a dynamic
                     error.
                  </p>
                  <p> If more than one operand of an expression raises
                     an error, the
                     implementation may choose which error is raised by the expression.
                     For example, in this expression:
                     
                     
                  </p>
                  <div class="exampleInner"><pre>($x div $y) + xs:decimal($z)</pre></div>
                  <p>
                     
                     both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may
                     raise an error.  The
                     implementation may choose which error is raised by the "<code>+</code>"
                     expression.  Once one operand raises an error, the implementation is
                     not required, but is permitted, to evaluate any other operands.
                  </p>
                  <p>
                     [<a id="dt-error-value" title="error value">Definition</a>: In addition to its identifying QName, a dynamic error may also carry a descriptive
                     string and one or more additional values called <b>error values</b>.] An implementation may provide a mechanism whereby an application-defined error
                     handler can process error values and produce diagnostic messages. 
                     
                     <span class="xpath">The host language may also provide error handling mechanisms.</span>
                     
                  </p>
                  <p>A dynamic error may be raised by a <a title="built-in function" href="#dt-built-in-function">built-in
                        function</a> or operator.  For example,
                     the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
                     is equal to zero. Errors raised by built-in functions and operators are defined in
                     <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                  </p>
                  <p>A dynamic error can also be raised explicitly by calling the
                     <code>fn:error</code> function, which always raises a dynamic error and never
                     returns a value.  This function is defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-error">Section 
                        
                        3.1.1 fn:error
                        </a><sup><small>FO31</small></sup>. For example, the following
                     function call raises a dynamic
                     error, providing a QName that identifies the error, a descriptive string, and a diagnostic
                     value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):
                  </p>
                  <div class="exampleInner"><pre>fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</pre></div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-errors-and-opt"></a>2.3.4 Errors and
                     Optimization
                  </h4>
                  <p>Because different implementations may
                     choose to evaluate or optimize an expression in different ways,
                     certain aspects of raising <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> are <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>, as described in this section.
                  </p>
                  <p>An implementation is always free to evaluate the operands of an operator in any order.</p>
                  <p>In some cases,  a processor can determine the result of an expression without accessing
                     all the data that would be implied by the formal expression semantics. For example,
                     the formal description of <a title="filter expression" href="#dt-filter-expression">filter expressions</a> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression
                     by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore
                     greatly improve performance. However, a consequence of this strategy is that a dynamic
                     error or type error that would be detected if the expression semantics were followed
                     literally might not be detected at all if the evaluation exits early. In this example,
                     such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.
                  </p>
                  <p>The extent to which a processor may optimize its access to data, at the cost of not
                     raising errors, is defined by the following rules.
                  </p>
                  <p>Consider an expression <em>Q</em> that has an operand (sub-expression) <em>E</em>. In general the value of <em>E</em> is a sequence. At an intermediate stage during evaluation of the sequence, some of
                     its items will be known and others will be unknown. If, at such an intermediate stage
                     of evaluation, a processor is able to establish that there are only two possible outcomes
                     of evaluating <em>Q</em>, namely the value <em>V</em> or an error, then the processor may deliver the result <em>V</em> without evaluating further items in the operand <em>E</em>. For this purpose, two values are considered to represent the same outcome if their
                     items are pairwise the same, where nodes are the same if they have the same identity,
                     and values are the same if they are equal and have exactly the same type.
                  </p>
                  <p>There is an exception to this rule: If a processor evaluates an operand <em>E</em> (wholly or in part), then it  is required to establish that the actual value of the
                     operand <em>E</em> does not violate any constraints on its cardinality. For example, the expression
                     <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating
                     the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value
                     of <code>$e</code> contains no more than one item.
                  </p>
                  <p>These rules apply to all the operands of an expression considered in combination:
                     thus if an expression has two operands <em>E1</em> and <em>E2</em>, it may be evaluated using any samples of the respective sequences that satisfy the
                     above rules.
                  </p>
                  <p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and <em>B</em> is an operand of <em>C</em>, then the processor needs to evaluate only a sufficient sample of <em>B</em> to determine the value of <em>C</em>, and needs to evaluate only a sufficient sample of <em>A</em> to determine this sample of <em>B</em>.
                  </p>
                  <p>The effect of these rules is that the processor is free to stop examining further
                     items in a sequence as soon as it can establish that further items would not affect
                     the result except possibly by causing an error. For example, the processor may return
                     <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.
                  </p>
                  <p>Another consequence of these rules is that where none of the items in a sequence contributes
                     to the result of an expression, the processor is not obliged to evaluate any part
                     of the sequence. Again, however, the processor cannot dispense with a required cardinality
                     check: if an empty sequence is not permitted in the relevant context, then the processor
                     must ensure that the operand is not an empty sequence.
                  </p>
                  <p>Examples:</p>
                  <ul>
                     <li>
                        <p>If an implementation can find (for example, by using an index) that at
                           least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to
                           return <code>true</code> as the result of the <code>some</code> expression, without searching for
                           another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
                           
                        </p>
                        <div class="exampleInner"><pre>some $x in $expr1 satisfies $x = 47</pre></div>
                     </li>
                     <li>
                        <p>In the following example, if an implementation can find (for example, by using an
                           index) the
                           <code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the
                           result of the <a title="path expression" href="#dt-path-expression">path expression</a>, without searching for another <code>product</code> node that
                           would raise an error because it has an <code>id</code> child whose value is not an integer.
                        </p>
                        <div class="exampleInner"><pre>//product[id = 47]</pre></div>
                     </li>
                  </ul>
                  <p>For a variety of reasons, including optimization, implementations
                     may rewrite expressions into a different
                     form. There are a number of rules that limit the extent of this freedom:
                     
                  </p>
                  <ul>
                     <li>
                        <p>
                           Other than the raising or not raising of errors, the result
                           of evaluating a rewritten expression must
                           conform to the semantics
                           defined in this specification for the original expression.
                           
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>
                              This allows an implementation to return a result in cases where the
                              original expression would have raised an error, or to raise an error in cases
                              where the original expression would have returned a result. The main cases
                              where this is likely to arise in practice are (a) where a rewrite changes the
                              order of evaluation, such that a subexpression causing an error is evaluated
                              when the expression is written one way and is not evaluated when the expression
                              is written a different way, and (b) where intermediate results of the
                              evaluation cause overflow or other out-of-range conditions.
                              
                           </p>
                        </div>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>
                              This rule does not mean that the result of the expression will always
                              be the same in non-error cases as if it had not been rewritten, because there
                              are many cases where the result of an expression is to some degree
                              <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>
                              or <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                              
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           <span class="xpath">Conditional</span> expressions
                           must not raise a dynamic error in
                           respect of subexpressions occurring in a branch that is not selected,
                           and must not
                           return the value delivered by a branch unless that branch is selected.
                           Thus, the following example must not raise a
                           dynamic error if the document <code>abc.xml</code> does not exist:
                           
                        </p>
                        <div class="exampleInner"><pre>if (doc-available('abc.xml')) then doc('abc.xml') else ()</pre></div>
                        <p>Of course, the condition must be evaluated in order to determine which branch is selected,
                           and the query must not be rewritten in a way that would bypass evaluating the condition.
                        </p>
                     </li>
                     <li>
                        <p>
                           As stated earlier, an expression
                           must not be rewritten to dispense with a
                           required cardinality check: for example, <code>string-length(//title)</code>
                           must raise an
                           error if the document contains more than one title element.
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           Expressions must not be rewritten in such a way
                           as to create or remove static errors.
                           
                           The static errors in this specification are defined
                           for the original expression, and must be preserved if
                           the expression is rewritten.
                        </p>
                     </li>
                  </ul>
                  <p>
                     Expression rewrite is illustrated by the following examples.
                     
                  </p>
                  <ul>
                     <li>
                        <p>Consider the expression <code>//part[color eq "Red"]</code>. An implementation might
                           choose to rewrite this expression as <code>//part[color = "Red"][color eq
                              "Red"]</code>. The implementation might then process the expression as follows:
                           First process the "<code>=</code>" predicate by probing an index on parts by color to
                           quickly find all the parts that have a Red color; then process the "<code>eq</code>"
                           predicate by checking each of these parts to make sure it has only a
                           single color. The result would be as follows:
                           
                           
                        </p>
                        <ul>
                           <li>
                              <p>Parts that have exactly one color that is Red are returned.</p>
                           </li>
                           <li>
                              <p>If some part has color Red together with some other color, an error is
                                 raised.
                              </p>
                           </li>
                           <li>
                              <p>The existence of some part that has no color Red but has multiple non-Red
                                 colors does not trigger an error.
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>The expression in the following example cannot raise a casting error if it is evaluated
                           exactly as written (i.e., left to right). Since neither predicate depends on the context
                           position, an implementation might choose to reorder the predicates to achieve better
                           performance (for example, by taking advantage of an index). This
                           reordering could cause the expression to raise an
                           error.
                        </p>
                        <div class="exampleInner"><pre>$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</pre></div>
                        <p>To avoid unexpected errors caused by expression rewrite,
                           tests that are designed to prevent dynamic errors should be expressed
                           using conditional  expressions. For example, the above expression can be written as
                           follows:
                        </p>
                        <div class="exampleInner"><pre>$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</pre></div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-important-concepts"></a>2.4 Concepts
               </h3>
               <p>This section explains some concepts that are important to the processing of XPath
                  3.1 expressions.
               </p>
               <div class="div3">
                  
                  <h4><a id="id-document-order"></a>2.4.1 Document Order
                  </h4>
                  <p>An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xpath">expression</span>, which may consist of one or more <b>trees</b> (documents or fragments). 
                     
                     Document order is defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#document-order">Section 
                        
                        2.4 Document Order
                        </a><sup><small>DM31</small></sup>, and its definition is repeated here for convenience. 
                     
                     Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.  
                     
                     [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.]  
                     
                     [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing
                     of a given <span class="xpath">expression</span>, even if this order is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.]
                     
                     [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.]
                     
                  </p>
                  <p>Within a tree, document order satisfies the following constraints:</p>
                  <ol class="enumar">
                     <li>
                        <p>The root node is the first node.</p>
                     </li>
                     <li>
                        <p>Every node occurs before all of its children and descendants.</p>
                     </li>
                     <li>
                        <p>Namespace nodes immediately follow the element node with
                           which they are associated. The relative order of namespace nodes is
                           stable but <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
                        </p>
                     </li>
                     <li>
                        <p>Attribute nodes immediately follow the <span class="xpath">namespace nodes of the
                              </span> element node with which they are associated. The relative order of
                           attribute nodes is stable but <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
                        </p>
                     </li>
                     <li>
                        <p>The relative order of siblings is the order in which they occur
                           in the <code>children</code> property of their parent node.
                        </p>
                     </li>
                     <li>
                        <p>Children and descendants occur before following siblings.</p>
                     </li>
                  </ol>
                  <p>The relative order of nodes in distinct trees is stable but
                     <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>,
                     subject to the following constraint: If any node in a given tree T1 is before
                     any node in a different tree T2, then all nodes in tree T1 are before all nodes in
                     tree T2.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-atomization"></a>2.4.2 Atomization
                  </h4>
                  <p>The semantics of some
                     XPath 3.1 operators depend on a process called <a title="atomization" href="#dt-atomization">atomization</a>. Atomization is
                     applied to a value when the value is used in a context in which a
                     sequence of atomic values is required. The result of atomization is
                     either a sequence of atomic values or a <a title="type error" href="#dt-type-error">type error</a>  
                     [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012" title="err:FOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup>.  [<a id="dt-atomization" title="atomization">Definition</a>: 
                     <b>Atomization</b> of a sequence
                     is defined as the result of invoking the <span>
                        <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 
                           
                           2.4 fn:data
                           </a><sup><small>FO31</small></sup>.</span>
                     
                     ]
                     
                  </p>
                  <p> The semantics of
                     <code>fn:data</code> are repeated here for convenience. The result of
                     <code>fn:data</code> is the sequence of atomic values produced by
                     applying the following rules to each item in the input
                     sequence:
                  </p>
                  <ul>
                     <li>
                        <p>If the item is an atomic value, it is
                           returned.
                        </p>
                     </li>
                     <li>
                        <p>If the item is a node,
                           its <a title="typed value" href="#dt-typed-value">typed value</a> is returned (<span>a <a title="type error" href="#dt-type-error">type error</a>
                              </span> 
                           [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012" title="err:FOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup> is raised if the node has no typed value.)
                        </p>
                     </li>
                     <li>
                        <p>If the item is a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup> 
                           <span>(other than an array) </span>
                           <span>or map a <a title="type error" href="#dt-type-error">type error</a>
                              </span> 
                           <span>
                              [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0013" title="err:FOTY0013">err:FOTY0013</a>]<sup><small>FO31</small></sup>
                              </span> is raised.
                        </p>
                     </li>
                     <li>
                        <p>If the item is an array <code>$a</code>, atomization is defined as 
                           <code>$a?* ! fn:data(.)</code>, which is equivalent to atomizing the members of the array.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This definition recursively atomizes members that are arrays. Hence, the result of
                              atomizing the array <code>[ [1, 2, 3], [4, 5, 6] ]</code> is the sequence <code>(1, 2, 3, 4, 5, 6)</code>.
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>Atomization is  used in
                     processing the following types of expressions: 
                  </p>
                  <ul>
                     <li>
                        <p>Arithmetic expressions</p>
                     </li>
                     <li>
                        <p>Comparison expressions</p>
                     </li>
                     <li>
                        <p>Function calls and returns</p>
                     </li>
                     <li>
                        <p>Cast expressions</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-ebv"></a>2.4.3 Effective Boolean Value
                  </h4>
                  <p>Under certain circumstances (listed below), it is necessary to find
                     the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a
                     value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The
                     <b>effective boolean value</b> of a value is defined as the result
                     of applying the <code>fn:boolean</code> function to the value, as
                     defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 
                        
                        7.3.1 fn:boolean
                        </a><sup><small>FO31</small></sup>.]
                     
                  </p>
                  <p>The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.
                        </p>
                     </li>
                     <li>
                        <p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.
                        </p>
                     </li>
                     <li>
                        <p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.
                        </p>
                     </li>
                     <li>
                        <p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.
                        </p>
                     </li>
                     <li>
                        <p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of any <a title="numeric" href="#dt-numeric">numeric</a> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.
                        </p>
                     </li>
                     <li>
                        <p>In all other cases, <code>fn:boolean</code> raises a type error [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>]<sup><small>FO31</small></sup>.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>For instance, <code>fn:boolean</code> raises a type error if the operand is a function, a map, or an array.
                           </p>
                        </div>
                     </li>
                  </ol>
                  <p>The <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during  processing of the following types of
                     expressions: 
                  </p>
                  <ul>
                     <li>
                        <p>Logical expressions (<code>and</code>, <code>or</code>)
                        </p>
                     </li>
                     <li>
                        <p>The <code>fn:not</code> function
                        </p>
                     </li>
                     <li>
                        <p>Certain types of <a title="" href="#dt-predicate">predicates</a>, such as <code>a[b]</code>
                           
                        </p>
                     </li>
                     <li>
                        <p>Conditional expressions (<code>if</code>)
                        </p>
                     </li>
                     <li>
                        <p>Quantified expressions (<code>some</code>, <code>every</code>)
                        </p>
                     </li>
                     <li>
                        <p>General comparisons, in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
                              		compatibility mode</a>.
                        </p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The definition of <a title="effective boolean value" href="#dt-ebv">effective boolean
                           value</a> is <em>not</em> used when casting a value to the
                        type <code>xs:boolean</code>, for example in a <code>cast</code>
                        expression or when passing a value to a function whose expected
                        parameter is of type <code>xs:boolean</code>.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-input-sources"></a>2.4.4 Input Sources
                  </h4>
                  <p>XPath 3.1 has a set of functions that provide access to XML documents (<code>fn:doc</code>, <code>fn:doc-available</code>), collections (<code>fn:collection</code>, <code>fn:uri-collection</code>), text files (<code>fn:unparsed-text</code>, <code>fn:unparsed-text-lines</code>, <code>fn:unparsed-text-available</code>), and environment variables (<code>fn:environment-variable</code>, <code>fn:available-environment-variables</code>).  These functions are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#fns-on-docs">Section 
                        
                        14.6 Functions giving access to external information
                        </a><sup><small>FO31</small></sup>.
                  </p>
                  <p>An expression can access input data either by calling one
                     of these input functions or by referencing some part of the
                     <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that is initialized by the external
                     environment, such as a <a title="variable values" href="#dt-variable-values">variable</a> or
                     <a title="context item" href="#dt-context-item">context item</a>.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-uri-literals"></a>2.4.5 URI Literals
                  </h4>
                  <p>XPath 3.1 requires a statically known, valid URI in a <a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a>. 
                     
                     An implementation may raise a <a title="static error" href="#dt-static-error">static error</a> 
                     [<a href="#ERRXQST0046" title="err:XQST0046">err:XQST0046</a>] if the value of  a Braced URI Literal is of nonzero length
                     and is neither an
                     absolute URI nor a relative URI.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <code>xs:anyURI</code>
                        type is designed to anticipate the introduction of
                        Internationalized Resource Identifiers (IRI's) as defined in
                        <a href="#RFC3987">[RFC3987]</a>.
                     </p>
                  </div>
                  <p>Whitespace is normalized using the whitespace normalization rules
                     of <code>fn:normalize-space</code>. If the result of whitespace
                     normalization contains only whitespace, the corresponding URI
                     consists of the empty string.  
                  </p>
                  <p>A Braced URI Literal or URI Literal is not
                     subjected to percent-encoding
                     or decoding as defined in <a href="#RFC3986">[RFC3986]</a>.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-resolve-relative-uri"></a>2.4.6 Resolving a Relative URI Reference
                  </h4>
                  <p>
                     [<a id="dt-resolve-relative-uri" title="resolve">Definition</a>: To
                     <b>resolve a relative URI</b> 
                     <code>$rel</code> against a
                     base URI <code>$base</code> is to expand it to an absolute URI,
                     as if by calling the function <code>fn:resolve-uri($rel,
                        $base)</code>.] During static analysis, the base URI is
                     the Static Base URI. During dynamic evaluation, the base URI
                     used to resolve a relative URI reference depends on the semantics of the
                     expression.
                  </p>
                  <p>Any process that attempts to <a title="resolve" href="#dt-resolve-relative-uri">resolve URI</a> against a
                     base URI, or to dereference the URI, may apply percent-encoding
                     or decoding as defined in the relevant RFCs.
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-types"></a>2.5 Types
               </h3>
               <p>The type system of XPath 3.1 is based on
                  		<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.
                  
               </p>
               <p>
                  [<a id="dt-sequence-type" title="sequence type">Definition</a>: A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath31-SequenceType">SequenceType</a>
                  syntax. Sequence types are used whenever it is necessary to refer to a type in an
                  XPath 3.1 expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an XPath 3.1 value, which
                  is always a sequence.]
                  
               </p>
               <p>
                  [<a id="dt-schema-type" title="schema type">Definition</a>: A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the built-in types).] A schema type  can be used as a type annotation
                  on an
                  element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>, in which case its derived
                  types can be so used). Every schema type is either a <b>complex type</b> or a
                  <b>simple type</b>; simple types are further subdivided into <b>list types</b>, <b>union
                     types</b>, and <b>atomic types</b> (see <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> for definitions and explanations of these terms.)
               </p>
               <p>
                  [<a id="dt-generalized-atomic-type" title="generalized atomic type">Definition</a>: A <b>generalized atomic type</b> is a type which is either (a) an atomic type or (b) a <a title="pure union type" href="#dt-pure-union-type">pure union type</a>
                  ].
               </p>
               <p>
                  [<a id="dt-pure-union-type" title="pure union type">Definition</a>: A <b>pure union type</b> is an XML Schema union type that satisfies the following constraints:
                  (1) <code>{variety}</code> is <code>union</code>, (2) the <code>{facets}</code> property is empty, (3) no type in the transitive membership of the union type has
                  <code>{variety}</code> 
                  <code>list</code>, and (4) no type in the transitive membership of the union type is a type with <code>{variety}</code> 
                  <code>union</code> having a non-empty <code>{facets}</code> property].
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The definition of <a title="pure union type" href="#dt-pure-union-type">pure union type</a>
                     excludes union types derived by non-trivial restriction from other
                     union types, as well as union types that include list types in their
                     membership. Pure union types have the property that every
                     instance of an atomic type defined as one of the member types of the
                     union is also a valid instance of the union type.
                  </p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The current (second) edition of XML Schema 1.0 contains an
                     error in respect of the substitutability of a union type by one of its
                     members: it fails to recognize that this is unsafe if the union is
                     derived by restriction from another union.
                  </p>
                  <p>This problem is fixed in XSD 1.1, but the effect of the resolution
                     is that an atomic value labeled with an atomic type cannot be treated
                     as being substitutable for a union type without explicit validation.
                     This specification therefore allows union types to be used as item
                     types only if they are defined directly as the union of a number of
                     atomic types.
                  </p>
               </div>
               <p>
                  <a title="generalized atomic type" href="#dt-generalized-atomic-type">Generalized atomic types</a>
                  represent the intersection between the categories of <a title="sequence type" href="#dt-sequence-type">sequence type</a> and <a title="schema type" href="#dt-schema-type">schema type</a>. A generalized atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <a title="sequence type" href="#dt-sequence-type">sequence type</a> and a
                  <a title="schema type" href="#dt-schema-type">schema type</a>.
               </p>
               <div class="div3">
                  
                  <h4><a id="id-predefined-types"></a>2.5.1 Predefined Schema Types
                  </h4>
                  <p class="xpath">The <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>
                     in the <a title="static context" href="#dt-static-context">static
                        context</a> are initialized with a set of
                     predefined schema types that is determined by the host
                     language. This set may include some or all of the
                     schema types in the
                     namespace
                     <code>http://www.w3.org/2001/XMLSchema</code>,
                     represented in this document by the namespace prefix
                     <code>xs</code>. The schema types in this namespace are defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>
                     and augmented by additional types defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. An implementation
                     that has based its type system on <a href="#XMLSchema10">[XML Schema 1.0]</a> is not required to support the <code>xs:dateTimeStamp</code> 
                     <span>or <code>xs:error</code> types.</span>
                     
                     
                  </p>
                  <p>The schema types defined in  <a href="https://www.w3.org/TR/xpath-datamodel-31/#types-predefined">Section 
                        
                        2.7.2 Predefined Types
                        </a><sup><small>DM31</small></sup> are summarized below.
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>
                           [<a id="dt-untyped" title="xs:untyped">Definition</a>: 
                           <code>xs:untyped</code> is  used as the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.] No predefined schema types are derived from <code>xs:untyped</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-untypedAtomic" title="xs:untypedAtomic">Definition</a>: 
                           <code>xs:untypedAtomic</code>
                           is an atomic type that is used to denote untyped atomic data, such as text that has
                           not been assigned a more specific type.] An attribute that has been validated in <code>skip</code> mode is represented in the <a title="data model" href="#dt-datamodel">data model</a> by an attribute node with the <a title="type annotation" href="#dt-type-annotation">type annotation</a> 
                           <code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-dayTimeDuration" title="xs:dayTimeDuration">Definition</a>: 
                           <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
                           is restricted to contain only day, hour, minute, and second
                           components.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-yearMonthDuration" title="xs:yearMonthDuration">Definition</a>: 
                           <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
                           restricted to contain only year and month
                           components.]
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-anyAtomicType" title="xs:anyAtomicType">Definition</a>: 
                           <code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
                           are not atomic). Its base type is
                           <code>xs:anySimpleType</code> from which all simple types, including atomic,
                           list, and union types, are derived. All primitive atomic types, such as
                           <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.]
                           
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>
                              <code>xs:anyAtomicType</code>  will not appear as the type of an actual value in an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a>.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>
                           [<a id="dt-xs-error" title="xs:error">Definition</a>: 
                           <code>xs:error</code> is a simple type with no value space.  It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error">Section 
                              
                              3.16.7.3 xs:error
                              
                              </a><sup><small>XS11-1</small></sup> and  can be used in the <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a> to raise errors.]
                           
                        </p>
                     </li>
                  </ol>
                  <p>The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XPath 3.1
                     type hierarchy can be found in 
                     <a href="https://www.w3.org/TR/xpath-functions-31/#datatypes">Section 
                        
                        1.6 Type System
                        </a><sup><small>FO31</small></sup>.
                  </p><img src="types.jpg" alt="Type Hierarchy Diagram"><p>Figure 2: Hierarchy of Schema Types used in XPath 3.1.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-namespace-sensitive"></a>2.5.2 Namespace-sensitive Types
                  </h4>
                  <p>
                     [<a id="dt-namespace-sensitive" title="namespace-sensitive">Definition</a>: The <b>namespace-sensitive</b>
                     types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types
                     derived by restriction from <code>xs:QName</code> or
                     <code>xs:NOTATION</code>, list types that have a namespace-sensitive
                     item type, and union types with a namespace-sensitive type in their
                     transitive membership.]
                     
                  </p>
                  <p>It is not possible to preserve the type of a <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a> value without also preserving the namespace binding that defines the meaning of each
                     namespace prefix used in the value. Therefore, XPath 3.1 defines some error conditions
                     that occur only with <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a> values. For instance, casting to a <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a> type raises 
                     a <a title="type error" href="#dt-type-error">type error</a> 
                     [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFONS0004" title="err:FONS0004">err:FONS0004</a>]<sup><small>FO31</small></sup> if the namespace bindings for the result cannot be determined. 
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-typed-value"></a>2.5.3 Typed Value and String Value
                  </h4>
                  <p>Every node has a <b>typed value</b> and a <b>string value</b>, except for nodes whose value is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
                     
                     [<a id="dt-typed-value" title="typed value">Definition</a>: The <b>typed
                        value</b> of a node is a sequence of atomic values and can be
                     extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 
                        
                        2.4 fn:data
                        </a><sup><small>FO31</small></sup> function to the
                     node.] 
                     [<a id="dt-string-value" title="string value">Definition</a>: The
                     <b>string value</b> of a node is a string and can be extracted
                     by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 
                        
                        2.3 fn:string
                        </a><sup><small>FO31</small></sup>
                     function to the node.]
                     
                     
                  </p>
                  <p>An implementation may store both the <a title="typed value" href="#dt-typed-value">typed value</a> and the <a title="string value" href="#dt-string-value">string value</a> of a node, or it may store only one of these and derive the other as needed. The
                     string value of a node must be a valid lexical representation of the typed value of
                     the node, but the node is not required to preserve the string representation from
                     the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".
                  </p>
                  <p class="xpath">The <a title="typed value" href="#dt-typed-value">typed value</a>, <a title="string value" href="#dt-string-value">string value</a>, and <a title="type annotation" href="#dt-type-annotation">type annotation</a> of a node are closely related.  If the node was created by mapping from an Infoset
                     or PSVI, the relationships among these properties are defined by rules in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 
                        
                        2.7 Schema Information
                        </a><sup><small>DM31</small></sup>.
                  </p>
                  <p>As a convenience to the reader, the relationship between <a title="typed value" href="#dt-typed-value">typed value</a> and
                     <a title="string value" href="#dt-string-value">string value</a> for various kinds of nodes is summarized and illustrated
                     by examples below.
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>For text and document nodes, the typed value of the node is the same as its
                           string value, as an instance of  the type <code>xs:untypedAtomic</code>. The
                           string value of a document node is formed by concatenating the string
                           values of all its descendant text nodes, in <a title="document order" href="#dt-document-order">document
                              order</a>.
                        </p>
                     </li>
                     <li>
                        <p>The typed value of a comment<span class="xpath">, namespace,</span> or processing instruction node is the same as its string value. It is an instance
                           of the type <code>xs:string</code>.
                        </p>
                     </li>
                     <li>
                        <p>The typed value of an attribute node with
                           the <a title="type annotation" href="#dt-type-annotation">type annotation</a> 
                           <code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its
                           string value, as an instance of <code>xs:untypedAtomic</code>. The
                           typed value of an attribute node with any other type annotation is
                           derived from its string value and type annotation using the lexical-to-value-space
                           mapping defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 2 for
                           the relevant type.
                        </p>
                        <p>Example: A1 is an attribute
                           having string value <code>"3.14E-2"</code> and type annotation
                           <code>xs:double</code>.  The typed value of A1 is the
                           <code>xs:double</code> value whose lexical representation is
                           <code>3.14E-2</code>. 
                        </p>
                        <p>Example: A2 is an attribute with type
                           annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
                           "<code>bar baz faz</code>". The typed value of A2 is a sequence of
                           three atomic values ("<code>bar</code>", "<code>baz</code>",
                           "<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
                           value of a node is never treated as an instance of a named list
                           type. Instead, if the type annotation of a node is a list type (such
                           as <code>xs:IDREFS</code>), its typed value is treated as a sequence
                           of the <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a> from which it is derived (such as
                           <code>xs:IDREF</code>).
                        </p>
                     </li>
                     <li>
                        <p>For an element node, the
                           relationship between typed value and string value depends on the
                           node's <a title="type annotation" href="#dt-type-annotation">type annotation</a>, as follows:
                        </p>
                        <ol class="enumla">
                           <li>
                              <p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or
                                 denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
                                 node is equal to its string value, as an instance of
                                 <code>xs:untypedAtomic</code>.  However, if the <code>nilled</code>
                                 property of the node is <code>true</code>, then its typed value is the empty sequence.
                              </p>
                              <p>Example: E1 is an element node
                                 having type annotation <code>xs:untyped</code> and string value
                                 "<code>1999-05-31</code>". The typed value of E1 is
                                 "<code>1999-05-31</code>", as an instance of
                                 <code>xs:untypedAtomic</code>.
                              </p>
                              <p>Example: E2 is an element node
                                 with the type annotation <code>formula</code>, which is a complex type
                                 with mixed content. The content of E2 consists of the character
                                 "<code>H</code>", a child element named <code>subscript</code> with
                                 string value "<code>2</code>", and the character "<code>O</code>". The
                                 typed value of E2 is "<code>H2O</code>" as an instance of
                                 <code>xs:untypedAtomic</code>.
                              </p>
                           </li>
                           <li>
                              <p>If the type
                                 annotation denotes a simple type or a complex type with simple
                                 content, then the typed value of the node is derived from its string
                                 value and its type annotation in a way that is consistent with schema
                                 validation. However, if the <code>nilled</code>
                                 property of the node is <code>true</code>, then its typed value is the empty sequence.
                              </p>
                              <p>Example: E3 is an element node with the type
                                 annotation <code>cost</code>, which is a complex type that has several
                                 attributes and a simple content type of <code>xs:decimal</code>. The
                                 string value of E3 is "<code>74.95</code>". The typed value of E3 is
                                 <code>74.95</code>, as an instance of
                                 <code>xs:decimal</code>.
                              </p>
                              <p>Example: E4 is an element node with the
                                 type annotation <code>hatsizelist</code>, which is a simple type
                                 derived from the atomic type <code>hatsize</code>, which in turn is
                                 derived from <code>xs:integer</code>. The string value of E4 is
                                 "<code>7 8 9</code>". The typed value of E4 is a sequence of three
                                 values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
                                 <code>hatsize</code>.
                              </p>
                              <p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation
                                 of a node is a union type, the typed value of the node will be an instance of one
                                 of the member types of the union.
                              </p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>If an implementation stores only the string value of a node, and the type annotation
                                    of the node is a union type, the implementation must be able to deliver the typed
                                    value of the node as an instance of the appropriate member type.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>If the type annotation
                                 denotes a complex type with empty content, then the typed value of the
                                 node is the empty sequence and its string value is the zero-length string.
                              </p>
                           </li>
                           <li>
                              <p>If the type annotation
                                 denotes a complex type with element-only content, then the typed value
                                 of the node is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The <code>fn:data</code> function raises a
                                 <a title="type error" href="#dt-type-error">type error</a> 
                                 [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012" title="err:FOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup> when applied to such a node. The string value of such a node is equal to the concatenated
                                 string values of all its text node descendants, in document order.
                              </p>
                              <p>Example: E6 is an
                                 element node with the type annotation <code>weather</code>, which is a
                                 complex type whose content type specifies
                                 <code>element-only</code>. E6 has two child elements named
                                 <code>temperature</code> and <code>precipitation</code>. The typed
                                 value of E6 is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, and the <code>fn:data</code> function
                                 applied to E6 raises an error.
                                 
                              </p>
                           </li>
                        </ol>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-sequencetype-syntax"></a>2.5.4 SequenceType Syntax
                  </h4>
                  <p>Whenever it is necessary to refer to a type in an XPath 3.1 expression, the <a href="#doc-xpath31-SequenceType">SequenceType</a> syntax is used.
                  </p>
                  <a id="d2e4926"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-SequenceType"></a>[79]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-SequenceType">SequenceType</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>("empty-sequence"  "("  ")")<br>|  (<a href="#doc-xpath31-ItemType">ItemType</a>  
                                 <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ItemType"></a>[81]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ItemType">ItemType</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#doc-xpath31-FunctionTest">FunctionTest</a>  |  <a href="#doc-xpath31-MapTest">MapTest</a>  |  <a href="#doc-xpath31-ArrayTest">ArrayTest</a>  |  <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>  |  <a href="#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-OccurrenceIndicator"></a>[80]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"?"  |  "*"  |  "+"</code></td>
                           <td><i>/* 
                                 <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AtomicOrUnionType"></a>[82]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-KindTest"></a>[83]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-KindTest">KindTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-DocumentTest">DocumentTest</a>
                                 <br>|  <a href="#doc-xpath31-ElementTest">ElementTest</a>
                                 <br>|  <a href="#doc-xpath31-AttributeTest">AttributeTest</a>
                                 <br>|  <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
                                 <br>|  <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
                                 <br>|  <a href="#doc-xpath31-PITest">PITest</a>
                                 <br>|  <a href="#doc-xpath31-CommentTest">CommentTest</a>
                                 <br>|  <a href="#doc-xpath31-TextTest">TextTest</a>
                                 <br>|  <a href="#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a>
                                 <br>|  <a href="#doc-xpath31-AnyKindTest">AnyKindTest</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-DocumentTest"></a>[85]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-DocumentTest">DocumentTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"document-node"  "("  (<a href="#doc-xpath31-ElementTest">ElementTest</a>  |  <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4845.doc-xpath31-ElementTest"></a>[94]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ElementTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"element"  "("  (<a href="#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#doc-xpath31-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4846.doc-xpath31-SchemaElementTest"></a>[96]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>SchemaElementTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"schema-element"  "("  <a href="#doc-xpath31-ElementDeclaration">ElementDeclaration</a>  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4847.doc-xpath31-ElementDeclaration"></a>[97]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ElementDeclaration</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ElementName">ElementName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4848.doc-xpath31-AttributeTest"></a>[90]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>AttributeTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"attribute"  "("  (<a href="#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#doc-xpath31-TypeName">TypeName</a>)?)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4850.doc-xpath31-SchemaAttributeTest"></a>[92]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>SchemaAttributeTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"schema-attribute"  "("  <a href="#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4851.doc-xpath31-AttributeDeclaration"></a>[93]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>AttributeDeclaration</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AttributeName">AttributeName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4852.doc-xpath31-ElementNameOrWildcard"></a>[95]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ElementNameOrWildcard</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ElementName">ElementName</a>  |  "*"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ElementName"></a>[99]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ElementName">ElementName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4854.doc-xpath31-AttribNameOrWildcard"></a>[91]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>AttribNameOrWildcard</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AttributeName">AttributeName</a>  |  "*"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AttributeName"></a>[98]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AttributeName">AttributeName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-TypeName"></a>[101]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-TypeName">TypeName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-PITest"></a>[89]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-PITest">PITest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"processing-instruction"  "("  (<a href="#prod-xpath31-NCName">NCName</a>  |  <a href="#doc-xpath31-StringLiteral">StringLiteral</a>)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-CommentTest"></a>[87]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-CommentTest">CommentTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"comment"  "("  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-NamespaceNodeTest"></a>[88]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"namespace-node"  "("  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-TextTest"></a>[86]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-TextTest">TextTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"text"  "("  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AnyKindTest"></a>[84]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AnyKindTest">AnyKindTest</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"node"  "("  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4863.doc-xpath31-FunctionTest"></a>[102]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>FunctionTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a>
                                 <br>|  <a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4864.doc-xpath31-AnyFunctionTest"></a>[103]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>AnyFunctionTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"function"  "("  "*"  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4865.doc-xpath31-TypedFunctionTest"></a>[104]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>TypedFunctionTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"function"  "("  (<a href="#doc-xpath31-SequenceType">SequenceType</a>  (","  <a href="#doc-xpath31-SequenceType">SequenceType</a>)*)?  ")"  "as"  <a href="#doc-xpath31-SequenceType">SequenceType</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ParenthesizedItemType"></a>[111]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"("  <a href="#doc-xpath31-ItemType">ItemType</a>  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4867.doc-xpath31-MapTest"></a>[105]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>MapTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AnyMapTest">AnyMapTest</a>  |  <a href="#doc-xpath31-TypedMapTest">TypedMapTest</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e4868.doc-xpath31-ArrayTest"></a>[108]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ArrayTest</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AnyArrayTest">AnyArrayTest</a>  |  <a href="#doc-xpath31-TypedArrayTest">TypedArrayTest</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>With the exception of the special type
                     <code>empty-sequence()</code>, a <a title="sequence type" href="#dt-sequence-type">sequence type</a> consists of an
                     <b>item type</b> that constrains the type of each item in the
                     sequence, and a <b>cardinality</b> that constrains the number of
                     items in the sequence. Apart from the item type <code>item()</code>,
                     which permits any kind of item, item types divide into <b>node
                        types</b> (such as <code>element()</code>), <b>generalized atomic
                        types</b> (such as <code>xs:integer</code>) and function types
                     (such as function() as item()*).
                  </p>
                  <p>
                     <a title="lexical QName" href="#dt-qname">Lexical QNames</a> appearing in a <a title="sequence type" href="#dt-sequence-type">sequence type</a> have their
                     		  prefixes expanded to namespace URIs by means of the
                     		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> and (where applicable) the
                     		  <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>.
                     Equality of QNames is defined by the <code>eq</code> operator.
                  </p>
                  <p>Item types representing element
                     and attribute nodes may specify the required <a title="type annotation" href="#dt-type-annotation">type annotations</a> of those nodes, in
                     the form of a <a title="schema type" href="#dt-schema-type">schema
                        type</a>. Thus the item type <code>element(*, us:address)</code>
                     denotes any element node whose type annotation is (or is derived from)
                     the schema type named <code>us:address</code>.
                  </p>
                  <p>The occurrence indicators '+', '*', and '?' bind to the last <a href="#doc-xpath31-ItemType">ItemType</a> in the <a href="#doc-xpath31-SequenceType">SequenceType</a>, as described in <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.
                  </p>
                  <p>Here are some examples of <a title="sequence type" href="#dt-sequence-type">sequence types</a> that
                     		  might be used in XPath 3.1:
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code>
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>attribute()?</code> refers to an optional attribute node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>element()</code> refers to any element node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>node()*</code> refers to a sequence of zero or more nodes of any kind
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>item()+</code> refers to a sequence of one or more <a title="item" href="#dt-item">items</a>
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>function(*)</code> refers to any <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>, regardless of arity or type
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>function(node()) as xs:string*</code> refers to a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup> that takes a single argument whose value is a single node,
                           and returns a sequence of zero or more xs:string values
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>(function(node()) as xs:string)*</code> refers to a sequence of zero or more <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup>, each of which takes a single
                           argument whose value is a single node, and returns as its result a single xs:string
                           value
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-sequencetype-matching"></a>2.5.5 SequenceType Matching
                  </h4>
                  <p> 
                     [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: 
                     <b>SequenceType matching</b> compares the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
                     		  with an expected <a title="sequence type" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a given value matches a given <a title="sequence type" href="#dt-sequence-type">sequence type</a>, or <code>false</code> if it does not.
                  </p>
                  <p>An XPath 3.1 implementation must be able to determine relationships among the types
                     in type annotations in an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a> and the types in the  <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD). 
                  </p>
                  <p>
                     [<a id="dt-subtype-substitution" title="subtype substitution">Definition</a>: The use of a value whose <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> is derived from an
                     		  expected type is known as <b>subtype substitution</b>.]
                     		  Subtype substitution does not change the actual type of a value. For
                     		  example, if an <code>xs:integer</code> value is used where an
                     		  <code>xs:decimal</code> value is expected, the value retains its type
                     		  as <code>xs:integer</code>.
                  </p>
                  <p>The definition of <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> relies
                     		  on a pseudo-function named <code>derives-from(</code>
                     <em>AT</em>,
                     		  <em>ET</em>
                     <code>)</code>, which takes an actual simple or complex
                     		  schema type <em>AT</em> and an expected simple or complex schema
                     		  type <em>ET</em>, and either returns a boolean value or raises a
                     		  <a title="type error" href="#dt-type-error">type error</a> 
                     [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].  This function is defined as follows:
                  </p>
                  <ul>
                     <li>
                        <p>
                           <code>derives-from(</code>
                           <em>AT</em>, <em>ET</em>
                           <code>)</code> raises a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] if <em>ET</em> is
                           		    not present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD). 
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>derives-from(</code>
                           <em>AT</em>,
                           		    <em>ET</em>
                           <code>)</code> returns <code>true</code>  
                           		    if any of the following conditions applies:
                           
                           		    
                        </p>
                        <ul>
                           <li>
                              <p>
                                 <em>AT</em> is <em>ET</em>
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 <em>ET</em> is the base type of <em>AT</em>
                                 
                              </p>
                           </li>
                           <li>
                              <p>
                                 <em>ET</em> is a pure union type of which <em>AT</em> is a member type
                              </p>
                           </li>
                           <li>
                              <p>There is a type <em>MT</em> such that <code>derives-from(</code>
                                 <em>AT</em>, <em>MT</em>
                                 <code>)</code> 
                                 		      and <code>derives-from(</code>
                                 <em>MT</em>, <em>ET</em>
                                 <code>)</code>
                                 
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>Otherwise, <code>derives-from(</code>
                           <em>AT</em>, <em>ET</em>
                           <code>)</code> returns <code>false</code>
                           
                        </p>
                     </li>
                  </ul>
                  <p>The rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                        		  matching</a> are given below, with examples (the examples are
                     		  for purposes of illustration, and do not cover all possible
                     		  cases).
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-matching-value"></a>2.5.5.1 Matching a SequenceType and a Value
                     </h5>
                     <ul>
                        <li>
                           <p>The <a title="sequence type" href="#dt-sequence-type">sequence type</a> 
                              <code>empty-sequence()</code> matches a value that is the empty sequence.
                           </p>
                        </li>
                        <li>
                           <p>An <a href="#doc-xpath31-ItemType">ItemType</a> with no <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xpath31-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>2.5.5.2 Matching an ItemType and an Item</b></a>).
                           </p>
                        </li>
                        <li>
                           <p>An <a href="#doc-xpath31-ItemType">ItemType</a> with an <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xpath31-ItemType">ItemType</a> matches each of the items in the value.
                           </p>
                        </li>
                     </ul>
                     <p>An <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in
                        		    a sequence, as follows:
                     </p>
                     <ul>
                        <li>
                           <p> 
                              <code>?</code> matches zero or one items
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>*</code> matches zero or more items
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>+</code> matches one or more items
                           </p>
                        </li>
                     </ul>
                     <p>As a consequence of these rules, any <a title="sequence type" href="#dt-sequence-type">sequence type</a> whose
                        		    <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a
                        		    value that is an empty sequence.
                     </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-matching-item"></a>2.5.5.2 Matching an ItemType and an Item
                     </h5>
                     <ul>
                        <li>
                           <p>An <a href="#doc-xpath31-ItemType">ItemType</a> consisting simply of an
                              EQName is interpreted as an <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>.
                              
                              The expected type <em>AtomicOrUnionType</em> matches an atomic value whose
                              actual type is <em>AT</em> if <code>derives-from(</code>
                              <em>AT,
                                 AtomicOrUnionType</em>
                              <code>)</code> is <code>true</code>.
                           </p>
                           <p>
                              The name of an <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>
                              has its prefix expanded to a namespace URI by means of the
                              <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the
                              <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>.
                              If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of an
                              <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> is not defined as a  <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a> in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema
                                 types</a>, a <a title="static error" href="#dt-static-error">static
                                 error</a> is raised [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].
                           </p>
                           <p>Example: The <a href="#doc-xpath31-ItemType">ItemType</a>
                              <code>xs:decimal</code> matches any value of type
                              <code>xs:decimal</code>.  It also matches any value of type
                              <code>shoesize</code>, if <code>shoesize</code> is an atomic type
                              derived by restriction from <code>xs:decimal</code>.
                           </p>
                           <p>Example: Suppose <a href="#doc-xpath31-ItemType">ItemType</a> 
                              <code>dress-size</code> is a union type that allows
                              either <code>xs:decimal</code> values for numeric sizes (e.g. 4, 6, 10, 12),
                              or one of an enumerated set of <code>xs:strings</code> (e.g. "small", "medium", "large"). The <a href="#doc-xpath31-ItemType">ItemType</a> 
                              <code>dress-size</code> matches any of these values.
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The names of non-atomic
                                 types such as <code>xs:IDREFS</code> are not accepted in this context,
                                 but can often be replaced by a <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a> with an occurrence indicator, such as
                                 <code>xs:IDREF+</code>.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>
                              <code>item()</code> matches
                              any single <a title="item" href="#dt-item">item</a>.
                           </p>
                           <p>Example: <code>item()</code> matches the atomic
                              value <code>1</code>, the element <code>&lt;a/&gt;</code>, or the function <code>fn:concat#3</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>node()</code>
                              matches any node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>text()</code> matches any
                              text node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>processing-instruction()</code>
                              matches any processing-instruction
                              node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>processing-instruction(</code>
                              <em>N</em>
                              <code>)</code>
                              matches any processing-instruction node whose PITarget is equal to <code>fn:normalize-space(N)</code>. If <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]
                              
                           </p>
                           <p>Example:
                              <code>processing-instruction(xml-stylesheet)</code> matches any
                              processing instruction whose PITarget is
                              <code>xml-stylesheet</code>.
                           </p>
                           <p>For backward compatibility with
                              XPath 1.0, the PITarget of a
                              processing instruction may also be expressed as a
                              string literal, as in this example:
                              <code>processing-instruction("xml-stylesheet")</code>.
                           </p>
                           <p>If the specified PITarget is not a syntactically valid NCName, a type error is raised
                              [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>comment()</code> matches any comment node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>namespace-node()</code> matches any
                              namespace node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>document-node()</code> matches any document
                              node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>document-node(</code>
                              <em>E</em>
                              <code>)</code>
                              matches any document node that contains exactly one element node, optionally accompanied
                              by one or more comment and processing instruction nodes, if
                              <em>E</em> is an <a href="#doc-xpath31-ElementTest">ElementTest</a> or <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> that matches the element node (see
                              <a href="#id-element-test"><b>2.5.5.3 Element Test</b></a> and <a href="#id-schema-element-test"><b>2.5.5.4 Schema Element Test</b></a>).
                           </p>
                           <p>Example:
                              <code>document-node(element(book))</code> matches a document node
                              containing
                              exactly one element node that is matched by the ElementTest
                              <code>element(book)</code>.
                           </p>
                        </li>
                        <li>
                           <p>A <a href="#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a> matches an item if and only if the
                              item matches the <a href="#doc-xpath31-ItemType">ItemType</a> that is in parentheses.
                           </p>
                        </li>
                        <li>
                           <p>An <a href="#doc-xpath31-ItemType">ItemType</a> that is an
                              <a href="#doc-xpath31-ElementTest">ElementTest</a>, <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>, <a href="#doc-xpath31-AttributeTest">AttributeTest</a>,
                              <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>, or <a href="#doc-xpath31-FunctionTest">FunctionTest</a> matches an item as described in the following sections.
                              
                           </p>
                        </li>
                        <li>
                           <p>The <code>ItemType</code> 
                              <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a 
                              <a title="map" href="#dt-map">map</a>, and (b) every
                              entry in <var>M</var> has a key that matches <code>K</code> and an associated value that matches <code>V</code>. For example,
                              <code>map(xs:integer, element(employee))</code> matches a map if all the keys in the map are integers, and all the associated
                              values are <code>employee</code> elements. Note that a map (like a sequence) carries no intrinsic type information
                              separate
                              from the types of its entries, and the type of existing entries in a map does not
                              constrain the type of new entries that can be
                              added to the map.
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>In consequence, <code>map(K, V)</code> matches an empty map, 
                                 whatever the types <var>K</var> and <var>V</var> might be.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>The <code>ItemType</code> 
                              <code>map(*)</code> matches
                              any map regardless of its contents. It is equivalent to <code>map(xs:anyAtomicType, item()*)</code>.
                           </p>
                        </li>
                        <li>
                           <p>The <code>ItemType</code> 
                              <code>array(T)</code> matches any array in which the type of every member is <code>T</code>.
                           </p>
                        </li>
                        <li>
                           <p>The <code>ItemType</code> 
                              <code>array(*)</code> matches any array regardless of its contents.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-element-test"></a>2.5.5.3 Element Test
                     </h5>
                     <a id="d2e6092"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ElementTest"></a>[94]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ElementTest">ElementTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"element"  "("  (<a href="#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#doc-xpath31-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ElementNameOrWildcard"></a>[95]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-ElementName">ElementName</a>  |  "*"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e5726.doc-xpath31-ElementName"></a>[99]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>ElementName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e5727.doc-xpath31-TypeName"></a>[101]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>TypeName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        An <a href="#doc-xpath31-ElementTest">ElementTest</a> is used to match an
                        element node by its name and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a>.
                        
                     </p>
                     <p>
                        The <a href="#doc-xpath31-ElementName">ElementName</a> and <a href="#doc-xpath31-TypeName">TypeName</a> of an <a href="#doc-xpath31-ElementTest">ElementTest</a>
                        have their prefixes expanded to namespace URIs by means of the
                        <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the
                        <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>.
                        
                        The <a href="#doc-xpath31-ElementName">ElementName</a> need not be
                        present in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, but the <a href="#doc-xpath31-TypeName">TypeName</a> must be present in the
                        <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> 
                        [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>]. Note that
                        <a title="substitution group" href="#dt-substitution-group">substitution groups</a> do not affect the semantics of <a href="#doc-xpath31-ElementTest">ElementTest</a>.
                        
                     </p>
                     <p>
                        An <a href="#doc-xpath31-ElementTest">ElementTest</a> may take any of the following forms:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>
                              <code>element()</code> and
                              
                              <code>element(*)</code>  match any
                              single element node, regardless of its name or
                              type annotation.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(</code>
                              <a href="#doc-xpath31-ElementName">ElementName</a>
                              <code>)</code>
                              matches any element node whose name is <a href="#doc-xpath31-ElementName">ElementName</a>, regardless of its type annotation or <code>nilled</code> property.
                           </p>
                           <p>Example: <code>element(person)</code> matches any element node whose name is <code>person</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(</code>
                              <a href="#doc-xpath31-ElementName">ElementName</a>
                              <code>,</code> 
                              <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code>
                              matches an element node whose name is <a href="#doc-xpath31-ElementName">ElementName</a> if <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a> 
                              <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.
                           </p>
                           <p>Example: <code>element(person, surgeon)</code> matches a
                              non-nilled element node whose name is <code>person</code> and whose
                              type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). 
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(</code>
                              <a href="#doc-xpath31-ElementName">ElementName</a>, <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code> ?)</code>
                              matches an element node whose name is <a href="#doc-xpath31-ElementName">ElementName</a> if <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.
                           </p>
                           <p>Example: <code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
                              annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(*,
                                 </code>
                              <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code> matches an element
                              node regardless of its name, if
                              <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a> 
                              <code>)</code> is
                              <code>true</code>, where <em>AT</em> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.
                           </p>
                           <p>Example: <code>element(*, surgeon)</code>
                              matches any non-nilled element node whose type annotation is
                              <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(*,</code>
                              <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code> ?)</code> matches an element
                              node regardless of its name, if
                              <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a> 
                              <code>)</code> is
                              <code>true</code>, where <em>AT</em> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.
                           </p>
                           <p>Example: <code>element(*, surgeon?)</code>
                              matches any nilled or non-nilled element node whose type annotation is
                              <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-schema-element-test"></a>2.5.5.4 Schema Element Test
                     </h5>
                     <a id="d2e6442"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-SchemaElementTest"></a>[96]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-SchemaElementTest">SchemaElementTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"schema-element"  "("  <a href="#doc-xpath31-ElementDeclaration">ElementDeclaration</a>  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ElementDeclaration"></a>[97]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ElementDeclaration">ElementDeclaration</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-ElementName">ElementName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e6045.doc-xpath31-ElementName"></a>[99]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>ElementName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        A <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> matches an element node against a corresponding
                        element declaration found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.
                        
                     </p>
                     <p>
                        The <a href="#doc-xpath31-ElementName">ElementName</a> of a <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
                        has its prefixes expanded to a namespace URI by means of the
                        <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the
                        <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>.
                        
                        If the <a href="#doc-xpath31-ElementName">ElementName</a> specified in the <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
                        is not found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, a
                        <a title="static error" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].
                        
                     </p>
                     <p>
                        A <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> matches a candidate element node if all of the following conditions are satisfied:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>Either:</p>
                           <ol class="enumla">
                              <li>
                                 <p>The name <em>N</em> of the candidate node matches the specified <a href="#doc-xpath31-ElementName">ElementName</a>, or
                                 </p>
                              </li>
                              <li>
                                 <p>The name <em>N</em> of the candidate node matches the name of an element declaration that is a member
                                    of the actual substitution group headed by the declaration of element <a href="#doc-xpath31-ElementName">ElementName</a>.
                                 </p>
                              </li>
                           </ol>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The term "actual substitution group" is defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group of an element declaration <em>H</em> includes those element declarations <em>P</em> that are declared to have <em>H</em> as their direct or indirect substitution group head, provided that <em>P</em> is not declared as abstract, and that <em>P</em> is validly substitutable for <em>H</em>, which means that there must be no blocking constraints that prevent substitution.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>The schema element declaration named <em>N</em> is not abstract.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>derives-from( AT, ET )</code> is true, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared in the schema element declaration named <em>N</em>.
                           </p>
                        </li>
                        <li>
                           <p>If the schema element declaration named <em>N</em> is not nillable, then the nilled property of the candidate node is false.
                           </p>
                        </li>
                     </ol>
                     <p>Example: The <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> 
                        <code>schema-element(customer)</code> matches a candidate element node 
                        in the following two situations:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>customer is a top-level element declaration in the in-scope element declarations;
                              the name of the candidate node is customer; the element declaration of customer is
                              not abstract; the type annotation of the candidate node is the same as or derived
                              from the schema type declared in the customer element declaration; and either the
                              candidate node is not nilled, or customer is declared to be nillable.
                           </p>
                        </li>
                        <li>
                           <p>customer is a top-level element declaration in the in-scope element declarations;
                              the name of the candidate node is client; client is an actual (non-abstract and non-blocked)
                              member of the substitution group of customer; the type annotation of the candidate
                              node is the same as or derived from the schema type declared for the client element;
                              and either the candidate node is not nilled, or client is declared to be nillable.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-attribute-test"></a>2.5.5.5 Attribute Test
                     </h5>
                     <a id="d2e6604"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AttributeTest"></a>[90]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AttributeTest">AttributeTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"attribute"  "("  (<a href="#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#doc-xpath31-TypeName">TypeName</a>)?)?  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AttribNameOrWildcard"></a>[91]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-AttributeName">AttributeName</a>  |  "*"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e6186.doc-xpath31-AttributeName"></a>[98]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>AttributeName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e6187.doc-xpath31-TypeName"></a>[101]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>TypeName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        An <a href="#doc-xpath31-AttributeTest">AttributeTest</a> is used to match an
                        attribute node by its name and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a>.
                        
                     </p>
                     <p>
                        The <a href="#doc-xpath31-AttributeName">AttributeName</a> and <a href="#doc-xpath31-TypeName">TypeName</a> of an <a href="#doc-xpath31-AttributeTest">AttributeTest</a>
                        have their prefixes expanded to namespace URIs by means of the
                        <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If unprefixed, the
                        <a href="#doc-xpath31-AttributeName">AttributeName</a> is in no namespace, but an unprefixed <a href="#doc-xpath31-TypeName">TypeName</a> is in the
                        <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>.
                        
                        The <a href="#doc-xpath31-AttributeName">AttributeName</a> need not be present in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>,
                        but the <a href="#doc-xpath31-TypeName">TypeName</a> must be present in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> 
                        [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].
                        
                     </p>
                     <p>
                        An <a href="#doc-xpath31-AttributeTest">AttributeTest</a> may take any of the following forms:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>
                              <code>attribute()</code> and <code>attribute(*)</code> match any single attribute node,
                              regardless of its name or type annotation.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute(</code>
                              <a href="#doc-xpath31-AttributeName">AttributeName</a>
                              <code>)</code>
                              matches any attribute node whose name is <a href="#doc-xpath31-AttributeName">AttributeName</a>, regardless of its type annotation.
                           </p>
                           <p>Example: <code>attribute(price)</code>
                              matches any attribute node whose name is <code>price</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute(</code>
                              <a href="#doc-xpath31-AttributeName">AttributeName</a>, <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code>
                              matches an attribute node whose name is <a href="#doc-xpath31-AttributeName">AttributeName</a> if <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a> 
                              <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the attribute node.
                           </p>
                           <p>Example: <code>attribute(price, currency)</code> matches an
                              attribute node whose name is <code>price</code> and whose type
                              annotation is
                              <code>currency</code> (or is derived from <code>currency</code>).
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute(*,
                                 </code>
                              <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code> matches an attribute
                              node regardless of its name, if
                              <code>derives-from(</code>
                              <em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a>
                              <code>)</code> is
                              <code>true</code>, where <em>AT</em> is the type annotation of the attribute node.
                           </p>
                           <p>Example:
                              <code>attribute(*, currency)</code> matches any attribute node whose
                              type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
                              name.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-schema-attribute-test"></a>2.5.5.6 Schema Attribute Test
                     </h5>
                     <a id="d2e6822"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-SchemaAttributeTest"></a>[92]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"schema-attribute"  "("  <a href="#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AttributeDeclaration"></a>[93]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AttributeDeclaration">AttributeDeclaration</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-AttributeName">AttributeName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e6373.doc-xpath31-AttributeName"></a>[98]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>AttributeName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        A <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> matches an attribute node against a corresponding
                        attribute declaration found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>.
                        
                     </p>
                     <p>
                        The <a href="#doc-xpath31-AttributeName">AttributeName</a> of a <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
                        has its prefixes expanded to a namespace URI by means of the
                        <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If unprefixed, an
                        <a href="#doc-xpath31-AttributeName">AttributeName</a> is in no namespace.
                        
                        If the <a href="#doc-xpath31-AttributeName">AttributeName</a> specified in the <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
                        is not found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, a
                        <a title="static error" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].
                        
                     </p>
                     <p>
                        A <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> matches a candidate attribute node if both of the
                        following conditions are satisfied:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>The name of the candidate node matches the specified <a href="#doc-xpath31-AttributeName">AttributeName</a>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>derives-from(</code>
                              <em>AT, ET</em>
                              <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared for attribute <a href="#doc-xpath31-AttributeName">AttributeName</a> in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>.
                           </p>
                        </li>
                     </ol>
                     <p>Example: The <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> 
                        <code>schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the
                        schema type declared for the <code>color</code> attribute.
                     </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-function-test"></a>2.5.5.7 Function Test
                     </h5>
                     <a id="d2e6949"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-FunctionTest"></a>[102]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-FunctionTest">FunctionTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a>
                                    <br>|  <a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AnyFunctionTest"></a>[103]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AnyFunctionTest">AnyFunctionTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"function"  "("  "*"  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-TypedFunctionTest"></a>[104]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"function"  "("  (<a href="#doc-xpath31-SequenceType">SequenceType</a>  (","  <a href="#doc-xpath31-SequenceType">SequenceType</a>)*)?  ")"  "as"  <a href="#doc-xpath31-SequenceType">SequenceType</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        A <a href="#doc-xpath31-FunctionTest">FunctionTest</a> matches a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>,
                        potentially also checking its <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function signature</a><sup><small>DM31</small></sup> .
                        
                        An <a href="#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a>
                        matches any item that is a function.
                        
                        A <a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a> matches an
                        item if it is a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup> and the function's type signature (as defined in
                        <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 
                           
                           2.8.1 Functions
                           </a><sup><small>DM31</small></sup>) is a <a title="subtype" href="#dt-subtype">subtype</a> of the <a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a>.
                        
                     </p>
                     <p>
                        Here are some examples of <a href="#doc-xpath31-FunctionTest">FunctionTest</a>s:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>
                              <code>function(*)</code> matches any <span>function, including maps and arrays.</span>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>function(int, int) as int</code> matches any <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup> with the function signature <code>function(int, int) as int</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>function(xs:anyAtomicType) as item()*</code> matches any map<span>, or any function with the required signature</span>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>function(xs:integer) as item()*</code> matches any array<span>, or any function with the required signature</span>.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-map-test"></a>2.5.5.8 Map Test
                     </h5>
                     <a id="d2e7060"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-MapTest"></a>[105]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-MapTest">MapTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-AnyMapTest">AnyMapTest</a>  |  <a href="#doc-xpath31-TypedMapTest">TypedMapTest</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AnyMapTest"></a>[106]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AnyMapTest">AnyMapTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"map"  "("  "*"  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-TypedMapTest"></a>[107]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-TypedMapTest">TypedMapTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"map"  "("  <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>  ","  <a href="#doc-xpath31-SequenceType">SequenceType</a>  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>The <a href="#doc-xpath31-MapTest">MapTest</a> 
                        <code>map(*)</code> matches any map. The <a href="#doc-xpath31-MapTest">MapTest</a>
                        <code>map(X, Y)</code> matches any map where the type of every key
                        is an instance of <code>X</code> and the type of every value is an
                        instance of <code>Y</code>.
                     </p>
                     <p>Examples:</p>
                     <p>Given a map <code>$M</code> whose keys are integers and whose
                        results are strings, such as <code>map{0:"no", 1:"yes"}</code>,
                        consider the results of the following expressions:
                        
                     </p>
                     <ul>
                        <li>
                           <p>
                              <code>$M instance of map(*)</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of map(xs:integer, xs:string)</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of map(xs:decimal, xs:anyAtomicType)</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>not($M instance of map(xs:int, xs:string))</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>not($M instance of map(xs:integer, xs:token))</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                     </ul>
                     <p>Because of the rules for subtyping of function types according to their signature,
                        it follows that the item type
                        <code>function(A) as item()*</code>, where A is an atomic type, also matches any map, regardless of the type of the keys
                        actually
                        found in the map. For example, a map whose keys are all strings can be supplied where
                        the required type is 
                        <code>function(xs:integer) as item()*</code>; a call on the map that treats it as a function with an integer argument will always
                        succeed,
                        and will always return an empty sequence.
                     </p>
                     <p>The function signature of a map matching type
                        <code>map(K, V)</code>, treated as a function, is
                        <code>function(xs:anyAtomicType) as V?</code>.  It is thus always a
                        subtype of <code>function(xs:anyAtomicType) as item()*</code> regardless of the
                        actual types of the keys and values in the map.  The rules for
                        function coercion mean that any map can be supplied as a value in a
                        context where the required type has a more specific return type,
                        such as <code>function(xs:anyAtomicType) as xs:integer</code>, even when the map
                        does not match in the sense required to satisfy the instance of
                        operator. In such cases, a type error will only occur if an actual
                        call on the map (treated as a function) returns a value that is not
                        an instance of the required return type.
                        
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>$M instance of function(*)</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of function(xs:anyAtomicType) as item()*</code> returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of function(xs:integer) as item()*</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of function(xs:int) as item()*</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$M instance of function(xs:string) as item()*</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>not($M instance of function(xs:integer) as xs:string)</code>  returns <code>true()</code>
                              
                           </p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The last case might seem surprising; however, function coercion ensures that <code>$M</code> can be used successfully 
                           anywhere that the required type is <code>function(xs:integer) as xs:string</code>.
                        </p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-array-test"></a>2.5.5.9 Array Test
                     </h5>
                     <a id="d2e7269"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ArrayTest"></a>[108]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ArrayTest">ArrayTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-AnyArrayTest">AnyArrayTest</a>  |  <a href="#doc-xpath31-TypedArrayTest">TypedArrayTest</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-AnyArrayTest"></a>[109]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-AnyArrayTest">AnyArrayTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"array"  "("  "*"  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-TypedArrayTest"></a>[110]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"array"  "("  <a href="#doc-xpath31-SequenceType">SequenceType</a>  ")"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>The <a href="#doc-xpath31-AnyArrayTest">AnyArrayTest</a> 
                        <code>array(*)</code> matches any
                        array. The <a href="#doc-xpath31-TypedArrayTest">TypedArrayTest</a> 
                        <code>array(X)</code> matches any array
                        <span>in which</span> every array member matches the <a href="#doc-xpath31-SequenceType">SequenceType</a> 
                        <code>X</code>.
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>[ 1, 2 ] instance array(*)</code> returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[] instance of array(xs:string)</code> returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ "foo" ] instance of array(xs:string)</code> returns <code>true()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ "foo" ] instance of array(xs:integer)</code> returns <code>false()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[(1,2),(3,4)] instance of array(xs:integer)</code> returns <code>false()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[(1,2),(3,4)] instance of array(xs:integer+)</code> returns <code>true()</code>
                              
                           </p>
                        </li>
                     </ul>
                     <p>An array also matches certain other ItemTypes, including:</p>
                     <ul>
                        <li>
                           <p>
                              <code>item()</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>function(*)</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>function(xs:integer) as item()*</code>
                              
                           </p>
                        </li>
                     </ul>
                     <p>The function signature of an array
                        matching <code>array(X)</code>, treated as a function, is
                        <code>function(xs:integer) as X</code>.  It is thus always a subtype of
                        <code>function(xs:integer) as item()*</code>
                        regardless of the actual member types in the array.  The rules for
                        function coercion mean that any array can be supplied as a value in
                        a context where the required type has a more specific return type,
                        such as <code>function(xs:integer) as xs:integer</code>, even when the array does
                        not match in the sense required to satisfy the instance of
                        operator. In such cases, a type error will only occur if an actual
                        call on the array (treated as a function) returns a value that is
                        not an instance of the required return type.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-sequencetype-subtype"></a>2.5.6 SequenceType Subtype Relationships
                  </h4>
                  <p>
                     Given two <a title="sequence type" href="#dt-sequence-type">sequence types</a>, it is possible to determine if one is a subtype of the other.
                     [<a id="dt-subtype" title="subtype">Definition</a>: A <a title="sequence type" href="#dt-sequence-type">sequence type</a> 
                     <code>A</code> is a <b>subtype</b> of a sequence type <code>B</code>
                     if the judgement <code>subtype(A, B)</code> is true.]
                     
                     When the judgement <code>subtype(A, B)</code> is true, it is always the case that for any value <code>V</code>, <code>(V instance of A)</code> implies <code>(V instance of B)</code>.
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-seqtype-subtype"></a>2.5.6.1 The judgement <code>subtype(A, B)</code>
                        
                     </h5>
                     <p>The judgement <code>subtype(A, B)</code> determines if the <a title="sequence type" href="#dt-sequence-type">sequence type</a> 
                        <code>A</code>
                        is a <a title="subtype" href="#dt-subtype">subtype</a> of the sequence type <code>B</code>.
                        
                        <code>A</code> can either be <code>empty-sequence()</code>, <code>xs:error</code>, or an <a href="#doc-xpath31-ItemType">ItemType</a>, <code>Ai</code>, possibly followed by an occurrence indicator. Similarly
                        <code>B</code> can either be <code>empty-sequence()</code>, <code>xs:error</code>, or an <a href="#doc-xpath31-ItemType">ItemType</a>, <code>Bi</code>, possibly followed by an occurrence indicator.
                        The result of the <code>subtype(A, B)</code> judgement can be determined from the table below, which makes use of the auxiliary
                        judgement <code>subtype-itemtype(Ai, Bi)</code> defined
                        in <a href="#id-itemtype-subtype"><b>2.5.6.2 The judgement subtype-itemtype(Ai, Bi) 
                              </b></a>.
                        
                     </p>
                     <table class="medium">
                        <tbody>
                           <tr>
                              <th rowspan="2" colspan="2"></th>
                              <th colspan="6">
                                 <a title="sequence type" href="#dt-sequence-type">Sequence type</a> 
                                 <code>B</code>
                                 
                              </th>
                           </tr>
                           <tr>
                              <th>
                                 <code>empty-sequence()</code>
                                 
                              </th>
                              <th>
                                 <code>Bi?</code>
                                 
                              </th>
                              <th>
                                 <code>Bi*</code>
                                 
                              </th>
                              <th>
                                 <code>Bi</code>
                                 
                              </th>
                              <th>
                                 <code>Bi+</code>
                                 
                              </th>
                              <th>xs:error</th>
                           </tr>
                           <tr>
                              <th rowspan="6">
                                 <a title="sequence type" href="#dt-sequence-type">Sequence type</a> 
                                 <code>A</code>
                                 
                              </th>
                              <th>
                                 <code>empty-sequence()</code>
                                 
                              </th>
                              <td>true</td>
                              <td>true</td>
                              <td>true</td>
                              <td>false</td>
                              <td>false</td>
                              <td>false</td>
                           </tr>
                           <tr>
                              <th>
                                 <code>Ai?</code>
                                 
                              </th>
                              <td>false</td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>false</td>
                              <td>false</td>
                              <td>false</td>
                           </tr>
                           <tr>
                              <th>
                                 <code>Ai*</code>
                                 
                              </th>
                              <td>false</td>
                              <td>false</td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>false</td>
                              <td>false</td>
                              <td>false</td>
                           </tr>
                           <tr>
                              <th>
                                 <code>Ai</code>
                                 
                              </th>
                              <td>false</td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>false</td>
                           </tr>
                           <tr>
                              <th>
                                 <code>Ai+</code>
                                 
                              </th>
                              <td>false</td>
                              <td>false</td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>false</td>
                              <td>
                                 <code>subtype-itemtype(Ai, Bi)</code>
                                 
                              </td>
                              <td>false</td>
                           </tr>
                           <tr>
                              <th>
                                 <code>xs:error</code>
                                 
                              </th>
                              <td>true</td>
                              <td>true</td>
                              <td>true</td>
                              <td>true</td>
                              <td>true</td>
                              <td>true</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        <code>xs:error+</code> is treated the same way as <code>xs:error</code> in the above table. <code>xs:error?</code> and <code>xs:error*</code> are treated the same way as <code>empty-sequence()</code>.
                     </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-itemtype-subtype"></a>2.5.6.2 The judgement <code>subtype-itemtype(Ai, Bi)</code> 
                        
                     </h5>
                     <p>The judgement <code>subtype-itemtype(Ai, Bi)</code> determines if the <a href="#doc-xpath31-ItemType">ItemType</a> 
                        <code>Ai</code>
                        is a <a title="subtype" href="#dt-subtype">subtype</a> of the ItemType <code>Bi</code>. <code>Ai</code> is a subtype of <code>Bi</code>
                        if and only if at least one of the following conditions applies:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>
                              <code>Ai</code> and <code>Bi</code> are <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionTypes</a>, and <code>derives-from(Ai, Bi)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is a pure union type, 
                              and every type <code>t</code> in the transitive membership of <code>Ai</code>
                              satisfies <code>subtype-itemType(t, Bi)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>xs:error</code> and <code>Bi</code> is a <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>item()</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>node()</code>, and <code>Ai</code> is a <a href="#doc-xpath31-KindTest">KindTest</a>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>text()</code> and <code>Ai</code> is also <code>text()</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>comment()</code> and <code>Ai</code> is also <code>comment()</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>namespace-node()</code> and <code>Ai</code> is also <code>namespace-node()</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>processing-instruction()</code> and <code>Ai</code> is either <code>processing-instruction()</code> or
                              <code>processing-instruction(N)</code> for any name N.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>processing-instruction(Bn)</code>, and <code>Ai</code> is also <code>processing-instruction(Bn)</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>document-node()</code> and <code>Ai</code> is either <code>document-node()</code> or
                              <code>document-node(E)</code> for any <a href="#doc-xpath31-ElementTest">ElementTest</a> E.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>document-node(Be)</code> and <code>Ai</code> is <code>document-node(Ae)</code>, and <code>subtype-itemtype(Ae, Be)</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is either <code>element()</code> or <code>element(*)</code>, and <code>Ai</code> is an <a href="#doc-xpath31-ElementTest">ElementTest</a>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is either <code>element(Bn)</code> or <code>element(Bn, xs:anyType?)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              and <code>Ai</code> is either <code>element(An)</code> 
                              <span>or <code>element(An, T)</code> 
                                 </span> 
                              or <code>element(An, T?)</code> for any type T.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>element(Bn, Bt)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              <code>Ai</code> is <code>element(An, At)</code>, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>element(Bn, Bt?)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              <code>Ai</code> is either <code>element(An, At)</code> or <code>element(An, At?)</code>,
                              and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>element(*, Bt)</code>, <code>Ai</code> is either <code>element(*, At)</code> or <code>element(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>element(*, Bt?)</code>, <code>Ai</code> is either <code>element(*, At)</code>, <code>element(*, At?)</code>, <code>element(N, At)</code>, or <code>element(N, At?)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>schema-element(Bn)</code>,
                              <code>Ai</code> is <code>schema-element(An)</code>,
                              and every element declaration that is an actual member of the substitution group of
                              <code>An</code> is also an actual member of the substitution group of <code>Bn</code>.
                              
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The fact that <code>P</code> is a member of the substitution group of <code>Q</code> does not mean that every element declaration in the substitution group of <code>P</code> is also in the substitution group of <code>Q</code>. For example, <code>Q</code> might block substitution of elements whose type is derived by extension, while <code>P</code> does not.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is either <code>attribute()</code> or <code>attribute(*)</code>, and <code>Ai</code> is an <a href="#doc-xpath31-AttributeTest">AttributeTest</a>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is either <code>attribute(Bn)</code> or <code>attribute(Bn, xs:anyType)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              and <code>Ai</code> is either <code>attribute(An)</code>, or <code>attribute(An, T)</code> for any type T.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>attribute(Bn, Bt)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              <code>Ai</code> is <code>attribute(An, At)</code>,
                              and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>attribute(*, Bt)</code>, <code>Ai</code> is either <code>attribute(*, At)</code>, or <code>attribute(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>schema-attribute(Bn)</code>,
                              the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>An</code> equals the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
                              and <code>Ai</code> is <code>schema-attribute(An)</code>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code> function(*)</code>,
                              <code>Ai</code> is a <a href="#doc-xpath31-FunctionTest">FunctionTest</a>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Bi</code> is <code>function(Ba_1, Ba_2, ... Ba_N) as Br</code>,
                              <code>Ai</code> is <code>function(Aa_1, Aa_2, ... Aa_M) as Ar</code>,
                              where 
                              
                              <code>N</code> (arity of Bi) equals <code>M</code> (arity of Ai);
                              <code>subtype(Ar, Br)</code>;
                              <span class="xpath">and</span>
                              for values of <code>I</code> between 1 and <code>N</code>, <code>subtype(Ba_I, Aa_I)</code>.
                              
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Function return types are covariant because this rule invokes subtype(Ar, Br) for
                                 return types. Function arguments are contravariant because this rule invokes subtype(Ba_I,
                                 Aa_I) for arguments.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>map(K, V)</code>,
                              for any <code>K</code> and <code>V</code>
                              and <code>Bi</code> is <code>map(*)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is  <code>map(Ka, Va)</code> 
                              and <code>Bi</code> is <code>map(Kb, Vb)</code>, 
                              where <code>subtype-itemtype(Ka, Kb)</code>
                              and <code>subtype(Va, Vb)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>map(*)</code> (or, because of the transitivity rules, any other map type), 
                              and <code>Bi</code> 
                              is <code>function(*)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>map(*)</code> 
                              (or, because of the transitivity rules, any other map type),
                              and <code>Bi</code> is 
                              <code>function(xs:anyAtomicType) as item()*</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>array(*)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>array(Y)</code>, and <code>subtype(X, Y)</code> is true.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>array(*)</code> (or, because of the transitivity rules, any other array type) and <code>Bi</code> is <code>function(*)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>array(*)</code> (or, because of the transitivity rules, any other array type) and <code>Bi</code> is <code>function(xs:integer) as item()*</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>map(K, V)</code>, and <code>Bi</code> is <code>function(xs:anyAtomicType) as V?</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>function(xs:integer) as X</code>.
                           </p>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-xs-error"></a>2.5.7 xs:error
                  </h4>
                  <p>The type <code>xs:error</code> has an empty value space; it never appears as a dynamic type or as the content type
                     of a dynamic element or attribute type. 
                     		
                     
                     <span>It was defined in XML Schema in the interests of making the type system complete and
                        closed, and it is also available in XPath 3.1
                        for similar reasons.</span>
                     
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The
                        practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error handling
                        function that always raises a dynamic error 
                        never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.
                     </p>
                     <p>The semantics of <code>xs:error</code> are well-defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with
                        no member types. For example:
                     </p>
                     <ul>
                        <li>
                           <p>
                              <code>$x instance of xs:error</code> always returns false, regardless of the value of <code>$x</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$x cast as xs:error</code> fails dynamically with error [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup>,  regardless of the value of <code>$x</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$x cast as xs:error?</code> raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
                              [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup> if <code>exists($x)</code>, evaluates to the empty sequence if <code>empty($x)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>xs:error($x)</code> has the same semantics as <code>$x cast as xs:error?</code> (see the previous bullet point)
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$x castable as xs:error</code> evaluates to <code>false</code>, regardless of the value of <code>$x</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$x treat as xs:error</code>  raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
                              [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>] if evaluated, regardless of the value of <code>$x</code>. It never fails statically.
                           </p>
                        </li>
                     </ul>
                     <p>All of the above examples assume that <code>$x</code> is actually evaluated. If the result of the query does not depend on the value of
                        <code>$x</code>. the rules specified in <a href="#id-errors-and-opt"><b>2.3.4 Errors and
                              Optimization</b></a> permit an implementation to avoid evaluating <code>$x</code> and thus to avoid raising an error.
                     </p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="comments"></a>2.6 Comments
               </h3>
               <a id="d2e8666"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-Comment"></a>[121]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-Comment">Comment</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"(:"  (<a href="#doc-xpath31-CommentContents">CommentContents</a>  |  <a href="#doc-xpath31-Comment">Comment</a>)*  ":)"</code></td>
                        <td><i>/* 
                              <a href="#ws-explicit">ws: explicit</a>
                              */</i></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td><i>/* 
                              <a href="#parse-note-comments">gn: comments</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-CommentContents"></a>[126]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-CommentContents">CommentContents</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>(<a href="#prod-xpath31-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>Comments may be used to provide information relevant to programmers who read <span class="xpath">an expression</span>. Comments are lexical constructs only, and do not affect  <span class="xpath">expression</span> processing.
               </p>
               <p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.
               </p>
               <p>A comment may be used anywhere <a title="ignorable whitespace" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed (see <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>).
               </p>
               <p>The following is an example of a comment:</p>
               <div class="exampleInner"><pre>(: Houston, we have a problem :)</pre></div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-expressions"></a>3 Expressions
            </h2>
            <p>This section discusses each of the basic kinds of expression. Each kind of expression
               has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the
               expression. Since XPath 3.1 is a composable language, each kind of expression is defined
               in terms of other expressions whose operators have a higher precedence. In this way,
               the precedence of operators is represented explicitly in the grammar.
            </p>
            <p>The order in which expressions are discussed in this document does not reflect the
               order of operator precedence. In general, this document introduces the simplest kinds
               of expressions first, followed by more complex expressions.  For the complete grammar,
               see Appendix [<a href="#nt-bnf"><b>A XPath 3.1 Grammar</b></a>].
            </p>
            <p> 
               <span class="xpath">The highest-level symbol in the XPath grammar is XPath.</span> 
               
            </p>
            <a id="d2e8741"></a><table class="scrap">
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-XPath"></a>[1]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-XPath">XPath</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-Expr">Expr</a>
                           </code></td>
                     <td></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-Expr"></a>[6]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-Expr">Expr</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
                     <td></td>
                  </tr>
               </tbody>
               <tbody>
                  <tr style="vertical-align:baseline;">
                     <td><a id="doc-xpath31-ExprSingle"></a>[7]&nbsp;&nbsp;&nbsp;
                     </td>
                     <td><code><a href="#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
                     <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                     <td><code>
                           <a href="#doc-xpath31-ForExpr">ForExpr</a>
                           <br>|  <a href="#doc-xpath31-LetExpr">LetExpr</a>
                           <br>|  <a href="#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a>
                           <br>|  <a href="#doc-xpath31-IfExpr">IfExpr</a>
                           <br>|  <a href="#doc-xpath31-OrExpr">OrExpr</a>
                           </code></td>
                     <td></td>
                  </tr>
               </tbody>
            </table>
            <p>The XPath 3.1 operator that has lowest precedence is the <a title="comma operator" href="#dt-comma-operator">comma operator</a>, which is used to combine two operands to form a sequence. As shown in the grammar,
               a general expression (<a href="#doc-xpath31-Expr">Expr</a>) can consist of multiple <a href="#doc-xpath31-ExprSingle">ExprSingle</a> operands, separated by commas. The name <a href="#doc-xpath31-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level <a title="comma operator" href="#dt-comma-operator">comma operator</a> (despite its name, an <a href="#doc-xpath31-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)
            </p>
            <p>The symbol <a href="#doc-xpath31-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain
               a top-level comma. For example, each of the arguments of a function call must be an
               <a href="#doc-xpath31-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.
            </p>
            <p>After the comma, the expressions that have next lowest precedence are
               
               <span class="xpath">
                  <a href="#doc-xpath31-ForExpr">ForExpr</a>, <a href="#doc-xpath31-LetExpr">LetExpr</a>, </span>
               <a href="#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a>,
               
               <a href="#doc-xpath31-IfExpr">IfExpr</a>,
               
               and <a href="#doc-xpath31-OrExpr">OrExpr</a>. Each of these expressions is described in a separate section of this document.
            </p>
            <div class="div2">
               
               <h3><a id="id-primary-expressions"></a>3.1 Primary Expressions
               </h3>
               <p> 
                  [<a id="dt-primary-expression" title="primary expression">Definition</a>: 
                  <b>Primary expressions</b> are the basic primitives of the
                  	 language. They include literals, variable references,  context item expressions,
                  and function calls. A primary expression may also be created by enclosing any expression
                  in parentheses, which is sometimes helpful in controlling the precedence of operators.]
                  
                  <span>Map and Array Constructors are described in <a href="#id-maps-and-arrays"><b>3.11 Maps and Arrays</b></a>.</span>
                  
                  
               </p>
               <a id="d2e8856"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-PrimaryExpr"></a>[56]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-PrimaryExpr">PrimaryExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-Literal">Literal</a>
                              <br>|  <a href="#doc-xpath31-VarRef">VarRef</a>
                              <br>|  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>
                              <br>|  <a href="#doc-xpath31-ContextItemExpr">ContextItemExpr</a>
                              <br>|  <a href="#doc-xpath31-FunctionCall">FunctionCall</a>
                              <br>|  <a href="#doc-xpath31-FunctionItemExpr">FunctionItemExpr</a>
                              <br>|  <a href="#doc-xpath31-MapConstructor">MapConstructor</a>
                              <br>|  <a href="#doc-xpath31-ArrayConstructor">ArrayConstructor</a>
                              <br>|  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-FunctionItemExpr"></a>[66]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-FunctionItemExpr">FunctionItemExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-NamedFunctionRef">NamedFunctionRef</a>  |  <a href="#doc-xpath31-InlineFunctionExpr">InlineFunctionExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <div class="div3">
                  
                  <h4><a id="id-literals"></a>3.1.1 Literals
                  </h4>
                  <p> 
                     [<a id="dt-literal" title="literal">Definition</a>: A <b>literal</b> is a direct syntactic representation of an
                     		atomic value.] XPath 3.1 supports two kinds of literals: numeric literals and
                     		string literals.
                  </p>
                  <a id="d2e8930"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-Literal"></a>[57]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-Literal">Literal</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-NumericLiteral">NumericLiteral</a>  |  <a href="#doc-xpath31-StringLiteral">StringLiteral</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-NumericLiteral"></a>[58]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-NumericLiteral">NumericLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>  |  <a href="#doc-xpath31-DecimalLiteral">DecimalLiteral</a>  |  <a href="#doc-xpath31-DoubleLiteral">DoubleLiteral</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-IntegerLiteral"></a>[113]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-Digits">Digits</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-DecimalLiteral"></a>[114]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-DecimalLiteral">DecimalLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>("."  <a href="#doc-xpath31-Digits">Digits</a>)  |  (<a href="#doc-xpath31-Digits">Digits</a>  "."  [0-9]*)</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-DoubleLiteral"></a>[115]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(("."  <a href="#doc-xpath31-Digits">Digits</a>)  |  (<a href="#doc-xpath31-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#doc-xpath31-Digits">Digits</a>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-StringLiteral"></a>[116]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-StringLiteral">StringLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>('"'  (<a href="#doc-xpath31-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"')  |  ("'"  (<a href="#doc-xpath31-EscapeApos">EscapeApos</a>  |  [^'])*  "'")</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-EscapeQuot"></a>[119]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-EscapeQuot">EscapeQuot</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>'""'</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-EscapeApos"></a>[120]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-EscapeApos">EscapeApos</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"''"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-Digits"></a>[125]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-Digits">Digits</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>[0-9]+</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p> The value of a <b>numeric literal</b> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is  an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. The value of the numeric literal is determined by casting it to the
                     appropriate type according to the rules for casting from <code>xs:untypedAtomic</code>
                     to a numeric type as specified in <a href="https://www.w3.org/TR/xpath-functions-31/#casting-from-strings">Section 
                        
                        19.2 Casting from xs:string and xs:untypedAtomic
                        </a><sup><small>FO31</small></sup>.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The effect of the above rule is that in the case of an integer or decimal literal,
                        a dynamic error [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAR0002" title="err:FOAR0002">err:FOAR0002</a>]<sup><small>FO31</small></sup> will generally be raised if the literal is outside the range of values supported
                        by the implementation (other options are available: see <a href="https://www.w3.org/TR/xpath-functions-31/#op.numeric">Section 
                           
                           4.2 Arithmetic operators on numeric values
                           </a><sup><small>FO31</small></sup> for details.)
                     </p>
                     <p class="xpath">The XML Schema specification allows implementations to impose a limit (which
                        must not be less than 18 digits) on the size of integer and decimal
                        values. The full range of values of built-in subtypes of <code>xs:integer</code>,
                        such as <code>xs:long</code> and <code>xs:unsignedLong</code>, can be supported only if the
                        limit is 20 digits or higher. Negative numbers such as the minimum
                        value of <code>xs:long</code> (<code>-9223372036854775808</code>) are technically unary
                        expressions rather than literals, but implementations may prefer to
                        ensure that they are expressible.
                     </p>
                  </div>
                  <p id="id-string-literal">The value of a <b>string literal</b> is an atomic value whose  type is <code>xs:string</code> and whose value is the string denoted by the characters between the
                     		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes,
                     two adjacent apostrophes within the literal are interpreted as a single apostrophe.
                     Similarly, if the literal is delimited by quotation marks, two adjacent quotation
                     marks within the literal are interpreted as one quotation mark.
                  </p>
                  <p>Here are some examples of literal expressions:</p>
                  <ul>
                     <li>
                        <p> 
                           <code>"12.5"</code> denotes the string containing the characters '1', '2', '.', and
                           			 '5'.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>12</code> denotes the <code>xs:integer</code> value twelve.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>When XPath expressions are embedded in contexts where quotation
                              marks have special significance, such as inside XML attributes, additional
                              escaping may be needed.
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>
                     The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be constructed by calls to the
                     <a title="built-in function" href="#dt-built-in-function">built-in functions</a> 
                     <code>fn:true()</code> and <code>fn:false()</code>, respectively.
                     
                  </p>
                  <p>Values of other 
                     <span>simple</span> types can be constructed by calling the <a title="constructor function" href="#dt-constructor-function">constructor function</a> for the given type. The constructor functions for XML Schema
                     		built-in types are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#constructor-functions-for-xsd-types">Section 
                        
                        18.1 Constructor functions for XML Schema built-in atomic types
                        </a><sup><small>FO31</small></sup>. In general, the name of a constructor function for a given type is the same as the
                     name of the type (including its namespace). For
                     		example:
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>xs:integer("12")</code> returns the integer value twelve.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>xs:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xs:dayTimeDuration</code> and whose value represents a duration of five hours.
                        </p>
                     </li>
                  </ul>
                  <p>Constructor functions can also be used to create special values that have no literal
                     representation, as in the following examples:
                     
                  </p>
                  <ul>
                     <li>
                        <p>
                           <code>xs:float("NaN")</code> returns the special floating-point value, "Not a Number."
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>xs:double("INF")</code> returns the special double-precision value, "positive infinity."
                        </p>
                     </li>
                  </ul>
                  <p>Constructor functions are available for all 
                     <span>simple types</span>,
                     including union types. For example, if <code>my:dt</code> is a user-defined union
                     type whose member types are <code>xs:date</code>, <code>xs:time</code>, and <code>xs:dateTime</code>, then
                     the expression <code>my:dt("2011-01-10")</code> creates an atomic value of type
                     <code>xs:date</code>. The rules follow XML Schema validation rules for union types:
                     the effect is to choose the first member type that accepts the given
                     string in its lexical space.
                  </p>
                  <p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>9 cast as
                              hatsize</code> returns the atomic value <code>9</code>
                           			 whose type is  <code>hatsize</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-variables"></a>3.1.2 Variable References
                  </h4>
                  <a id="d2e9277"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-VarRef"></a>[59]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-VarRef">VarRef</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"$"  <a href="#doc-xpath31-VarName">VarName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-VarName"></a>[60]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-VarName">VarName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p> 
                     [<a id="dt-variable-reference" title="variable reference">Definition</a>: A <b>variable reference</b> is an EQName preceded by a $-sign.] 
                     An unprefixed variable reference is in no namespace. Two variable references are equivalent
                     if their  <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a>  are equal (as defined by the <code>eq</code> operator). The scope of a variable binding is defined separately for each kind of
                     expression that can bind variables.
                  </p>
                  <p>Every variable reference must match a name in the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>. 
                  </p>
                  <p>Every variable binding has a static scope. The scope defines where
                     references to the variable can validly occur.
                     
                     It is a <a title="static error" href="#dt-static-error">static error</a> 
                     [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] to reference a variable that is not in scope. If a variable is bound in the <a title="static context" href="#dt-static-context">static context</a> for an expression, that variable is in scope for the entire expression except where
                     it is occluded by another binding that uses the same name within that scope.
                  </p>
                  <p>
                     At evaluation time, the value of a variable reference is the value to which the relevant
                     variable is bound.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-paren-expressions"></a>3.1.3 Parenthesized Expressions
                  </h4>
                  <a id="d2e9329"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ParenthesizedExpr"></a>[61]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"("  <a href="#doc-xpath31-Expr">Expr</a>?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>Parentheses may be used to override the precedence rules.
                     For example, the expression <code>(2 + 4)
                        		    * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
                     			 parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
                     			 precedence than the addition operator.
                  </p>
                  <p>Empty parentheses are used to denote an empty sequence, as
                     		described in <a href="#construct_seq"><b>3.4.1 Constructing Sequences</b></a>.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-context-item-expression"></a>3.1.4 Context Item Expression
                  </h4>
                  <a id="d2e9357"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ContextItemExpr"></a>[62]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ContextItemExpr">ContextItemExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"."</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>A <b>context item expression</b> evaluates to
                     the <a title="context item" href="#dt-context-item">context item</a>, which may be either a node (as in the
                     expression
                     <code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>),
                     or an atomic value or function (as in the expression <code>(1 to
                        100)[. mod 5 eq 0]</code>).
                  </p>
                  <p>If the <a title="context item" href="#dt-context-item">context item</a> is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, a context item expression raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>  
                     [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-function-calls"></a>3.1.5 Static Function Calls
                  </h4>
                  <p>
                     [<a id="dt-built-in-function" title="built-in function">Definition</a>: The <b>built-in functions</b> 
                     are 
                     <span>the functions</span>
                     defined in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>
                     <span>in the 
                        <code>http://www.w3.org/2005/xpath-functions</code>,
                        <code>http://www.w3.org/2001/XMLSchema</code>,
                        <code>http://www.w3.org/2005/xpath-functions/math</code>,
                        <code>http://www.w3.org/2005/xpath-functions/map</code>,
                        and <code>http://www.w3.org/2005/xpath-functions/array</code> namespaces.
                        </span>
                     ] 
                     
                     <span class="xpath">The set of built-in functions is specified by the host language.</span>
                     
                     <span class="xpath">Additional functions may be provided in
                        		the <a title="static context" href="#dt-static-context">static
                           		context</a>. XPath per se does not provide a way
                        		to declare named functions, but a host language may provide
                        		such a mechanism.</span>
                     
                     		             
                  </p>
                  <a id="d2e9436"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-FunctionCall"></a>[63]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-FunctionCall">FunctionCall</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>  
                                 <a href="#doc-xpath31-ArgumentList">ArgumentList</a>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a>
                                 */</i></td>
                        </tr>
                        <tr style="vertical-align:baseline;">
                           <td></td>
                           <td></td>
                           <td></td>
                           <td></td>
                           <td><i>/* 
                                 <a href="#parse-note-parens">gn: parens</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e8645.doc-xpath31-ArgumentList"></a>[50]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ArgumentList</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"("  (<a href="#doc-xpath31-Argument">Argument</a>  (","  <a href="#doc-xpath31-Argument">Argument</a>)*)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-Argument"></a>[64]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-Argument">Argument</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  |  <a href="#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ArgumentPlaceholder"></a>[65]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"?"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-static-function-call" title="static function call">Definition</a>: A <b>static function call</b> consists of an EQName followed by a
                     		parenthesized list of zero or more arguments.] 
                     [<a id="dt-arg-expr" title="argument expression">Definition</a>: An argument to a function call is either an
                     <b>argument expression</b> or an ArgumentPlaceholder ("?").] If the EQName in a static function
                     		call is a <a title="lexical QName" href="#dt-qname">lexical QName</a> that has no namespace prefix, it is considered to be
                     		in the <a title="default function namespace" href="#dt-def-fn-ns">default function
                        		namespace.</a>
                     
                  </p>
                  <p>If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>
                     and number of arguments in a static function call do not match the name and arity
                     		of a <a title="statically known function signatures" href="#dt-known-func-signatures">function signature</a> in the
                     <a title="static context" href="#dt-static-context">static context</a>,  a
                     <a title="static error" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].
                  </p>
                  <p>
                     [<a id="dt-partial-function-application" title="partial function application">Definition</a>: 
                     A static or <a title="dynamic function call" href="#dt-dynamic-function-invocation">dynamic</a>
                     function call is a <b>partial function application</b>
                     if one or more arguments is an ArgumentPlaceholder.
                     ]    
                     
                  </p>
                  <p>
                     Evaluation of function calls is described in <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>.
                     
                  </p>
                  <p>Since the arguments of a function call are separated by commas, any
                     <a title="argument expression" href="#dt-arg-expr">argument expression</a> that contains a top-level <a title="comma operator" href="#dt-comma-operator">comma operator</a> must be
                     enclosed in parentheses. Here are some illustrative examples of
                     static function calls:
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>my:three-argument-function(1,
                              			2, 3)</code> denotes a static function call with three arguments.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>my:two-argument-function((1,
                              			2), 3)</code> denotes a static function call with two arguments, the first of which is a
                           			 sequence of two values.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>my:two-argument-function(1,
                              			())</code> denotes a static function call with two arguments, the second of which is an
                           			 empty sequence.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>my:one-argument-function((1, 2,
                              			3))</code> denotes a static function call with one argument that is a sequence of three
                           			 values. 
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>my:zero-argument-function( )</code> denotes a static function call with zero arguments.
                        </p>
                     </li>
                  </ul>
                  <div class="div4">
                     
                     <h5><a id="id-eval-function-call"></a>3.1.5.1 Evaluating Static and Dynamic Function Calls
                     </h5>
                     <p>
                        When a static or dynamic function call <var>FC</var> is evaluated
                        with respect to a static context <var>SC</var> and
                        a dynamic context <var>DC</var>,
                        the result is obtained as follows:
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>
                              [<a id="dt-argumentlist-arity" title="arity">Definition</a>: 
                              The number of <code>Argument</code>s
                              in an <code>ArgumentList</code>
                              is its <b>arity</b>.
                              ]
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              The function <var>F</var> to be called or partially applied
                              is obtained as follows:
                              
                           </p>
                           <ol class="enumla">
                              <li>
                                 <p>
                                    If <var>FC</var> is a static function call:
                                    Using
                                    the expanded QName corresponding to <var>FC</var>'s <code>EQName</code>,
                                    
                                    and
                                    the arity of <var>FC</var>'s <code>ArgumentList</code>,
                                    the corresponding function
                                    is looked up
                                    in the <a title="named functions" href="#dt-named-functions">named functions</a> component
                                    of <var>DC</var>.
                                    Let <var>F</var> denote the function obtained.
                                    
                                    
                                 </p>
                              </li>
                              <li>
                                 <p>
                                    If <var>FC</var> is a dynamic function call:
                                    <var>FC</var>'s base expression is evaluated with respect to <var>SC</var> and <var>DC</var>.
                                    If this yields a sequence consisting of a single function
                                    with the same arity as the arity of the <code>ArgumentList</code>,
                                    let <var>F</var> denote that function.
                                    Otherwise, a type error is raised
                                    [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                                    
                                 </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>
                              [<a id="dt-arg-value" title="argument value">Definition</a>: 
                              <a title="argument expression" href="#dt-arg-expr">Argument expressions</a> are evaluated with respect to <var>DC</var>, producing <b>argument
                                 values</b>.] The order of argument evaluation is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> and a function need not evaluate an argument if the function can evaluate its body
                              without evaluating that argument.
                           </p>
                        </li>
                        <li>
                           <p>
                              Each argument value is converted
                              to the corresponding parameter type in <var>F</var>'s signature
                              by applying the
                              <a title="function conversion rules" href="#dt-function-conversion">function conversion rules</a>,
                              resulting in a <a title="argument value" href="#dt-arg-value">converted argument value</a>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              The remainder depends on whether or not <var>FC</var>
                              is a <a title="partial function application" href="#dt-partial-function-application">partial function application</a>.
                              
                           </p>
                           <ol class="enumla">
                              <li>
                                 <p>
                                    If <var>FC</var> is a <a title="partial function application" href="#dt-partial-function-application">partial function application</a>
                                    <span>the result of the function call is a new function, which is a <a title="partially applied function" href="#dt-partially-applied-function">partially applied function</a>.
                                       [<a id="dt-partially-applied-function" title="partially applied function">Definition</a>: A <b>partially applied function</b>
                                       is a function created by  <a title="partial function application" href="#dt-partial-function-application">partial function application</a>.]
                                       </span>
                                    [<a id="dt-fixed-position" title="fixed position">Definition</a>: In a partial function application, a <b>fixed position</b>
                                    is an argument/parameter position for which the <code>ArgumentList</code> has an argument expression (as opposed to an <code>ArgumentPlaceholder</code>).]
                                    A partial function application need not have any fixed positions.  A <a title="partially applied function" href="#dt-partially-applied-function">partially applied function</a> has
                                    the following properties (which are defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 
                                       
                                       2.8.1 Functions
                                       </a><sup><small>DM31</small></sup>):
                                    
                                 </p>
                                 <ul>
                                    <li>
                                       <p>
                                          <b>name</b>:
                                          Absent.
                                          
                                       </p>
                                    </li>
                                    <li>
                                       <p>
                                          <b>parameter names</b>:
                                          The parameter names of <var>F</var>,
                                          removing the parameter names at the fixed positions.
                                          (So the function's arity is
                                          the arity of F
                                          minus
                                          the number of fixed positions.)
                                          
                                       </p>
                                    </li>
                                    <li>
                                       <p>
                                          <b>signature</b>:
                                          The signature of <var>F</var>,
                                          removing the parameter type
                                          at each of the fixed positions.
                                          				  <span>
                                             				    An implementation which can determine a more specific signature (for example,
                                             through use of type analysis) is permitted to do so.</span>
                                          
                                       </p>
                                    </li>
                                    <li>
                                       <p>
                                          <b>implementation</b>:
                                          
                                          <span>
                                             The implementation of <var>F</var>.
                                             If this is not an XPath 3.1 expression
                                             then the new function's implementation
                                             is associated with a static context and a dynamic context in one of two ways:
                                             if <var>F</var>'s implementation is already associated with contexts, then those are used; otherwise,
                                             <var>SC</var> and <var>DC</var> are used. 
                                             </span>
                                          
                                       </p>
                                    </li>
                                    <li>
                                       <p>
                                          <b>nonlocal variable bindings</b>:
                                          The nonlocal variable bindings of <var>F</var>,
                                          plus, for each fixed position,
                                          a binding of the converted argument value
                                          to the corresponding parameter name.
                                          
                                       </p>
                                    </li>
                                 </ul>
                                 <div class="exampleOuter">
                                    
                                    <div class="exampleHeader"><a id="d2e9833"></a>Example: Partial Application of an Anonymous Function
                                    </div>
                                    <p>In the following example, <code>$f</code> is an anonymous function, and <code>$paf</code> is a partially applied function created from <code>$f</code>.
                                    </p>
                                    <div class="exampleInner"><pre>
let $f := function ($seq, $delim) { fn:fold-left($seq, "", fn:concat(?, $delim, ?)) },
    $paf := $f(?, ".")
return $paf(1 to 5)
</pre></div>
                                    <p>
                                       <code>$paf</code> is also an anonymous function.  It has one parameter, named <code>$delim</code>, which is taken from the corresponding parameter in <code>$f</code>
                                       (the other parameter is fixed).  The implementation of <code>$paf</code> is the implementation of <code>$f</code>, which is <code>fn:fold-left($seq, "", fn:concat(?, $delim, ?))</code>.  This implementation is associated with the <code>SC</code> and <code>DC</code> of the original expression in <code>$f</code>.  The nonlocal bindings associate the value <code>"."</code> with the parameter <code>$delim</code>.
                                    </p>
                                 </div>
                                 <div class="exampleOuter">
                                    
                                    <div class="exampleHeader"><a id="d2e9885"></a>Example: Partial Application of a Built-In Function
                                    </div>
                                    <p>The following partial function application creates a function that computes the sum
                                       of squares of a sequence.
                                    </p>
                                    <div class="exampleInner"><pre>let $sum-of-squares := fn:fold-right(?, 0, function($a, $b) { $a*$a + $b })
return $sum-of-squares(1 to 3)</pre></div>
                                    <p>
                                       <code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <code>fn:fold-right</code> (the other two parameters are fixed). The implementation is the implementation of
                                       <code>fn:fold-right</code>, which is a built-in context-independent function.  The nonlocal bindings contain
                                       the fixed bindings for the second and third parameters of <code>fn:fold-right</code>.
                                    </p>
                                 </div>
                                 <p>Partial function application never returns a map or an array.  If <code>$F</code> is a map or an array, then <code>$F(?)</code> is 
                                    a partial function application that returns a function, but the function it returns
                                    is not a map nor an array.
                                 </p>
                                 <div class="exampleOuter">
                                    
                                    <div class="exampleHeader"><a id="d2e9917"></a>Example: Partial Application of a Map
                                    </div>
                                    <p>The following partial function application converts a map to an equivalent function
                                       that is not a map.
                                    </p>
                                    <div class="exampleInner"><pre>let $a := map {"A": 1, "B": 2}(?)
return $a("A")</pre></div>
                                 </div>
                              </li>
                              <li>
                                 <p>
                                    If <var>FC</var> is not a partial function application,
                                    <span>
                                       the semantics of the call depend on the nature of
                                       function <var>F</var>'s 'implementation' property
                                       (see <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 
                                          
                                          2.8.1 Functions
                                          </a><sup><small>DM31</small></sup>):
                                       </span>
                                    
                                 </p>
                                 <div class="note">
                                    <p class="prefix"><b>Note:</b></p>
                                    <p>XPath 3.1 is a host language with respect to the <a title="data model" href="#dt-datamodel">data model</a>.
                                       In XPath 3.1, if the implementation is a host language expression, then it is an XPath
                                       3.1 expression.
                                    </p>
                                 </div>
                                 <ol class="enumlr">
                                    <li>
                                       <p>If <var>F</var> is a map, it is evaluated as described in <a href="#id-map-lookup"><b>3.11.1.2 Map Lookup using Function Call Syntax</b></a>.  If <var>F</var> is an array, it is evaluated as described in <a href="#id-array-lookup"><b>3.11.2.2 Array Lookup using Function Call Syntax</b></a>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>
                                          If <var>F</var>'s implementation is 
                                          
                                          <span>an XPath 3.1 expression</span>
                                          <span>
                                             (e.g., <var>F</var> is
                                             
                                             an <a title="anonymous function" href="#dt-anonymous-function">anonymous function</a>,
                                             or a
                                             <a title="partially applied function" href="#dt-partially-applied-function">partial application</a>
                                             of such a function):
                                             </span>
                                          
                                       </p>
                                       <ol class="enumua">
                                          <li>
                                             <p>                                      
                                                
                                                <span>
                                                   <var>F</var>'s implementation</span> 
                                                is evaluated.
                                                <span>
                                                   The static context for this evaluation
                                                   is the static context of the XPath 3.1 expression.
                                                   </span>
                                                The dynamic context for this evaluation is obtained
                                                by taking the dynamic context of the
                                                
                                                <span class="xpath">
                                                   <code>InlineFunctionExpr</code>
                                                   </span>
                                                that contains the <code>FunctionBody</code>, and
                                                making the following changes:
                                                
                                             </p>
                                             <ul>
                                                <li>
                                                   <p>
                                                      The <a title="focus" href="#dt-focus">focus</a>
                                                      (context item, context position, and context size)
                                                      is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
                                                      
                                                   </p>
                                                </li>
                                                <li>
                                                   <p>
                                                      In the <a title="variable values" href="#dt-variable-values">variable values</a> component of the dynamic context,
                                                      each converted argument value is bound to the
                                                      corresponding parameter name.
                                                      
                                                   </p>
                                                   <p>
                                                      When
                                                      this is done,
                                                      the converted argument value retains
                                                      its most specific
                                                      <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>,
                                                      even though this type
                                                      may be derived from the type of the formal parameter.
                                                      For example, a function with
                                                      a parameter <code>$p</code> of type <code>xs:decimal</code>
                                                      can be invoked with an argument of type <code>xs:integer</code>,
                                                      which is derived from <code>xs:decimal</code>.
                                                      During the processing of this function
                                                      call,
                                                      the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>
                                                      of <code>$p</code> inside the body of the function
                                                      is considered to be <code>xs:integer</code>.
                                                      
                                                   </p>
                                                </li>
                                                <li>
                                                   <p>
                                                      F's nonlocal variable bindings
                                                      are also added to the <a title="variable values" href="#dt-variable-values">variable values</a>.
                                                      (Note that the names of the nonlocal variables
                                                      are by definition disjoint from the parameter names,
                                                      so there can be no conflict.)
                                                      
                                                   </p>
                                                </li>
                                             </ul>
                                          </li>
                                          <li>
                                             <p>
                                                The value returned by evaluating the function body
                                                is then converted to the declared return type of <var>F</var>
                                                by applying the
                                                <a title="function conversion rules" href="#dt-function-conversion">function conversion rules</a>.
                                                The result is then the result of evaluating <var>FC</var>.
                                                
                                             </p>
                                             <p>
                                                As with argument values,
                                                the value returned by a function
                                                retains its most specific type,
                                                which may be derived from the declared return type of <var>F</var>.
                                                For example, a function that has
                                                a declared return type of <code>xs:decimal</code>
                                                may in fact return a value of dynamic type <code>xs:integer</code>.
                                                
                                             </p>
                                          </li>
                                       </ol>
                                       <div class="exampleOuter">
                                          
                                          <div class="exampleHeader"><a id="d2e10085"></a>Example: Derived Types and Nonlocal Variable Bindings
                                          </div>
                                          <p>
                                             <code>$incr</code> is a nonlocal variable that is available within the function because its variable
                                             binding has been added to the variable values of the function..  Even though the parameter
                                             and return type of this function are both <code>xs:decimal</code>,
                                             the more specific type <code>xs:integer</code> is preserved in both cases.
                                          </p>
                                          <div class="exampleInner"><pre>
let $incr := 1,
    $f := function ($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)                      </pre></div>
                                       </div>
                                       <div class="exampleOuter">
                                          
                                          <div class="exampleHeader"><a id="d2e10101"></a>Example: Using the Context Item in an Anonymous Function
                                          </div>
                                          <p>The following example will raise a dynamic error [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]:
                                          </p>
                                          <div class="exampleInner"><pre>
let $vat := function() { @vat + @price }
return shop/article/$vat()</pre></div>
                                          <p>Instead, the context item can be used as an argument to the anonymous function:</p>
                                          <div class="exampleInner"><pre>
let $vat := function($art) { $art/@vat + $art/@price }
return shop/article/$vat(.)</pre></div>
                                          <p>Or, the value can be referenced as a nonlocal variable binding:</p>
                                          <div class="exampleInner"><pre>
let $ctx := shop/article,
$vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()
</pre></div>
                                       </div>
                                    </li>
                                    <li>
                                       <p>                                  
                                          If <var>F</var>'s implementation is
                                          
                                          <span>not an XPath 3.1 expression</span>
                                          (e.g., <span>
                                             <var>F</var> is</span>
                                          a <a title="built-in function" href="#dt-built-in-function">built-in function</a>
                                          
                                          <span class="xpath">or a <a title="host language function" href="#dt-host-language-function">host language function</a>
                                             </span>
                                          or a
                                          <a title="partially applied function" href="#dt-partially-applied-function">partial application</a>
                                          of such a function):
                                          
                                       </p>
                                       <ul>
                                          <li>
                                             <p>
                                                <var>F</var>'s implementation is invoked
                                                
                                                <span>
                                                   in an implementation-dependent way.
                                                   The processor makes the following information
                                                   available to that invocation:
                                                   </span>
                                                
                                             </p>
                                             <ul>
                                                <li>
                                                   <p>the converted argument values;</p>
                                                </li>
                                                <li>
                                                   <p>
                                                      <var>F</var>'s nonlocal variable bindings; and
                                                   </p>
                                                </li>
                                                <li>
                                                   <p>
                                                      a static context and dynamic context.
                                                      If <var>F</var>'s implementation is associated with a static and a dynamic context,
                                                      then these are supplied,
                                                      otherwise <var>SC</var> and <var>DC</var> are supplied.
                                                      
                                                   </p>
                                                </li>
                                             </ul>
                                             <p>
                                                How this information is used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                                                An API used to invoke external functions must state
                                                how the static and dynamic contexts are provided
                                                to a function that is invoked.
                                                The F&amp;O specification states how the static and dynamic contexts
                                                are used in each function that it defines. 
                                                <span class="xpath">
                                                   A host language must state how the static and dynamic contexts
                                                   are used in functions that it provides.
                                                   </span>
                                                
                                             </p>
                                          </li>
                                          <li>
                                             <p>
                                                The result is either an instance of <var>F</var>'s return type
                                                or a dynamic error.
                                                This result is then the result of evaluating <var>FC</var>.
                                                
                                             </p>
                                          </li>
                                          <li>
                                             <p>
                                                Errors raised by built-in functions are defined in
                                                <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                                                
                                             </p>
                                          </li>
                                          <li>
                                             <p>
                                                Errors raised by host-language-dependent functions are
                                                <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                                                
                                             </p>
                                          </li>
                                       </ul>
                                       <div class="exampleOuter">
                                          
                                          <div class="exampleHeader"><a id="d2e10227"></a>Example: A Built-in Function
                                          </div>
                                          <p>The following function call uses the function 
                                             <a href="https://www.w3.org/TR/xpath-functions-31/#func-base-uri">Section 
                                                
                                                2.5 fn:base-uri
                                                </a><sup><small>FO31</small></sup>.  Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in 
                                             <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                                          </p>
                                          <div class="exampleInner"><pre>fn:base-uri()</pre></div>
                                       </div>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-function-conversion-rules"></a>3.1.5.2 Function Conversion Rules
                     </h5>
                     <p>
                        [<a id="dt-function-conversion" title="function conversion rules">Definition</a>: The <b>function conversion rules</b> are used to convert an
                        		argument value  to its expected type; that is, to
                        		the declared type of the function <span class="xpath">parameter.</span>
                        ] The expected type is expressed as a <a title="sequence type" href="#dt-sequence-type">sequence type</a>. The function conversion rules are applied to a given value
                        		as follows:
                     </p>
                     <ul>
                        <li>
                           <p>In a static function call, if  <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath
                                 1.0 compatibility mode</a> is <code>true</code> and an
                              argument of a static function is not of
                              the expected type, then the following conversions are applied
                              sequentially to the argument value V:
                           </p>
                           <ol class="enumar">
                              <li>
                                 <p>If the expected type calls for a single item or optional single item (examples: <code>xs:string</code>, <code>xs:string?</code>, <code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>), then the value V is effectively replaced by V[1].
                                 </p>
                              </li>
                              <li>
                                 <p>If the expected type is
                                    		<code>xs:string</code> or <code>xs:string?</code>,
                                    		then the  value <code>V</code> is effectively
                                    		replaced by
                                    		<code>fn:string(V)</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>If
                                    		the expected type is <code>xs:double</code> or <code>xs:double?</code>, then the value <code>V</code> is effectively replaced by
                                    		<code>fn:number(V)</code>.
                                 </p>
                              </li>
                           </ol>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>
                                 <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility
                                    mode</a> has no effect on dynamic function calls,
                                 converting the result of an inline function to its required type,
                                 partial function application, or implicit function calls that
                                 occur when evaluating functions such as fn:for-each and fn:filter.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>If the expected type is a sequence of a <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a> (possibly with an occurrence indicator <code>*</code>, <code>+</code>, or <code>?</code>), the following conversions are applied:
                           </p>
                           <ol class="enumar">
                              <li>
                                 <p>
                                    <a title="atomization" href="#dt-atomization">Atomization</a> is applied
                                    		to the given value, resulting in a sequence of atomic
                                    		values.
                                 </p>
                              </li>
                              <li>
                                 <p>Each item in the atomic
                                    		sequence that is of type
                                    		<code>xs:untypedAtomic</code> is cast to the expected generalized
                                    		atomic type.  If the item is of type <code>xs:untypedAtomic</code> and the expected type is <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a>, a <a title="type error" href="#dt-type-error">type error</a> 
                                    [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised.
                                 </p>
                              </li>
                              <li>
                                 <p>For each <a title="numeric" href="#dt-numeric">numeric</a> item
                                    		in the atomic sequence that can be
                                    		<a title="type promotion" href="#dt-type-promotion">promoted</a> to the expected atomic type
                                    		using numeric promotion as described in <a href="#promotion"><b>B.1 Type Promotion</b></a>, the promotion is
                                    		done.
                                 </p>
                              </li>
                              <li>
                                 <p>For each item of type <code>xs:anyURI</code>
                                    		in the atomic sequence that can be
                                    		<a title="type promotion" href="#dt-type-promotion">promoted</a> to the expected atomic type
                                    		using URI promotion as described in <a href="#promotion"><b>B.1 Type Promotion</b></a>, the promotion is
                                    		done.
                                 </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>If the
                              		expected type is a <a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a> (possibly with an occurrence indicator <code>*</code>,
                              		<code>+</code>, or <code>?</code>), <a title="function coercion" href="#dt-function-item-coercion">function coercion</a> is applied to each function in the given value.
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>In XPath 3.1, maps and arrays are functions, so function coercion applies to them
                                 as well.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p> If, after the
                              		above conversions, the resulting value does not match
                              		the expected type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                                 		Matching</a>, a <a title="type error" href="#dt-type-error">type error</a> is
                              		raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                              		
                              		Note that the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                                 		Matching</a> permit a value of a derived type to
                              		be substituted for a value of its base
                              		type. 
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-function-coercion"></a>3.1.5.3 Function Coercion
                     </h5>
                     <p>
                        Function coercion is a transformation applied to <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup> during application of the
                        <a title="function conversion rules" href="#dt-function-conversion">function conversion rules</a>.
                        [<a id="dt-function-item-coercion" title="function coercion">Definition</a>: 
                        <b>Function coercion</b> wraps a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
                        in a new function
                        with signature the same as the expected type.
                        This effectively delays the checking
                        of the argument and return types
                        until the function is invoked.]
                        
                     </p>
                     <p>
                        Function coercion
                        is only defined to operate on
                        <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup>.
                        Given a function
                        <var>F</var>,
                        	and an expected function type,
                        function coercion
                        	proceeds as follows:
                        	If <var>F</var> and the expected type have different arity,
                        	a type error is raised
                        [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                        	Otherwise, coercion
                        returns a new function
                        with the following properties
                        (as defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 
                           
                           2.8.1 Functions
                           </a><sup><small>DM31</small></sup>):
                        
                        
                     </p>
                     <ul>
                        <li>
                           <p>
                              <b>name</b>:
                              The name of 
                              <var>F</var>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <b>parameter names</b>:
                              	      The parameter names of <var>F</var>.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <b>signature</b>:
                              <code>Annotations</code> is set to the annotations of <var>F</var>. <code>TypedFunctionTest</code> is set to the expected type.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <b>implementation</b>:
                              In effect,
                              a <code>FunctionBody</code> that calls <var>F</var>,
                              passing it the parameters of this new function,
                              in order.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <b>nonlocal variable bindings</b>:
                              An empty mapping.
                              
                           </p>
                        </li>
                     </ul>
                     <p>
                        If the result of invoking the new function would
                        necessarily result in a type error, that
                        error may be raised during
                        function coercion. It is implementation dependent whether this
                        happens or not.
                        
                     </p>
                     <p>
                        These rules have the following consequences:
                        
                        
                     </p>
                     <ul>
                        <li>
                           <p>
                              SequenceType matching of the function's arguments and result are delayed until that
                              function is invoked.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              The function conversion rules applied to the function's arguments and result are defined
                              by the SequenceType
                              it has most recently been coerced to. Additional function conversion rules could apply
                              when the wrapped function
                              is invoked.
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              If an implementation has static type information about a function, that can be used
                              to type check the
                              function's argument and return types during static analysis.
                              
                           </p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>
                           Although the semantics of function coercion are specified in terms of wrapping the
                           functions,
                           static typing will often be able to reduce the number of places where this is actually
                           necessary.
                           
                        </p>
                     </div>
                     <p>Since maps and arrays are also functions in XPath 3.1, function coercion applies to
                        them as well.
                        
                        For instance, consider the following expression:
                        
                     </p>
                     <div class="exampleInner"><pre>
let $m := map {
  "Monday" : true(),
  "Wednesday" : true(),
  "Friday" : true(),
  "Saturday" : false(),
  "Sunday" : false()
},
$days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
return fn:filter($days,$m)
      </pre></div>
                     <p>
                        The map <code>$m</code> has a function signature of <code>function(xs:anyAtomicType) as item()*</code>. When the <code>fn:filter()</code> function is called, the following occurs to the map:
                        
                        
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>The map <code>$m</code> is treated as <code>function ($f)</code>,  equivalent to <code>map:get($m,?)</code>.
                           </p>
                        </li>
                        <li>
                           <p>The function conversion rules result in applying function coercion to <code>$f</code>, wrapping <code>$f</code> in a new function (<code>$p</code>) with the signature <code>function(item()) as xs:boolean</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$p</code> is matched against the SequenceType <code>function(item()) as xs:boolean</code>, and succeeds.
                           </p>
                        </li>
                        <li>
                           <p>When <code>$p</code> is invoked by <code>fn:filter()</code>, function conversion and SequenceType matching rules are applied to the argument,
                              resulting in an <code>item()</code> value (<code>$a</code>) or a type error.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$f</code> is invoked with <code>$a</code>, which returns an <code>xs:boolean</code> or the empty sequence.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$p</code> applies function conversion rules and SequenceType matching to the result sequence
                              from <code>$f</code>. When the result is an <code>xs:boolean</code> the SequenceType matching succeeds. When it is an empty sequence (such as when <code>$m</code> does not contain a key for <code>"Tuesday"</code>), SequenceType matching results in a type error  [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code> and the actual type is an empty sequence.
                           </p>
                        </li>
                     </ol>
                     <p>Consider the following expression:
                        
                     </p>
                     <div class="exampleInner"><pre>
let $m := map {
"Monday" : true(),
"Tuesday" : false(),
"Wednesday" : true(),
"Thursday" : false(),
"Friday" : true(),
"Saturday" : false(),
"Sunday" : false()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
return fn:filter($days,$m)
      </pre></div>
                     <p>The result of the expression is the sequence <code>("Monday", "Wednesday", "Friday")</code>
                        
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-named-function-ref"></a>3.1.6 Named Function References
                  </h4>
                  <a id="d2e10682"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-NamedFunctionRef"></a>[67]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-NamedFunctionRef">NamedFunctionRef</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EQName">EQName</a>  "#"  <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e9847.doc-xpath31-EQName"></a>[112]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>EQName</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-QName">QName</a>  |  <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-named-function-ref" title="named function reference">Definition</a>: 
                     A <b>named function reference</b> is an expression
                     which evaluates to a <a title="named function" href="#dt-named-func">named
                        function</a>.  The name and arity of the returned
                     function are known statically, and correspond to a function
                     signature present in the static context; if the function is
                     context dependent, then the returned function is associated
                     with the static context of the named function reference and
                     the dynamic context in which it is evaluated.
                     ]
                     [<a id="dt-named-func" title="named function">Definition</a>: A <b>named function</b> is a function defined in the
                     static context for the <span class="xpath">expression</span>. 
                     To uniquely identify a particular named function, both its name as an expanded QName
                     and its arity are required.]
                     
                  </p>
                  <p>If the EQName is a <a title="lexical QName" href="#dt-qname">lexical QName</a> that has no namespace prefix, it is considered to be in the default function namespace.
                  </p>
                  <p>If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and arity in a named function reference do not match the name and arity of a function
                     signature in the
                     static context, a static error is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].
                  </p>
                  <p>
                     The value of a <code>NamedFunctionRef</code>
                     is the function obtained by looking up
                     the expanded QName and arity
                     in the <a title="named functions" href="#dt-named-functions">named functions</a> component
                     of the dynamic context.
                     
                     
                  </p>
                  <p>
                     Furthermore, if the function returned by the evaluation of
                     a <code>NamedFunctionRef</code> has an
                     implementation-dependent implementation, then the
                     implementation of this function is associated with the
                     static context of this <code>NamedFunctionRef</code>
                     expression and with the dynamic context in which
                     the <code>NamedFunctionRef</code> is evaluated.
                     
                  </p>
                  <p>The following are examples of named function references:
                     
                  </p>
                  <ul>
                     <li>
                        <p>
                           <code>fn:abs#1</code> references the fn:abs function which takes a single argument.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>fn:concat#5</code> references the fn:concat function which takes 5 arguments.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>local:myfunc#2</code> references a function named local:myfunc which takes 2 arguments.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-inline-func"></a>3.1.7 Inline Function Expressions
                  </h4>
                  <a id="d2e10798"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-InlineFunctionExpr"></a>[68]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"function"  "("  <a href="#prod-xpath31-ParamList">ParamList</a>?  ")"  ("as"  <a href="#doc-xpath31-SequenceType">SequenceType</a>)?  <a href="#prod-xpath31-FunctionBody">FunctionBody</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e9938.doc-xpath31-ParamList"></a>[2]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ParamList</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#prod-xpath31-Param">Param</a>  (","  <a href="#prod-xpath31-Param">Param</a>)*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e9939.doc-xpath31-Param"></a>[3]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>Param</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"$"  <a href="#doc-xpath31-EQName">EQName</a>  
                                 <a href="#prod-xpath31-TypeDeclaration">TypeDeclaration</a>?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e9940.doc-xpath31-TypeDeclaration"></a>[78]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>TypeDeclaration</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"as"  <a href="#doc-xpath31-SequenceType">SequenceType</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e9941.doc-xpath31-FunctionBody"></a>[4]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>FunctionBody</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-EnclosedExpr">EnclosedExpr</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-inline-func" title="inline function expression">Definition</a>: An <b>inline function expression</b> creates
                     an <a title="anonymous function" href="#dt-anonymous-function">anonymous
                        function</a>
                     defined directly in the
                     inline function expression.] An inline function expression specifies the names and
                     SequenceTypes of the parameters to the function,
                     the SequenceType of the result, and the body of the function. [<a id="dt-anonymous-function" title="anonymous function">Definition</a>: An <b>anonymous function</b> is a function with no name.  Anonymous functions may be created, for example, by
                     evaluating an inline function expression or by partial function application.]
                     
                  </p>
                  <p>
                     If a function parameter is declared using a name but no type, its default type is
                     item()*. If the result type is omitted from an inline function expression, its default
                     result type is item()*.
                     
                  </p>
                  <p>
                     The parameters of an inline function expression are considered to be variables whose
                     scope is the function body. It is a static error
                     [<a href="#ERRXQST0039" title="err:XQST0039">err:XQST0039</a>] for an inline function expression to have more than one parameter with the same
                     name.
                     
                  </p>
                  <p>
                     The static context for the function body is inherited from the location of the inline
                     function expression, with the exception of the
                     static type of the context item which is initially <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
                     
                  </p>
                  <p>
                     The variables in scope for the function body include all variables representing the
                     function parameters, as well as all variables that
                     are in scope for the inline function expression.
                     
                     
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>
                        Function parameter names can mask variables that would otherwise be in scope for the
                        function body.
                        
                     </p>
                  </div>
                  <p>The result of an inline function expression is a single function with the following
                     properties (as defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 
                        
                        2.8.1 Functions
                        </a><sup><small>DM31</small></sup>):
                     
                     
                  </p>
                  <ul>
                     <li>
                        <p>
                           <b>name</b>:
                           An absent name.
                           Absent.
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           <b>parameter names</b>:
                           The parameter names in
                           the <code>InlineFunctionExpr</code>'s
                           <code>ParamList</code>.
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           <b>signature</b>:
                           A <code>FunctionTest</code>
                           constructed from the
                           
                           	      <code>SequenceType</code>s in the <code>InlineFunctionExpr</code>.
                           	      <span>An implementation which can determine a more specific signature (for example, through
                              use of type analysis of the function's body) is permitted to do so.</span>
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           <b>implementation</b>:
                           The <code>InlineFunctionExpr</code>'s <code>FunctionBody</code>.
                           
                        </p>
                     </li>
                     <li>
                        <p>
                           <b>nonlocal variable bindings</b>:
                           For each nonlocal variable,
                           a binding of it to its value in the
                           <a title="variable values" href="#dt-variable-values">variable values</a> component
                           of the dynamic context of the <code>InlineFunctionExpr</code>.
                           
                        </p>
                     </li>
                  </ul>
                  <p>The following are examples of some inline function expressions:</p>
                  <ul>
                     <li>
                        <p>This example creates a function that takes no arguments and returns a sequence of
                           the first 6 primes:
                           
                        </p>
                        <div class="exampleInner"><pre>function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }</pre></div>
                     </li>
                     <li>
                        <p>This example creates a function that takes two xs:double arguments and returns their
                           product:
                           
                        </p>
                        <div class="exampleInner"><pre>function($a as xs:double, $b as xs:double) as xs:double { $a * $b }</pre></div>
                     </li>
                     <li>
                        <p>This example creates a function that returns its item()* argument:
                           
                        </p>
                        <div class="exampleInner"><pre>function($a) { $a }</pre></div>
                     </li>
                     <li>
                        <p>This example creates a sequence of functions each of which returns a
                           different 
                           <span>item</span>
                           from the default  collection.
                           
                           
                        </p>
                        <div class="exampleInner"><pre>collection()/(let $a := . return function() { $a })</pre></div>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-enclosed-expr"></a>3.1.8 Enclosed Expressions
                  </h4>
                  <p>
                     
                     
                     
                     <a id="d2e10996"></a></p>
                  <table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-EnclosedExpr"></a>[5]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-EnclosedExpr">EnclosedExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"{"  <a href="#doc-xpath31-Expr">Expr</a>?  "}"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     
                     [<a id="dt-enclosed-expression" title="enclosed expression">Definition</a>: An <b>enclosed expression</b> is an instance of the <a href="#doc-xpath31-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly braces.]  
                     [<a id="dt-content-expression" title="content expression">Definition</a>: In an  <a title="enclosed expression" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly braces is called the <b>content expression</b>.] If the <a title="content expression" href="#dt-content-expression">content expression</a> is 
                     <span>not provided explicitly</span>,  the content expression is <code>()</code>.
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-postfix-expression"></a>3.2 Postfix Expressions
               </h3>
               <a id="d2e11044"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-PostfixExpr"></a>[49]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-PostfixExpr">PostfixExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>  (<a href="#doc-xpath31-Predicate">Predicate</a>  |  <a href="#doc-xpath31-ArgumentList">ArgumentList</a>  |  <a href="#doc-xpath31-Lookup">Lookup</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="noid_d3e10130.doc-xpath31-Predicate"></a>[52]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>Predicate</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"["  <a href="#doc-xpath31-Expr">Expr</a>  "]"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="noid_d3e10131.doc-xpath31-ArgumentList"></a>[50]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>ArgumentList</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"("  (<a href="#doc-xpath31-Argument">Argument</a>  (","  <a href="#doc-xpath31-Argument">Argument</a>)*)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>
                  [<a id="dt-filter-expression" title="filter expression">Definition</a>: An
                  expression followed by a predicate (that is, <code>E1[E2]</code>)
                  is referred to as a <b>filter expression</b>: its effect is
                  to return those items from the value of <code>E1</code> that
                  satisfy the predicate in E2.] Filter expressions are
                  described in <a href="#id-filter-expression"><b>3.2.1 Filter Expressions</b></a>
                  
               </p>
               <p>An expression (other than a raw EQName) followed by an argument
                  list in parentheses (that is, <code>E1(E2, E3, ...)</code>) is
                  referred to as a <a title="dynamic function call" href="#dt-dynamic-function-invocation">dynamic function call</a>. Its
                  effect is to evaluate <code>E1</code> to obtain a function,
                  and then call that function, with
                  <code>E2</code>, <code>E3</code>, <code>...</code> as
                  arguments. Dynamic function calls are described in <a href="#id-dynamic-function-invocation"><b>3.2.2 Dynamic Function Calls</b></a>.
               </p>
               <div class="div3">
                  
                  <h4><a id="id-filter-expression"></a>3.2.1 Filter Expressions
                  </h4>
                  <a id="d2e11124"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10176.doc-xpath31-PostfixExpr"></a>[49]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>PostfixExpr</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>  (<a href="#doc-xpath31-Predicate">Predicate</a>  |  <a href="#doc-xpath31-ArgumentList">ArgumentList</a>  |  <a href="#doc-xpath31-Lookup">Lookup</a>)*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-Predicate"></a>[52]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-Predicate">Predicate</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"["  <a href="#doc-xpath31-Expr">Expr</a>  "]"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>A filter expression consists of a base expression followed by
                     a predicate, which is an expression written in square
                     brackets. The result of the filter expression consists of the
                     items returned by the base expression, filtered by applying the
                     predicate to each item in turn. The ordering of the items
                     returned by a filter expression is the same as their order in
                     the result of the primary expression.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Where the expression before the square brackets is a
                        <a href="#doc-xpath31-ReverseStep">ReverseStep</a> or <a href="#doc-xpath31-ForwardStep">ForwardStep</a>, the expression is technically not a
                        filter expression but an <a href="#doc-xpath31-AxisStep">AxisStep</a>. There are minor differences
                        in the semantics: see <a href="#id-predicate"><b>3.3.3 Predicates within Steps</b></a>
                        
                     </p>
                  </div>
                  <p>Here are some examples of filter expressions:</p>
                  <ul>
                     <li>
                        <p>Given a sequence of products in a variable, return only those products whose price
                           is greater than 100.
                        </p>
                        <div class="exampleInner"><pre>$products[price gt 100]</pre></div>
                     </li>
                     <li>
                        <p>List all the integers from 1 to 100 that are divisible by 5. (See <a href="#construct_seq"><b>3.4.1 Constructing Sequences</b></a> for an explanation of the <code>to</code> operator.)
                        </p>
                        <div class="exampleInner"><pre>(1 to 100)[. mod 5 eq 0]</pre></div>
                     </li>
                     <li>
                        <p>The result of the following expression is the integer 25:</p>
                        <div class="exampleInner"><pre>(21 to 29)[5]</pre></div>
                     </li>
                     <li>
                        <p>The following example returns the fifth through ninth items in the sequence bound
                           to variable <code>$orders</code>.
                        </p>
                        <div class="exampleInner"><pre>$orders[fn:position() = (5 to 9)]</pre></div>
                     </li>
                     <li>
                        <p>The following example illustrates the use of a filter expression as a <a title="step" href="#dt-step">step</a> in a <a title="path expression" href="#dt-path-expression">path expression</a>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:
                        </p>
                        <div class="exampleInner"><pre>$book/(chapter | appendix)[fn:last()]</pre></div>
                     </li>
                  </ul>
                  <p>For each item in the input sequence, the predicate expression
                     is evaluated using an <b>inner focus</b>, defined as
                     follows: The context item is the item currently being tested
                     against the predicate. The context size is the number of items
                     in the input sequence. The context position is the position of
                     the context item within the input sequence. 
                  </p>
                  <p>For each item in the input sequence, the result of the
                     predicate expression is coerced to an <code>xs:boolean</code>
                     value, called the <b>predicate truth value</b>, as
                     described below. Those items for which the predicate truth value
                     is <code>true</code> are retained, and those for which the
                     predicate truth value is <code>false</code> are discarded.
                  </p>
                  <p>The predicate truth value is derived by applying the following rules,
                     in order:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>If the value of the predicate expression is a <a title="singleton" href="#dt-singleton">singleton</a> atomic value of a
                           	   <a title="numeric" href="#dt-numeric">numeric</a> type or derived
                           	   from a <a title="numeric" href="#dt-numeric">numeric</a> type,
                           	   the predicate truth value is <code>true</code> if the value
                           	   of the predicate expression is equal (by the
                           	   <code>eq</code> operator) to the <b>context
                              	   position</b>, and is <code>false</code>
                           	   otherwise. 
                        </p>
                     </li>
                     <li>
                        <p>Otherwise, the predicate truth value is the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the
                           	   predicate expression.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-dynamic-function-invocation"></a>3.2.2 Dynamic Function Calls
                  </h4>
                  <a id="d2e11268"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10297.doc-xpath31-PostfixExpr"></a>[49]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>PostfixExpr</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>  (<a href="#doc-xpath31-Predicate">Predicate</a>  |  <a href="#doc-xpath31-ArgumentList">ArgumentList</a>  |  <a href="#doc-xpath31-Lookup">Lookup</a>)*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ArgumentList"></a>[50]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ArgumentList">ArgumentList</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"("  (<a href="#doc-xpath31-Argument">Argument</a>  (","  <a href="#doc-xpath31-Argument">Argument</a>)*)?  ")"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10299.doc-xpath31-Argument"></a>[64]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>Argument</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  |  <a href="#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10300.doc-xpath31-ArgumentPlaceholder"></a>[65]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>ArgumentPlaceholder</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"?"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-dynamic-function-invocation" title="dynamic function call">Definition</a>: A <b>dynamic function call</b>
                     consists of a
                     base expression
                     that returns the function and a
                     parenthesized list of zero or more arguments (<a title="argument expression" href="#dt-arg-expr">argument expressions</a> or
                     ArgumentPlaceholders).]
                     
                  </p>
                  <p>
                     A dynamic function call
                     is evaluated as described in
                     <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>.
                     
                  </p>
                  <p>The following are examples of some dynamic function calls:</p>
                  <ul>
                     <li>
                        <p>This example invokes the function contained in $f, passing the arguments 2 and 3:
                           
                        </p>
                        <div class="exampleInner"><pre>$f(2, 3)</pre></div>
                     </li>
                     <li>
                        <p>This example fetches the second item from sequence $f, treats it as a function and
                           invokes it, passing an <code>xs:string</code> argument:
                           
                        </p>
                        <div class="exampleInner"><pre>$f[2]("Hi there")</pre></div>
                     </li>
                     <li>
                        <p>This example invokes the function $f passing no arguments, and filters the result
                           with a positional predicate:
                           
                        </p>
                        <div class="exampleInner"><pre>$f()[2]</pre></div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-path-expressions"></a>3.3 Path Expressions
               </h3>
               <a id="d2e11356"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-PathExpr"></a>[36]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-PathExpr">PathExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("/"  <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>?)<br>|  ("//"  <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>)<br>|  <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>
                              </code></td>
                        <td><i>/* 
                              <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="noid_d3e10346.doc-xpath31-RelativePathExpr"></a>[37]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>RelativePathExpr</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#doc-xpath31-StepExpr">StepExpr</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>
                  [<a id="dt-path-expression" title="path expression">Definition</a>: A <b>path expression</b> can be used to locate nodes
                  	 within trees. A path expression consists of a series of one or more
                  	 <a title="step" href="#dt-step">steps</a>, separated by "<code>/</code>" or
                  	 "<code>//</code>", and optionally beginning with
                  	 "<code>/</code>" or "<code>//</code>".] An initial
                  	 "<code>/</code>" or "<code>//</code>" is an abbreviation for
                  	 one or more initial steps that are implicitly added to the
                  	 beginning of the path expression, as described below.
               </p>
               <p>A
                  	 path expression consisting of a single step is evaluated as
                  	 described in <a href="#id-steps"><b>3.3.2 Steps</b></a>.
               </p>
               <p>A "<code>/</code>"
                  	 at the beginning of a path expression is an abbreviation for
                  	 the initial step <code>(fn:root(self::node()) treat as document-node())/</code> (however, if the
                  	 "<code>/</code>" is the entire path expression, the trailing "<code>/</code>" is omitted from the expansion.) The effect
                  	 of this initial step is to begin the path at the root node of
                  	 the tree that contains the context node. If the context item
                  	 is not a node, a <a title="type error" href="#dt-type-error">type
                     	 error</a> is raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. At
                  	 evaluation time, if the root node <span>of</span> the context node is
                  	 not a document node, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
                  	 raised [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].
               </p>
               <p>A "<code>//</code>" at the beginning of a path expression
                  	 is an abbreviation for the initial steps
                  	 <code>(fn:root(self::node()) treat as
                     	 document-node())/descendant-or-self::node()/</code> (however, "<code>//</code>" by itself is not a valid path expression [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>].)  The
                  	 effect of these initial steps is to establish an initial node
                  	 sequence that contains the root of the tree in which the
                  	 context node is found, plus all nodes descended from this
                  	 root.
                  	 This node sequence is used as the input to subsequent steps
                  	 in the path expression. If the context item is not a node, a
                  	 <a title="type error" href="#dt-type-error">type error</a> is
                  	 raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. At evaluation time, if the
                  	 root node <span>of</span> the context node is not a document node, a
                  	 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
                  	 raised [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The descendants of a node do not include attribute
                     	 nodes<span class="xpath"> or namespace nodes</span>.
                  </p>
               </div>
               <p>
                  A path expression that starts with "<code>/</code>"
                  or "<code>//</code>" selects nodes starting from the root of
                  the tree containing the context item; it is often referred to
                  as an absolute path expression.
                  
               </p>
               <div class="div3">
                  
                  <h4><a id="id-relative-path-expressions"></a>3.3.1 Relative Path Expressions
                  </h4>
                  <a id="d2e11498"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-RelativePathExpr"></a>[37]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#doc-xpath31-StepExpr">StepExpr</a>)*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     A relative path expression is a path expression that selects
                     nodes within a tree by following a series of steps starting
                     at the context node (which, unlike an absolute path
                     expression, may be any node in a tree).
                     
                  </p>
                  <p>
                     Each non-initial occurrence of "<code>//</code>" in a path expression is
                     expanded as described in <a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>, leaving a
                     sequence of steps separated by "<code>/</code>". This sequence of steps
                     is then evaluated from left to right. So a path such as
                     <code>E1/E2/E3/E4</code> is evaluated
                     as <code>((E1/E2)/E3)/E4</code>. The semantics of a path
                     expression are thus defined by the semantics of the
                     binary "<code>/</code>" operator, which is defined in
                     <a href="#id-path-operator"><b>3.3.1.1 Path operator (/)</b></a>.
                     
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>
                        Although the semantics describe the evaluation of a path with
                        more than two steps as proceeding from left to right, the "<code>/</code>"
                        operator is in most cases associative, so evaluation from
                        right to left usually delivers the same result. The cases
                        where "<code>/</code>" is not associative arise when the functions
                        <code>fn:position()</code> and <code>fn:last()</code> are
                        used: <code>A/B/position()</code> delivers a sequence of
                        integers from 1 to the size of <code>(A/B)</code>, whereas
                        <code>A/(B/position())</code> restarts the counting at each <code>B</code> element.
                        
                     </p>
                  </div>
                  <p>The following example illustrates the use of relative path expressions.</p>
                  <div class="exampleOuter">
                     <ul>
                        <li>
                           <p>
                              <code>child::div1/child::para</code>
                              
                           </p>
                           <p>Selects the
                              	     <code>para</code> element children of the <code>div1</code>
                              	     element children of the context node; that is, the
                              	     <code>para</code> element grandchildren of the context node
                              	     that have <code>div1</code> parents.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Since each step in a path provides context nodes for the following step, in effect,
                        only the last step in a path is allowed to return a sequence of non-nodes.
                     </p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p id="Chg-slash-note">The "<code>/</code>" character
                        	 can be used either as a complete path expression or as the
                        	 beginning of a longer path expression such as
                        	 "<code>/*</code>".  Also, "<code>*</code>"
                        	 is both the multiply operator and a wildcard in path
                        	 expressions.  This can cause parsing difficulties when
                        	 "<code>/</code>" appears on the left-hand side of
                        	 "<code>*</code>".  This is resolved using the <a href="#parse-note-leading-lone-slash">leading-lone-slash
                           	 </a> constraint.  For example, "<code>/*</code>" and "<code>/
                           	 *</code>" are valid path expressions containing wildcards,
                        	 but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax
                        	 errors. Parentheses must be used when "<code>/</code>" is
                        	 used on the left-hand side of an operator, as in "<code>(/) * 5</code>". Similarly, "<code>4 + / *
                           	 5</code>" raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid expression.
                        	 The expression "<code>4 + /</code>" is also
                        	 valid, because <code>/</code> does not occur on the left-hand
                        	 side of the operator.
                     </p>
                     <p>Similarly, in the expression <code>/
                           	 union /*</code>, "union" is interpreted as an element name
                        	 rather than an operator. For it to be parsed as an operator,
                        	 the expression should be written <code>(/)
                           	 union /*</code>.
                     </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-path-operator"></a>3.3.1.1 Path operator (<code>/</code>)
                     </h5>
                     <p>The path operator "/" is used to build expressions for locating nodes within trees.
                        Its left-hand side expression must return a sequence of nodes. The operator returns
                        either a sequence of nodes, in which case it additionally performs document ordering
                        and duplicate elimination, or a sequence of non-nodes.
                     </p>
                     <p>Each operation <code>E1/E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated, and if the result is not a (possibly empty) sequence <code>S</code> of nodes, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0019" title="err:XPTY0019">err:XPTY0019</a>]. Each node in <code>S</code> then serves in turn to provide an inner focus (the node as the context item, its
                        position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code>, as described in  <a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows:
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of nodes, these sequences are combined, and duplicate
                              nodes are eliminated based on node identity.
                              <span class="xpath">The resulting node sequence is returned in <a title="document order" href="#dt-document-order">document order</a>.</span>
                              
                           </p>
                        </li>
                        <li>
                           <p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of non-nodes, these sequences are concatenated<span class="xpath">, in order,</span> and returned.
                              
                              <span class="xpath">The</span> returned sequence preserves the orderings within and among the subsequences generated
                              by the evaluations of <code>E2</code>
                              <span class="xpath">.</span>
                              
                           </p>
                        </li>
                        <li>
                           <p>If the multiple evaluations of <code>E2</code> return at least one node and at least one non-node, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0018" title="err:XPTY0018">err:XPTY0018</a>].
                           </p>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The semantics of the path operator can also be defined using the <span>simple map operator</span> as follows (forming the union with an empty sequence <code>($R | ())</code> has the effect of eliminating duplicates and sorting nodes into document order):
                        </p>
                        <div class="exampleInner"><pre>E1/E2 ::= let $R := E1!E2
  return
    if (every $r in $R satisfies $r instance of node())
    then ($R|())
    else if (every $r in $R satisfies not($r instance of node()))
    then $R
    else error()</pre></div>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-steps"></a>3.3.2 Steps
                  </h4>
                  <a id="d2e11749"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-StepExpr"></a>[38]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-StepExpr">StepExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-PostfixExpr">PostfixExpr</a>  |  <a href="#doc-xpath31-AxisStep">AxisStep</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10697.doc-xpath31-AxisStep"></a>[39]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>AxisStep</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(<a href="#doc-xpath31-ReverseStep">ReverseStep</a>  |  <a href="#doc-xpath31-ForwardStep">ForwardStep</a>)  <a href="#doc-xpath31-PredicateList">PredicateList</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ForwardStep"></a>[40]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ForwardStep">ForwardStep</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(<a href="#doc-xpath31-ForwardAxis">ForwardAxis</a>  
                                 <a href="#doc-xpath31-NodeTest">NodeTest</a>)  |  <a href="#doc-xpath31-AbbrevForwardStep">AbbrevForwardStep</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-ReverseStep"></a>[43]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-ReverseStep">ReverseStep</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(<a href="#doc-xpath31-ReverseAxis">ReverseAxis</a>  
                                 <a href="#doc-xpath31-NodeTest">NodeTest</a>)  |  <a href="#doc-xpath31-AbbrevReverseStep">AbbrevReverseStep</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e10700.doc-xpath31-PredicateList"></a>[51]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>PredicateList</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-Predicate">Predicate</a>*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-step" title="step">Definition</a>: A <b>step</b> is a part of a <a title="path expression" href="#dt-path-expression">path expression</a> that generates a sequence of items
                     		and then filters the sequence by zero or more
                     		<a title="" href="#dt-predicate">predicates</a>. The value of the step
                     		consists of those items that satisfy the
                     		predicates, working from left to right. A step may be either an <a title="axis step" href="#dt-axis-step">axis step</a> or a postfix expression.] Postfix expressions are described in <a href="#id-postfix-expression"><b>3.2 Postfix Expressions</b></a>.
                  </p>
                  <p>
                     [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified
                     axis. Such a step has two parts: an
                     		<b>axis</b>, which defines the "direction of
                     		movement" for the step, and a <a title="node test" href="#dt-node-test">node test</a>,
                     		which selects nodes based on their kind, name, and/or
                     		<a title="type annotation" href="#dt-type-annotation">type annotation</a>.] If the context item is a node, an axis
                     		step returns a sequence of zero or more
                     		nodes; otherwise, a <a title="type error" href="#dt-type-error">type error</a> is
                     		raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>].   <span class="xpath">The resulting node sequence is returned in <a title="document order" href="#dt-document-order">document
                           	 order</a>.</span>  An axis step may be either a <b>forward
                        		step</b> or a <b>reverse step</b>, followed
                     		by zero or more <a title="" href="#dt-predicate">predicates</a>.
                  </p>
                  <p>In the <b>abbreviated syntax</b> for a step, the axis can
                     		be omitted and other shorthand notations can be used as described in
                     		<a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.
                  </p>
                  <p>The unabbreviated syntax for an axis step consists of the axis name
                     		and node test separated by a double colon. The result of the step consists of the
                     nodes
                     		reachable from the context node via the specified axis that have the node kind,
                     name,
                     		and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a> specified by the node test. For example, the
                     		step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes
                     are described in <a href="#axes"><b>3.3.2.1 Axes</b></a>. The
                     		available node tests are described in <a href="#node-tests"><b>3.3.2.2 Node Tests</b></a>. Examples of
                     		steps are provided in <a href="#unabbrev"><b>3.3.4 Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.
                  </p>
                  <div class="div4">
                     
                     <h5><a id="axes"></a>3.3.2.1 Axes
                     </h5>
                     <a id="d2e11905"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ForwardAxis"></a>[41]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ForwardAxis">ForwardAxis</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>("child"  "::")<br>|  ("descendant"  "::")<br>|  ("attribute"  "::")<br>|  ("self"  "::")<br>|  ("descendant-or-self"  "::")<br>|  ("following-sibling"  "::")<br>|  ("following"  "::")<br>|  ("namespace"  "::")</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ReverseAxis"></a>[44]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ReverseAxis">ReverseAxis</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>("parent"  "::")<br>|  ("ancestor"  "::")<br>|  ("preceding-sibling"  "::")<br>|  ("preceding"  "::")<br>|  ("ancestor-or-self"  "::")</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p class="xpath">XPath defines a full set of <b>axes</b>
                        		  for traversing documents, but a <b>host language</b> may define a subset
                        		  of these axes. The following axes are defined:
                     </p>
                     <ul>
                        <li>
                           <p>The <code>child</code> axis
                              				contains the children of the context
                              				node, which are the nodes returned by the
                              				<a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-children">Section 
                                 
                                 5.3 children Accessor
                                 </a><sup><small>DM31</small></sup>.
                              
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Only document
                                 nodes and element
                                 nodes have
                                 children. If the
                                 context node is any
                                 other kind of node,
                                 or if the context
                                 node is an empty
                                 document or element
                                 node, then the child
                                 axis is an empty
                                 sequence.  The
                                 children of a
                                 document node or
                                 element node may be
                                 element, processing
                                 instruction,
                                 comment, or text
                                 nodes.  Attribute<span class="xpath">,
                                    namespace,</span> and
                                 document nodes can
                                 never appear as
                                 children.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>the <code>descendant</code>
                              			 axis is defined as the transitive closure of
                              			 the child axis; it contains the descendants
                              			 of the context node (the children, the children of the children, and so on)
                           </p>
                        </li>
                        <li>
                           <p>the <code>parent</code>
                              axis contains the sequence
                              returned by the
                              				          <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-parent">Section 
                                 
                                 5.11 parent Accessor
                                 </a><sup><small>DM31</small></sup>, 
                              which returns
                              the parent of the context
                              node, or an empty sequence
                              if the context node has no
                              parent
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>An attribute node may have an element node as its parent, even though the attribute
                                 node is not a child of the element node.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>the
                              <code>ancestor</code> axis is
                              defined as the transitive
                              closure of the parent axis; it
                              contains the ancestors of the
                              context node (the parent, the
                              parent of the parent, and so
                              on)
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The ancestor axis
                                 includes the root node of the
                                 tree in which the context node
                                 is found, unless the context
                                 node is the root node.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>the <code>following-sibling</code>
                              			 axis contains the context node's following
                              			 siblings, those children of the context
                              			 node's parent that occur after the context
                              			 node in <a title="document order" href="#dt-document-order">document order</a>; if the context node
                              			 is an attribute <span class="xpath"> or namespace </span> node, the
                              			 <code>following-sibling</code> axis is
                              			 empty
                           </p>
                        </li>
                        <li>
                           <p>the <code>preceding-sibling</code>
                              			 axis contains the context node's preceding
                              			 siblings, those children of the context
                              			 node's parent that occur before the context
                              			 node in <a title="document order" href="#dt-document-order">document order</a>; if the context node
                              			 is an attribute <span class="xpath"> or namespace </span> node, the
                              			 <code>preceding-sibling</code> axis is
                              			 empty
                           </p>
                        </li>
                        <li>
                           <p>the <code>following</code> axis
                              				contains all nodes that are
                              				descendants of the root of the tree in
                              				which the context node is found, are
                              				not descendants of the context node,
                              				and occur after the context node in
                              				<a title="document order" href="#dt-document-order">document order</a>
                              
                           </p>
                        </li>
                        <li>
                           <p>the <code>preceding</code> axis
                              				contains all nodes that are
                              				descendants of the root of the tree in
                              				which the context node is found, are
                              				not ancestors of the context node, and
                              				occur before the context node in
                              				<a title="document order" href="#dt-document-order">document order</a>
                              
                           </p>
                        </li>
                        <li>
                           <p>the <code>attribute</code> axis
                              			 contains the attributes of the context node,
                              			 which are the nodes returned by the
                              			 <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-parent">Section 
                                 
                                 5.11 parent Accessor
                                 </a><sup><small>DM31</small></sup>; the axis will be
                              			 empty unless the context node is an
                              			 element
                           </p>
                        </li>
                        <li>
                           <p>the <code>self</code> axis contains just the context node itself
                           </p>
                        </li>
                        <li>
                           <p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context
                              				node
                           </p>
                        </li>
                        <li>
                           <p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
                              				thus, the ancestor-or-self axis will always include the root node
                           </p>
                        </li>
                        <li>
                           <p>the <code>namespace</code> axis
                              				contains the namespace nodes of the
                              				context node, which are the nodes
                              				returned by the
                              <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-namespace-nodes">Section 
                                 
                                 5.7 namespace-nodes Accessor
                                 </a><sup><small>DM31</small></sup>; this axis
                              				is empty unless the context node is an
                              				element node. The
                              				<code>namespace</code> axis is
                              				deprecated as of XPath 2.0. If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
                                 		compatibility mode</a> is <code>true</code>, the <code>namespace</code> axis must be supported. If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
                                 		compatibility mode</a> is <code>false</code>, then support for the
                              				<code>namespace</code> axis is
                              				<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. An implementation
                              				that does not support the
                              				<code>namespace</code> axis when <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
                                 		compatibility mode</a> is <code>false</code> must raise
                              				a <a title="static error" href="#dt-static-error">static
                                 				error</a> 
                              [<a href="#ERRXPST0010" title="err:XPST0010">err:XPST0010</a>] if it is
                              				used. Applications needing information
                              				about the <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of an element
                              				should use the functions
                              				<a href="https://www.w3.org/TR/xpath-functions-31/#func-in-scope-prefixes">Section 
                                 
                                 10.2.6 fn:in-scope-prefixes
                                 </a><sup><small>FO31</small></sup>, 
                              				and
                              				<a href="https://www.w3.org/TR/xpath-functions-31/#func-namespace-uri-for-prefix">Section 
                                 
                                 10.2.5 fn:namespace-uri-for-prefix
                                 </a><sup><small>FO31</small></sup>.
                              
                           </p>
                        </li>
                     </ul>
                     <p>Axes can be categorized as <b>forward axes</b> and
                        		  <b>reverse axes</b>. An axis that only ever contains the context node or
                        		  nodes that are after the context node in <a title="document order" href="#dt-document-order">document order</a> is a forward axis. An
                        		  axis that only ever contains the context node or nodes that are before the
                        		  context node in <a title="document order" href="#dt-document-order">document order</a> is a reverse axis.
                     </p>
                     <p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <span class="xpath">and namespace</span> nodes):
                        		  they do not overlap and together they contain all the nodes in the
                        		  document.
                     </p>
                     <p>
                        [<a id="dt-principal-node-kind" title="principal node kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can
                        		  contain elements, then the principal node kind is element; otherwise, it is the
                        		  kind of nodes that the axis can contain.] Thus:
                     </p>
                     <ul>
                        <li>
                           <p>For the attribute axis, the principal node kind is
                              				attribute.
                           </p>
                        </li>
                        <li>
                           <p>For the namespace axis, the principal node kind is
                              				namespace.
                           </p>
                        </li>
                        <li>
                           <p>For all other axes, the principal node kind is element.</p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="node-tests"></a>3.3.2.2 Node Tests
                     </h5>
                     <p>
                        [<a id="dt-node-test" title="node test">Definition</a>: A <b>node test</b> is a condition on the name, kind (element, attribute, text, document, comment,
                        		  or processing instruction), and/or  <a title="type annotation" href="#dt-type-annotation">type annotation</a> of a node. 
                        A node test determines which nodes contained by an axis are selected by a <a title="step" href="#dt-step">step</a>.] 
                        
                     </p>
                     <a id="d2e12205"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-NodeTest"></a>[46]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-NodeTest">NodeTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-KindTest">KindTest</a>  |  <a href="#doc-xpath31-NameTest">NameTest</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-NameTest"></a>[47]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-NameTest">NameTest</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-EQName">EQName</a>  |  <a href="#doc-xpath31-Wildcard">Wildcard</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-Wildcard"></a>[48]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-Wildcard">Wildcard</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"*"<br>|  (<a href="#prod-xpath31-NCName">NCName</a>  ":*")<br>|  ("*:"  <a href="#prod-xpath31-NCName">NCName</a>)<br>|  (<a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a>  "*")</code></td>
                              <td><i>/* 
                                    <a href="#ws-explicit">ws: explicit</a>
                                    */</i></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="noid_d3e11068.doc-xpath31-EQName"></a>[112]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code>EQName</code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-QName">QName</a>  |  <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        [<a id="dt-name-test" title="name test">Definition</a>: A node test that consists only of an EQName or a
                        		  Wildcard is called a <b>name test</b>.] A name
                        		  test <span>that consists of an EQName</span> is true if and only if the <b>kind</b> of
                        		  the node is the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> for the step axis and the
                        		  <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the node is equal (as defined by the <code>eq</code> operator) to the
                        		  <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> specified by the name test. For
                        		  example, <code>child::para</code>
                        		  selects the <code>para</code> element children of
                        		  the context node; if the context node has no
                        		  <code>para</code> children, it selects an empty set
                        		  of nodes. <code>attribute::abc:href</code> selects
                        		  the attribute of the context node with the QName
                        		  <code>abc:href</code>; if the context node has no
                        		  such attribute, it selects an empty set of
                        		  nodes.
                     </p>
                     <p>If the EQName is a <a title="lexical QName" href="#dt-qname">lexical QName</a>, it is resolved into an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> using the
                        		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> in the expression
                        		  context. It is a <a title="static error" href="#dt-static-error">static error</a> 
                        [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>] if the QName has a prefix that does not
                        		  correspond to any statically known namespace.
                        
                        An unprefixed QName, when used as a
                        		  name test on an axis whose <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> is
                        		  element, has the namespace URI of the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> in
                        		  the expression context; otherwise, it has no namespace URI. 
                     </p>
                     <p>A name test is not satisfied by an element node whose name does not match the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the name test, even if it is in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> whose head is the named element.
                     </p>
                     <p>A node test <code>*</code> is true for any node of the
                        		  <a title="principal node kind" href="#dt-principal-node-kind">principal node
                           		  kind</a> of the step axis. For example, <code>child::*</code> will select all element
                        		  children of the context node, and <code>attribute::*</code> will select all
                        		  attributes of the context node.
                     </p>
                     <p>A node test can have the form
                        		  <code>NCName:*</code>. In this case, the prefix is
                        		  expanded in the same way as with a <a title="lexical QName" href="#dt-qname">lexical QName</a>, using the
                        		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known
                           		  namespaces</a> in the <a title="static context" href="#dt-static-context">static context</a>. If
                        		  the prefix is not found in the statically known namespaces,
                        		  a <a title="static error" href="#dt-static-error">static
                           		  error</a> is raised [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].
                        		  The node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal
                           		  node kind</a> of the step axis whose <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> has the namespace URI
                        		  to which the prefix is bound, regardless of the
                        		  local part of the name.
                     </p>
                     <p>A node test can contain a BracedURILiteral, e.g.
                        		  <code>Q{http://example.com/msg}*</code> Such a node test is true for any node of the principal node kind of the step axis
                        whose expanded QName has the namespace URI specified in the BracedURILiteral, regardless
                        of the local part of the name.
                     </p>
                     <p>A node test can also
                        		  have the form <code>*:NCName</code>. In this case,
                        		  the node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal
                           		  node kind</a> of the step axis whose local name matches the given NCName,
                        		  regardless of its namespace or lack of a namespace.
                     </p>
                     <p>
                        [<a id="dt-kind-test" title="kind test">Definition</a>: An alternative
                        		  form of a node test called a
                        		  <b>kind test</b> can select nodes based
                        		  on their kind, name, and <a title="type annotation" href="#dt-type-annotation">type annotation</a>.] The syntax
                        		  and semantics of a kind test are described in
                        		  <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a> and <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>. When a kind test is used
                        		  in a <a title="node test" href="#dt-node-test">node test</a>, only those nodes on the designated
                        		  axis that match the kind test are selected. Shown
                        		  below are several examples of kind tests that might
                        		  be used in path
                        		  expressions:
                     </p>
                     <ul>
                        <li>
                           <p>
                              <code>node()</code>
                              		  matches any
                              		  node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>text()</code> matches
                              		  any text
                              		  node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>comment()</code>
                              		  matches any comment
                              		  node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>namespace-node()</code> matches any
                              		  namespace node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element()</code>
                              		  matches any element
                              		  node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>schema-element(person)</code>
                              		  matches any element node whose name is
                              		  <code>person</code> (or is in the <a title="substitution group" href="#dt-substitution-group">substitution group</a>
                              		  headed by <code>person</code>), and whose type
                              		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
                              		  element in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(person)</code> matches any element node whose name is
                              		  <code>person</code>, regardless of its type annotation.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(person, surgeon)</code> matches any non-nilled element node whose name
                              		  is <code>person</code>, and whose type
                              		  annotation is
                              		  <code>surgeon</code> or is derived from <code>surgeon</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>element(*,
                                 		  surgeon)</code> matches any non-nilled element node whose type
                              		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
                              		  its
                              		  name.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute()</code> matches any
                              attribute node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute(price)</code> matches
                              any attribute whose name is <code>price</code>,
                              regardless of its type annotation.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>attribute(*,
                                 xs:decimal)</code> matches any attribute whose type
                              annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                              its
                              name.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>document-node()</code>
                              matches any document
                              node.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>document-node(element(book))</code>
                              matches any document node whose content consists of
                              a single element node that satisfies the <a title="kind test" href="#dt-kind-test">kind test</a>
                              <code>element(book)</code>, interleaved with zero or more
                              comments and processing
                              instructions.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-predicate"></a>3.3.3 Predicates within Steps
                  </h4>
                  <a id="d2e12550"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AxisStep"></a>[39]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AxisStep">AxisStep</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(<a href="#doc-xpath31-ReverseStep">ReverseStep</a>  |  <a href="#doc-xpath31-ForwardStep">ForwardStep</a>)  <a href="#doc-xpath31-PredicateList">PredicateList</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-PredicateList"></a>[51]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-PredicateList">PredicateList</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-Predicate">Predicate</a>*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e11357.doc-xpath31-Predicate"></a>[52]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>Predicate</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"["  <a href="#doc-xpath31-Expr">Expr</a>  "]"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p id="dt-predicate">A predicate within a Step has similar syntax and semantics
                     	 to a predicate within a <a title="" href="#id-filter-expression">filter expression</a>.  The
                     	 only difference is in the way the context position is set for
                     	 evaluation of the predicate.
                  </p>
                  <p>For the purpose of evaluating the context position within
                     	 a predicate, the input sequence is considered to be sorted as
                     	 follows: into document order if the predicate is in a
                     	 forward-axis step, into reverse document order if the
                     	 predicate is in a reverse-axis step, or in its original order
                     	 if the predicate is not in a step.
                  </p>
                  <p>Here are some examples of <a title="axis step" href="#dt-axis-step">axis steps</a> that contain predicates:
                  </p>
                  <ul>
                     <li>
                        <p>This example selects the second <code>chapter</code> element that is a child
                           			 of the context node:
                        </p>
                        <div class="exampleInner"><pre>child::chapter[2]</pre></div>
                     </li>
                     <li>
                        <p>This example selects all the descendants of the
                           		  context node that are elements named
                           		  <code>"toy"</code> and whose <code>color</code>
                           		  attribute has the value <code>"red"</code>:
                        </p>
                        <div class="exampleInner"><pre>descendant::toy[attribute::color = "red"]</pre></div>
                     </li>
                     <li>
                        <p>This example selects all the <code>employee</code> children of the context node
                           		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:
                        </p>
                        <div class="exampleInner"><pre>child::employee[secretary][assistant]</pre></div>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When using <a title="" href="#dt-predicate">predicates</a> with a sequence of nodes selected using a
                        <b>reverse axis</b>, it is important to remember that the
                        context positions for such a sequence are assigned in <a title="reverse document order" href="#dt-reverse-document-order">reverse
                           document order</a>. For example, <code>preceding::foo[1]</code>
                        returns the first qualifying <code>foo</code> element in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>, because the predicate is part of an <a title="axis step" href="#dt-axis-step">axis step</a> using a reverse axis. By
                        contrast, <code>(preceding::foo)[1]</code> returns the first qualifying <code>foo</code>
                        element in <a title="document order" href="#dt-document-order">document order</a>, because the parentheses cause  <code>(preceding::foo)</code> to be parsed as a <a title="primary expression" href="#dt-primary-expression">primary expression</a> in which context positions are assigned in document order. Similarly, <code>ancestor::*[1]</code>
                        returns the nearest ancestor element, because the <code>ancestor</code> axis is a
                        reverse axis, whereas <code>(ancestor::*)[1]</code> returns the root element (first ancestor in document order).
                     </p>
                     <p>The fact that a reverse-axis step assigns context positions in reverse
                        document order for the purpose of evaluating predicates does not alter the
                        fact that the final result of the step  is always in document order.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="unabbrev"></a>3.3.4 Unabbreviated Syntax
                  </h4>
                  <p>This section provides a number of examples of path expressions in which the
                     axis is explicitly specified in each <a title="step" href="#dt-step">step</a>. The syntax used in these examples is
                     called the <b>unabbreviated syntax</b>. In many common cases, it is
                     possible to write path expressions more concisely using an <b>abbreviated
                        syntax</b>, as explained in <a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>child::para</code> selects
                           the <code>para</code> element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::*</code> selects all element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::text()</code> selects all text node children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned,
                           because attributes are not children.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>attribute::name</code> selects the <code>name</code> attribute of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>attribute::*</code> selects all the attributes of the context node
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node,
                           this expression returns the element node (if any) to which the attribute node is attached.
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>descendant::para</code> selects the <code>para</code> element descendants of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>ancestor::div</code> selects all <code>div</code> ancestors of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::chapter/descendant::para</code> selects the <code>para</code> element
                           descendants of the <code>chapter</code> element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/</code> selects the root of the tree that contains the context node, but raises a dynamic
                           error if this root is not a document node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/descendant::list/child::member</code> selects all
                           the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>following-sibling::chapter[fn:position() = 1]</code> selects the next <code>chapter</code> sibling of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>preceding-sibling::chapter[fn:position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the
                           second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[attribute::type eq "warning"]</code> selects
                           all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[attribute::type eq 'warning'][fn:position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::para[fn:position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::chapter[child::title = 'Introduction']</code> selects
                           the <code>chapter</code> children of the context node that have one or
                           more <code>title</code> children whose <a title="typed value" href="#dt-typed-value">typed value</a> is equal to the
                           string <code>Introduction</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::*[self::chapter or self::appendix]</code>
                           selects the <code>chapter</code> and <code>appendix</code> children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>child::*[self::chapter or
                              self::appendix][fn:position() = fn:last()]</code> selects the
                           last <code>chapter</code> or <code>appendix</code> child of the context node
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="abbrev"></a>3.3.5 Abbreviated Syntax
                  </h4>
                  <a id="d2e13033"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AbbrevForwardStep"></a>[42]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"@"?  <a href="#doc-xpath31-NodeTest">NodeTest</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-AbbrevReverseStep"></a>[45]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>".."</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The abbreviated syntax permits the following abbreviations:</p>
                  <ol class="enumar">
                     <li>
                        <p>The attribute axis <code>attribute::</code> can be
                           abbreviated by <code>@</code>. For example, a path expression <code>para[@type="warning"]</code> is short
                           for <code>child::para[attribute::type="warning"]</code> and
                           so selects <code>para</code> children with a <code>type</code> attribute with value
                           equal to <code>warning</code>.
                        </p>
                     </li>
                     <li>
                        <p>If the axis name is omitted from an <a title="axis step" href="#dt-axis-step">axis step</a>, the default axis is
                           <code>child</code>, with two exceptions:
                           
                           (1) if the <a href="#doc-xpath31-NodeTest">NodeTest</a> in an axis step contains an <a href="#doc-xpath31-AttributeTest">AttributeTest</a> or <a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> then the
                           default axis is <code>attribute</code>;     
                           (2) if the <a href="#doc-xpath31-NodeTest">NodeTest</a> in an axis step is a <a href="#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a> 
                           
                           <span class="xpath">then the default axis is <code>namespace</code> - in an implementation that does not support
                              the namespace axis, an error is raised [<a href="#ERRXQST0134" title="err:XQST0134">err:XQST0134</a>].</span>
                           
                           
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>
                              The namespace
                              axis is deprecated as of XPath 2.0, but required in some languages
                              that use XPath, including XSLT.
                           </p>
                        </div>
                        <p>
                           
                           For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path
                           expression <code>section/@id</code> is an
                           abbreviation for <code>child::section/attribute::id</code>.  Similarly,
                           <code>section/attribute(id)</code> is an
                           abbreviation for <code>child::section/attribute::attribute(id)</code>. Note
                           that the latter expression contains both an axis specification and
                           a <a title="node test" href="#dt-node-test">node test</a>.
                        </p>
                     </li>
                     <li>
                        <p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code>div1//para</code> is
                           short for <code>child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The path expression <code>//para[1]</code> does <em>not</em> mean the same as the path
                              expression <code>/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former
                              selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>A step consisting
                           of <code>..</code> is short
                           for <code>parent::node()</code>. For example, <code>../title</code> is short for <code>parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The expression <code>.</code>, known as a <b>context item
                                 expression</b>, is a <a title="primary expression" href="#dt-primary-expression">primary expression</a>,
                              and is described in <a href="#id-context-item-expression"><b>3.1.4 Context Item Expression</b></a>.
                           </p>
                        </div>
                     </li>
                  </ol>
                  <p>Here are some examples of path expressions that use the abbreviated
                     syntax:
                  </p>
                  <ul>
                     <li>
                        <p> 
                           <code>para</code> selects the <code>para</code> element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>*</code> selects all element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>text()</code> selects all text node children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>@name</code> selects
                           the <code>name</code> attribute of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>@*</code> selects all the attributes of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>para[1]</code> selects the first <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>para[fn:last()]</code> selects the last <code>para</code> child of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>*/para</code> selects
                           all <code>para</code> grandchildren of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>/book/chapter[5]/section[2]</code> selects the
                           second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>//para</code> selects all
                           the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>.//para</code> selects
                           the <code>para</code> element descendants of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>..</code> selects the parent of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>../@lang</code> selects
                           the <code>lang</code> attribute of the parent of the context node
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one
                           or more <code>title</code> children whose <a title="typed value" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code> 
                           
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>employee[@secretary and @assistant]</code> selects all
                           the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and
                           an <code>assistant</code> attribute
                        </p>
                     </li>
                     <li>
                        <p> 
                           <code>book/(chapter|appendix)/section</code> selects
                           every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.
                        </p>
                     </li>
                     <li>
                        <p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-sequence-expressions"></a>3.4 Sequence Expressions
               </h3>
               <p>XPath 3.1 supports operators to construct, filter,  and combine
                  <a title="sequence" href="#dt-sequence">sequences</a> of <a title="item" href="#dt-item">items</a>.
                  Sequences are never nested—for
                  example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
                  in the sequence <code>(1, 2, 3)</code>.
               </p>
               <div class="div3">
                  
                  <h4><a id="construct_seq"></a>3.4.1 Constructing Sequences
                  </h4>
                  <a id="d2e13517"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e12284.doc-xpath31-Expr"></a>[6]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>Expr</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-RangeExpr"></a>[20]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-RangeExpr">RangeExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#doc-xpath31-AdditiveExpr">AdditiveExpr</a> )?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     [<a id="dt-comma-operator" title="comma operator">Definition</a>: One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in
                     order, into a single result sequence.] Empty parentheses can be used to denote an
                     empty sequence.
                  </p>
                  <p>A sequence may contain duplicate
                     <a title="item" href="#dt-item">items</a>, but a sequence is never an item in another sequence. When a
                     new sequence is created by concatenating two or more input sequences, the new
                     sequence contains all the items of the input sequences and its length is the
                     sum of the lengths of the input sequences.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In places where the grammar calls for <a href="#doc-xpath31-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level
                        comma operator must be enclosed in parentheses.
                     </p>
                  </div>
                  <p>Here are some examples of expressions that construct sequences:
                     
                  </p>
                  <ul>
                     <li>
                        <p>The result of this expression is a sequence of five integers:</p>
                        <div class="exampleInner"><pre>(10, 1, 2, 3, 4)</pre></div>
                     </li>
                     <li>
                        <p>This expression combines four sequences of length one, two, zero, and two, respectively,
                           into a single sequence of length five. The result of this expression is the sequence
                           <code>10, 1, 2, 3, 4</code>.
                        </p>
                        <div class="exampleInner"><pre>(10, (1, 2), (), (3, 4))</pre></div>
                     </li>
                     <li>
                        <p>The result of this expression is a sequence containing
                           all <code>salary</code> children of the context node followed by all <code>bonus</code> children.
                        </p>
                        <div class="exampleInner"><pre>(salary, bonus)</pre></div>
                     </li>
                     <li>
                        <p>Assuming that <code>$price</code> is bound to
                           the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.
                        </p>
                        <div class="exampleInner"><pre>($price, $price)</pre></div>
                     </li>
                  </ul>
                  <p>A <b>range expression</b> can be used to construct a sequence of consecutive
                     integers. Each of the operands of the <code>to</code> operator is
                     converted as though it was an argument of a function with the expected
                     parameter type <code>xs:integer?</code>.
                     If either operand is an empty sequence, or if the integer derived from the first operand
                     is greater than the integer derived from the second operand, the result of the range
                     expression is an empty sequence. If the two operands convert to the same integer,
                     the result of the range expression is that integer. Otherwise, the result is a sequence
                     containing the two integer operands and
                     every integer between the two operands, in increasing order. 
                  </p>
                  <ul>
                     <li>
                        <p>This example uses a range expression as one operand in constructing a sequence. It
                           evaluates to the sequence <code>10, 1, 2, 3, 4</code>.
                        </p>
                        <div class="exampleInner"><pre>(10, 1 to 4)</pre></div>
                     </li>
                     <li>
                        <p>This example constructs a sequence of length one containing the single integer <code>10</code>.
                        </p>
                        <div class="exampleInner"><pre>10 to 10</pre></div>
                     </li>
                     <li>
                        <p>The result of this example is a sequence of length zero.</p>
                        <div class="exampleInner"><pre>15 to 10</pre></div>
                     </li>
                     <li>
                        <p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates
                           to the sequence <code>15, 14, 13, 12, 11, 10</code>.
                        </p>
                        <div class="exampleInner"><pre>fn:reverse(10 to 15)</pre></div>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="combining_seq"></a>3.4.2 Combining Node Sequences
                  </h4>
                  <a id="d2e13648"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-UnionExpr"></a>[23]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-UnionExpr">UnionExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-IntersectExceptExpr"></a>[24]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#doc-xpath31-InstanceofExpr">InstanceofExpr</a> )*</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>XPath 3.1 provides the following operators for combining sequences of
                     nodes:
                  </p>
                  <ul>
                     <li>
                        <p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
                           return a sequence containing all the nodes that occur in either of the
                           operands.
                        </p>
                     </li>
                     <li>
                        <p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
                           containing all the nodes that occur in both operands.
                        </p>
                     </li>
                     <li>
                        <p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
                           containing all the nodes that occur in the first operand but not in the second
                           operand.
                        </p>
                     </li>
                  </ul>
                  <p>
                     All these operators eliminate duplicate nodes from their result sequences based on
                     node identity. <span class="xpath">The resulting sequence is returned in <a title="document order" href="#dt-document-order">document
                           	 order</a>.</span>
                     
                  </p>
                  <p>If an operand
                     of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                  </p>
                  <p>
                     If an IntersectExceptExpr contains more than two InstanceofExprs,
                     they are grouped from left to right.
                     With a UnionExpr, it makes no difference how operands are grouped,
                     the results are the same.
                     
                  </p>
                  <div class="exampleOuter">
                     <p>Here are some examples of expressions that combine sequences. Assume the existence
                        of three element nodes that we will refer to by symbolic names A, B, and C.  Assume
                        that the variables <code>$seq1</code>,  <code>$seq2</code>  and <code>$seq3</code> are bound to the following sequences of these nodes:
                     </p>
                     <ul>
                        <li>
                           <p>
                              <code>$seq1</code> is bound to (A, B)
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$seq2</code> is bound to (A, B)
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$seq3</code> is bound to (B, C)
                           </p>
                        </li>
                     </ul>
                     <p>Then: </p>
                     <ul>
                        <li>
                           <p> 
                              <code>$seq1 union $seq2</code>  evaluates to the sequence (A, B). 
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). 
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). 
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>$seq1 except $seq2</code>   evaluates to the empty sequence.
                           </p>
                        </li>
                        <li>
                           <p> 
                              <code>$seq2 except $seq3</code>  evaluates to the sequence containing A only.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>In addition to the sequence operators described here, <span>see <a href="https://www.w3.org/TR/xpath-functions-31/#sequence-functions">Section 
                           
                           14 Functions and operators on sequences
                           </a><sup><small>FO31</small></sup> for functions defined on sequences.</span>
                     
                     
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-arithmetic"></a>3.5 Arithmetic Expressions
               </h3>
               <p>XPath 3.1 provides arithmetic operators for addition, subtraction,
                  multiplication, division, and modulus, in their usual binary and unary
                  forms.
               </p>
               <a id="d2e13809"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-AdditiveExpr"></a>[21]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-AdditiveExpr">AdditiveExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-MultiplicativeExpr"></a>[22]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#doc-xpath31-UnionExpr">UnionExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-UnaryExpr"></a>[30]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-UnaryExpr">UnaryExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("-"  |  "+")* <a href="#doc-xpath31-ValueExpr">ValueExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ValueExpr"></a>[31]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ValueExpr">ValueExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-SimpleMapExpr">SimpleMapExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>A subtraction operator must be preceded by whitespace if
                  it could otherwise be interpreted as part of the previous token. For
                  example, <code>a-b</code> will be interpreted as a
                  name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a> for further details on whitespace handling.)
               </p>
               <p>
                  If an AdditiveExpr contains more than two MultiplicativeExprs,
                  they are grouped from left to right. So, for instance,
                  
               </p>
               <div class="exampleInner"><pre>A - B + C - D</pre></div>
               <p>
                  is equivalent to
                  
               </p>
               <div class="exampleInner"><pre>((A - B) + C) - D</pre></div>
               <p>
                  Similarly, the operands of a MultiplicativeExpr are grouped from left to right.
                  
               </p>
               <p>The first step in evaluating an arithmetic expression is to evaluate its operands.
                  The order in which the operands are evaluated is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
               </p>
               <p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, each operand is evaluated by applying the following steps, in order:
               </p>
               <ol class="enumar">
                  <li>
                     <p>
                        <a title="atomization" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this
                        operation is called the <b>atomized operand</b>.
                     </p>
                  </li>
                  <li>
                     <p>If the atomized operand is an empty sequence, the result of
                        the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation
                        need not evaluate the other operand or apply the operator. However,
                        an implementation may choose to evaluate the other operand in order
                        to determine whether it raises an error.
                     </p>
                  </li>
                  <li>
                     <p>If the atomized operand is a sequence of length greater than one, any items after
                        the first item in the sequence are discarded.
                     </p>
                  </li>
                  <li>
                     <p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>,
                        <code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it
                        is converted to the type <code>xs:double</code> by applying the <code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)
                     </p>
                  </li>
               </ol>
               <p>
                  <span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, each</span> operand is evaluated by applying the following steps, in order:
               </p>
               <ol class="enumar">
                  <li>
                     <p>
                        <a title="atomization" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this
                        operation is called the <b>atomized operand</b>.
                     </p>
                  </li>
                  <li>
                     <p>If the atomized operand is an empty sequence, the result of
                        the arithmetic expression is an empty sequence, and the implementation
                        need not evaluate the other operand or apply the operator. However,
                        an implementation may choose to evaluate the other operand in order
                        to determine whether it raises an error.
                     </p>
                  </li>
                  <li>
                     <p> If the atomized operand is a sequence of
                        length greater than one, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                     </p>
                  </li>
                  <li>
                     <p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
                        the cast fails, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
                           error</a> is raised. [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup>
                        
                     </p>
                  </li>
               </ol>
               <p>After evaluation of the operands, if the types of the operands are a valid combination
                  for the given arithmetic operator, the operator is applied to the operands,
                  resulting in an atomic value or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> (for example, an error
                  might result from dividing by zero.) The combinations of atomic types
                  that are accepted by the various arithmetic operators, and their
                  respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
                  together with the <a title="operator function" href="#dt-operator-function">operator functions</a>
                  that define the semantics of the operator for each
                  type combination, including the dynamic errors that can be raised by the operator.
                  The definitions of the operator functions are found in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
               </p>
               <p>If the types of the operands, after evaluation, are not a valid combination for the
                  given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
               </p>
               <p>XPath 3.1 supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any <a title="numeric" href="#dt-numeric">numeric</a> type. 
                  
                  <span>The semantics of <code>div</code> are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-numeric-integer-divide">Section 
                        
                        4.2.5 op:numeric-integer-divide
                        </a><sup><small>FO31</small></sup>.</span>
                  <span>The semantics of <code>idiv</code> are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-numeric-divide">Section 
                        
                        4.2.4 op:numeric-divide
                        </a><sup><small>FO31</small></sup>.</span>
                  
               </p>
               <p>Here are some examples of arithmetic expressions:</p>
               <ul>
                  <li>
                     <p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:
                     </p>
                     <div class="exampleInner"><pre>-3 div 2
-3 idiv 2</pre></div>
                  </li>
                  <li>
                     <p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:
                     </p>
                     <div class="exampleInner"><pre>$emp/hiredate - $emp/birthdate</pre></div>
                  </li>
                  <li>
                     <p>This example illustrates the difference between a subtraction operator and a
                        hyphen:
                     </p>
                     <div class="exampleInner"><pre>$unit-price - $unit-discount</pre></div>
                  </li>
                  <li>
                     <p>Unary operators have higher precedence than binary operators (other than "<code>!</code>", "<code>/</code>", and "<code>[]</code>"), subject of
                        course to the use of parentheses. Therefore, the following two examples have different
                        meanings:
                     </p>
                     <div class="exampleInner"><pre>-$bellcost + $whistlecost
-($bellcost + $whistlecost)</pre></div>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted.
                     
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-string-concat-expr"></a>3.6 String Concatenation Expressions
               </h3>
               <a id="d2e14122"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-StringConcatExpr"></a>[19]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-StringConcatExpr">StringConcatExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-RangeExpr">RangeExpr</a> ( "||"  <a href="#doc-xpath31-RangeExpr">RangeExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>String concatenation expressions allow the string representations of values to be
                  concatenated. In XPath 3.1, <code>$a || $b</code> is equivalent to <code>fn:concat($a, $b)</code>. The following expression evaluates to the string <code>concatenate</code>:
               </p>
               <div class="exampleInner"><pre>"con" || "cat" || "enate"</pre></div>
            </div>
            <div class="div2">
               
               <h3><a id="id-comparisons"></a>3.7 Comparison Expressions
               </h3>
               <p>Comparison expressions allow two values to be compared. XPath 3.1 provides
                  three kinds of comparison expressions, called value comparisons, general
                  comparisons, and node comparisons.
               </p>
               <a id="d2e14153"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ComparisonExpr"></a>[18]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ComparisonExpr">ComparisonExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-StringConcatExpr">StringConcatExpr</a> ( (<a href="#doc-xpath31-ValueComp">ValueComp</a>
                              <br>|  <a href="#doc-xpath31-GeneralComp">GeneralComp</a>
                              <br>|  <a href="#doc-xpath31-NodeComp">NodeComp</a>)  <a href="#doc-xpath31-StringConcatExpr">StringConcatExpr</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ValueComp"></a>[33]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ValueComp">ValueComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-GeneralComp"></a>[32]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-GeneralComp">GeneralComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-NodeComp"></a>[34]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-NodeComp">NodeComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p class="xpath">When an XPath expression is written
                     within an XML document, the XML escaping rules for special characters
                     must be followed; thus "<code>&lt;</code>" must be written as
                     "<code>&amp;lt;</code>".
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-value-comparisons"></a>3.7.1 Value Comparisons
                  </h4>
                  <p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.
                  </p>
                  <p>The first step in evaluating a value comparison is to evaluate its operands. The order
                     in which the operands are evaluated is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. Each operand is evaluated by applying the following steps, in order:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>
                           <a title="atomization" href="#dt-atomization">Atomization</a> is applied to <span>each</span>  operand. The result of this
                           operation is called the <b>atomized operand</b>.
                        </p>
                     </li>
                     <li>
                        <p>If <span>an</span> atomized operand is an empty sequence, the result of
                           the value comparison is an empty sequence, and the implementation
                           need not evaluate the other operand or apply the operator. However,
                           an implementation may choose to evaluate the other operand in order
                           to determine whether it raises an error.
                        </p>
                     </li>
                     <li>
                        <p> If <span>an</span> atomized operand is a sequence of
                           length greater than one, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                        </p>
                     </li>
                     <li>
                        <p>If <span>an</span>  atomized operand is of type
                           <code>xs:untypedAtomic</code>, it is cast to
                           <code>xs:string</code>.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The purpose of this rule is to
                              make value comparisons transitive. Users should be aware that the
                              general comparison operators have a different rule for casting of
                              <code>xs:untypedAtomic</code> operands. Users should also be aware
                              that transitivity of value comparisons may be compromised by loss of
                              precision during type conversion (for example, two
                              <code>xs:integer</code> values that differ slightly may both be
                              considered equal to the same <code>xs:float</code> value because
                              <code>xs:float</code> has less precision than
                              <code>xs:integer</code>).
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>If the two operands are instances of different primitive types (meaning the 19 primitive
                           types defined in <a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes">Section 
                              3.2 Primitive datatypes</a><sup><small>XS2</small></sup>), then:
                           
                        </p>
                        <ol class="enumla">
                           <li>
                              <p>If each operand is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then both operands are cast to type <code>xs:string</code>.
                              </p>
                           </li>
                           <li>
                              <p>If each operand is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then both operands are cast to type <code>xs:float</code>.
                              </p>
                           </li>
                           <li>
                              <p>If each operand is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then both operands are cast to type <code>xs:double</code>.
                              </p>
                           </li>
                           <li>
                              <p>Otherwise, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                              </p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </li>
                     <li>
                        <p>Finally, if the types of the operands are a valid
                           combination for the given operator, the operator is applied to the
                           operands.
                        </p>
                     </li>
                  </ol>
                  <p>The combinations of atomic types that are accepted by the various
                     value comparison operators, and their respective result types, are
                     listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a> together with the <a title="operator function" href="#dt-operator-function">operator functions</a> that define
                     the semantics of the operator for each type combination. The
                     definitions of the operator functions are found in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                  </p>
                  <p>Informally, if both atomized operands consist of exactly one atomic
                     value, then the result of the comparison is <code>true</code> if the value of the
                     first operand is (equal, not equal, less than, less than or equal,
                     greater than, greater than or equal) to the value of the second
                     operand; otherwise the result of the comparison is <code>false</code>.
                  </p>
                  <p>If the types of the operands, after evaluation, are not a valid
                     combination for the given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" href="#dt-type-error">type error</a>
                     is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                  </p>
                  <p>Here are some examples of value comparisons:</p>
                  <ul>
                     <li>
                        <p>The following comparison atomizes the node(s) that are returned by the expression
                           <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy"
                           as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison
                           is an empty sequence. If the result of atomization is a sequence containing more than
                           one value, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                        </p>
                        <div class="exampleInner"><pre>$book1/author eq "Kennedy"</pre></div>
                     </li>
                     <li>
                        <p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:
                        </p>
                        <div class="exampleInner"><pre>[ "Kennedy" ] eq "Kennedy"</pre></div>
                     </li>
                     <li>
                        <p>The following <a title="path expression" href="#dt-path-expression">path expression</a> contains a predicate that selects products whose weight is greater than 100. For
                           any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is
                           not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.
                        </p>
                        <div class="exampleInner"><pre>//product[weight gt 100]</pre></div>
                     </li>
                     <li>
                        <p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <a title="numeric" href="#dt-numeric">numeric</a> type:
                        </p>
                        <div class="exampleInner"><pre>my:hatsize(5) eq my:shoesize(5)</pre></div>
                     </li>
                     <li>
                        <p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace
                           URIs and their local names, ignoring their namespace prefixes.
                        </p>
                        <div class="exampleInner"><pre>fn:QName("http://example.com/ns1", "this:color") eq fn:QName("http://example.com/ns1", "that:color")</pre></div>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-general-comparisons"></a>3.7.2 General Comparisons
                  </h4>
                  <p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied
                     to operand sequences of any length. The result of a general comparison that does not
                     raise an error is
                     always <code>true</code> or <code>false</code>.
                  </p>
                  <p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, a general comparison is evaluated by applying the following rules, in order:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>If either operand is a single atomic value that is an instance of
                           <code>xs:boolean</code>, then the other operand is converted to <code>xs:boolean</code> by taking its
                           <a title="effective boolean value" href="#dt-ebv">effective boolean value</a>.
                        </p>
                     </li>
                     <li>
                        <p>
                           <a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand. After atomization, each operand is a sequence of atomic
                           values.
                        </p>
                     </li>
                     <li>
                        <p>If the comparison operator is <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then each item in both of the
                           operand sequences is converted to the type  <code>xs:double</code> by applying the
                           <code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)
                        </p>
                     </li>
                     <li>
                        <p>The result of the comparison is <code>true</code> if and only if there is a pair of
                           atomic values, one in the first operand sequence and the other in the second operand
                           sequence, that have the required
                           <b>magnitude relationship</b>. Otherwise the result of the  comparison is
                           <code>false</code> 
                           <span>or an error</span>. The <b>magnitude relationship</b> between two atomic values is determined by
                           applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>  is raised. [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup>
                           
                        </p>
                        <ol class="enumla">
                           <li>
                              <p>If at least one of the two atomic values is an instance of a <a title="numeric" href="#dt-numeric">numeric</a> type, then both atomic values are converted to the type <code>xs:double</code> by
                                 applying the <code>fn:number</code> function.
                              </p>
                           </li>
                           <li>
                              <p>If at least one of the two atomic values is an instance of <code>xs:string</code>,
                                 or if both atomic values are instances of <code>xs:untypedAtomic</code>, then both
                                 atomic values are cast to the type <code>xs:string</code>.
                              </p>
                           </li>
                           <li>
                              <p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xs:untypedAtomic</code>, or any <a title="numeric" href="#dt-numeric">numeric</a> type, then the <code>xs:untypedAtomic</code> value is
                                 cast to the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of the other value.
                              </p>
                           </li>
                           <li>
                              <p>After performing the conversions described above, the atomic values are
                                 compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
                                 <code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
                                 <code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if and only if the result
                                 of this value comparison is <code>true</code>.
                              </p>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  <p>
                     <span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, a</span> general comparison is evaluated by applying the following rules, in order:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>
                           <a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand. After atomization, each operand is a sequence of atomic
                           values.
                        </p>
                     </li>
                     <li>
                        <p>The result of the comparison is <code>true</code> if and only if there is a pair of
                           atomic values, one in the first operand sequence and the other in the second operand
                           sequence, that have the required
                           <b>magnitude relationship</b>. Otherwise the result of the  comparison is
                           <code>false</code> 
                           <span>or an error</span>. The <b>magnitude relationship</b> between two atomic values is determined by
                           applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>  is raised. [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup>
                           
                        </p>
                        <ol class="enumla">
                           <li>
                              <p>If both atomic values are instances of <code>xs:untypedAtomic</code>,
                                 then the values are cast to the type <code>xs:string</code>.
                                 
                              </p>
                           </li>
                           <li>
                              <p>If exactly one of the atomic values is an instance of
                                 <code>xs:untypedAtomic</code>, it is cast to a type depending on
                                 the other value's dynamic type T according to the following rules,
                                 in which V denotes the value to be cast:
                                 
                              </p>
                              <ol class="enumlr">
                                 <li>
                                    <p>If T is a numeric type or is derived from a numeric type,
                                       then V is cast to <code>xs:double</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If T is <code>xs:dayTimeDuration</code> or is derived from
                                       <code>xs:dayTimeDuration</code>,
                                       then V is cast to <code>xs:dayTimeDuration</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If T is <code>xs:yearMonthDuration</code> or is derived from
                                       <code>xs:yearMonthDuration</code>,
                                       then V is cast to <code>xs:yearMonthDuration</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>In all other cases, V is cast to the primitive base type of T.</p>
                                 </li>
                              </ol>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>
                                    The special treatment of the duration types is required to avoid
                                    errors that may arise when comparing the primitive type
                                    <code>xs:duration</code> with any duration type.
                                    
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>After performing the conversions described above, the atomic values are
                                 compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
                                 <code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
                                 <code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if and only if the result
                                 of this value comparison is <code>true</code>.
                              </p>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  <p>When evaluating a general comparison in which either operand is a sequence of items,
                     an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand
                     that have the required <b>magnitude relationship</b>. Similarly, a general comparison may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it encounters an error in evaluating either operand, or in comparing a
                     pair of items from the two operands. As a result of these rules, the result of a general
                     comparison is not deterministic in the presence of errors.
                  </p>
                  <p>Here are some examples of  general comparisons:</p>
                  <ul>
                     <li>
                        <p>The following comparison is true if the <a title="typed value" href="#dt-typed-value">typed value</a> of any
                           <code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:
                        </p>
                        <div class="exampleInner"><pre>$book1/author = "Kennedy"</pre></div>
                     </li>
                     <li>
                        <p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:
                        </p>
                        <div class="exampleInner"><pre>[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"</pre></div>
                     </li>
                     <li>
                        <p>The following example contains three general comparisons. The value of the first two
                           comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.
                        </p>
                        <div class="exampleInner"><pre>(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</pre></div>
                     </li>
                     <li>
                        <p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.
                        </p>
                        <div class="exampleInner"><pre>(1, 2) = (2, 3)
(1, 2) != (2, 3)</pre></div>
                     </li>
                     <li>
                        <p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <a title="string value" href="#dt-string-value">string values</a> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-node-comparisons"></a>3.7.3 Node Comparisons
                  </h4>
                  <p>Node comparisons are used to compare two nodes, by their identity or by their <a title="document order" href="#dt-document-order">document order</a>. The result of a node comparison is defined by the following rules:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>The operands of a node comparison are evaluated in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.
                        </p>
                     </li>
                     <li>
                        <p>If either operand is an empty sequence, the result of the
                           comparison is an empty sequence, and the implementation need not
                           evaluate the other operand or apply the operator. However, an
                           implementation may choose to evaluate the other operand in order to
                           determine whether it raises an error.
                        </p>
                     </li>
                     <li>
                        <p> Each operand must be either a single node or an empty sequence; otherwise
                           a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                        </p>
                     </li>
                     <li>
                        <p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes 
                           <span>are</span> the same node; otherwise it
                           is <code>false</code>. See <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> for  <span>the</span> definition of node identity.
                        </p>
                     </li>
                     <li>
                        <p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
                           <a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.
                        </p>
                     </li>
                     <li>
                        <p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
                           <a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.
                        </p>
                     </li>
                  </ol>
                  <p>Here are some examples of node comparisons:</p>
                  <ul>
                     <li>
                        <p>The following comparison is true only if the left and right sides each
                           evaluate to exactly the same single node:
                        </p>
                        <div class="exampleInner"><pre>/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</pre></div>
                     </li>
                     <li>
                        <p>The following comparison is true only if the node identified by the left
                           side occurs before the node identified by the right side in document order:
                        </p>
                        <div class="exampleInner"><pre>/transactions/purchase[parcel="28-451"] &lt;&lt; /transactions/sale[parcel="33-870"]</pre></div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-logical-expressions"></a>3.8 Logical Expressions
               </h3>
               <p>A <b>logical expression</b> is either an <b>and-expression</b> or
                  an <b>or-expression</b>. If a logical expression does not raise an error, its value is always one
                  of the boolean values <code>true</code> or <code>false</code>.
               </p>
               <a id="d2e15080"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-OrExpr"></a>[16]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-OrExpr">OrExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-AndExpr">AndExpr</a> ( "or"  <a href="#doc-xpath31-AndExpr">AndExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-AndExpr"></a>[17]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-AndExpr">AndExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#doc-xpath31-ComparisonExpr">ComparisonExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>The first step in evaluating a logical expression is to find the  <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of each of its operands (see <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>).
               </p>
               <p>The value of an and-expression is determined by the effective
                  boolean values (EBV's) of its operands, as shown in the following table:
               </p>
               <table style="width:80%" class="medium">
                  <tbody>
                     <tr>
                        <th>AND:</th>
                        <th>EBV<sub>2</sub> =
                           <code>true</code>
                           
                        </th>
                        <th>EBV<sub>2</sub> = <code>false</code>
                           
                        </th>
                        <th>error in EBV<sub>2</sub>
                           
                        </th>
                     </tr>
                     <tr>
                        <th>EBV<sub>1</sub> =
                           <code>true</code>
                           
                        </th>
                        <td>
                           <code>true</code>
                           
                        </td>
                        <td>
                           <code>false</code>
                           
                        </td>
                        <td>error</td>
                     </tr>
                     <tr>
                        <th>EBV<sub>1</sub>
                           = <code>false</code>
                           
                        </th>
                        <td>
                           <code>false</code>
                           
                        </td>
                        <td>
                           <code>false</code>
                           
                        </td>
                        <td>
                           <span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then <code>false</code>; otherwise either <code>false</code> or error.</span>
                           
                        </td>
                     </tr>
                     <tr>
                        <th>error in EBV<sub>1</sub>
                           
                        </th>
                        <td>error</td>
                        <td>
                           <span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then error; otherwise either <code>false</code> or error.</span>
                           
                        </td>
                        <td>error</td>
                     </tr>
                  </tbody>
               </table>
               <p>The value of an
                  or-expression is determined by the effective boolean values (EBV's) of
                  its operands, as shown in
                  the following table:
               </p>
               <table style="width:80%" class="medium">
                  <tbody>
                     <tr>
                        <th>OR:</th>
                        <th>EBV<sub>2</sub> =
                           <code>true</code>
                           
                        </th>
                        <th>EBV<sub>2</sub> = <code>false</code>
                           
                        </th>
                        <th>error in
                           EBV<sub>2</sub>
                           
                        </th>
                     </tr>
                     <tr>
                        <th>EBV<sub>1</sub> =
                           <code>true</code>
                           
                        </th>
                        <td>
                           <code>true</code>
                           
                        </td>
                        <td>
                           <code>true</code>
                           
                        </td>
                        <td>
                           <span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then <code>true</code>; otherwise either <code>true</code> or error.</span>
                           
                        </td>
                     </tr>
                     <tr>
                        <th>EBV<sub>1</sub> =
                           <code>false</code>
                           
                        </th>
                        <td>
                           <code>true</code>
                           
                        </td>
                        <td>
                           <code>false</code>
                           
                        </td>
                        <td>error</td>
                     </tr>
                     <tr>
                        <th>error
                           in EBV<sub>1</sub>
                           
                        </th>
                        <td>
                           <span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then error; otherwise either <code>true</code> or error.</span>
                           
                        </td>
                        <td>error</td>
                        <td>error</td>
                     </tr>
                  </tbody>
               </table>
               <p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, the order in which the operands of a logical expression are evaluated is effectively
                  prescribed. Specifically, it is defined that when there is no
                  need to evaluate the second operand in order to determine the result, then
                  no error can occur as a result of evaluating the second operand.
               </p>
               <p>
                  <span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, the
                     order in which the operands of a logical expression are evaluated is
                     <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. In this case,</span> an or-expression can return <code>true</code> if the first
                  expression evaluated is true, and it can raise an error if evaluation
                  of the first expression raises an error. Similarly, an and-expression
                  can return <code>false</code> if the first expression evaluated is
                  false, and it can raise an error if evaluation of the first expression
                  raises an error. As a result of these rules, a logical expression is
                  not deterministic in the presence of errors, as illustrated in the examples
                  below.
               </p>
               <p>Here are some examples of logical expressions:</p>
               <ul>
                  <li>
                     <p>The following expressions return
                        <code>true</code>:
                     </p>
                     <div class="exampleInner"><pre>1 eq 1 and 2 eq 2</pre></div>
                     <div class="exampleInner"><pre>1 eq 1 or 2 eq 3</pre></div>
                  </li>
                  <li>
                     <p>The following
                        expression may return either <code>false</code> or raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
                        <span class="xpath"> (in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>, the result must be <code>false</code>)</span>:
                     </p>
                     <div class="exampleInner"><pre>1 eq 2 and 3 idiv 0 = 1</pre></div>
                  </li>
                  <li>
                     <p>The
                        following expression may return either <code>true</code> or raise a
                        <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
                        <span class="xpath"> (in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>, the result must be <code>true</code>)</span>:
                     </p>
                     <div class="exampleInner"><pre>1 eq 1 or 3 idiv 0 = 1</pre></div>
                  </li>
                  <li>
                     <p>The
                        following expression must raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:
                     </p>
                     <div class="exampleInner"><pre>1 eq 1 and 3 idiv 0 = 1</pre></div>
                  </li>
               </ul>
               <p>In addition to and- and or-expressions, XPath 3.1 provides a
                  function named <code>fn:not</code> that takes a general sequence as
                  parameter and returns a boolean value.  The <code>fn:not</code> function
                  is defined in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>. The
                  <code>fn:not</code> function reduces its parameter to an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a>. It then returns
                  <code>true</code> if the effective boolean value of its parameter is
                  <code>false</code>, and <code>false</code> if the effective boolean
                  value of its parameter is <code>true</code>. If an error is
                  encountered in finding the effective boolean value of its operand,
                  <code>fn:not</code> raises the same error.
               </p>
            </div>
            <div class="div2">
               
               <h3><a id="id-for-expressions"></a>3.9 For Expressions
               </h3>
               <p>XPath provides an iteration facility called a <b>for expression</b>.
               </p>
               <a id="d2e15459"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ForExpr"></a>[8]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ForExpr">ForExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-SimpleForClause">SimpleForClause</a>  "return"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-SimpleForClause"></a>[9]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-SimpleForClause">SimpleForClause</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"for"  <a href="#doc-xpath31-SimpleForBinding">SimpleForBinding</a>  (","  <a href="#doc-xpath31-SimpleForBinding">SimpleForBinding</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-SimpleForBinding"></a>[10]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-SimpleForBinding">SimpleForBinding</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#doc-xpath31-VarName">VarName</a>  "in"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>A <code>for</code> expression is evaluated as follows:
               </p>
               <ol class="enumar">
                  <li>
                     <p>If the <code>for</code> expression uses multiple variables, it is first expanded to a set of nested <code>for</code> expressions, each of which uses only one variable. For example, the expression
                        <code>for $x in X, $y in Y return $x + $y</code>
                        is expanded to
                        <code>for $x in X return
                           for $y in Y return $x + $y</code>.
                     </p>
                  </li>
                  <li>
                     <p>In a single-variable <code>for</code> expression, the variable is called the <b>range variable</b>, the value of the expression that follows the <code>in</code> keyword is called the <b>binding sequence</b>, and the expression that follows the <code>return</code> keyword is called the <b>return expression</b>. The result of the <code>for</code> expression is obtained by evaluating the <code>return</code> expression once for each item in the binding sequence, with the range variable bound
                        to that item. The resulting sequences  are concatenated (as if by the <a title="comma operator" href="#dt-comma-operator">comma operator</a>) in the order of the items in the binding sequence from which they were derived.
                        
                     </p>
                  </li>
               </ol>
               <p class="xpath">The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following
                  input:
               </p>
               <div class="exampleInner"><pre>&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</pre></div>
               <p>The following example transforms the input document into a list in
                  which each author's name appears only once, followed by a list of
                  titles of books written by that author. This example assumes that the
                  context item is the <code>bib</code> element in the input
                  document.
               </p>
               <div class="exampleInner"><pre><span class="parse-test">for $a in fn:distinct-values(book/author)
return ((book/author[. = $a])[1], book[author = $a]/title)</span></pre></div>
               <p>The result of the above expression consists of the following
                  sequence of elements. The titles of books written by a given author
                  are listed after the name of the author.
                  
                  The ordering of <code>author</code> elements in the result is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> due to the semantics of the <code>fn:distinct-values</code> function.
               </p>
               <div class="exampleInner"><pre>&lt;author&gt;Stevens&lt;/author&gt;
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</pre></div>
               <p>The following example illustrates a <code>for</code> expression containing more than one variable:
               </p>
               <div class="exampleInner"><pre><span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></pre></div>
               <p>The result of the above expression, expressed as a sequence of numbers, is as follows:
                  <code>11, 12, 21, 22</code>
                  
               </p>
               <p>The scope of a variable bound in a <code>for</code> expression comprises all subexpressions of the <code>for</code> expression
                  that appear after the variable binding. The scope does not
                  include the expression to which the variable is bound. The following example illustrates
                  how a variable binding may reference another variable bound earlier in the same  <code>for</code> expression:
               </p>
               <div class="exampleInner"><pre><span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></pre></div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression
                     is the same as the focus for evaluation of the <code>for</code> expression itself. The
                     following example, which attempts to find the total value of a set of
                     order-items, is therefore incorrect:
                     
                     
                  </p>
                  <div class="exampleInner"><pre>fn:sum(for $i in order-item return @price * @qty)</pre></div>
                  <p>
                     
                     Instead, the expression must be written to use the variable bound in the <code>for</code> clause:
                  </p>
                  <div class="exampleInner"><pre>fn:sum(for $i in order-item return $i/@price * $i/@qty)</pre></div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-let-expressions"></a>3.10 Let Expressions
               </h3>
               <p>XPath allows a variable to be declared and bound to a value using a <b>let expression</b>.
               </p>
               <a id="d2e15631"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-LetExpr"></a>[11]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-LetExpr">LetExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-SimpleLetClause">SimpleLetClause</a>  "return"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-SimpleLetClause"></a>[12]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-SimpleLetClause">SimpleLetClause</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"let"  <a href="#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a>  (","  <a href="#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-SimpleLetBinding"></a>[13]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#doc-xpath31-VarName">VarName</a>  ":="  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>A let expression is evaluated as follows:</p>
               <ul>
                  <li>
                     <p>If the let expression uses multiple variables, it is first expanded to a
                        set of nested let expressions, each of which uses only one variable. For
                        example, the expression <code>let $x := 4, $y := 3 return $x + $y</code> is expanded to
                        <code>let $x := 4 return let $y := 3 return $x + $y</code>.
                     </p>
                  </li>
                  <li>
                     <p>In a single-variable let expression, the variable is called the range
                        variable, the value of the expression that follows the <code>:=</code> symbol is called
                        the binding sequence, and the expression that follows the return keyword is
                        called the return expression. The result of the let expression is obtained
                        by evaluating the return expression with the range variable bound to the
                        binding sequence. 
                     </p>
                  </li>
               </ul>
               <p>The scope of a variable bound in a let expression comprises all
                  subexpressions of the let expression that appear after the variable binding.
                  The scope does not include the expression to which the variable is bound.
                  The following example illustrates how a variable binding may reference
                  another variable bound earlier in the same let expression:
               </p>
               <div class="exampleInner"><pre>
let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]
</pre></div>
            </div>
            <div class="div2">
               
               <h3><a id="id-maps-and-arrays"></a>3.11 Maps and Arrays
               </h3>
               <p>Most modern programming languages have support for collections of
                  key/value pairs, which may be called maps, dictionaries, associative
                  arrays, hash tables, keyed lists, or objects (these are not the same
                  thing as objects in object-oriented systems). In XPath 3.1, we call
                  these maps. Most modern programming languages also support ordered
                  lists of values, which may be called arrays, vectors, or sequences.
                  <span>In XPath 3.1, we have both
                     sequences and arrays. Unlike sequences, an array is an
                     item, and can appear as an item in a sequence.</span>
                  
               </p>
               <p>In previous versions of the language, element structures and
                  sequences were the only complex data structures.  We are adding maps
                  and arrays to XPath 3.1 in order to provide lightweight data
                  structures that are easier to optimize and less complex to use for
                  intermediate processing and to allow programs to easily combine XML
                  processing with JSON processing.
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The XPath 3.1 specification focuses on syntax provided for maps
                     and arrays, especially constructors and lookup.
                  </p>
                  <p>Some of the functionality typically needed for maps and
                     arrays is provided by functions defined in <a href="https://www.w3.org/TR/xpath-functions-31/#maps-and-arrays">Section 
                        
                        17 Maps and Arrays
                        </a><sup><small>FO31</small></sup>, including functions used to
                     read JSON to create maps and arrays, serialize maps and arrays to
                     JSON, combine maps to create a new map, remove map entries to create
                     a new map, iterate over the keys of a map, convert an array to
                     create a sequence, combine arrays to form a new array, and iterate
                     over arrays in various ways.
                  </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-maps"></a>3.11.1 Maps
                  </h4>
                  <p>
                     [<a id="dt-map" title="map">Definition</a>: A <b>map</b> is a <span>function
                        that associates a set of keys with values, resulting in a</span> collection
                     of key / value pairs.]
                     
                     [<a id="dt-entry" title="entry">Definition</a>: Each key / value pair in a map
                     is called an <b>entry</b>.]
                     
                     [<a id="dt-associated-value" title="associated value">Definition</a>: The value
                     associated with a given key is called the <b>associated
                        value</b> of the key.]
                     
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-map-constructors"></a>3.11.1.1 Map Constructors
                     </h5>
                     <p>A Map is created using a <a href="#doc-xpath31-MapConstructor">MapConstructor</a>.
                     </p>
                     <a id="d2e15739"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-MapConstructor"></a>[69]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-MapConstructor">MapConstructor</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"map"  "{"  (<a href="#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a>  (","  <a href="#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a>)*)?  "}"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-MapConstructorEntry"></a>[70]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a>  ":"  <a href="#doc-xpath31-MapValueExpr">MapValueExpr</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-MapKeyExpr"></a>[71]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-MapKeyExpr">MapKeyExpr</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-MapValueExpr"></a>[72]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-MapValueExpr">MapValueExpr</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>
                           In some circumstances, it is necessary to include whitespace before or after the colon
                           of a <a href="#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a> to ensure that it is parsed as intended.
                           
                        </p>
                        <p>
                           For instance, consider the expression <code>map{a:b}</code>.
                           Although it matches the EBNF for MapConstructor
                           (with <code>a</code> matching MapKeyExpr and <code>b</code> matching MapValueExpr),
                           the "longest possible match" rule requires that <code>a:b</code> be parsed as a QName,
                           which results in a syntax error.
                           Changing the expression to <code>map{a :b}</code> or <code>map{a: b}</code>
                           will prevent this, resulting in the intended parse.
                           
                        </p>
                        <p>Similarly, consider these three expressions:</p>
                        <div class="exampleInner"><pre>
    map{a:b:c}
    map{a:*:c}
    map{*:b:c}</pre></div>
                        <p>
                           In each case, the expression matches the EBNF in two different ways,
                           but the "longest possible match" rule forces the parse in which
                           the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively)
                           and the MapValueExpr is <code>c</code>.
                           To achieve the alternative parse
                           (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>),
                           insert whitespace before and/or after the first colon.
                           
                        </p>
                        <p>See <a href="#lexical-structure"><b>A.2 Lexical structure</b></a>.
                        </p>
                     </div>
                     <p>The value of the expression is a map whose entries
                        correspond to the key-value pairs obtained by
                        evaluating the successive <a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a> and
                        <a href="#doc-xpath31-MapValueExpr">MapValueExpr</a> expressions.
                     </p>
                     <p>Each <a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a> expression is evaluated
                        and atomized; a 
                        
                        
                        <span>
                           <a title="type error" href="#dt-type-error">type error</a>   
                           [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] occurs if the result is
                           not a single atomic value.</span>
                        
                        The associated value is the
                        result of evaluating the corresponding
                        <a href="#doc-xpath31-MapValueExpr">MapValueExpr</a>.
                        
                        <span>If the <a href="#doc-xpath31-MapValueExpr">MapValueExpr</a> evaluates to a node, the
                           associated value is the node itself, not a new node with the same
                           values.</span>
                        
                        
                     </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XPath 3.1 has no operators
                           that can distinguish a map or array from another map or array with
                           the same values.  Future versions of the XQuery Update Facility,
                           on the other hand, will expose this difference, and need to be
                           clear about the data model instance that is constructed.
                        </p>
                        <p>In some existing implementations that support updates via
                           proprietary extensions, if the <a href="#doc-xpath31-MapValueExpr">MapValueExpr</a> evaluates to a map or array,
                           the associated value is a new map or array with the same
                           values.
                        </p>
                     </div>
                     <p>
                        
                        
                        
                        
                        [<a id="dt-same-key" title="same key">Definition</a>: Two atomic values <code>K1</code> and
                        <code>K2</code> have the <b>same key value</b> if
                        
                        <span>
                           <code>op:same-key(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://www.w3.org/TR/xpath-functions-31/#func-same-key">Section 
                              
                              17.1.1 op:same-key
                              </a><sup><small>FO31</small></sup> 
                           </span>
                        ]
                        
                        If two or more entries have the <a title="same key" href="#dt-same-key">same key value</a> then a dynamic
                        error is raised [<a href="#ERRXQDY0137" title="err:XQDY0137">err:XQDY0137</a>].
                        
                        
                        
                     </p>
                     <p>Example:</p>
                     <p>The following expression constructs a map with seven entries:</p>
                     <div class="exampleInner"><a id="map-weekdays"></a><pre>
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</pre></div>
                     <p>Maps can nest, and can contain any XDM value. Here is an example of a nested map with
                        values that can be string values, numeric values, or arrays:
                     </p>
                     <div class="exampleInner"><a id="map-book"></a><pre>
map {
    "book": map {
        "title": "Data on the Web",
        "year": 2000,
        "author": [
            map {
                "last": "Abiteboul",
                "first": "Serge"
            },
            map {
                "last": "Buneman",
                "first": "Peter"
            },
            map {
                "last": "Suciu",
                "first": "Dan"
            }
        ],
        "publisher": "Morgan Kaufmann Publishers",
        "price": 39.95
    }
}
    </pre></div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-map-lookup"></a>3.11.1.2 Map Lookup using Function Call Syntax
                     </h5>
                     <p>Maps are functions, and function calls can be used to look up
                        the value associated with a key in a map.
                        
                        <span>
                           If <code>$map</code> is a map and <code>$key</code> is a key,
                           then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>.
                           The semantics of such a function call are formally defined in
                           <a href="https://www.w3.org/TR/xpath-functions-31/#func-map-get">Section 
                              
                              17.1.6 map:get
                              </a><sup><small>FO31</small></sup>.
                           </span>
                        
                        
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>$weekdays("Su")</code> returns the <a title="associated value" href="#dt-associated-value">associated value</a> of the key <code>Su</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>$books("Green Eggs and Ham")</code> returns  <a title="associated value" href="#dt-associated-value">associated value</a>  of the key <code>Green Eggs and Ham</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XPath 3.1 also provides an alternate syntax for map and
                           array lookup that is more terse, supports wildcards, and allows lookup to
                           iterate over a sequence of maps or arrays. See <a href="#id-lookup"><b>3.11.3 The Lookup Operator ("?") for Maps and Arrays</b></a> for details.
                        </p>
                     </div>
                     <p>Map lookups can be chained.</p>
                     <p>Examples: (These examples assume that <code>$b</code> is bound to the books map from the previous section)
                     </p>
                     <ul>
                        <li>
                           <p>The expression <code>$b("book")("title")</code> returns the string <code>Data on the Web</code>.
                           </p>
                        </li>
                        <li>
                           <p>The expression <code>$b("book")("author")</code> returns the array of authors.
                           </p>
                        </li>
                        <li>
                           <p>The expression <code>$b("book")("author")(1)("last")</code> returns the string <code>Abiteboul</code>.
                           </p>
                           <p>(This example combines <a href="#id-array-lookup"><b>3.11.2.2 Array Lookup using Function Call Syntax</b></a> with map lookups.)
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-arrays"></a>3.11.2 Arrays
                  </h4>
                  <div class="div4">
                     
                     <h5><a id="id-array-constructors"></a>3.11.2.1 Array Constructors
                     </h5>
                     <p>
                        [<a id="dt-array" title="array">Definition</a>: An <b>array</b> is
                        a <span>function</span> that associates a set of positions, represented as
                        positive integer keys, with values.] 
                        <span>The first position
                           in an array is associated with the integer 1.</span>
                        [<a id="dt-member" title="member">Definition</a>: The values of an array are called
                        its <b>members</b>.]
                        
                        In the type hierarchy, array has a distinct type, which is
                        derived from function.
                        <span>Atomization converts arrays to sequences (see <a title="atomization" href="#dt-atomization">Atomization</a>).</span>  
                        
                     </p>
                     <p>An array is created using an <a href="#doc-xpath31-ArrayConstructor">ArrayConstructor</a>.
                     </p>
                     <a id="d2e16392"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-ArrayConstructor"></a>[73]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-ArrayConstructor">ArrayConstructor</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a>  |  <a href="#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-SquareArrayConstructor"></a>[74]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-SquareArrayConstructor">SquareArrayConstructor</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"["  (<a href="#doc-xpath31-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*)?  "]"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-CurlyArrayConstructor"></a>[75]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"array"  <a href="#doc-xpath31-EnclosedExpr">EnclosedExpr</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        <span>If a member of an array is a
                           node, its node identity is preserved.</span>
                        
                        
                        
                        <span>In both forms of an <a href="#doc-xpath31-ArrayConstructor">ArrayConstructor</a>, if a member
                           expression evaluates to a node, the associated value is the
                           node itself, not a new node with the same values.  If the
                           member expression evaluates to a map or array, the associated
                           value is a new map or array with the same values.</span>
                        
                        
                        
                     </p>
                     <p>A <a href="#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a> 
                        consists of a comma-delimited set of argument expressions. It returns an array in
                        which each member contains the value of the corresponding argument expression.
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>[ 1, 2, 5, 7 ]</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ (), (27, 17, 0)]</code> creates an array with two members: <code>()</code> and the sequence <code>(27, 17, 0)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; ]</code> creates an array with three members: the value of $x, the result of evaluating the
                              function call, and a tautology element.
                           </p>
                        </li>
                     </ul>
                     <p>A <a href="#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a>
                        can use any  expression to create its members.  It
                        evaluates its operand expression to obtain a sequence of items
                        and creates an array with these items as members.  Unlike a
                        SquareArrayConstructor, a comma in a CurlyArrayConstructor is
                        the  
                        <a title="comma operator" href="#dt-comma-operator">comma operator</a>, not a delimiter.
                        
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>array { $x }</code> creates an array with one member for each item <span>in the sequence</span> to which $x is bound.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { local:items() }</code> creates an array with one member for each item  <span>in the sequence</span> to which <code>local:items()</code> evaluates.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { 1, 2, 5, 7 }</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { (), (27, 17, 0) }</code> creates an array with three members: <code>27</code>, <code>17</code>, and <code>0</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array{ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; }</code> creates an array with the following members: the items to which <code>$x</code> is bound, followed by the items to which <code>local:items()</code> evaluates, followed by a tautology element.
                           </p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XPath 3.1 does not provide explicit support for sparse arrays. Use integer-valued
                           maps to represent sparse arrays, e.g. <code>map { 27 : -1, 153 : 17 } </code>.
                        </p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-array-lookup"></a>3.11.2.2 Array Lookup using Function Call Syntax
                     </h5>
                     <p>Arrays are functions, and function calls can be used to look up
                        the value associated with <span>position</span> in an array.
                        
                        
                        
                        <span>
                           If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array,
                           then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>.
                           The semantics of such a function call are formally defined in
                           <a href="https://www.w3.org/TR/xpath-functions-31/#func-array-get">Section 
                              
                              17.3.2 array:get
                              </a><sup><small>FO31</small></sup>.
                           </span>
                        
                        
                     </p>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ [1, 2, 3], [4, 5, 6]](2)</code> evaluates to <code>[4, 5, 6]</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ [1, 2, 3], [4, 5, 6]](2)(2)</code> evaluates to <code>5</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</code> evaluates to <code>&lt;name&gt;Robert Johnson&lt;/name&gt;</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { (), (27, 17, 0) }(1)</code> evaluates to  
                              <code>27</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { (), (27, 17, 0) }(2)</code> evaluates to  
                              <code>17</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>array { "licorice", "ginger" }(20)</code> raises a dynamic error [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO31</small></sup>.
                           </p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XPath 3.1 also provides an alternate syntax for map and
                           array lookup that is more terse, supports wildcards, and allows
                           lookup to iterate over a sequence of maps or arrays. See
                           <a href="#id-lookup"><b>3.11.3 The Lookup Operator ("?") for Maps and Arrays</b></a> for details.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-lookup"></a>3.11.3 The Lookup Operator ("?") for Maps and Arrays
                  </h4>
                  <p>XPath 3.1 provides a lookup operator for maps and arrays that is
                     more convenient for some common cases. It provides a terse syntax
                     for simple strings as keys in maps or integers as keys in arrays,
                     supports wildcards, and iterates over sequences of maps and
                     arrays.
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-unary-lookup"></a>3.11.3.1 Unary Lookup
                     </h5>
                     <a id="d2e16875"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-UnaryLookup"></a>[76]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-UnaryLookup">UnaryLookup</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"?"  <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-KeySpecifier"></a>[54]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-KeySpecifier">KeySpecifier</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>
                                    <a href="#prod-xpath31-NCName">NCName</a>  |  <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>  |  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>  |  "*"</code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>Unary lookup is used in predicates (e.g. <code>$map[?name='Mike']</code> or with the <span>simple map operator</span> (e.g. <code>$maps ! ?name='Mike'</code>). See <a href="#id-postfix-lookup"><b>3.11.3.2 Postfix Lookup</b></a> for the postfix lookup operator.
                     </p>
                     <p>UnaryLookup returns a sequence of values selected from the
                        context item, which must be a map or array. If the context item is
                        not a map or an array, <span>a
                           <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                           </span>
                        
                     </p>
                     <p>If the context item is a map:</p>
                     <ol class="enumar">
                        <li>
                           <p>If the  <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a>  is an <code>NCName</code>, the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <code>NCName</code>.
                           </p>
                        </li>
                        <li>
                           <p>If the   <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a>  is an <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>,  the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>.
                           </p>
                        </li>
                        <li>
                           <p>If the <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a> is a  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>,  the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to the following expression,  where <code>KS</code> is the value of the  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>:
                           </p>
                           <div class="exampleInner"><pre>
for $k in fn:data(KS)
return .($k)  
</pre></div>
                        </li>
                        <li>
                           <p>If the <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a> is a wildcard ("<code>*</code>"), the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to the following expression:
                           </p>
                           <div class="exampleInner"><pre>
for $k in map:keys(.)
return .($k)
</pre></div>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The order of keys in map:keys() is implementation-dependent, so
                                 the order of values in the result sequence is also
                                 implementation-dependent.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <p>If the context item is an array:</p>
                     <ol class="enumar">
                        <li>
                           <p>If the  <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a>  is an <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>,  the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>.
                           </p>
                        </li>
                        <li>
                           <p>If the <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a> is an <code>NCName</code>, the <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator raises a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                           </p>
                        </li>
                        <li>
                           <p>If the <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a> is a  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>,  the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to the following expression,  where <code>KS</code> is the value of the  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>:
                           </p>
                           <div class="exampleInner"><pre>
for $k in fn:data(KS)
return .($k)  
</pre></div>
                        </li>
                        <li>
                           <p>If the <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a> is a wildcard ("<code>*</code>"), the  <a href="#doc-xpath31-UnaryLookup">UnaryLookup</a> operator is equivalent to the following expression:
                           </p>
                           <div class="exampleInner"><pre>
for $k in 1 to array:size(.)
return .($k)
</pre></div>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>
                                 Note that array items are returned in order.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>?name</code> is equivalent to <code>.("name")</code>, an appropriate lookup for a map.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>?2</code> is equivalent to <code>.(2)</code>, an appropriate lookup for an array or an integer-valued map.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>?($a)</code> is equivalent to <code>for $k in $a return .($k)</code>, allowing keys for an array or map to be passed using a variable.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>?(2 to 4)</code> is equivalent to <code>for $k in (2,3,4) return .($k)</code>, a convenient way to return a range of values from an array.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>?(3.5)</code> raises a type error <span>if the context item is an array</span> because the parameter must be an integer.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>([1,2,3], [1,2,5], [1,2])[?3 = 5]</code> raises an error because <code>?3</code> on one of the
                              items in the sequence fails.
                           </p>
                        </li>
                        <li>
                           <p>If <code>$m</code> is bound to the weekdays map described in <a href="#id-maps"><b>3.11.1 Maps</b></a>, then <code>$m?*</code> returns the values <code>("Sunday","Monday","Tuesday","Wednesday", "Thursday", "Friday","Saturday")</code>, in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[1, 2, 5, 7]?*</code> evaluates to <code>(1, 2, 5, 7)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[[1, 2, 3], [4, 5, 6]]?*</code> evaluates to <code>([1, 2, 3], [4, 5, 6])</code>
                              
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-postfix-lookup"></a>3.11.3.2 Postfix Lookup
                     </h5>
                     <a id="d2e17186"></a><table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xpath31-Lookup"></a>[53]&nbsp;&nbsp;&nbsp;
                              </td>
                              <td><code><a href="#prod-xpath31-Lookup">Lookup</a></code></td>
                              <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                              <td><code>"?"  <a href="#doc-xpath31-KeySpecifier">KeySpecifier</a>
                                    </code></td>
                              <td></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                        The semantics of a Postfix Lookup expression depend on the form of the KeySpecifier,
                        as follows:
                        
                     </p>
                     <ul>
                        <li>
                           <p>If the <code>KeySpecifier</code> is an <code>NCName</code>, <code>IntegerLiteral</code>, or <code>Wildcard</code> ("<code>*</code>"), then the expression <code>E?S</code> is equivalent to <code>E!?S</code>. (That is, the semantics of the postfix lookup operator are defined in terms of the
                              unary lookup operator).
                           </p>
                        </li>
                        <li>
                           <p>If the <code>KeySpecifier</code> is a <code>ParenthesizedExpr</code>, then the expression <code>E?(S)</code> is equivalent to
                           </p>
                           <div class="exampleInner"><pre>for $e in E, $s in fn:data(S) return $e($s)</pre></div>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The focus for evaluating <code>S</code> is the same as the focus for the <code>Lookup</code> expression itself.
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>Examples:</p>
                     <ul>
                        <li>
                           <p>
                              <code>map { "first" : "Jenna", "last" : "Scott" }?first</code> evaluates to <code>"Jenna"</code>
                              
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>[4, 5, 6]?2</code> evaluates to <code>5</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>(map {"first": "Tom"}, map {"first": "Dick"}, map {"first": "Harry"})?first</code> evaluates to the sequence <code>("Tom", "Dick", "Harry")</code>
                              .
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>([1,2,3], [4,5,6])?2</code> evaluates to the sequence <code>(2, 5)</code>.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>["a","b"]?3</code> raises a dynamic error [<a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO31</small></sup>
                              
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-conditionals"></a>3.12 Conditional Expressions
               </h3>
               <p>XPath 3.1 supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.
               </p>
               <a id="d2e17337"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-IfExpr"></a>[15]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-IfExpr">IfExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"if"  "("  <a href="#doc-xpath31-Expr">Expr</a>  ")"  "then"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  "else"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>The expression following the <code>if</code> keyword is called the <b>test expression</b>, and the expressions
                  following the <code>then</code> and <code>else</code> keywords are called the <b>then-expression</b> and <b>else-expression</b>, respectively.
               </p>
               <p>The first step in processing a conditional expression is to find
                  the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the test expression, as defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.
               </p>
               <p>The value of a conditional expression is defined as follows: If the
                  effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the
                  effective boolean value of the test expression is <code>false</code>,
                  the value of the else-expression is returned.
               </p>
               <p>Conditional expressions have a special rule for propagating <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered
                  in the else-expression. In this case, since the else-expression can have no observable
                  effect, it need not be evaluated. Similarly, if the effective value of the test expression
                  is <code>false</code>, the conditional expression ignores any <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> encountered in the then-expression, and the then-expression need not be evaluated.
               </p>
               <p>Here are some examples of conditional expressions:</p>
               <ul>
                  <li>
                     <p>In this example, the test expression is a comparison expression:</p>
                     <div class="exampleInner"><pre>if ($widget1/unit-cost &lt; $widget2/unit-cost)
  then $widget1
  else $widget2</pre></div>
                  </li>
                  <li>
                     <p>In this example, the test expression tests for the existence of an attribute
                        named <code>discounted</code>, independently of its value:
                     </p>
                     <div class="exampleInner"><pre>if ($part/@discounted)
  then $part/wholesale
  else $part/retail</pre></div>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="id-quantified-expressions"></a>3.13 Quantified Expressions
               </h3>
               <p>Quantified expressions support existential and universal quantification. The
                  value of a quantified expression is always <code>true</code> or <code>false</code>.
               </p>
               <a id="d2e17430"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-QuantifiedExpr"></a>[14]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-QuantifiedExpr">QuantifiedExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("some"  |  "every")  "$"  <a href="#doc-xpath31-VarName">VarName</a>  "in"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-xpath31-VarName">VarName</a>  "in"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>A <b>quantified expression</b> begins with
                  a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables,
                  followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
                  expression that returns a sequence of items, called the binding sequence for that
                  variable. The in-clauses generate tuples of variable bindings, including a tuple for
                  each combination of items in the binding sequences of the respective variables. Conceptually,
                  the test expression is evaluated for each
                  tuple of variable bindings. Results depend on the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the test expressions, as defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>. The value of the quantified expression is defined
                  by the following rules:
               </p>
               <ol class="enumar">
                  <li>
                     <p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> 
                        <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
                        tuples, the value of the quantified expression is <code>false</code>.
                     </p>
                  </li>
                  <li>
                     <p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> 
                        <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
                        tuples, the value of the quantified
                        expression is <code>true</code>.
                     </p>
                  </li>
               </ol>
               <p>The scope of a variable bound in a quantified expression comprises all
                  subexpressions of the quantified expression that appear after the variable binding.
                  The scope does not include the expression to which the variable is bound.
                  
               </p>
               <p>The order in which test expressions are evaluated for the various binding
                  tuples is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier
                  is <code>some</code>, an implementation may
                  return <code>true</code> as soon as it finds one binding tuple for which the test expression has
                  an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for
                  which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has
                  an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for
                  which the test expression raises an error. As a result of these rules, the
                  value of a quantified expression is not deterministic in the presence of
                  errors, as illustrated in the examples below.
               </p>
               <p>Here are some examples of quantified expressions:</p>
               <ul>
                  <li>
                     <p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):
                     </p>
                     <div class="exampleInner"><pre>every $part in /parts/part satisfies $part/@discounted</pre></div>
                  </li>
                  <li>
                     <p>This expression is <code>true</code> if at least
                        one <code>employee</code> element satisfies the given comparison expression:
                     </p>
                     <div class="exampleInner"><pre>some $emp in /emps/employee satisfies
     ($emp/bonus &gt; 0.25 * $emp/salary)</pre></div>
                  </li>
                  <li>
                     <p>In the following examples, each quantified expression evaluates its test
                        expression over nine tuples of variable bindings, formed from the Cartesian
                        product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.
                     </p>
                     <div class="exampleInner"><pre>some $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4</pre></div>
                     <div class="exampleInner"><pre>every $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4</pre></div>
                  </li>
                  <li>
                     <p>This quantified expression may either return  <code>true</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one variable binding
                        and raises a <a title="type error" href="#dt-type-error">type error</a> for another:
                     </p>
                     <div class="exampleInner"><pre>some $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div>
                  </li>
                  <li>
                     <p>This quantified expression may either return <code>false</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one variable binding and raises a <a title="type error" href="#dt-type-error">type error</a> for another:
                     </p>
                     <div class="exampleInner"><pre>every $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="id-expressions-on-datatypes"></a>3.14 Expressions on SequenceTypes
               </h3>
               <p>
                  The <code>instance
                     of</code>, <code>cast</code>, <code>castable</code>,
                  and <code>treat</code> expressions are used to test whether a value
                  conforms to a given type or to convert it to an instance of a given
                  type.
                  
               </p>
               <div class="div3">
                  
                  <h4><a id="id-instance-of"></a>3.14.1 Instance Of
                  </h4>
                  <a id="d2e17666"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-InstanceofExpr"></a>[25]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-InstanceofExpr">InstanceofExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#doc-xpath31-SequenceType">SequenceType</a> )?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The boolean
                     operator <code>instance of</code>
                     returns <code>true</code> if the value of its first operand matches
                     the <a href="#doc-xpath31-SequenceType">SequenceType</a> in its second
                     operand, according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                        matching</a>; otherwise it returns <code>false</code>. For example:
                  </p>
                  <ul>
                     <li>
                        <p>
                           <code>5 instance of xs:integer</code>
                           
                        </p>
                        <p>This example returns <code>true</code> because the given value is an instance of the given type.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>5 instance of xs:decimal</code>
                           
                        </p>
                        <p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>(5, 6) instance of xs:integer+</code>
                           
                        </p>
                        <p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the
                           specified type.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>. instance of element()</code>
                           
                        </p>
                        <p>This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. 
                           If the context item is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-cast"></a>3.14.2 Cast
                  </h4>
                  <a id="d2e17760"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-CastExpr"></a>[28]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-CastExpr">CastExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-ArrowExpr">ArrowExpr</a> ( "cast"  "as"  <a href="#doc-xpath31-SingleType">SingleType</a> )?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-SingleType"></a>[77]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-SingleType">SingleType</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>  "?"?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>Occasionally
                     it is necessary to convert a value to a specific datatype. For this
                     purpose, XPath 3.1 provides a <code>cast</code> expression that
                     creates a new value of a specific type based on an existing value. A
                     <code>cast</code> expression takes two operands: an <b>input
                        expression</b> and a <b>target type</b>. The type of the
                     atomized value of the input expression is called the <b>input type</b>. 
                     The SimpleTypeName must be the name of a type defined
                     in the  <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, and it must be a simple type [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>].
                     In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>,
                     or <code>xs:anyAtomicType</code> 
                     [<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]. The optional occurrence indicator "<code>?</code>" denotes that an empty
                     sequence is permitted. If the target type is a lexical QName that has no namespace
                     prefix, it
                     is considered to be in the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
                        namespace</a>.
                  </p>
                  <p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the static context of the cast expression to
                     provide the namespace bindings for this operation. 
                     Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <code>fn:QName</code> function, which allows the namespace context to be taken from the document containing
                     the QName.
                  </p>
                  <p>The semantics of the <code>cast</code> expression
                     are as follows:
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>The input expression is evaluated.</p>
                     </li>
                     <li>
                        <p>The result of the first step is <a title="atomization" href="#dt-atomization">atomized</a>.
                        </p>
                     </li>
                     <li>
                        <p> If the result of atomization is a
                           sequence of more than one atomic value, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                        </p>
                     </li>
                     <li>
                        <p>If the result
                           of atomization is an empty sequence:
                        </p>
                        <ol class="enumla">
                           <li>
                              <p>If
                                 <code>?</code> is specified after the target type, the result of the
                                 <code>cast</code> expression is an empty sequence.
                              </p>
                           </li>
                           <li>
                              <p>
                                 If <code>?</code> is not specified after the target type, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
                              </p>
                           </li>
                        </ol>
                     </li>
                     <li>
                        <p>If the result of atomization is a single
                           atomic value, the result of the cast expression is determined by
                           casting to the target type as described in <a href="https://www.w3.org/TR/xpath-functions-31/#casting">Section 
                              
                              19 Casting
                              </a><sup><small>FO31</small></sup>. When casting, an
                           implementation may need to determine whether one type is derived by
                           restriction from another. An implementation can determine this either
                           by examining the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema
                              definitions</a> or by using an alternative, <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>
                           mechanism such as a data dictionary.
                           <span>
                              The result of a cast expression is one of the following: 
                              </span>
                           
                        </p>
                        <ol class="enumla">
                           <li>
                              <p> 
                                 A value of the target type (or, in the case of list types,
                                 a sequence of values that are instances of the item type of the
                                 list type).
                                 
                              </p>
                           </li>
                           <li>
                              <p> 
                                 A type error, if casting from the source type to the
                                 target type is not supported (for example attempting to convert an
                                 integer to a date).
                                 
                              </p>
                           </li>
                           <li>
                              <p> 
                                 A dynamic error, if the particular input value cannot be
                                 converted to the target type (for example, attempting to convert
                                 the string <code>"three"</code> to an integer).
                                 
                              </p>
                           </li>
                        </ol>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-castable"></a>3.14.3 Castable
                  </h4>
                  <a id="d2e18060"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-CastableExpr"></a>[27]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-CastableExpr">CastableExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#doc-xpath31-SingleType">SingleType</a> )?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="noid_d3e16481.doc-xpath31-SingleType"></a>[77]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>SingleType</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>  "?"?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>XPath 3.1
                     provides an expression that tests whether a given value
                     is castable into a given target type. 
                     
                     The SimpleTypeName must be the name of a type defined
                     in the  <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, and the type must be
                     <code>simple</code> 
                     [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>]. 
                     
                     In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code> 
                     [<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]. The optional occurrence indicator "<code>?</code>" denotes that an empty
                     sequence is permitted. 
                  </p>
                  <p>The expression <code>E castable as T</code> returns <code>true</code> 
                     if the result of evaluating <code>E</code>  
                     can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; 
                     otherwise it returns <code>false</code>. 
                     If evaluation of <code>E</code> fails with a dynamic error <span>or if the value of <code>E</code> cannot be atomized</span>, 
                     the <code>castable</code> expression as a whole fails. 
                     The <code>castable</code> expression can be used as a <a title="" href="#dt-predicate">predicate</a>  to
                     avoid errors at evaluation time. 
                     It can also be used to select an appropriate type for processing of a given value,
                     as illustrated in
                     the following example:
                  </p>
                  <div class="exampleInner"><pre>
if ($x castable as hatsize)
   then $x cast as hatsize
   else if ($x castable as IQ)
   then $x cast as IQ
   else $x cast as xs:string</pre></div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-constructor-functions"></a>3.14.4 Constructor Functions
                  </h4>
                  <p>For every  
                     <span>simple type</span> in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>  (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, <span>and <code>xs:anySimpleType</code>,</span> which are not instantiable), a <b>constructor function</b> is implicitly defined. In each case, the name of the constructor function is the
                     same as the name of its target type (including namespace). The signature of the constructor
                     function for  
                     <span>a given type depends on the type that is being constructed, and can be found in  <a href="https://www.w3.org/TR/xpath-functions-31/#constructor-functions">Section 
                           
                           18 Constructor functions
                           </a><sup><small>FO31</small></sup>.</span>
                     
                  </p>
                  <p> 
                     [<a id="dt-constructor-function" title="constructor function">Definition</a>: The <b>constructor function</b> for a given type is used to convert instances of other  
                     <span>simple</span> types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.]
                     
                  </p>
                  <p>The following examples illustrate the use of constructor functions:</p>
                  <ul>
                     <li>
                        <p>This
                           example is equivalent to <code>("2000-01-01" cast as
                              xs:date?)</code>.
                        </p>
                        <div class="exampleInner"><pre>xs:date("2000-01-01")</pre></div>
                     </li>
                     <li>
                        <p>This
                           example is equivalent to
                           
                           <code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.
                        </p>
                        <div class="exampleInner"><pre>xs:decimal($floatvalue * 0.2E-5)</pre></div>
                     </li>
                     <li>
                        <p>This example returns an
                           <code>xs:dayTimeDuration</code> value equal to 21 days. It is
                           equivalent to <code>("P21D" cast as xs:dayTimeDuration?)</code>.
                        </p>
                        <div class="exampleInner"><pre>xs:dayTimeDuration("P21D")</pre></div>
                     </li>
                     <li>
                        <p>If
                           <code>usa:zipcode</code> is a user-defined atomic type
                           in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, then the
                           following expression is equivalent to the
                           expression <code>("12345" cast as
                              usa:zipcode?)</code>.
                        </p>
                        <div class="exampleInner"><pre>usa:zipcode("12345")</pre></div>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>
                        An instance of an atomic type that is not in a namespace can be
                        constructed by using a <a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a> 
                        in either a cast expression or a constructor function call.  Examples:
                        
                     </p>
                     <div class="exampleInner"><pre>17 cast as Q{}apple</pre></div>
                     <div class="exampleInner"><pre>Q{}apple(17)</pre></div>
                     <p>
                        If the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
                           namespace</a> is absent, the <a href="#doc-xpath31-QName">QName</a> syntax can also be used.
                        Examples:
                        
                     </p>
                     <div class="exampleInner"><pre>17 cast as apple</pre></div>
                     <div class="exampleInner"><pre>apple(17)</pre></div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-treat"></a>3.14.5 Treat
                  </h4>
                  <a id="d2e18279"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xpath31-TreatExpr"></a>[26]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#prod-xpath31-TreatExpr">TreatExpr</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#doc-xpath31-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#doc-xpath31-SequenceType">SequenceType</a> )?</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>XPath 3.1 provides an
                     expression called <code>treat</code> that can be used to modify the
                     <a title="static type" href="#dt-static-type">static type</a> of its
                     operand.
                  </p>
                  <p>Like <code>cast</code>, the <code>treat</code>
                     expression takes two operands: an expression and a <a href="#doc-xpath31-SequenceType">SequenceType</a>. Unlike
                     <code>cast</code>, however, <code>treat</code> does not change the
                     <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> or value of its operand. Instead, the purpose of
                     <code>treat</code> is to ensure that an expression has an expected
                     dynamic type at evaluation time.
                  </p>
                  <p>The semantics of <em>
                        <code>expr1</code>
                        </em>
                     <code> treat as </code>
                     <em>
                        <code>type1</code>
                        </em> are as
                     follows:
                  </p>
                  <ul>
                     <li>
                        <p>During static analysis:</p>
                        <p> The
                           <a title="static type" href="#dt-static-type">static type</a> of the
                           <code>treat</code> expression is <em>
                              <code>type1</code>
                              </em>. This enables the
                           expression to be used as an argument of a function that requires a
                           parameter of <em>
                              <code>type1</code>
                              </em>.
                        </p>
                     </li>
                     <li>
                        <p>During expression
                           evaluation:
                        </p>
                        <p>If <em>
                              <code>expr1</code>
                              </em> matches <em>
                              <code>type1</code>
                              </em>,
                           using the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                              matching</a>,
                           the <code>treat</code> expression returns the value of
                           <em>
                              <code>expr1</code>
                              </em>; otherwise, it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
                           [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].
                           If the value of <em>
                              <code>expr1</code>
                              </em> is returned, 
                           <span>the identity of any nodes in the value</span> is
                           preserved. The <code>treat</code> expression ensures that the value of
                           its expression operand conforms to the expected type at
                           run-time.
                        </p>
                     </li>
                     <li>
                        <p>Example:</p>
                        <div class="exampleInner"><pre>$myaddress treat as element(*, USAddress)</pre></div>
                        <p>The
                           <a title="static type" href="#dt-static-type">static type</a> of
                           <code>$myaddress</code> may be <code>element(*, Address)</code>, a
                           less specific type than <code>element(*, USAddress)</code>. However,
                           at run-time, the value of <code>$myaddress</code> must match the type
                           <code>element(*, USAddress)</code> using rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
                              matching</a>;
                           otherwise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
                           raised [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-map-operator"></a>3.15 Simple map operator (<code>!</code>)
               </h3>
               <a id="d2e18456"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-SimpleMapExpr"></a>[35]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-PathExpr">PathExpr</a>  ("!"  <a href="#doc-xpath31-PathExpr">PathExpr</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>
                  A mapping expression <code>S!E</code> evaluates the
                  expression <code>E</code> once for every item in the sequence
                  obtained by evaluating <code>S</code>. The simple mapping operator
                  "<code>!</code>" can be applied to any sequence, regardless of the
                  types of its items, and it can deliver a mixed sequence of nodes,
                  atomic values, and functions. Unlike the similar "<code>/</code>"
                  operator, it does not sort nodes into document order or eliminate
                  duplicates.
                  
               </p>
               <p>Each operation <code>E1!E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated to a sequence <code>S</code>. Each item in <code>S</code> then serves in turn to provide an inner focus (the item as the context item, its
                  position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code> in the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows: Every evaluation of <code>E2</code> returns a (possibly empty) sequence of items. These sequences are concatenated and
                  returned. <span class="xpath">The</span> returned sequence preserves the orderings within and among the subsequences generated
                  by the evaluations of <code>E2</code>
                  <span class="xpath">.</span>
                  
               </p>
               <p>Simple map operators have functionality similar to <a href="#id-path-operator"><b>3.3.1.1 Path operator (/)</b></a>.
                  The following table summarizes the differences between these two operators
               </p>
               <table style="width:100%" class="medium">
                  <thead>
                     <tr>
                        <th>Operator</th>
                        <th>Path operator (<code>E1 / E2</code>)
                        </th>
                        <th>Simple map operator (<code>E1 ! E2</code>)
                        </th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <th>E1</th>
                        <td>Any sequence of nodes</td>
                        <td>Any sequence of items</td>
                     </tr>
                     <tr>
                        <th>E2</th>
                        <td>Either a sequence of nodes or a sequence of non-node items</td>
                        <td>A sequence of items</td>
                     </tr>
                     <tr>
                        <th>Additional processing</th>
                        <td>Duplicate elimination and document ordering</td>
                        <td>Simple sequence concatenation</td>
                     </tr>
                  </tbody>
               </table>
               <p>The following examples illustrate the use of simple map operators combined with path
                  expressions.
               </p>
               <div class="exampleOuter">
                  <ul>
                     <li>
                        <p>
                           <code>child::div1 / child::para / string() ! concat("id-", .)</code>
                           
                        </p>
                        <p>Selects the <code>para</code> element children of the <code>div1</code> element children of the context node; that is, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents. It then outputs the strings obtained by prepending <code>"id-"</code> to each of the string values of these grandchildren.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>$emp ! (@first, @middle, @last)</code>
                           
                        </p>
                        <p>Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for element <code>$emp</code>, in the order given. (The <code>/</code> operator here returns the attributes in an unpredictable order.)
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>$docs ! ( //employee)</code>
                           
                        </p>
                        <p>Returns all the employees within all the documents identified by the variable docs,
                           in document order within each document, but retaining the order of documents.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>avg( //employee / salary ! translate(., '$', '') ! number(.))</code>
                           
                        </p>
                        <p>Returns the average salary of the employees, having converted the salary to a number
                           by removing any <code>$</code> sign and then converting to a number. (The second occurrence of <code>!</code> could not be written as <code>/</code> because the left-hand operand of <code>/</code> cannot be an atomic value.)
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>fn:string-join((1 to $n)!"*")</code>
                           
                        </p>
                        <p>Returns a string containing <code>$n</code> asterisks.
                        </p>
                     </li>
                     <li>
                        <p>
                           <code>$values!(.*.) =&gt; fn:sum()</code>
                           
                        </p>
                        <p>Returns the sum of the squares of a sequence of numbers.</p>
                     </li>
                     <li>
                        <p>
                           <code>string-join(ancestor::*!name(), '/')</code>
                           
                        </p>
                        <p>Returns a path containing the names of the ancestors of an element, separated by "<code>/</code>" characters.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-arrow-operator"></a>3.16 Arrow operator (<code>=&gt;</code>)
               </h3>
               <a id="d2e18684"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ArrowExpr"></a>[29]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ArrowExpr">ArrowExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-UnaryExpr">UnaryExpr</a> ( "=&gt;"  <a href="#doc-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a>  
                              <a href="#doc-xpath31-ArgumentList">ArgumentList</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="doc-xpath31-ArrowFunctionSpecifier"></a>[55]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#prod-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#doc-xpath31-EQName">EQName</a>  |  <a href="#doc-xpath31-VarRef">VarRef</a>  |  <a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <p>
                  [<a id="dt-arrow-operator" title="arrow operator">Definition</a>: An <b>arrow operator</b> 
                  applies a function to 
                  <span>the value of an expression</span>, using 
                  <span>the value</span> as the first argument to the function.]  
                  
                  <span>
                     Given a  <a href="#doc-xpath31-UnaryExpr">UnaryExpr</a> 
                     <code>U</code>, an <a href="#doc-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a> 
                     <code>F</code>, 
                     and an <a href="#doc-xpath31-ArgumentList">ArgumentList</a> 
                     <code>(A, B, C...)</code>, the expression <code>U =&gt; F(A, B, C...)</code> is equivalent to the
                     expression <code>F(U, A, B, C...)</code>.
                     </span>
                  
               </p>
               <p>
                  This syntax is particularly helpful when applying multiple
                  functions to a value in turn. For example, the following
                  expression invites syntax errors due to misplaced parentheses:
                  
               </p>
               <div class="exampleInner"><pre>tokenize((normalize-unicode(upper-case($string))),"\s+")</pre></div>
               <p>In the following reformulation, it is easier to see that the parentheses are balanced:</p>
               <div class="exampleInner"><pre>$string =&gt; upper-case() =&gt; normalize-unicode() =&gt; tokenize("\s+")</pre></div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-conformance"></a>4 Conformance
            </h2>
            <p>This section defines the conformance criteria for an XPath 3.1 processor. In this
               section, the
               following terms are used to indicate the requirement levels defined in <a href="#RFC2119">[RFC2119]</a>. [<a id="must" title="must">Definition</a>: 
               <b>MUST</b> means that the item is an absolute
               requirement of the specification.]
               [<a id="mustnot" title="must not">Definition</a>: 
               <b>MUST NOT</b> means that the item is an
               absolute prohibition of the specification.]
               [<a id="may" title="may">Definition</a>: 
               <b>MAY</b> means that an item is truly
               optional.]
               
               
            </p>
            <p class="xpath">XPath is intended primarily as a component that can be used by
               other specifications. Therefore, XPath relies on specifications that
               use it (such as <a href="#XPTR">[XPointer]</a> and <a href="#xslt-30">[XSL Transformations (XSLT) Version 3.0]</a>) to
               specify conformance criteria for XPath in their respective
               environments. Specifications that set conformance criteria for their
               use of XPath <a title="must not" href="#mustnot">MUST NOT</a> change the
               syntactic or semantic definitions of XPath as given in this
               specification, except by subsetting and/or compatible extensions.
            </p>
            <p class="xpath">
               <span>If a language is described as an extension of XPath, 
                  then every expression that conforms to the XPath grammar <a title="must" href="#must">MUST</a>  behave as described in this specification.</span>
               
               
            </p>
            <div class="div2">
               
               <h3><a id="id-xpath-static-typing"></a>4.1 Static Typing Feature
               </h3>
               <p>
                  [<a id="dt-xpath-static-typing-feature" title="static typing feature">Definition</a>: The <b>Static
                     Typing Feature</b> is an optional feature of XPath that provides support for static semantics, and requires
                  implementations to detect and report <a title="type error" href="#dt-type-error">type errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.] Specifications that use XPath <a title="may" href="#may">MAY</a>  specify conformance criteria for use of the Static Typing Feature.
               </p>
               <p>If an implementation does not support the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a>, but can
                  nevertheless determine during the static analysis phase that
                  <span class="xpath">an XPath expression</span>, if evaluated, would necessarily raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> or that an expression, if evaluated, would necessarily raise a <a title="type error" href="#dt-type-error">type error</a>, the implementation <a title="may" href="#may">MAY</a> raise that error during the static analysis phase. The choice
                  of whether to raise such an error at analysis time is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation dependent</a>.
               </p>
            </div>
         </div>
      </div>
      <div class="back">
         <div class="div1">
            
            <h2><a id="nt-bnf"></a>A XPath 3.1 Grammar
            </h2>
            <div class="div2">
               
               <h3><a id="id-grammar"></a>A.1 EBNF
               </h3>
               <p>The grammar of XPath 3.1 uses the same simple Extended Backus-Naur Form (EBNF) notation
                  as
                  <a href="#XML">[XML 1.0]</a> with the following minor differences.
               </p>
               <ul>
                  <li>
                     <p>All named symbols have a name that begins with an uppercase letter.</p>
                  </li>
                  <li>
                     <p>It adds a notation for referring to productions in external specifications.</p>
                  </li>
                  <li>
                     <p>Comments or extra-grammatical constraints on grammar productions are between '/*'
                        and
                        '*/' symbols.
                     </p>
                     <ul>
                        <li>
                           <p>A 'xgc:' prefix is an extra-grammatical constraint, the details of which are
                              explained in <a href="#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical Constraints</b></a>
                              
                           </p>
                        </li>
                        <li>
                           <p>A 'ws:' prefix explains the whitespace rules for the production, the details of which
                              are explained in <a href="#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a>
                              
                           </p>
                        </li>
                        <li>
                           <p>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing
                              rules, and is explained in <a href="#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>. These notes are not
                              normative.
                           </p>
                        </li>
                     </ul>
                  </li>
               </ul>
               <p>The terminal symbols for this grammar include the quoted strings used in the production
                  rules
                  below, and the terminal symbols defined in section <a href="#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.
               </p>
               <p>The EBNF notation is described in more detail in <a href="#EBNFNotation"><b>A.1.1 Notation</b></a>.
               </p>
               <a id="BNF-Grammar"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-XPath"></a>[1]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-XPath">XPath</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-Expr">Expr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ParamList"></a>[2]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>ParamList</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-Param">Param</a>  (","  <a href="#prod-xpath31-Param">Param</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Param"></a>[3]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>Param</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#prod-xpath31-EQName">EQName</a>  
                              <a href="#prod-xpath31-TypeDeclaration">TypeDeclaration</a>?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-FunctionBody"></a>[4]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>FunctionBody</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EnclosedExpr">EnclosedExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-EnclosedExpr"></a>[5]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-EnclosedExpr">EnclosedExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"{"  <a href="#prod-xpath31-Expr">Expr</a>?  "}"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Expr"></a>[6]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Expr">Expr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ExprSingle"></a>[7]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ForExpr">ForExpr</a>
                              <br>|  <a href="#prod-xpath31-LetExpr">LetExpr</a>
                              <br>|  <a href="#prod-xpath31-QuantifiedExpr">QuantifiedExpr</a>
                              <br>|  <a href="#prod-xpath31-IfExpr">IfExpr</a>
                              <br>|  <a href="#prod-xpath31-OrExpr">OrExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ForExpr"></a>[8]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ForExpr">ForExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-SimpleForClause">SimpleForClause</a>  "return"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleForClause"></a>[9]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SimpleForClause">SimpleForClause</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"for"  <a href="#prod-xpath31-SimpleForBinding">SimpleForBinding</a>  (","  <a href="#prod-xpath31-SimpleForBinding">SimpleForBinding</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleForBinding"></a>[10]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SimpleForBinding">SimpleForBinding</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#prod-xpath31-VarName">VarName</a>  "in"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-LetExpr"></a>[11]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-LetExpr">LetExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-SimpleLetClause">SimpleLetClause</a>  "return"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleLetClause"></a>[12]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SimpleLetClause">SimpleLetClause</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"let"  <a href="#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a>  (","  <a href="#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleLetBinding"></a>[13]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#prod-xpath31-VarName">VarName</a>  ":="  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-QuantifiedExpr"></a>[14]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("some"  |  "every")  "$"  <a href="#prod-xpath31-VarName">VarName</a>  "in"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xpath31-VarName">VarName</a>  "in"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-IfExpr"></a>[15]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-IfExpr">IfExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"if"  "("  <a href="#prod-xpath31-Expr">Expr</a>  ")"  "then"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-OrExpr"></a>[16]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-OrExpr">OrExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AndExpr">AndExpr</a> ( "or"  <a href="#prod-xpath31-AndExpr">AndExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AndExpr"></a>[17]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AndExpr">AndExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#prod-xpath31-ComparisonExpr">ComparisonExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ComparisonExpr"></a>[18]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ComparisonExpr">ComparisonExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-StringConcatExpr">StringConcatExpr</a> ( (<a href="#prod-xpath31-ValueComp">ValueComp</a>
                              <br>|  <a href="#prod-xpath31-GeneralComp">GeneralComp</a>
                              <br>|  <a href="#prod-xpath31-NodeComp">NodeComp</a>)  <a href="#prod-xpath31-StringConcatExpr">StringConcatExpr</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-StringConcatExpr"></a>[19]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-StringConcatExpr">StringConcatExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-RangeExpr">RangeExpr</a> ( "||"  <a href="#prod-xpath31-RangeExpr">RangeExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-RangeExpr"></a>[20]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-RangeExpr">RangeExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#prod-xpath31-AdditiveExpr">AdditiveExpr</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AdditiveExpr"></a>[21]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AdditiveExpr">AdditiveExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MultiplicativeExpr"></a>[22]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#prod-xpath31-UnionExpr">UnionExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-UnionExpr"></a>[23]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-UnionExpr">UnionExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-IntersectExceptExpr"></a>[24]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#prod-xpath31-InstanceofExpr">InstanceofExpr</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-InstanceofExpr"></a>[25]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-InstanceofExpr">InstanceofExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#prod-xpath31-SequenceType">SequenceType</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TreatExpr"></a>[26]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TreatExpr">TreatExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#prod-xpath31-SequenceType">SequenceType</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-CastableExpr"></a>[27]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-CastableExpr">CastableExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-xpath31-SingleType">SingleType</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-CastExpr"></a>[28]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-CastExpr">CastExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ArrowExpr">ArrowExpr</a> ( "cast"  "as"  <a href="#prod-xpath31-SingleType">SingleType</a> )?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArrowExpr"></a>[29]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArrowExpr">ArrowExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-UnaryExpr">UnaryExpr</a> ( "=&gt;"  <a href="#prod-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a>  
                              <a href="#prod-xpath31-ArgumentList">ArgumentList</a> )*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-UnaryExpr"></a>[30]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-UnaryExpr">UnaryExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("-"  |  "+")* <a href="#prod-xpath31-ValueExpr">ValueExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ValueExpr"></a>[31]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ValueExpr">ValueExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-SimpleMapExpr">SimpleMapExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-GeneralComp"></a>[32]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-GeneralComp">GeneralComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ValueComp"></a>[33]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ValueComp">ValueComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NodeComp"></a>[34]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NodeComp">NodeComp</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleMapExpr"></a>[35]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-PathExpr">PathExpr</a>  ("!"  <a href="#prod-xpath31-PathExpr">PathExpr</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-PathExpr"></a>[36]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-PathExpr">PathExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("/"  <a href="#prod-xpath31-RelativePathExpr">RelativePathExpr</a>?)<br>|  ("//"  <a href="#prod-xpath31-RelativePathExpr">RelativePathExpr</a>)<br>|  <a href="#prod-xpath31-RelativePathExpr">RelativePathExpr</a>
                              </code></td>
                        <td><i>/* 
                              <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-RelativePathExpr"></a>[37]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#prod-xpath31-StepExpr">StepExpr</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-StepExpr"></a>[38]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-StepExpr">StepExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-PostfixExpr">PostfixExpr</a>  |  <a href="#prod-xpath31-AxisStep">AxisStep</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AxisStep"></a>[39]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AxisStep">AxisStep</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>(<a href="#prod-xpath31-ReverseStep">ReverseStep</a>  |  <a href="#prod-xpath31-ForwardStep">ForwardStep</a>)  <a href="#prod-xpath31-PredicateList">PredicateList</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ForwardStep"></a>[40]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ForwardStep">ForwardStep</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>(<a href="#prod-xpath31-ForwardAxis">ForwardAxis</a>  
                              <a href="#prod-xpath31-NodeTest">NodeTest</a>)  |  <a href="#prod-xpath31-AbbrevForwardStep">AbbrevForwardStep</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ForwardAxis"></a>[41]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ForwardAxis">ForwardAxis</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("child"  "::")<br>|  ("descendant"  "::")<br>|  ("attribute"  "::")<br>|  ("self"  "::")<br>|  ("descendant-or-self"  "::")<br>|  ("following-sibling"  "::")<br>|  ("following"  "::")<br>|  ("namespace"  "::")</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AbbrevForwardStep"></a>[42]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"@"?  <a href="#prod-xpath31-NodeTest">NodeTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ReverseStep"></a>[43]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ReverseStep">ReverseStep</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>(<a href="#prod-xpath31-ReverseAxis">ReverseAxis</a>  
                              <a href="#prod-xpath31-NodeTest">NodeTest</a>)  |  <a href="#prod-xpath31-AbbrevReverseStep">AbbrevReverseStep</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ReverseAxis"></a>[44]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ReverseAxis">ReverseAxis</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("parent"  "::")<br>|  ("ancestor"  "::")<br>|  ("preceding-sibling"  "::")<br>|  ("preceding"  "::")<br>|  ("ancestor-or-self"  "::")</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AbbrevReverseStep"></a>[45]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>".."</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NodeTest"></a>[46]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NodeTest">NodeTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-KindTest">KindTest</a>  |  <a href="#prod-xpath31-NameTest">NameTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NameTest"></a>[47]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NameTest">NameTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>  |  <a href="#prod-xpath31-Wildcard">Wildcard</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Wildcard"></a>[48]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Wildcard">Wildcard</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"*"<br>|  (<a href="#prod-xpath31-NCName">NCName</a>  ":*")<br>|  ("*:"  <a href="#prod-xpath31-NCName">NCName</a>)<br>|  (<a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a>  "*")</code></td>
                        <td><i>/* 
                              <a href="#ws-explicit">ws: explicit</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-PostfixExpr"></a>[49]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-PostfixExpr">PostfixExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-PrimaryExpr">PrimaryExpr</a>  (<a href="#prod-xpath31-Predicate">Predicate</a>  |  <a href="#prod-xpath31-ArgumentList">ArgumentList</a>  |  <a href="#prod-xpath31-Lookup">Lookup</a>)*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArgumentList"></a>[50]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArgumentList">ArgumentList</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"("  (<a href="#prod-xpath31-Argument">Argument</a>  (","  <a href="#prod-xpath31-Argument">Argument</a>)*)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-PredicateList"></a>[51]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-PredicateList">PredicateList</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-Predicate">Predicate</a>*</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Predicate"></a>[52]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Predicate">Predicate</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"["  <a href="#prod-xpath31-Expr">Expr</a>  "]"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Lookup"></a>[53]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Lookup">Lookup</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"?"  <a href="#prod-xpath31-KeySpecifier">KeySpecifier</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-KeySpecifier"></a>[54]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-KeySpecifier">KeySpecifier</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-NCName">NCName</a>  |  <a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>  |  "*"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArrowFunctionSpecifier"></a>[55]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>  |  <a href="#prod-xpath31-VarRef">VarRef</a>  |  <a href="#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-PrimaryExpr"></a>[56]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-Literal">Literal</a>
                              <br>|  <a href="#prod-xpath31-VarRef">VarRef</a>
                              <br>|  <a href="#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>
                              <br>|  <a href="#prod-xpath31-ContextItemExpr">ContextItemExpr</a>
                              <br>|  <a href="#prod-xpath31-FunctionCall">FunctionCall</a>
                              <br>|  <a href="#prod-xpath31-FunctionItemExpr">FunctionItemExpr</a>
                              <br>|  <a href="#prod-xpath31-MapConstructor">MapConstructor</a>
                              <br>|  <a href="#prod-xpath31-ArrayConstructor">ArrayConstructor</a>
                              <br>|  <a href="#prod-xpath31-UnaryLookup">UnaryLookup</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Literal"></a>[57]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Literal">Literal</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-xpath31-StringLiteral">StringLiteral</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NumericLiteral"></a>[58]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NumericLiteral">NumericLiteral</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xpath31-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xpath31-DoubleLiteral">DoubleLiteral</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-VarRef"></a>[59]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-VarRef">VarRef</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"$"  <a href="#prod-xpath31-VarName">VarName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-VarName"></a>[60]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-VarName">VarName</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ParenthesizedExpr"></a>[61]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"("  <a href="#prod-xpath31-Expr">Expr</a>?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ContextItemExpr"></a>[62]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ContextItemExpr">ContextItemExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"."</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-FunctionCall"></a>[63]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-FunctionCall">FunctionCall</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>  
                              <a href="#prod-xpath31-ArgumentList">ArgumentList</a>
                              </code></td>
                        <td><i>/* 
                              <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a>
                              */</i></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td><i>/* 
                              <a href="#parse-note-parens">gn: parens</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-Argument"></a>[64]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-Argument">Argument</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ExprSingle">ExprSingle</a>  |  <a href="#prod-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArgumentPlaceholder"></a>[65]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"?"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-FunctionItemExpr"></a>[66]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-FunctionItemExpr">FunctionItemExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-NamedFunctionRef">NamedFunctionRef</a>  |  <a href="#prod-xpath31-InlineFunctionExpr">InlineFunctionExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NamedFunctionRef"></a>[67]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NamedFunctionRef">NamedFunctionRef</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>  "#"  <a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>
                              </code></td>
                        <td><i>/* 
                              <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-InlineFunctionExpr"></a>[68]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"function"  "("  <a href="#prod-xpath31-ParamList">ParamList</a>?  ")"  ("as"  <a href="#prod-xpath31-SequenceType">SequenceType</a>)?  <a href="#prod-xpath31-FunctionBody">FunctionBody</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MapConstructor"></a>[69]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MapConstructor">MapConstructor</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"map"  "{"  (<a href="#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a>  (","  <a href="#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a>)*)?  "}"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MapConstructorEntry"></a>[70]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-MapKeyExpr">MapKeyExpr</a>  ":"  <a href="#prod-xpath31-MapValueExpr">MapValueExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MapKeyExpr"></a>[71]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MapValueExpr"></a>[72]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MapValueExpr">MapValueExpr</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ExprSingle">ExprSingle</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArrayConstructor"></a>[73]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArrayConstructor">ArrayConstructor</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-SquareArrayConstructor">SquareArrayConstructor</a>  |  <a href="#prod-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SquareArrayConstructor"></a>[74]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"["  (<a href="#prod-xpath31-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath31-ExprSingle">ExprSingle</a>)*)?  "]"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-CurlyArrayConstructor"></a>[75]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"array"  <a href="#prod-xpath31-EnclosedExpr">EnclosedExpr</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-UnaryLookup"></a>[76]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-UnaryLookup">UnaryLookup</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"?"  <a href="#prod-xpath31-KeySpecifier">KeySpecifier</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SingleType"></a>[77]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SingleType">SingleType</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>  "?"?</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TypeDeclaration"></a>[78]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>TypeDeclaration</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"as"  <a href="#prod-xpath31-SequenceType">SequenceType</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SequenceType"></a>[79]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SequenceType">SequenceType</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>("empty-sequence"  "("  ")")<br>|  (<a href="#prod-xpath31-ItemType">ItemType</a>  
                              <a href="#prod-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-OccurrenceIndicator"></a>[80]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"?"  |  "*"  |  "+"</code></td>
                        <td><i>/* 
                              <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a>
                              */</i></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ItemType"></a>[81]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ItemType">ItemType</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#prod-xpath31-FunctionTest">FunctionTest</a>  |  <a href="#prod-xpath31-MapTest">MapTest</a>  |  <a href="#prod-xpath31-ArrayTest">ArrayTest</a>  |  <a href="#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>  |  <a href="#prod-xpath31-ParenthesizedItemType">ParenthesizedItemType</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AtomicOrUnionType"></a>[82]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-KindTest"></a>[83]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-KindTest">KindTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-DocumentTest">DocumentTest</a>
                              <br>|  <a href="#prod-xpath31-ElementTest">ElementTest</a>
                              <br>|  <a href="#prod-xpath31-AttributeTest">AttributeTest</a>
                              <br>|  <a href="#prod-xpath31-SchemaElementTest">SchemaElementTest</a>
                              <br>|  <a href="#prod-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
                              <br>|  <a href="#prod-xpath31-PITest">PITest</a>
                              <br>|  <a href="#prod-xpath31-CommentTest">CommentTest</a>
                              <br>|  <a href="#prod-xpath31-TextTest">TextTest</a>
                              <br>|  <a href="#prod-xpath31-NamespaceNodeTest">NamespaceNodeTest</a>
                              <br>|  <a href="#prod-xpath31-AnyKindTest">AnyKindTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AnyKindTest"></a>[84]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AnyKindTest">AnyKindTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"node"  "("  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-DocumentTest"></a>[85]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-DocumentTest">DocumentTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"document-node"  "("  (<a href="#prod-xpath31-ElementTest">ElementTest</a>  |  <a href="#prod-xpath31-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TextTest"></a>[86]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TextTest">TextTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"text"  "("  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-CommentTest"></a>[87]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-CommentTest">CommentTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"comment"  "("  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-NamespaceNodeTest"></a>[88]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"namespace-node"  "("  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-PITest"></a>[89]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-PITest">PITest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"processing-instruction"  "("  (<a href="#prod-xpath31-NCName">NCName</a>  |  <a href="#prod-xpath31-StringLiteral">StringLiteral</a>)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AttributeTest"></a>[90]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AttributeTest">AttributeTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"attribute"  "("  (<a href="#prod-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-xpath31-TypeName">TypeName</a>)?)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AttribNameOrWildcard"></a>[91]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AttributeName">AttributeName</a>  |  "*"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SchemaAttributeTest"></a>[92]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"schema-attribute"  "("  <a href="#prod-xpath31-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AttributeDeclaration"></a>[93]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AttributeName">AttributeName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ElementTest"></a>[94]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ElementTest">ElementTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"element"  "("  (<a href="#prod-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-xpath31-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ElementNameOrWildcard"></a>[95]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ElementName">ElementName</a>  |  "*"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SchemaElementTest"></a>[96]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"schema-element"  "("  <a href="#prod-xpath31-ElementDeclaration">ElementDeclaration</a>  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ElementDeclaration"></a>[97]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ElementDeclaration">ElementDeclaration</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-ElementName">ElementName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AttributeName"></a>[98]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AttributeName">AttributeName</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ElementName"></a>[99]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ElementName">ElementName</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-SimpleTypeName"></a>[100]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code>SimpleTypeName</code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-TypeName">TypeName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TypeName"></a>[101]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TypeName">TypeName</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-EQName">EQName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-FunctionTest"></a>[102]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-FunctionTest">FunctionTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AnyFunctionTest">AnyFunctionTest</a>
                              <br>|  <a href="#prod-xpath31-TypedFunctionTest">TypedFunctionTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AnyFunctionTest"></a>[103]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"function"  "("  "*"  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TypedFunctionTest"></a>[104]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"function"  "("  (<a href="#prod-xpath31-SequenceType">SequenceType</a>  (","  <a href="#prod-xpath31-SequenceType">SequenceType</a>)*)?  ")"  "as"  <a href="#prod-xpath31-SequenceType">SequenceType</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-MapTest"></a>[105]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-MapTest">MapTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AnyMapTest">AnyMapTest</a>  |  <a href="#prod-xpath31-TypedMapTest">TypedMapTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AnyMapTest"></a>[106]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AnyMapTest">AnyMapTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"map"  "("  "*"  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TypedMapTest"></a>[107]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TypedMapTest">TypedMapTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"map"  "("  <a href="#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>  ","  <a href="#prod-xpath31-SequenceType">SequenceType</a>  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ArrayTest"></a>[108]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ArrayTest">ArrayTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-AnyArrayTest">AnyArrayTest</a>  |  <a href="#prod-xpath31-TypedArrayTest">TypedArrayTest</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-AnyArrayTest"></a>[109]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-AnyArrayTest">AnyArrayTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"array"  "("  "*"  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-TypedArrayTest"></a>[110]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"array"  "("  <a href="#prod-xpath31-SequenceType">SequenceType</a>  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-ParenthesizedItemType"></a>[111]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>"("  <a href="#prod-xpath31-ItemType">ItemType</a>  ")"</code></td>
                        <td></td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xpath31-EQName"></a>[112]&nbsp;&nbsp;&nbsp;
                        </td>
                        <td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
                        <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                        <td><code>
                              <a href="#prod-xpath31-QName">QName</a>  |  <a href="#prod-xpath31-URIQualifiedName">URIQualifiedName</a>
                              </code></td>
                        <td></td>
                     </tr>
                  </tbody>
               </table>
               <div class="div3">
                  
                  <h4><a id="EBNFNotation"></a>A.1.1 Notation
                  </h4>
                  <p>
                     [<a id="symbol" title="symbol">Definition</a>: Each rule in the grammar defines one <b>symbol</b>,
                     using the following format: 
                  </p>
                  <div class="exampleInner"><pre>symbol ::= expression</pre></div>
                  <p>
                     ]
                     
                  </p>
                  <p>
                     [<a id="terminal" title="terminal">Definition</a>: A <b>terminal</b> is a symbol or string or
                     pattern that can appear in the right-hand side of a rule, but never appears on the
                     left-hand side in the main grammar, although it may appear on the left-hand side of
                     a rule
                     in the grammar for terminals.] The following constructs are used to match strings
                     of one or more characters in a terminal:
                  </p>
                  <dl>
                     <dt class="label">[a-zA-Z]</dt>
                     <dd>
                        <p>matches any <a href="#prod-xpath31-Char">Char</a> with a value in the range(s) indicated
                           (inclusive).
                        </p>
                     </dd>
                     <dt class="label">[abc]</dt>
                     <dd>
                        <p>matches any <a href="#prod-xpath31-Char">Char</a> with a value among the characters enumerated.
                           
                        </p>
                     </dd>
                     <dt class="label">[^abc]</dt>
                     <dd>
                        <p>matches any <a href="#prod-xpath31-Char">Char</a> with a value not among the characters given.
                        </p>
                     </dd>
                     <dt class="label">"string"</dt>
                     <dd>
                        <p>matches the sequence of characters that appear inside the double quotes.</p>
                     </dd>
                     <dt class="label">'string'</dt>
                     <dd>
                        <p>matches the sequence of characters that appear inside the single quotes.</p>
                     </dd>
                     <dt class="label"> [http://www.w3.org/TR/REC-example/#NT-Example]</dt>
                     <dd>
                        <p>matches any string matched by the production defined in the external specification
                           as
                           per the provided reference.
                        </p>
                     </dd>
                  </dl>
                  <p>Patterns (including the above constructs) can be combined with grammatical operators
                     to
                     form more complex patterns, matching more complex sets of character strings. In the
                     examples
                     that follow, A and B represent (sub-)patterns.
                  </p>
                  <dl>
                     <dt class="label">(A)</dt>
                     <dd>
                        <p>
                           <code>A</code> is treated as a unit and may be combined as described in this list.
                        </p>
                     </dd>
                     <dt class="label">A?</dt>
                     <dd>
                        <p>matches <code>A</code> or nothing; optional <code>A</code>.
                        </p>
                     </dd>
                     <dt class="label">A B</dt>
                     <dd>
                        <p>matches <code>A</code> followed by <code>B</code>. This operator has higher
                           precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) |
                              (C D)</code>.
                        </p>
                     </dd>
                     <dt class="label">A | B</dt>
                     <dd>
                        <p>matches <code>A</code> or <code>B</code> but not both.
                        </p>
                     </dd>
                     <dt class="label">A - B</dt>
                     <dd>
                        <p>matches any string that matches <code>A</code> but does not match <code>B</code>.
                        </p>
                     </dd>
                     <dt class="label">A+</dt>
                     <dd>
                        <p>matches one or more occurrences of <code>A</code>. Concatenation has higher
                           precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) |
                              (B+)</code>.
                        </p>
                     </dd>
                  </dl>
                  <dl>
                     <dt class="label">A*</dt>
                     <dd>
                        <p>matches zero or more occurrences of <code>A</code>. Concatenation has higher
                           precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) |
                              (B*)</code>
                           
                        </p>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="extra-grammatical-constraints"></a>A.1.2 Extra-grammatical Constraints
                  </h4>
                  <p>This section contains constraints on the EBNF productions, which are required to parse
                     syntactically valid sentences. The notes below are referenced from the right side
                     of the
                     production, with the notation: <em>/* xgc: &lt;id&gt; */</em>.
                  </p>
                  <div class="constraint">
                     <p class="prefix"><a id="parse-note-leading-lone-slash"></a><b>Constraint: leading-lone-slash</b></p>
                     <p>A single slash may appear either as a complete path expression or as the first part
                        of a
                        path expression in which it is followed by a <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>. In some cases, the next token after the slash is insufficient to
                        allow a parser to distinguish these two possibilities: the <code>*</code> token and
                        keywords like <code>union</code> could be either an operator or a <a href="#doc-xpath31-NameTest">NameTest</a>
                        . For example,
                        without lookahead the first part of the expression <code>/ * 5</code> is easily taken to
                        be a complete expression, <code>/ *</code>, which has a very different
                        interpretation (the child nodes of <code>/</code>).
                     </p>
                     <p>If the token immediately following a slash
                        can form the start of a <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>, then the slash
                        must be the beginning of a <a href="#doc-xpath31-PathExpr">PathExpr</a>, not the entirety of it.
                     </p>
                     <p>A single slash may be used as the left-hand argument of an operator by parenthesizing
                        it:
                        <code>(/) * 5</code>. The expression <code>5 *
                           /</code>, on the other hand, is syntactically valid without parentheses.
                     </p>
                  </div>
                  <div class="constraint">
                     <p class="prefix"><a id="parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
                     <p>The version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>,
                        or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. It is recommended that
                        the latest applicable version be used (even if it is published later than this
                        specification). The EBNF in this specification links only to the 1.0 versions. Note
                        also
                        that these external productions follow the whitespace rules of their respective
                        specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>. Thus <code>prefix : localname</code> is not a
                        syntactically valid <a title="lexical QName" href="#dt-qname">lexical QName</a> for purposes of this
                        specification, just as it is not permitted in a XML document. Also, comments are not
                        permissible on either side of the colon. Also extra-grammatical constraints such as
                        well-formedness constraints must be taken into account.
                     </p>
                  </div>
                  <div class="constraint">
                     <p class="prefix"><a id="parse-note-reserved-function-names"></a><b>Constraint: reserved-function-names</b></p>
                     <p>Unprefixed function names spelled the same way as language keywords could make the
                        language impossible to parse. For instance, <code>element(foo)</code> could be taken either as
                        a <a href="#doc-xpath31-FunctionCall">FunctionCall</a> or as an <a href="#doc-xpath31-ElementTest">ElementTest</a>. Therefore, an unprefixed function name must not be any of the names in
                        <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.
                     </p>
                     <p>A function named "if" can be called by binding its namespace to a prefix and using
                        the
                        prefixed form: "library:if(foo)" instead of "if(foo)".
                     </p>
                  </div>
                  <div class="constraint">
                     <p class="prefix"><a id="parse-note-occurrence-indicators"></a><b>Constraint: occurrence-indicators</b></p>
                     <p>As written, the grammar in <a href="#nt-bnf"><b>A XPath 3.1 Grammar</b></a> is ambiguous for some forms using the
                        '+' and '*' occurrence indicators. The ambiguity is resolved as follows: these operators
                        are
                        tightly bound to the <a href="#doc-xpath31-SequenceType">SequenceType</a> expression, and have higher
                        precedence than other uses of these symbols. Any occurrence of '+' and '*', as well
                        as
                        '?', following a sequence type is assumed to be an occurrence indicator, which binds
                        to
                        the last <a href="#doc-xpath31-ItemType">ItemType</a> in the <a href="#doc-xpath31-SequenceType">SequenceType</a>.
                     </p>
                     <p>Thus, <code>4 treat as item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>, taking the '+' as an
                        OccurrenceIndicator and the '-' as a subtraction operator. To force the interpretation
                        of
                        "+" as an addition operator (and the corresponding interpretation of the "-" as a
                        unary
                        minus), parentheses may be used: the form <code>(4 treat as item()) +
                           -5</code> surrounds the <a href="#doc-xpath31-SequenceType">SequenceType</a> expression with
                        parentheses and leads to the desired interpretation.
                     </p>
                     <p>
                        <code>function () as xs:string *</code> is interpreted as <code>function () as (xs:string
                           *)</code>, not as <code>(function () as xs:string) *</code>. Parentheses can be used as
                        shown to force the latter interpretation.
                     </p>
                     <p>This rule has as a consequence that certain forms which would otherwise be syntactically
                        valid and unambiguous are not recognized: in "4 treat as item() + 5", the "+" is taken
                        as
                        an <a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>, and not as an operator, which
                        means this is not a syntactically valid expression.
                     </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="notes-on-parsing"></a>A.1.3 Grammar Notes
                  </h4>
                  <p>This section contains general notes on the EBNF productions, which may be helpful
                     in
                     understanding how to interpret and implement the EBNF. These notes are not normative.
                     The
                     notes below are referenced from the right side of the production, with the notation:
                     <em>/* gn: &lt;id&gt; */</em>.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <dl>
                        <dt class="label"><a id="parse-note-parens"></a>grammar-note: parens
                        </dt>
                        <dd>
                           <p>Look-ahead is required to distinguish <a href="#doc-xpath31-FunctionCall">FunctionCall</a> from
                              a EQName or keyword followed by a 
                              <a href="#doc-xpath31-Comment">Comment</a>. For example: <code>address (: this
                                 may be empty :)</code> may be mistaken for a call to a function named "address"
                              unless this lookahead is employed. Another example is <code>for (:
                                 whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must
                              not be mistaken for a function name.
                           </p>
                        </dd>
                        <dt class="label"><a id="parse-note-comments"></a>grammar-note: comments
                        </dt>
                        <dd>
                           <p>Comments are allowed everywhere that <a title="ignorable whitespace" href="#IgnorableWhitespace">ignorable
                                 whitespace</a> is allowed, and the <a href="#doc-xpath31-Comment">Comment</a> symbol
                              does not explicitly appear on the right-hand side of the grammar (except in its own
                              production). See <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>. 
                           </p>
                           <p>A comment can contain nested comments, as long as all "(:" and ":)" patterns are
                              balanced, no matter where they occur within the outer comment.
                           </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Lexical analysis may typically handle nested comments by incrementing a counter
                                 for each "(:" pattern, and decrementing the counter for each ":)" pattern. The
                                 comment does not terminate until the counter is back to zero.
                              </p>
                           </div>
                           <p>Some illustrative examples:</p>
                           <ul>
                              <li>
                                 <p>
                                    <code>(: commenting out a (: comment :) may be confusing, but often helpful
                                       :)</code> is a syntactically valid Comment, since balanced nesting of comments
                                    is allowed.
                                 </p>
                              </li>
                              <li>
                                 <p>
                                    <code>"this is just a string :)"</code> is a syntactically
                                    valid expression. However, <code>(: "this is just a string :)" :)</code> will
                                    cause a syntax error. Likewise, <code>"this is another string
                                       (:"</code> is a syntactically valid expression, but <code>(: "this is another
                                       string (:" :)</code> will cause a syntax error. It is a limitation of nested
                                    comments that literal content can cause unbalanced nesting of comments.
                                 </p>
                              </li>
                              <li>
                                 <p>
                                    <code>for (: set up loop :) $i in $x return $i</code> is
                                    syntactically valid, ignoring the comment.
                                 </p>
                              </li>
                              <li>
                                 <p>
                                    <code>5 instance (: strange place for a comment :) of
                                       xs:integer</code> is also syntactically valid.
                                 </p>
                              </li>
                           </ul>
                        </dd>
                     </dl>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="lexical-structure"></a>A.2 Lexical structure
               </h3>
               <p>The terminal symbols assumed by the grammar above are described in this section.</p>
               <p>Quoted strings appearing in production rules are terminal symbols.</p>
               <p>Other terminal symbols are defined in <a href="#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.
               </p>
               <p>Some productions are defined by reference to the XML and XML Names specifications
                  (e.g.
                  <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> . <span class="xpath">A host language may choose</span> which version of these specifications is
                  used; it is recommended that the latest applicable version be used (even if it is
                  published
                  later than this specification).
               </p>
               <p class="xpath">A <b>host language</b> may choose whether the lexical rules of <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> are followed, or alternatively, the lexical rules
                  of <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> are followed.
               </p>
               <p>When tokenizing, the longest possible match that is consistent with the EBNF is used.</p>
               <p>All keywords are case sensitive. Keywords are not reserved—that is, any <a title="lexical QName" href="#dt-qname">lexical QName</a> may duplicate a keyword except as noted in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.
               </p>
               <div class="div3">
                  
                  <h4><a id="terminal-symbols"></a>A.2.1 Terminal Symbols
                  </h4>
                  <a id="d2e20679"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-IntegerLiteral"></a>[113]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#prod-xpath31-Digits">Digits</a>
                                 </code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-DecimalLiteral"></a>[114]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-DecimalLiteral">DecimalLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>("."  <a href="#prod-xpath31-Digits">Digits</a>)  |  (<a href="#prod-xpath31-Digits">Digits</a>  "."  [0-9]*)</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-DoubleLiteral"></a>[115]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(("."  <a href="#prod-xpath31-Digits">Digits</a>)  |  (<a href="#prod-xpath31-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#prod-xpath31-Digits">Digits</a>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-StringLiteral"></a>[116]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-StringLiteral">StringLiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>('"'  (<a href="#prod-xpath31-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"')  |  ("'"  (<a href="#prod-xpath31-EscapeApos">EscapeApos</a>  |  [^'])*  "'")</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-URIQualifiedName"></a>[117]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a>  
                                 <a href="#prod-xpath31-NCName">NCName</a>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-BracedURILiteral"></a>[118]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"Q"  "{"  [^{}]*  "}"</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-EscapeQuot"></a>[119]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-EscapeQuot">EscapeQuot</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>'""'</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-EscapeApos"></a>[120]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-EscapeApos">EscapeApos</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"''"</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-Comment"></a>[121]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-Comment">Comment</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>"(:"  (<a href="#prod-xpath31-CommentContents">CommentContents</a>  |  <a href="#prod-xpath31-Comment">Comment</a>)*  ":)"</code></td>
                           <td><i>/* 
                                 <a href="#ws-explicit">ws: explicit</a>
                                 */</i></td>
                        </tr>
                        <tr style="vertical-align:baseline;">
                           <td></td>
                           <td></td>
                           <td></td>
                           <td></td>
                           <td><i>/* 
                                 <a href="#parse-note-comments">gn: comments</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-QName"></a>[122]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-QName">QName</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="https://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#parse-note-xml-version">xgc: xml-version</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-NCName"></a>[123]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>NCName</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#parse-note-xml-version">xgc: xml-version</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-Char"></a>[124]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code>Char</code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>
                                 <a href="https://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup>
                                 </code></td>
                           <td><i>/* 
                                 <a href="#parse-note-xml-version">xgc: xml-version</a>
                                 */</i></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The following symbols are used only in the definition of terminal symbols; they are
                     not
                     terminal symbols in the grammar of <a href="#id-grammar"><b>A.1 EBNF</b></a>.
                  </p>
                  <a id="d2e20841"></a><table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-Digits"></a>[125]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-Digits">Digits</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>[0-9]+</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="prod-xpath31-CommentContents"></a>[126]&nbsp;&nbsp;&nbsp;
                           </td>
                           <td><code><a href="#doc-xpath31-CommentContents">CommentContents</a></code></td>
                           <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
                           <td><code>(<a href="#prod-xpath31-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td>
                           <td></td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-terminal-delimitation"></a>A.2.2 Terminal Delimitation
                  </h4>
                  <p>XPath 3.1 expressions consist of <a href="#terminal-symbols">terminal symbols</a> and
                     <a title="symbol separators" href="#symbolseparators">symbol separators</a>.
                  </p>
                  <p>Terminal symbols that are not used exclusively in <a href="#ws-explicit">/* ws: explicit
                        */</a> productions are of two kinds: delimiting and non-delimiting.
                  </p>
                  <p>
                     [<a id="delimiting-token" title="delimiting terminal symbol">Definition</a>: The <b>delimiting
                        terminal symbols</b> are: "!", "!=", <a href="#prod-xpath31-StringLiteral">StringLiteral</a>, "#", "$", "(", ")", "*", "*:", "+", (comma), "-", (dot), "..", "/", "//", (colon),
                     ":*", "::", ":=", "&lt;", "&lt;&lt;", "&lt;=", "=", "=&gt;", "&gt;", "&gt;=", "&gt;&gt;", "?", "@", <a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a>, "[", "]", "{", "|", "||", "}"
                     ]
                     
                  </p>
                  <p>
                     [<a id="non-delimiting-token" title="non-delimiting terminal symbol">Definition</a>: The
                     <b>non-delimiting terminal symbols</b> are: <a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xpath31-URIQualifiedName">URIQualifiedName</a>, <a href="#prod-xpath31-NCName">NCName</a>, <a href="#prod-xpath31-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xpath31-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath31-QName">QName</a>, "ancestor", "ancestor-or-self", "and", "array", "as", "attribute", "cast", "castable",
                     "child", "comment", "descendant", "descendant-or-self", "div", "document-node", "element",
                     "else", "empty-sequence", "eq", "every", "except", "following", "following-sibling",
                     "for", "function", "ge", "gt", "idiv", "if", "in", "instance", "intersect", "is",
                     "item", "le", "let", "lt", "map", "mod", "namespace", "namespace-node", "ne", "node",
                     "of", "or", "parent", "preceding", "preceding-sibling", "processing-instruction",
                     "return", "satisfies", "schema-attribute", "schema-element", "self", "some", "text",
                     "then", "to", "treat", "union"
                     ]
                     
                  </p>
                  <p>
                     [<a id="symbolseparators" title="symbol separators">Definition</a>: 
                     <a title="whitespace" href="#Whitespace">Whitespace</a> and <a href="#doc-xpath31-Comment">Comments</a>
                     function as <b>symbol separators</b>. For the most part, they are not mentioned in
                     the grammar, and may occur between any two terminal symbols mentioned in the grammar,
                     except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a>
                     annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version
                        */</a> annotation.]
                     
                  </p>
                  <p>
                     One or more <a title="symbol separators" href="#symbolseparators">symbol separators</a>
                     are required between two consecutive terminal symbols
                     T and U (where T precedes U) when any of the following is true:
                     
                  </p>
                  <ul>
                     <li>
                        <p>T and U are both <a title="non-delimiting terminal symbol" href="#non-delimiting-token">non-delimiting terminal symbols</a>.
                        </p>
                     </li>
                     <li>
                        <p>T is a QName or an NCName and U is "." or "-".</p>
                     </li>
                     <li>
                        <p>T is a numeric literal and U is ".", or vice versa.</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-eol-handling"></a>A.2.3 End-of-Line Handling
                  </h4>
                  <p class="xpath">The host language must specify whether the XPath 3.1 processor normalizes all
                     line breaks on input, before parsing, and if it does so, whether it uses the rules
                     of
                     <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML 1.1]</a>. 
                  </p>
                  <div class="div4">
                     
                     <h5><a id="id-xml10-eol-handling"></a>A.2.3.1 XML 1.0 End-of-Line Handling
                     </h5>
                     <p>For <a href="#XML">[XML 1.0]</a> processing, all of the following must be translated to a single
                        #xA character:
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>the two-character sequence #xD #xA</p>
                        </li>
                        <li>
                           <p>any #xD character that is not immediately followed by #xA.</p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-xml11-eol-handling"></a>A.2.3.2 XML 1.1 End-of-Line Handling
                     </h5>
                     <p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the following must be translated to a
                        single #xA character:
                     </p>
                     <ol class="enumar">
                        <li>
                           <p>the two-character sequence #xD #xA</p>
                        </li>
                        <li>
                           <p>the two-character sequence #xD #x85</p>
                        </li>
                        <li>
                           <p>the single character #x85</p>
                        </li>
                        <li>
                           <p>the single character #x2028</p>
                        </li>
                        <li>
                           <p>any #xD character that is not immediately followed by #xA or #x85.</p>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="whitespace-rules"></a>A.2.4 Whitespace Rules
                  </h4>
                  <div class="div4">
                     
                     <h5><a id="DefaultWhitespaceHandling"></a>A.2.4.1 Default Whitespace Handling
                     </h5>
                     <p>
                        [<a id="Whitespace" title="whitespace">Definition</a>: A <b>whitespace</b> character is any of
                        the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S">
                           [http://www.w3.org/TR/REC-xml/#NT-S]</a>.]
                        
                     </p>
                     <p>
                        [<a id="IgnorableWhitespace" title="ignorable whitespace">Definition</a>: 
                        <b>Ignorable whitespace</b> consists of any <a title="whitespace" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" href="#terminal">terminals</a>, unless these characters occur in the context of a production
                        marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in
                        which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit Whitespace Handling</b></a>).] Ignorable whitespace characters are not
                        significant to the semantics of an expression. Whitespace is allowed before the first
                        terminal and after the last terminal <span class="xpath">of an XPath expression</span>. Whitespace is allowed between any two <a title="terminal" href="#terminal">terminals</a>. <a href="#doc-xpath31-Comment">Comments</a> may also act as
                        "whitespace" to prevent two adjacent terminals from being recognized as one. Some
                        illustrative examples are as follows:
                     </p>
                     <ul>
                        <li>
                           <p>
                              <code>foo- foo</code> results in a syntax error. "foo-" would be recognized as a
                              QName.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>foo -foo</code> is syntactically equivalent to <code>foo - foo</code>, two QNames separated by a subtraction
                              operator.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>foo(: This is a comment :)- foo</code> is syntactically
                              equivalent to <code>foo - foo</code>. This is because the comment prevents the two
                              adjacent terminals from being recognized as one.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>foo-foo</code> is syntactically equivalent to single QName.
                              This is because "-" is a valid character in a QName. When used as an operator after
                              the characters of a name, the "-" must be separated from the name, e.g. by using
                              whitespace or parentheses.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>10div 3</code> results in a syntax error.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>10 div3</code> also results in a syntax error.
                           </p>
                        </li>
                        <li>
                           <p>
                              <code>10div3</code> also results in a syntax error.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="ExplicitWhitespaceHandling"></a>A.2.4.2 Explicit Whitespace Handling
                     </h5>
                     <p>Explicit whitespace notation is specified with the EBNF productions, when it is different
                        from the default rules, using the notation shown below. This notation is not inherited.
                        In
                        other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not
                        automatically apply to all the 'child' EBNF productions of that rule.
                     </p>
                     <dl>
                        <dt class="label"><a id="ws-explicit"></a>ws: explicit
                        </dt>
                        <dd>
                           <p>/* ws: explicit */ means that the EBNF notation explicitly notates, with
                              <code>S</code> or otherwise, where <a title="whitespace" href="#Whitespace">whitespace
                                 characters</a> are allowed. In productions with the /* ws: explicit */
                              annotation, <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a> does not apply.
                              		  Comments are  not allowed in these productions <span>except where the <a href="#doc-xpath31-Comment">Comment</a> non-terminal appears</span>.
                              	      
                           </p>
                        </dd>
                     </dl>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-reserved-fn-names"></a>A.3 Reserved Function Names
               </h3>
               <p>The following names are not allowed as function names in an unprefixed form because
                  expression syntax takes precedence.
               </p>
               <ul>
                  <li>
                     <p>
                        <code>array</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>attribute</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>comment</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>document-node</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>element</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>empty-sequence</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>function</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>if</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>item</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>map</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>namespace-node</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>node</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>processing-instruction</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>schema-attribute</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>schema-element</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>switch</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>text</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>typeswitch</code>
                        
                     </p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p> Although the keywords <code>switch</code> and <code>typeswitch</code> are not used in
                     XPath, they are considered reserved function names for compatibility with XQuery.
                     
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-precedence-order"></a>A.4 Precedence Order (Non-Normative)
               </h3>
               <p>The grammar in <a href="#id-grammar"><b>A.1 EBNF</b></a> normatively defines built-in precedence among the
                  operators of <span class="xpath">XPath</span>. These operators are summarized here to make clear the order of their
                  precedence from lowest to highest. The associativity column indicates the order in
                  which
                  operators of equal precedence in an expression are applied.
               </p>
               <table class="medium">
                  <tbody>
                     <tr>
                        <th>#</th>
                        <th>Operator</th>
                        <th>Associativity</th>
                     </tr>
                     <tr>
                        <td>1</td>
                        <td>
                           <a href="#doc-xpath31-Expr">, (comma)</a>
                           
                        </td>
                        <td>either</td>
                     </tr>
                     <tr>
                        <td>2</td>
                        <td>
                           <span class="xpath">
                              <a href="#doc-xpath31-ForExpr">for</a>,</span>
                           <span class="xpath">
                              <a href="#doc-xpath31-LetExpr">let</a>,</span>
                           
                           <a href="#doc-xpath31-QuantifiedExpr">some, every</a>, 
                           
                           
                           <a href="#doc-xpath31-IfExpr">if</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>3</td>
                        <td>
                           <a href="#doc-xpath31-OrExpr">or</a>
                           
                        </td>
                        <td>either</td>
                     </tr>
                     <tr>
                        <td>4</td>
                        <td>
                           <a href="#doc-xpath31-AndExpr">and</a>
                           
                        </td>
                        <td>either</td>
                     </tr>
                     <tr>
                        <td>5</td>
                        <td>
                           <a href="#doc-xpath31-ValueComp">eq, ne, lt, le, gt, ge</a>, <a href="#doc-xpath31-GeneralComp">=, !=, &lt;,
                              &lt;=, &gt;, &gt;=</a>, <a href="#doc-xpath31-NodeComp">is, &lt;&lt;, &gt;&gt;</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>6</td>
                        <td>
                           <a href="#doc-xpath31-StringConcatExpr">||</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>7</td>
                        <td>
                           <a href="#doc-xpath31-RangeExpr">to</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>8</td>
                        <td>
                           <a href="#doc-xpath31-AdditiveExpr">+, - (binary)</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>9</td>
                        <td>
                           <a href="#doc-xpath31-MultiplicativeExpr">*, div, idiv, mod</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>10</td>
                        <td>
                           <a href="#doc-xpath31-UnionExpr">union, |</a>
                           
                        </td>
                        <td>either</td>
                     </tr>
                     <tr>
                        <td>11</td>
                        <td>
                           <a href="#doc-xpath31-IntersectExceptExpr">intersect, except</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>12</td>
                        <td>
                           <a href="#doc-xpath31-InstanceofExpr">instance of</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>13</td>
                        <td>
                           <a href="#doc-xpath31-TreatExpr">treat as</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>14</td>
                        <td>
                           <a href="#doc-xpath31-CastableExpr">castable as</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>15</td>
                        <td>
                           <a href="#doc-xpath31-CastExpr">cast as</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                     <tr>
                        <td>16</td>
                        <td>
                           <a href="#doc-xpath31-ArrowExpr">=&gt;</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>17</td>
                        <td>
                           <a href="#doc-xpath31-UnaryExpr">-, + (unary)</a>
                           
                        </td>
                        <td>right-to-left</td>
                     </tr>
                     <tr>
                        <td>18</td>
                        <td>
                           <a href="#doc-xpath31-SimpleMapExpr">!</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>19</td>
                        <td>
                           <a href="#doc-xpath31-PathExpr">/, //</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>20</td>
                        <td>
                           <a href="#doc-xpath31-Predicate">[ ]</a>, <a href="#doc-xpath31-Lookup">?</a>
                           
                        </td>
                        <td>left-to-right</td>
                     </tr>
                     <tr>
                        <td>21</td>
                        <td>
                           <a href="#doc-xpath31-UnaryLookup">? (unary)</a>
                           
                        </td>
                        <td>NA</td>
                     </tr>
                  </tbody>
               </table>
               <p> In the "Associativity" column, "either" indicates that all the operators at that
                  level have
                  the associative property (i.e., <code>(A op B) op C</code> is equivalent to <code>A op (B op
                     C)</code>), so their associativity is inconsequential. "NA" (not applicable) indicates that
                  the EBNF does not allow an expression that directly contains multiple operators from
                  that
                  precedence level, so the question of their associativity does not arise. 
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Parentheses can be used to override the operator precedence in the usual way. Square
                     brackets in an expression such as A[B] serve two roles: they act as an operator causing
                     B to
                     be evaluated once for each item in the value of A, and they act as parentheses enclosing
                     the
                     expression B.
                  </p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-type-promotion-and-operator-mapping"></a>B Type Promotion and Operator Mapping
            </h2>
            <div class="div2">
               
               <h3><a id="promotion"></a>B.1 Type Promotion
               </h3>
               <p>
                  [<a id="dt-type-promotion" title="type promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from
                  one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>)  and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).] The following type promotions are permitted:
               </p>
               <ol class="enumar">
                  <li>
                     <p>Numeric type promotion:</p>
                     <ol class="enumla">
                        <li>
                           <p>A value of type <code>xs:float</code> (or any type
                              derived by restriction from <code>xs:float</code>) can be promoted to
                              the type <code>xs:double</code>. The result is the
                              <code>xs:double</code> value that is the same as the original
                              value.
                           </p>
                        </li>
                        <li>
                           <p>A value of type <code>xs:decimal</code> (or any type derived
                              by restriction from <code>xs:decimal</code>) can be promoted to either
                              of the types <code>xs:float</code> or <code>xs:double</code>.  The
                              result of this promotion is created by casting the original value to
                              the required type. This kind of promotion may cause loss of
                              precision.
                           </p>
                        </li>
                     </ol>
                  </li>
                  <li>
                     <p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type
                        <code>xs:string</code>.
                     </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <a title="default collation" href="#dt-def-collation">default collation</a> also compare <code>xs:anyURI</code> values using the <a title="default collation" href="#dt-def-collation">default collation</a>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.
                        </p>
                     </div>
                  </li>
               </ol>
               <p>Note that <a title="type promotion" href="#dt-type-promotion">type promotion</a> is different from <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. For example:
               </p>
               <ul>
                  <li>
                     <p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <a title="type promotion" href="#dt-type-promotion">type promotion</a>. The value is actually converted to the expected type. Within the body of the function,
                        <code>$p instance of xs:decimal</code> returns <code>false</code>.
                     </p>
                  </li>
                  <li>
                     <p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="mapping"></a>B.2 Operator Mapping
               </h3>
               <p>The operator mapping tables in this section list the
                  combinations of types for which the various operators of XPath 3.1
                  are defined. [<a id="dt-operator-function" title="operator function">Definition</a>: For each operator and valid combination of operand types, the operator mapping tables
                  specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.] The definitions
                  of the operator functions are given in  <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>. The result of an operator may be the raising of an error by its operator function,
                  as defined in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>. The operator function fully defines the semantics of a given operator for the case
                  where the operands are single atomic values of the types given in the table. For the
                  definition of each operator (including its
                  behavior for empty sequences or sequences of length greater than one),
                  see the descriptive material in the main part of this
                  document.
               </p>
               <p>The <code>and</code> and
                  <code>or</code> operators are defined directly in the main body of
                  this document, and do not occur in the operator mapping tables.
               </p>
               <p>If an operator in the operator mapping tables expects an operand of type
                  <em>ET</em>, that operator can be applied to an operand of type <em>AT</em> if type <em>AT</em> can
                  be converted to type <em>ET</em> by a combination of <a title="type promotion" href="#dt-type-promotion">type promotion</a> and <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. For example, a table entry indicates that the <code>gt</code> operator may
                  be applied to two <code>xs:date</code> operands, returning
                  <code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
                  also be applied to two (possibly different) subtypes of
                  <code>xs:date</code>, also returning <code>xs:boolean</code>.
               </p>
               <p>
                  [<a id="dt-numeric" title="numeric">Definition</a>: When referring to a type, the term <b>numeric</b> denotes the types
                  <code>xs:integer</code>, <code>xs:decimal</code>,
                  <code>xs:float</code>, and <code>xs:double</code>
                  <span>which are all member types of the built-in union type <code>xs:numeric</code>
                     </span>.] An operator whose
                  operands and result are designated as <a title="numeric" href="#dt-numeric">numeric</a> might be
                  thought of as representing four operators, one for each of the numeric
                  types. For example, the numeric <code>+</code> operator might be
                  thought of as representing the following four operators:
               </p>
               <table style="width:80%" class="medium">
                  <tbody>
                     <tr>
                        <th style="text-align:center">Operator</th>
                        <th style="text-align:center">First operand type</th>
                        <th style="text-align:center">Second operand type</th>
                        <th style="text-align:center">Result type</th>
                     </tr>
                     <tr>
                        <td style="text-align:center">
                           <code>+</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:integer</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:integer</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:integer</code>
                           
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align:center">
                           <code>+</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:decimal</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:decimal</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:decimal</code>
                           
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align:center">
                           <code>+</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:float</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:float</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:float</code>
                           
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align:center">
                           <code>+</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:double</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:double</code>
                           
                        </td>
                        <td style="text-align:center">
                           <code>xs:double</code>
                           
                        </td>
                     </tr>
                  </tbody>
               </table>
               <p>A numeric operator may be validly applied to an operand of type <em>AT</em> if type
                  <em>AT</em> can be converted to any of the four numeric types by a combination of
                  <a title="type promotion" href="#dt-type-promotion">type promotion</a> and <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. If the result type of an
                  operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a> and <a title="type promotion" href="#dt-type-promotion">type promotion</a>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.
               </p>
               <p>
                  [<a id="dt-gregorian" title="Gregorian">Definition</a>: In the operator mapping tables,
                  the term <b>Gregorian</b> refers to the types
                  <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                  <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
                  <code>xs:gMonth</code>.]  For binary operators that accept two
                  Gregorian-type operands, both operands must have the same type (for
                  example, if one operand is of type <code>xs:gDay</code>, the other
                  operand must be of type <code>xs:gDay</code>.)
               </p>
               <table style="border:1px solid" class="small">
                  <caption>Binary Operators</caption>
                  <tbody>
                     <tr>
                        <th>Operator</th>
                        <th>Type(A)</th>
                        <th>Type(B)</th>
                        <th>Function</th>
                        <th>Result type</th>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-add(A, B)</td>
                        <td>numeric</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:date</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:add-yearMonthDuration-to-date(A, B)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:date</td>
                        <td>op:add-yearMonthDuration-to-date(B, A)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:date</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:add-dayTimeDuration-to-date(A, B)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:date</td>
                        <td>op:add-dayTimeDuration-to-date(B, A)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:time</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:add-dayTimeDuration-to-time(A, B)</td>
                        <td>xs:time</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:time</td>
                        <td>op:add-dayTimeDuration-to-time(B, A)</td>
                        <td>xs:time</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dateTime</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:dateTime</td>
                        <td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dateTime</td>
                        <td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:add-yearMonthDurations(A, B)</td>
                        <td>xs:yearMonthDuration</td>
                     </tr>
                     <tr>
                        <td>A + B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:add-dayTimeDurations(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-subtract(A, B)</td>
                        <td>numeric</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>op:subtract-dates(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:date</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:subtract-yearMonthDuration-from-date(A, B)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:date</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:subtract-dayTimeDuration-from-date(A, B)</td>
                        <td>xs:date</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>op:subtract-times(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:time</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:subtract-dayTimeDuration-from-time(A, B)</td>
                        <td>xs:time</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>op:subtract-dateTimes(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:dateTime</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
                        <td>xs:dateTime</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:subtract-yearMonthDurations(A, B)</td>
                        <td>xs:yearMonthDuration</td>
                     </tr>
                     <tr>
                        <td>A - B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:subtract-dayTimeDurations(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A * B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-multiply(A, B)</td>
                        <td>numeric</td>
                     </tr>
                     <tr>
                        <td>A * B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>numeric</td>
                        <td>op:multiply-yearMonthDuration(A, B)</td>
                        <td>xs:yearMonthDuration</td>
                     </tr>
                     <tr>
                        <td>A * B</td>
                        <td>numeric</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:multiply-yearMonthDuration(B, A)</td>
                        <td>xs:yearMonthDuration</td>
                     </tr>
                     <tr>
                        <td>A * B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>numeric</td>
                        <td>op:multiply-dayTimeDuration(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A * B</td>
                        <td>numeric</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:multiply-dayTimeDuration(B, A)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A idiv B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-integer-divide(A, B)</td>
                        <td>xs:integer</td>
                     </tr>
                     <tr>
                        <td>A div B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-divide(A, B)</td>
                        <td>numeric; but xs:decimal if both operands are xs:integer</td>
                     </tr>
                     <tr>
                        <td>A div B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>numeric</td>
                        <td>op:divide-yearMonthDuration(A, B)</td>
                        <td>xs:yearMonthDuration</td>
                     </tr>
                     <tr>
                        <td>A div B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>numeric</td>
                        <td>op:divide-dayTimeDuration(A, B)</td>
                        <td>xs:dayTimeDuration</td>
                     </tr>
                     <tr>
                        <td>A div B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
                        <td>xs:decimal</td>
                     </tr>
                     <tr>
                        <td>A div B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
                        <td>xs:decimal</td>
                     </tr>
                     <tr>
                        <td>A mod B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-mod(A, B)</td>
                        <td>numeric</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>op:boolean-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>op:numeric-equal(fn:compare(A, B), 0)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>op:date-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>op:time-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>op:dateTime-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:duration</td>
                        <td>xs:duration</td>
                        <td>op:duration-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>Gregorian</td>
                        <td>Gregorian</td>
                        <td>op:gYear-equal(A, B) etc.</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>op:hexBinary-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>op:base64Binary-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:QName</td>
                        <td>xs:QName</td>
                        <td>op:QName-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:NOTATION</td>
                        <td>xs:NOTATION</td>
                        <td>op:NOTATION-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>op:hexBinary-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A eq B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>op:hexBinary-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>fn:not(op:numeric-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>fn:not(op:boolean-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>fn:not(op:date-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>fn:not(op:time-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>fn:not(op:dateTime-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:duration</td>
                        <td>xs:duration</td>
                        <td>fn:not(op:duration-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>Gregorian</td>
                        <td>Gregorian</td>
                        <td>fn:not(op:gYear-equal(A, B)) etc.</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>fn:not(op:hexBinary-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>fn:not(op:base64Binary-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:QName</td>
                        <td>xs:QName</td>
                        <td>fn:not(op:QName-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:NOTATION</td>
                        <td>xs:NOTATION</td>
                        <td>fn:not(op:NOTATION-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>fn:not(op:hexBinary-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ne B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>fn:not(op:base64Binary-equal(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>op:boolean-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>op:date-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>op:time-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>op:dateTime-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:yearMonthDuration-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:dayTimeDuration-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>op:hexBinary-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A gt B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>op:base64Binary-greater-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>op:boolean-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>op:numeric-less-than(fn:compare(A, B), 0)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>op:date-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>op:time-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>op:dateTime-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>op:yearMonthDuration-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>op:dayTimeDuration-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>op:hexBinary-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A lt B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>op:base64Binary-less-than(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>fn:not(op:boolean-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>fn:not(op:date-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>fn:not(op:time-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>fn:not(op:dateTime-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>fn:not(op:hexBinary-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A ge B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>fn:not(op:base64Binary-less-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>numeric</td>
                        <td>numeric</td>
                        <td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:boolean</td>
                        <td>xs:boolean</td>
                        <td>fn:not(op:boolean-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:string</td>
                        <td>xs:string</td>
                        <td>op:numeric-less-than(fn:compare(A, B), 1)</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:date</td>
                        <td>xs:date</td>
                        <td>fn:not(op:date-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:time</td>
                        <td>xs:time</td>
                        <td>fn:not(op:time-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:dateTime</td>
                        <td>xs:dateTime</td>
                        <td>fn:not(op:dateTime-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:yearMonthDuration</td>
                        <td>xs:yearMonthDuration</td>
                        <td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:dayTimeDuration</td>
                        <td>xs:dayTimeDuration</td>
                        <td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:hexBinary</td>
                        <td>xs:hexBinary</td>
                        <td>fn:not(op:hexBinary-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                     <tr>
                        <td>A le B</td>
                        <td>xs:base64Binary</td>
                        <td>xs:base64Binary</td>
                        <td>fn:not(op:base64Binary-greater-than(A, B))</td>
                        <td>xs:boolean</td>
                     </tr>
                  </tbody>
               </table>
               <table style="border:1px solid" class="small">
                  <caption>Unary Operators</caption>
                  <tbody>
                     <tr>
                        <th>Operator</th>
                        <th>Operand type</th>
                        <th>Function</th>
                        <th>Result type</th>
                     </tr>
                     <tr>
                        <td>+ A</td>
                        <td>numeric</td>
                        <td>op:numeric-unary-plus(A)</td>
                        <td>numeric</td>
                     </tr>
                     <tr>
                        <td>- A</td>
                        <td>numeric</td>
                        <td>op:numeric-unary-minus(A)</td>
                        <td>numeric</td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-xp-context-components"></a>C Context Components
            </h2>
            <p>The tables in this
               section describe the scope (range of applicability) of the various
               components in a module's static context and dynamic context.
            </p>
            <div class="div2">
               
               <h3><a id="id-xp-static-context-components"></a>C.1 Static Context
                  Components
               </h3>
               <p>The following table describes the components of
                  the <b>static context</b>. For each component, "global"
                  indicates that the value of the component applies throughout an XPath
                  expression, whereas "lexical" indicates that the value of the
                  component applies only within the subexpression in which it is
                  defined.
               </p>
               <table style="width:60%; border:1px solid" class="small">
                  <caption>Static Context Components</caption>
                  <tbody>
                     <tr>
                        <th>Component</th>
                        <th>Scope</th>
                     </tr>
                     <tr>
                        <td>XPath 1.0 Compatibility Mode</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Statically known namespaces</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Default element/type namespace</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Default function namespace</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>In-scope schema types</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>In-scope element declarations</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>In-scope attribute declarations</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>In-scope variables</td>
                        <td>lexical; for-expressions, let-expressions, and quantified expressions can bind new
                           variables
                        </td>
                     </tr>
                     <tr>
                        <td>Context item static type</td>
                        <td>lexical</td>
                     </tr>
                     <tr>
                        <td>Statically known function signatures</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Statically known collations</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Default collation</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Base URI</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Statically known documents</td>
                        <td>global</td>
                     </tr>
                     <tr>
                        <td>Statically known collections</td>
                        <td>global  </td>
                     </tr>
                     <tr>
                        <td>Statically known default collection type</td>
                        <td>global</td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <div class="div2">
               
               <h3><a id="id-xp-evaluation-context-components"></a>C.2 Dynamic Context Components
               </h3>
               <p>The following table describes how values are assigned to the various components of
                  the <b>dynamic context</b>. All these components are initialized by mechanisms defined by the host language.
                  For each component, "global" indicates that the value of the component remains constant
                  throughout evaluation of the XPath expression, whereas "dynamic" indicates that the
                  value of the component can be modified by the evaluation of subexpressions.
               </p>
               <table style="width:60%; border:1px solid" class="small">
                  <caption>Dynamic Context Components</caption>
                  <tbody>
                     <tr>
                        <th>Component</th>
                        <th>Scope</th>
                     </tr>
                     <tr>
                        <td>Context item</td>
                        <td>dynamic; changes during evaluation of path expressions and predicates</td>
                     </tr>
                     <tr>
                        <td>Context position</td>
                        <td>dynamic; changes during evaluation of path expressions and predicates</td>
                     </tr>
                     <tr>
                        <td>Context size</td>
                        <td>dynamic; changes during evaluation of path expressions and predicates</td>
                     </tr>
                     <tr>
                        <td>Variable values</td>
                        <td>dynamic; for-expressions, let-expressions, and quantified expressions can bind new
                           variables
                        </td>
                     </tr>
                     <tr>
                        <td>Current date and time</td>
                        <td>global; must be initialized </td>
                     </tr>
                     <tr>
                        <td>Implicit timezone</td>
                        <td>global; must be initialized </td>
                     </tr>
                     <tr>
                        <td>Available documents</td>
                        <td>global; must be initialized </td>
                     </tr>
                     <tr>
                        <td>Available   collections</td>
                        <td>global; must be initialized </td>
                     </tr>
                     <tr>
                        <td>Default   collection</td>
                        <td>global; overwriteable by implementation</td>
                     </tr>
                     <tr>
                        <td>Available 
                           <span>URI</span> collections
                        </td>
                        <td>global; must be initialized </td>
                     </tr>
                     <tr>
                        <td>Default 
                           <span>URI</span> collection
                        </td>
                        <td>global; overwriteable by implementation</td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-impl-defined-items"></a>D Implementation-Defined Items
            </h2>
            <p>The following items in this specification are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>:
            </p>
            <ol class="enumar">
               <li>
                  <p>The version of Unicode that is used to construct expressions.</p>
               </li>
               <li>
                  <p>The <a title="statically known collations" href="#dt-static-collations">statically-known collations</a>.
                  </p>
               </li>
               <li>
                  <p>The <a title="implicit timezone" href="#dt-timezone">implicit timezone</a>.
                  </p>
               </li>
               <li>
                  <p>The circumstances in which <a title="warning" href="#dt-warning">warnings</a> are raised, and the ways in which warnings are handled.
                  </p>
               </li>
               <li>
                  <p>The method by which errors are reported to the external processing environment.</p>
               </li>
               <li>
                  <p>Which version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) and which version of XML Schema (e.g. <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>) is used for the definitions of primitives such as characters and names, and for
                     the definitions  of operations such as normalization of line endings and normalization
                     of whitespace in attribute values. It is recommended that the latest applicable version
                     be used (even if it is published later than this specification).
                  </p>
               </li>
               <li>
                  <p>How XDM instances are created from sources other than an Infoset or PSVI.</p>
               </li>
               <li>
                  <p>Whether the implementation supports the namespace axis.</p>
               </li>
               <li>
                  <p>Whether the type system is based on <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. An implementation that has based its type system on XML Schema 1.0 is not required
                     to support the use of the <code>xs:dateTimeStamp</code> constructor or the use of <code>xs:dateTimeStamp</code> 
                     <span>or <code>xs:error</code>
                        </span> as <a href="#doc-xpath31-TypeName">TypeName</a> in any expression.
                  </p>
               </li>
               <li>
                  <p>The signatures of functions provided by the implementation or via an implementation-defined
                     API (see <a href="#static_context"><b>2.1.1 Static Context</b></a>).
                  </p>
               </li>
               <li>
                  <p>Any <a title="environment variables" href="#dt-environment-variables">environment variables</a> provided by the implementation.
                  </p>
               </li>
               <li>
                  <p>Any rules used for static typing (see <a href="#id-static-analysis"><b>2.2.3.1 Static Analysis Phase</b></a>).
                  </p>
               </li>
               <li>
                  <p>Any serialization parameters provided by the implementation</p>
               </li>
               <li>
                  <p>What error, if any, is returned if an external function's implementation does not
                     return the declared result type (see <a href="#id-consistency-constraints"><b>2.2.4 Consistency Constraints</b></a>).
                  </p>
               </li>
            </ol>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Additional <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> items are listed in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> and <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
               </p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-references"></a>E References
            </h2>
            <div class="div2">
               
               <h3><a id="id-normative-references"></a>E.1 Normative References
               </h3>
               <dl>
                  <dt class="label"><span><a id="RFC2119"></a>RFC2119</span></dt>
                  <dd>
                     <div>S. Bradner.
                        <em>Key Words for use in RFCs to Indicate Requirement Levels.</em> IETF RFC 2119.
                        See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="RFC3986"></a>RFC3986</span></dt>
                  <dd>
                     <div>T. Berners-Lee, R. Fielding, and
                        L. Masinter.  <em>Uniform Resource Identifiers (URI): Generic
                           Syntax</em>. IETF RFC 3986.
                        See <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="RFC3987"></a>RFC3987</span></dt>
                  <dd>
                     <div>M. Duerst and M. Suignard.
                        <em>Internationalized Resource Identifiers (IRIs)</em>.
                        IETF RFC 3987. See <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="ISO10646"></a>ISO/IEC 10646</span></dt>
                  <dd>
                     <div>ISO (International Organization for Standardization).
                        <em>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character
                           Set (UCS)</em>,
                        as, from time to time, amended, replaced by a new edition, or expanded by the addition
                        of new parts.
                        [Geneva]: International Organization for Standardization.
                        (See <a href="http://www.iso.org">http://www.iso.org</a> for the latest version.)
                     </div>
                  </dd>
                  <dt class="label"><span><a id="Unicode"></a>Unicode</span></dt>
                  <dd>
                     <div>The Unicode Consortium. <em>The Unicode Standard</em>
                        Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication
                        of new versions.
                        See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
                        for the latest version and additional information on versions of the standard and
                        of the Unicode Character Database.
                        The version of Unicode to be used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>,
                        but implementations are recommended to use the latest Unicode version.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XML"></a>XML 1.0</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Extensible Markup Language (XML) 1.0.</em>
                        W3C Recommendation.
                        See <a href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>.
                        The edition of XML 1.0 must be no earlier than the Third Edition;
                        the edition used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>,
                        but we recommend that implementations use the latest version.
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XML1.1"></a>XML 1.1</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Extensible Markup Language (XML) 1.1.</em>
                        W3C Recommendation.
                        See <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLBASE"></a>XML Base</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>XML Base.</em> W3C Recommendation. See
                        <a href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLNAMES"></a>XML Names</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Namespaces in XML.</em> W3C Recommendation. See
                        <a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLNAMES11"></a>XML Names 1.1</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Namespaces in XML 1.1.</em> W3C Recommendation. See
                        <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLID"></a>XML ID</span></dt>
                  <dd>
                     <div>World Wide Web Consortium. <em>xml:id Version 1.0.</em>
                        W3C Recommendation. See <a href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLSchema10"></a>XML Schema 1.0</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>XML Schema, Parts 0, 1, and 2 (Second Edition)</em>. W3C Recommendation, 28 October 2004.
                        See <a href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
                        <a id="schema1" href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
                        and <a id="schema2" href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XMLSchema11"></a>XML Schema 1.1</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>XML Schema, Parts 1, and 2</em>. W3C Recommendation 5 April 2012.
                        See <a id="schema1-11" href="http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a>,
                        and <a id="schema2-11" href="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xpath-datamodel-31"></a>XQuery and XPath Data Model (XDM) 3.1</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xpath-datamodel-31/"><cite>XQuery and XPath Data Model (XDM) 3.1</cite></a>,
                        Norman Walsh, John Snelson, Andrew Coleman, Editors.
                        World Wide Web Consortium,
                        21 March 2017. 
                        This version is https://www.w3.org/TR/2017/REC-xpath-datamodel-31-20170321/.
                        The <a href="https://www.w3.org/TR/xpath-datamodel-31/">latest version</a>
                        is available at https://www.w3.org/TR/xpath-datamodel-31/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xpath-functions-31"></a>XQuery and XPath Functions and Operators 3.1</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xpath-functions-31/"><cite>XQuery and XPath Functions and Operators 3.1</cite></a>,
                        Michael Kay, Editor.
                        World Wide Web Consortium,
                        21 March 2017. 
                        This version is https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/.
                        The <a href="https://www.w3.org/TR/xpath-functions-31/">latest version</a>
                        is available at https://www.w3.org/TR/xpath-functions-31/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xslt-xquery-serialization-31"></a>XSLT and XQuery Serialization 3.1</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/"><cite>XSLT and XQuery Serialization 3.1</cite></a>,
                        Andrew Coleman and Michael Sperberg-McQueen, Editors.
                        World Wide Web Consortium,
                        21 March 2017. 
                        This version is https://www.w3.org/TR/2017/REC-xslt-xquery-serialization-31-20170321/.
                        The <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/">latest version</a>
                        is available at https://www.w3.org/TR/xslt-xquery-serialization-31/.
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="id-non-normative-references"></a>E.2 Non-normative References
               </h3>
               <dl>
                  <dt class="label"><span class="xpath"><a id="xquery-31"></a>XQuery 3.1: An XML Query Language</span></dt>
                  <dd>
                     <div class="xpath">
                        <a href="https://www.w3.org/TR/xquery-31/"><cite>XQuery 3.1: An XML Query Language</cite></a>,
                        Jonathan Robie, Michael Dyck and Josh Spiegel, Editors.
                        World Wide Web Consortium,
                        21 March 2017. 
                        This version is https://www.w3.org/TR/2017/REC-xquery-31-20170321/.
                        The <a href="https://www.w3.org/TR/xquery-31/">latest version</a>
                        is available at https://www.w3.org/TR/xquery-31/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xquery-semantics"></a>XQuery 1.0 and XPath 2.0 Formal Semantics</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xquery-semantics/"><cite>XQuery 1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>,
                        Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>, Editors.
                        World Wide Web Consortium,
                        14 December 2010.
                        This version is https://www.w3.org/TR/2010/REC-xquery-semantics-20101214/.
                        The <a href="https://www.w3.org/TR/xquery-semantics/">latest version</a>
                        is available at https://www.w3.org/TR/xquery-semantics/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xslt-30"></a>XSL Transformations (XSLT) Version 3.0</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xslt-30/"><cite>XSL Transformations (XSLT) Version 3.0</cite></a>,
                        Michael Kay, Editor.
                        World Wide Web Consortium,
                        7 February 2017. 
                        This version is https://www.w3.org/TR/2017/CR-xslt-30-20170207/.
                        The <a href="https://www.w3.org/TR/xslt-30/">latest version</a>
                        is available at https://www.w3.org/TR/xslt-30/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XINFO"></a>XML Infoset</span></dt>
                  <dd>
                     <div>World Wide Web
                        Consortium. <em>XML Information Set <span>(Second Edition).</span>
                           </em> W3C Recommendation <span>4 February 2004.</span> See
                        <a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a>
                        
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xpath"></a>XML Path Language (XPath) Version 1.0</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xpath/"><cite>XML Path Language (XPath) Version 1.0</cite></a>, James Clark and Steven DeRose, Editors. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999.
                        This version is http://www.w3.org/TR/1999/REC-xpath-19991116. The <a href="http://www.w3.org/TR/xpath/">latest version</a> is available at http://www.w3.org/TR/xpath.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xpath20"></a>XML Path Language (XPath) Version 2.0</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xpath20/"><cite>XML Path Language (XPath) 2.0 (Second Edition)</cite></a>,
                        Don Chamberlin, Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
                        World Wide Web Consortium,
                        14 December 2010.
                        This version is https://www.w3.org/TR/2010/REC-xpath20-20101214/.
                        The <a href="https://www.w3.org/TR/xpath20/">latest version</a>
                        is available at https://www.w3.org/TR/xpath20/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xpath-30"></a>XML Path Language (XPath) Version 3.0</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xpath-30/"><cite>XML Path Language (XPath) 3.0</cite></a>,
                        Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors.
                        World Wide Web Consortium,
                        08 April 2014. 
                        This version is https://www.w3.org/TR/2014/REC-xpath-30-20140408/.
                        The <a href="https://www.w3.org/TR/xpath-30/">latest version</a>
                        is available at https://www.w3.org/TR/xpath-30/.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="XPTR"></a>XPointer</span></dt>
                  <dd>
                     <div>World Wide Web Consortium. <em>XML
                           Pointer Language (XPointer).</em> W3C Last Call Working Draft 8 January 2001.
                        See <a href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a>
                        
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="id-background-material"></a>E.3 Background Material
               </h3>
               <dl>
                  <dt class="label"><span><a id="CHARMOD"></a>Character Model</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Character Model for the World Wide Web.</em> W3C Working
                        Draft. See <a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.
                     </div>
                  </dd>
                  <dt class="label"><span><a id="xslt"></a>XSL Transformations (XSLT) Version 1.0</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations (XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xslt-19991116.
                        The <a href="http://www.w3.org/TR/xslt">latest version</a> is available at http://www.w3.org/TR/xslt.
                     </div>
                  </dd>
               </dl>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-errors"></a>F Error Conditions
            </h2>
            <dl>
               <dt><a id="ERRXPST0001"></a>err:XPST0001
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> if analysis of an
                     expression relies on some component of the <a title="static context" href="#dt-static-context">static
                        context</a> that 
                     <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>
                        </span>.
                  </p>
               </dd>
               <dt><a id="ERRXPDY0002"></a>err:XPDY0002
               </dt>
               <dd>
                  <p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if evaluation of an
                     expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic
                        context</a> that 
                     <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>
                        </span>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0003"></a>err:XPST0003
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> if an expression is not a
                     valid instance of the grammar defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.
                  </p>
               </dd>
               <dt><a id="ERRXPTY0004"></a>err:XPTY0004
               </dt>
               <dd>
                  <p>It is a <a title="type error" href="#dt-type-error">type error</a> if, during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, an expression is found to
                     have a <a title="static type" href="#dt-static-type">static type</a> that is not appropriate for
                     the context in which the expression occurs, or during the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>, the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match a required
                     type as specified by the matching rules in <a href="#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0005"></a>err:XPST0005
               </dt>
               <dd>
                  <p> During the analysis phase, it is a <a title="static error" href="#dt-static-error">static
                        error</a> if the <a title="static type" href="#dt-static-type">static type</a> assigned
                     to an expression other than the expression <code>()</code> or <code>data(())</code> is
                     <code>empty-sequence()</code>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0008"></a>err:XPST0008
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> if an expression refers
                     to an element name, attribute name, schema type name, namespace prefix, or variable
                     name
                     that is not defined in the <a title="static context" href="#dt-static-context">static context</a>,
                     except for an ElementName in an <a href="#doc-xpath31-ElementTest">ElementTest</a> or an
                     AttributeName in an <a href="#doc-xpath31-AttributeTest">AttributeTest</a>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0010"></a>err:XPST0010
               </dt>
               <dd>
                  <p> An implementation that does not support the namespace axis must raise a <a title="static error" href="#dt-static-error">static error</a> if it encounters a reference to the
                     namespace axis and XPath 1.0 compatibility mode is false. 
                  </p>
               </dd>
               <dt><a id="ERRXPST0017"></a>err:XPST0017
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> if the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and number of arguments in a <span>static</span> function call do not match the name and arity of a
                     <a title="statically known function signatures" href="#dt-known-func-signatures">function signature</a> in the <a title="static context" href="#dt-static-context">static context</a>.
                  </p>
               </dd>
               <dt><a id="ERRXPTY0018"></a>err:XPTY0018
               </dt>
               <dd>
                  <p>It is a <a title="type error" href="#dt-type-error">type error</a> if the result of a path
                     operator contains both nodes and non-nodes.
                  </p>
               </dd>
               <dt><a id="ERRXPTY0019"></a>err:XPTY0019
               </dt>
               <dd>
                  <p> It is a <a title="type error" href="#dt-type-error">type error</a> if <code>E1</code> in a path
                     expression <code>E1/E2</code> does not evaluate to a sequence of nodes.
                  </p>
               </dd>
               <dt><a id="ERRXPTY0020"></a>err:XPTY0020
               </dt>
               <dd>
                  <p> It is a <a title="type error" href="#dt-type-error">type error</a> if, in an axis step, the
                     context item is not a node.
                  </p>
               </dd>
               <dt><a id="ERRXQST0039"></a>err:XQST0039
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> for 
                     <span>an inline function expression</span> to have more than one
                     parameter with the same name. 
                  </p>
               </dd>
               <dt><a id="ERRXQST0046"></a>err:XQST0046
               </dt>
               <dd>
                  <p>An implementation <span class="xpath">MAY</span> raise a <a title="static error" href="#dt-static-error">static
                        error</a> if the value of a <a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a> is
                     of nonzero length and is 
                     <span>neither an absolute URI nor a
                        relative URI</span>.
                  </p>
               </dd>
               <dt><a id="ERRXPDY0050"></a>err:XPDY0050
               </dt>
               <dd>
                  <p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of the operand of a <code>treat</code>
                     expression does not match the <a title="sequence type" href="#dt-sequence-type">sequence type</a>
                     specified by the <code>treat</code> expression. This error might also be raised by a
                     path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node
                     is not in a tree that is rooted at a document node. This is because a leading
                     "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an
                     initial step that includes the clause <code>treat as document-node()</code>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0051"></a>err:XPST0051
               </dt>
               <dd>
                  <p>It is a <a title="static error" href="#dt-static-error">static error</a> if the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> for an <a href="#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> in a <a href="#doc-xpath31-SequenceType">SequenceType</a> is not defined
                     in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> as a <a title="generalized atomic type" href="#dt-generalized-atomic-type">generalized atomic type</a>.
                  </p>
               </dd>
               <dt><a id="ERRXQST0052"></a>err:XQST0052
               </dt>
               <dd>
                  <p>The type named in a cast or castable expression must be the name of a type defined
                     in the <a title="in-scope schema type" href="#dt-is-types">in-scope
                        schema types</a>, and the type must be
                     <code>simple</code>.
                  </p>
               </dd>
               <dt><a id="ERRXQST0070"></a>err:XQST0070
               </dt>
               <dd>
                  <p class="xpath">A <a title="static error" href="#dt-static-error">static error</a> is raised if any of
                     the following conditions is statically detected in any expression: 
                  </p>
                  <ul>
                     <li>
                        <p>The prefix <code>xml</code> is bound to some namespace URI other than
                           <code>http://www.w3.org/XML/1998/namespace</code>. 
                        </p>
                     </li>
                     <li>
                        <p>A prefix other than <code>xml</code> is bound to the namespace URI
                           <code>http://www.w3.org/XML/1998/namespace</code>. 
                        </p>
                     </li>
                     <li>
                        <p>The prefix <code>xmlns</code> is bound to any namespace URI. 
                        </p>
                     </li>
                     <li>
                        <p>A prefix other than <code>xmlns</code> is bound to the namespace URI
                           <code>http://www.w3.org/2000/xmlns/</code>. 
                        </p>
                     </li>
                  </ul>
               </dd>
               <dt><a id="ERRXPST0080"></a>err:XPST0080
               </dt>
               <dd>
                  <p>It is a <a title="static error" href="#dt-static-error">static error</a> if the target type of a
                     <code>cast</code> or <code>castable</code> expression is
                     <code>xs:NOTATION</code>, <span>
                        <code>xs:anySimpleType</code>,</span> or
                     <code>xs:anyAtomicType</code>.
                  </p>
               </dd>
               <dt><a id="ERRXPST0081"></a>err:XPST0081
               </dt>
               <dd>
                  <p> It is a <a title="static error" href="#dt-static-error">static error</a> if a QName used in
                     <span class="xpath">an expression</span>
                     contains a namespace prefix that cannot be expanded into a namespace URI by using
                     the
                     <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.
                  </p>
               </dd>
               <dt><a id="ERRXPTY0117"></a>err:XPTY0117
               </dt>
               <dd>
                  <p>When applying the function conversion rules, if an item is of type <code>xs:untypedAtomic</code> and the
                     expected type is <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a>, a
                     <a title="type error" href="#dt-type-error">type error</a>
                     [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised. 
                  </p>
               </dd>
               <dt><a id="ERRXPDY0130"></a>err:XPDY0130
               </dt>
               <dd>
                  <p>An implementation-dependent limit has been exceeded.</p>
               </dd>
               <dt><a id="ERRXQST0134"></a>err:XQST0134
               </dt>
               <dd>
                  <p>The namespace axis is not supported.</p>
               </dd>
               <dt><a id="ERRXQDY0137"></a>err:XQDY0137
               </dt>
               <dd>
                  <p>No two keys in a map may have the  <a title="same key" href="#dt-same-key">same key value</a>.
                  </p>
               </dd>
            </dl>
         </div>
         <div class="div1">
            
            <h2><a id="id-glossary"></a>G Glossary (Non-Normative)
            </h2>
            <dl>
               <dt><a id="GLdt-gregorian"></a>Gregorian
               </dt>
               <dd>
                  <p>In the operator mapping tables,
                     the term <b>Gregorian</b> refers to the types
                     <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                     <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
                     <code>xs:gMonth</code>.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-NaN"></a>NaN
               </dt>
               <dd>
                  <p>
                     <b>NaN</b> is the string used to
                     		          represent the double value NaN (not-a-number); the default value is the
                     string "NaN"
                  </p>
               </dd>
               <dt><a id="GLdt-sequencetype-matching"></a>SequenceType matching
               </dt>
               <dd>
                  <p>
                     <b>SequenceType matching</b> compares the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
                     		  with an expected <a title="sequence type" href="#dt-sequence-type">sequence type</a>. 
                  </p>
               </dd>
               <dt><a id="GLdt-static-base-uri"></a>Static Base URI
               </dt>
               <dd>
                  <p>
                     <b>Static Base URI.</b>
                     This is an absolute URI, used to resolve
                     
                     <span class="xpath">relative URI references.</span>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-URI"></a>URI
               </dt>
               <dd>
                  <p>Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-data-model-instance"></a>XDM instance
               </dt>
               <dd>
                  <p>The term <b>XDM instance</b> is used,
                     synonymously with the term <a title="value" href="#dt-value">value</a>, to denote an unconstrained
                     <a title="sequence" href="#dt-sequence">sequence</a> of <a title="item" href="#dt-item">items</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility     mode
               </dt>
               <dd>
                  <p>
                     <b>XPath 1.0 compatibility
                        			 mode.</b>  
                     <span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise
                        it is <code>false</code>.</span>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-anonymous-function"></a>anonymous function
               </dt>
               <dd>
                  <p>An <b>anonymous function</b> is a function with no name.  Anonymous functions may be created, for example, by
                     evaluating an inline function expression or by partial function application.
                  </p>
               </dd>
               <dt><a id="GLdt-arg-expr"></a>argument expression
               </dt>
               <dd>
                  <p>An argument to a function call is either an
                     <b>argument expression</b> or an ArgumentPlaceholder ("?").
                  </p>
               </dd>
               <dt><a id="GLdt-arg-value"></a>argument value
               </dt>
               <dd>
                  <p>
                     <a title="argument expression" href="#dt-arg-expr">Argument expressions</a> are evaluated with respect to <var>DC</var>, producing <b>argument
                        values</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-argumentlist-arity"></a>arity
               </dt>
               <dd>
                  <p>
                     The number of <code>Argument</code>s
                     in an <code>ArgumentList</code>
                     is its <b>arity</b>.
                     
                  </p>
               </dd>
               <dt><a id="GLdt-array"></a>array
               </dt>
               <dd>
                  <p>An <b>array</b> is
                     a <span>function</span> that associates a set of positions, represented as
                     positive integer keys, with values.
                  </p>
               </dd>
               <dt><a id="GLdt-arrow-operator"></a>arrow operator
               </dt>
               <dd>
                  <p>An <b>arrow operator</b> 
                     applies a function to 
                     <span>the value of an expression</span>, using 
                     <span>the value</span> as the first argument to the function.
                  </p>
               </dd>
               <dt><a id="GLdt-associated-value"></a>associated value
               </dt>
               <dd>
                  <p>The value
                     associated with a given key is called the <b>associated
                        value</b> of the key.
                  </p>
               </dd>
               <dt><a id="GLdt-atomic-value"></a>atomic value
               </dt>
               <dd>
                  <p>An <b>atomic
                        	 value</b> is a value in the value space of an <b>atomic
                        	 type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a>  or <a href="#XMLSchema11">[XML Schema 1.1]</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-atomization"></a>atomization
               </dt>
               <dd>
                  <p>
                     <b>Atomization</b> of a sequence
                     is defined as the result of invoking the <span>
                        <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 
                           
                           2.4 fn:data
                           </a><sup><small>FO31</small></sup>.</span>
                     
                     
                  </p>
               </dd>
               <dt><a id="GLdt-available-docs"></a>available documents
               </dt>
               <dd>
                  <p>
                     <b>Available
                        documents.</b> This is a mapping of strings to document nodes.  Each string
                     represents the absolute URI of a resource. The document node is the root of a tree
                     that represents that resource 
                     using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> 
                     function when applied to that URI.
                  </p>
               </dd>
               <dt><a id="GLdt-available-collections"></a>available item collections
               </dt>
               <dd>
                  <p>
                     <b>Available
                        collections.</b> This is a mapping of
                     strings to sequences of 
                     <span>items</span>. Each string
                     represents the absolute URI of a
                     resource. The sequence of 
                     <span>items</span> represents
                     the result of the <code>fn:collection</code>
                     function when that URI is supplied as the
                     argument. 
                  </p>
               </dd>
               <dt><a id="GLdt-available-text-resources"></a>available text resources
               </dt>
               <dd>
                  <p>
                     <b>Available text resources</b>. 
                     This is a mapping of strings to text resources. Each string
                     represents the absolute URI of a resource. The resource is returned
                     by the <code>fn:unparsed-text</code> function when applied to that
                     URI.
                  </p>
               </dd>
               <dt><a id="GLdt-available-uri-collections"></a>available uri collections
               </dt>
               <dd>
                  <p>
                     <b>Available
                        
                        <span>URI</span> collections.</b> This is a mapping of
                     strings to sequences of URIs. The string
                     represents the absolute URI of a
                     resource which can be interpreted as an aggregation of a number of individual resources
                     each of which
                     has its own URI. The sequence of URIs represents
                     the result of the <code>fn:uri-collection</code>
                     function when that URI is supplied as the
                     argument. 
                  </p>
               </dd>
               <dt><a id="GLdt-axis-step"></a>axis step
               </dt>
               <dd>
                  <p>An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified
                     axis. Such a step has two parts: an
                     		<b>axis</b>, which defines the "direction of
                     		movement" for the step, and a <a title="node test" href="#dt-node-test">node test</a>,
                     		which selects nodes based on their kind, name, and/or
                     		<a title="type annotation" href="#dt-type-annotation">type annotation</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-built-in-function"></a>built-in function
               </dt>
               <dd>
                  <p>The <b>built-in functions</b> 
                     are 
                     <span>the functions</span>
                     defined in <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>
                     <span>in the 
                        <code>http://www.w3.org/2005/xpath-functions</code>,
                        <code>http://www.w3.org/2001/XMLSchema</code>,
                        <code>http://www.w3.org/2005/xpath-functions/math</code>,
                        <code>http://www.w3.org/2005/xpath-functions/map</code>,
                        and <code>http://www.w3.org/2005/xpath-functions/array</code> namespaces.
                        </span>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-collation"></a>collation
               </dt>
               <dd>
                  <p>A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension,
                     ordered. For a more complete definition of collation, see 
                     <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 
                        
                        5.3 Comparison of strings
                        </a><sup><small>FO31</small></sup>.
                  </p>
               </dd>
               <dt><a id="GLdt-comma-operator"></a>comma operator
               </dt>
               <dd>
                  <p>One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in
                     order, into a single result sequence.
                  </p>
               </dd>
               <dt><a id="GLdt-constructor-function"></a>constructor function
               </dt>
               <dd>
                  <p>The <b>constructor function</b> for a given type is used to convert instances of other  
                     <span>simple</span> types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.
                  </p>
               </dd>
               <dt><a id="GLdt-content-expression"></a>content expression
               </dt>
               <dd>
                  <p>In an  <a title="enclosed expression" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly braces is called the <b>content expression</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-context-item"></a>context item
               </dt>
               <dd>
                  <p>The <b>context item</b>
                     is the <a title="item" href="#dt-item">item</a> currently being processed.
                  </p>
               </dd>
               <dt><a id="GLdt-context-item-static-type"></a>context item static type
               </dt>
               <dd>
                  <p>
                     <b>Context item static type.</b> This component defines the <a title="static type" href="#dt-static-type">static type</a> of the context item within the scope of a given expression.
                  </p>
               </dd>
               <dt><a id="GLdt-context-node"></a>context node
               </dt>
               <dd>
                  <p>When the context item is a
                     node, it can also be referred to as the <b>context
                        node</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-context-position"></a>context position
               </dt>
               <dd>
                  <p>The <b>context
                        position</b> is the position of the context item within the
                     sequence of items currently being processed.
                  </p>
               </dd>
               <dt><a id="GLdt-context-size"></a>context size
               </dt>
               <dd>
                  <p>The <b>context
                        size</b> is the number of items in the sequence of items currently
                     being processed.
                  </p>
               </dd>
               <dt><a id="GLdt-date-time"></a>current dateTime
               </dt>
               <dd>
                  <p>
                     <b>Current dateTime.</b> This information represents
                     				an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xpath">an expression</span>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <span class="xpath">an expression</span>,
                     				this function always returns the same result.
                  </p>
               </dd>
               <dt><a id="GLdt-datamodel"></a>data model
               </dt>
               <dd>
                  <p>XPath 3.1 operates on the abstract, logical
                     			structure of an XML document <span>or JSON object</span>, rather than its surface syntax. This logical structure,
                     			known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-decimal-separator"></a>decimal-separator
               </dt>
               <dd>
                  <p>
                     <b>decimal-separator</b> is
                     		          the character used to separate the integer part of the number from the
                     fractional part, both in the picture
                     		          string and in the formatted number; the default
                     		          value is the period character (.)
                  </p>
               </dd>
               <dt><a id="GLdt-default-uri-collection"></a>default URI collection
               </dt>
               <dd>
                  <p>
                     <b>Default 
                        <span>URI</span> collection.</b>
                     This is the sequence of URIs that would result from calling the <code>fn:uri-collection</code> function
                     with no arguments.
                  </p>
               </dd>
               <dt><a id="GLdt-default-calendar"></a>default calendar
               </dt>
               <dd>
                  <p>
                     <b>Default calendar.</b>
                     This is the calendar used when formatting dates in human-readable output
                     (for example, by the functions <code>fn:format-date</code> and <code>fn:format-dateTime</code>)
                     if no other calendar is requested. 
                     The value is a string.
                  </p>
               </dd>
               <dt><a id="GLdt-def-collation"></a>default collation
               </dt>
               <dd>
                  <p>
                     <b>Default
                        				collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the  collation to be
                     				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
                     				explicit collation is
                     				specified.
                  </p>
               </dd>
               <dt><a id="GLdt-default-collection"></a>default collection
               </dt>
               <dd>
                  <p>
                     <b>Default  collection.</b>
                     This is the sequence of 
                     <span>items</span>  that would result from calling the <code>fn:collection</code> function
                     with no arguments.
                  </p>
               </dd>
               <dt><a id="GLdt-def-elemtype-ns"></a>default element/type namespace
               </dt>
               <dd>
                  <p>
                     <b>Default element/type namespace.</b> This is a
                     				namespace URI or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a
                     				position where an element or type name is expected.
                  </p>
               </dd>
               <dt><a id="GLdt-def-fn-ns"></a>default function namespace
               </dt>
               <dd>
                  <p>
                     <b>Default function namespace.</b> This is a
                     				namespace URI or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position
                     where a function name is expected.
                  </p>
               </dd>
               <dt><a id="GLdt-default-language"></a>default language
               </dt>
               <dd>
                  <p>
                     <b>Default language.</b>
                     This is the natural language used when creating human-readable output
                     (for example, by the functions <code>fn:format-date</code> and <code>fn:format-integer</code>)
                     if no other language is requested. 
                     The value is a language code as defined by the type <code>xs:language</code>.
                  </p>
               </dd>
               <dt><a id="GLdt-default-place"></a>default place
               </dt>
               <dd>
                  <p>
                     <b>Default place.</b>
                     This is a geographical location used to identify the place where events happened (or
                     will happen) when
                     formatting dates and times using functions such as <code>fn:format-date</code> and <code>fn:format-dateTime</code>,
                     if no other place is specified. It is used when translating timezone offsets to civil
                     timezone names,
                     and when using calendars where the translation from ISO dates/times to a local representation
                     is dependent
                     on geographical location. Possible representations of this information are an ISO
                     country code or an
                     Olson timezone name, but implementations are free to use other representations from
                     which the above
                     information can be derived.
                  </p>
               </dd>
               <dt><a id="GLdelimiting-token"></a>delimiting terminal symbol
               </dt>
               <dd>
                  <p>The <b>delimiting
                        terminal symbols</b> are: "!", "!=", <a href="#prod-xpath31-StringLiteral">StringLiteral</a>, "#", "$", "(", ")", "*", "*:", "+", (comma), "-", (dot), "..", "/", "//", (colon),
                     ":*", "::", ":=", "&lt;", "&lt;&lt;", "&lt;=", "=", "=&gt;", "&gt;", "&gt;=", "&gt;&gt;", "?", "@", <a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a>, "[", "]", "{", "|", "||", "}"
                     
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-digit"></a>digit
               </dt>
               <dd>
                  <p>
                     <b>digit</b> 
                     		          is a character used in the picture string to represent an optional digit;
                     the default value is the number sign character (#)
                  </p>
               </dd>
               <dt><a id="GLdt-document-order"></a>document order
               </dt>
               <dd>
                  <p>Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.
                  </p>
               </dd>
               <dt><a id="GLdt-dynamic-context"></a>dynamic context
               </dt>
               <dd>
                  <p>The <b>dynamic
                        context</b> of an expression is defined as information that is needed for the dynamic evaluation
                     of an expression.
                  </p>
               </dd>
               <dt><a id="GLdt-dynamic-error"></a>dynamic error
               </dt>
               <dd>
                  <p>A <b>dynamic
                        error</b> is an error that
                     must be detected during the dynamic evaluation phase and may be detected
                     during the static analysis phase.
                     Numeric overflow is an example of a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-dynamic-evaluation"></a>dynamic evaluation phase
               </dt>
               <dd>
                  <p>The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.
                  </p>
               </dd>
               <dt><a id="GLdt-dynamic-function-invocation"></a>dynamic function call
               </dt>
               <dd>
                  <p>A <b>dynamic function call</b>
                     consists of a
                     base expression
                     that returns the function and a
                     parenthesized list of zero or more arguments (<a title="argument expression" href="#dt-arg-expr">argument expressions</a> or
                     ArgumentPlaceholders).
                  </p>
               </dd>
               <dt><a id="GLdt-dynamic-type"></a>dynamic type
               </dt>
               <dd>
                  <p>A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may
                     be more specific than the <a title="static type" href="#dt-static-type">static type</a> of the expression that computed it (for example, the  static type of an expression
                     might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may
                     have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)
                  </p>
               </dd>
               <dt><a id="GLdt-ebv"></a>effective boolean value
               </dt>
               <dd>
                  <p>The
                     <b>effective boolean value</b> of a value is defined as the result
                     of applying the <code>fn:boolean</code> function to the value, as
                     defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 
                        
                        7.3.1 fn:boolean
                        </a><sup><small>FO31</small></sup>.
                  </p>
               </dd>
               <dt><a id="GLdt-empty-sequence"></a>empty sequence
               </dt>
               <dd>
                  <p>A sequence containing zero items is called an <b>empty sequence</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-enclosed-expression"></a>enclosed expression
               </dt>
               <dd>
                  <p>An <b>enclosed expression</b> is an instance of the <a href="#doc-xpath31-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly braces.
                  </p>
               </dd>
               <dt><a id="GLdt-entry"></a>entry
               </dt>
               <dd>
                  <p>Each key / value pair in a map
                     is called an <b>entry</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-environment-variables"></a>environment variables
               </dt>
               <dd>
                  <p>
                     <b>Environment variables.</b>
                     This is a mapping from names to values. 
                     Both the names and the values are strings. The names are compared using an
                     <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables
                     is
                     <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> and <strong>may</strong> be empty.
                  </p>
               </dd>
               <dt><a id="GLdt-error-value"></a>error value
               </dt>
               <dd>
                  <p>In addition to its identifying QName, a dynamic error may also carry a descriptive
                     string and one or more additional values called <b>error values</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-expanded-qname"></a>expanded QName
               </dt>
               <dd>
                  <p>An <b>expanded QName</b> is a
                     triple: its components are a prefix, a local name, and a
                     namespace URI. In the case of a name in no namespace, the
                     namespace URI and prefix are both absent. In the case of a name
                     in the default namespace, the prefix is absent.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-exponent-separator"></a>exponent-separator
               </dt>
               <dd>
                  <p>
                     <b>exponent-separator</b> is
                     		          the character used to separate the mantissa from the exponent in
                     		          scientific notation both in the picture string and in the
                     		          formatted number; the default value is the character (e).
                  </p>
               </dd>
               <dt><a id="GLdt-expression-context"></a>expression context
               </dt>
               <dd>
                  <p>The <b>expression
                        		context</b> for a given expression consists of all
                     		the information that can affect the result of the
                     		expression.
                  </p>
               </dd>
               <dt><a id="GLdt-external-function"></a>external function
               </dt>
               <dd>
                  <p>
                     <b>External functions</b> are functions that are implemented outside the query
                     environment.
                  </p>
               </dd>
               <dt><a id="GLdt-filter-expression"></a>filter expression
               </dt>
               <dd>
                  <p>An
                     expression followed by a predicate (that is, <code>E1[E2]</code>)
                     is referred to as a <b>filter expression</b>: its effect is
                     to return those items from the value of <code>E1</code> that
                     satisfy the predicate in E2.
                  </p>
               </dd>
               <dt><a id="GLdt-fixed-position"></a>fixed position
               </dt>
               <dd>
                  <p>In a partial function application, a <b>fixed position</b>
                     is an argument/parameter position for which the <code>ArgumentList</code> has an argument expression (as opposed to an <code>ArgumentPlaceholder</code>).
                  </p>
               </dd>
               <dt><a id="GLdt-focus"></a>focus
               </dt>
               <dd>
                  <p>The first three components of
                     the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
                     (context item, context position, and context size) are called the
                     <b>focus</b> of the expression. 
                  </p>
               </dd>
               <dt><a id="GLdt-function-item-coercion"></a>function coercion
               </dt>
               <dd>
                  <p>
                     <b>Function coercion</b> wraps a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
                     in a new function
                     with signature the same as the expected type.
                     This effectively delays the checking
                     of the argument and return types
                     until the function is invoked.
                  </p>
               </dd>
               <dt><a id="GLdt-function-conversion"></a>function conversion rules
               </dt>
               <dd>
                  <p>The <b>function conversion rules</b> are used to convert an
                     		argument value  to its expected type; that is, to
                     		the declared type of the function <span class="xpath">parameter.</span>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-generalized-atomic-type"></a>generalized atomic type
               </dt>
               <dd>
                  <p>A <b>generalized atomic type</b> is a type which is either (a) an atomic type or (b) a <a title="pure union type" href="#dt-pure-union-type">pure union type</a>
                     
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-grouping-separator"></a>grouping-separator
               </dt>
               <dd>
                  <p>
                     <b>grouping-separator</b>
                     		          is the character typically used as a thousands separator, both in the
                     picture string and in the formatted number; the default value is the
                     		          comma character (,)
                  </p>
               </dd>
               <dt><a id="GLdt-host-language-function"></a>host language function
               </dt>
               <dd>
                  <p>A <b>host language function</b> is an <a title="external function" href="#dt-external-function">external function</a> defined by the <a title="host-language" href="#dt-host-language">host language</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-host-language"></a>host-language
               </dt>
               <dd>
                  <p>
                     A <b>host language</b> for XPath is a language or
                     specification that incorporates XPath as a sublanguage and
                     that defines how the static and dynamic context for
                     evaluation of XPath expressions are to be
                     established.
                  </p>
               </dd>
               <dt><a id="GLIgnorableWhitespace"></a>ignorable whitespace
               </dt>
               <dd>
                  <p>
                     <b>Ignorable whitespace</b> consists of any <a title="whitespace" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" href="#terminal">terminals</a>, unless these characters occur in the context of a production
                     marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in
                     which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit Whitespace Handling</b></a>).
                  </p>
               </dd>
               <dt><a id="GLdt-implementation-dependent"></a>implementation   dependent
               </dt>
               <dd>
                  <p>
                     <b>Implementation-dependent</b> indicates an aspect that may differ
                     					between implementations, is not specified by this or any W3C specification, and
                     					is not required to be specified by the implementor for any particular
                     					implementation.
                  </p>
               </dd>
               <dt><a id="GLdt-implementation-defined"></a>implementation defined
               </dt>
               <dd>
                  <p>
                     <b>Implementation-defined</b> indicates an aspect that may differ
                     					between implementations, but must be specified by the implementor for each
                     					particular implementation.
                  </p>
               </dd>
               <dt><a id="GLdt-implementation-defined-function"></a>implementation-defined function
               </dt>
               <dd>
                  <p>An <b>implementation-defined function</b> is an <a title="external function" href="#dt-external-function">external function</a> that is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-timezone"></a>implicit timezone
               </dt>
               <dd>
                  <p>
                     <b>Implicit timezone.</b> This is the timezone to be used when a date,
                     time, or dateTime value that does not have a timezone is used in a
                     comparison or arithmetic operation. The implicit timezone is an  <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value of type
                     <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones">Section 
                        
                        3.2.7.3 Timezones
                        </a><sup><small>XS1-2</small></sup> or
                     <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime">Section 
                        
                        3.3.7 dateTime
                        </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.
                  </p>
               </dd>
               <dt><a id="GLdt-is-attrs"></a>in-scope attribute declarations
               </dt>
               <dd>
                  <p>
                     <b>In-scope attribute
                        declarations.</b> Each attribute declaration is identified either
                     by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an
                     <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute
                     declaration).  
                  </p>
               </dd>
               <dt><a id="GLdt-is-elems"></a>in-scope element declarations
               </dt>
               <dd>
                  <p>
                     <b>In-scope element declarations.</b> Each element
                     declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element
                     declaration) or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a
                     local element declaration). 
                  </p>
               </dd>
               <dt><a id="GLdt-in-scope-namespaces"></a>in-scope namespaces
               </dt>
               <dd>
                  <p>The <b>in-scope namespaces</b> property of an element node is a set of namespace bindings, each of which associates
                     a namespace prefix with a URI.
                  </p>
               </dd>
               <dt><a id="GLdt-issd"></a>in-scope schema definitions
               </dt>
               <dd>
                  <p>
                     <b>In-scope schema
                        			 definitions.</b> This is a generic term
                     			 for all the element declarations, attribute declarations, and schema type
                     			 definitions that are in scope during
                     			 static analysis of an expression.
                  </p>
               </dd>
               <dt><a id="GLdt-is-types"></a>in-scope schema type
               </dt>
               <dd>
                  <p>
                     <b>In-scope schema types.</b> Each schema type
                     			        definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded
                        			        QName</a> (for a <b>named type</b>)
                     			        or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> type
                     			        identifier (for an <b>anonymous
                        			        type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
                     
                     
                     
                     
                  </p>
               </dd>
               <dt><a id="GLdt-in-scope-variables"></a>in-scope variables
               </dt>
               <dd>
                  <p>
                     <b>In-scope variables.</b> 
                     This is a mapping from <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> to type. It defines the
                     set of variables that are available for reference within an
                     expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the
                     <a title="static type" href="#dt-static-type">static type</a> of the
                     variable.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-infinity"></a>infinity
               </dt>
               <dd>
                  <p>
                     <b>infinity</b> is the string used to represent the double value infinity (<code>INF</code>); the
                     		          default value is the string "Infinity"
                  </p>
               </dd>
               <dt><a id="GLdt-inline-func"></a>inline function expression
               </dt>
               <dd>
                  <p>An <b>inline function expression</b> creates
                     an <a title="anonymous function" href="#dt-anonymous-function">anonymous
                        function</a>
                     defined directly in the
                     inline function expression.
                  </p>
               </dd>
               <dt><a id="GLdt-item"></a>item
               </dt>
               <dd>
                  <p>
                     An <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a>, a <a title="node" href="#dt-node">node</a>,
                     or a <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.
                  </p>
               </dd>
               <dt><a id="GLdt-kind-test"></a>kind test
               </dt>
               <dd>
                  <p>An alternative
                     		  form of a node test called a
                     		  <b>kind test</b> can select nodes based
                     		  on their kind, name, and <a title="type annotation" href="#dt-type-annotation">type annotation</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-qname"></a>lexical QName
               </dt>
               <dd>
                  <p>A
                     <b>lexical QName</b> is a name that conforms to the syntax of the
                     <a href="#doc-xpath31-QName">QName</a> production
                  </p>
               </dd>
               <dt><a id="GLdt-literal"></a>literal
               </dt>
               <dd>
                  <p>A <b>literal</b> is a direct syntactic representation of an
                     		atomic value.
                  </p>
               </dd>
               <dt><a id="GLdt-map"></a>map
               </dt>
               <dd>
                  <p>A <b>map</b> is a <span>function
                        that associates a set of keys with values, resulting in a</span> collection
                     of key / value pairs.
                  </p>
               </dd>
               <dt><a id="GLmay"></a>may
               </dt>
               <dd>
                  <p>
                     <b>MAY</b> means that an item is truly
                     optional.
                  </p>
               </dd>
               <dt><a id="GLdt-member"></a>member
               </dt>
               <dd>
                  <p>The values of an array are called
                     its <b>members</b>.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-minus-sign"></a>minus-sign
               </dt>
               <dd>
                  <p>
                     <b>minus-sign</b> is the single character used to mark negative numbers; the
                     		          default value is the hyphen-minus character (#x2D). 
                  </p>
               </dd>
               <dt><a id="GLmust"></a>must
               </dt>
               <dd>
                  <p>
                     <b>MUST</b> means that the item is an absolute
                     requirement of the specification.
                  </p>
               </dd>
               <dt><a id="GLmustnot"></a>must not
               </dt>
               <dd>
                  <p>
                     <b>MUST NOT</b> means that the item is an
                     absolute prohibition of the specification.
                  </p>
               </dd>
               <dt><a id="GLdt-name-test"></a>name test
               </dt>
               <dd>
                  <p>A node test that consists only of an EQName or a
                     		  Wildcard is called a <b>name test</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-named-func"></a>named function
               </dt>
               <dd>
                  <p>A <b>named function</b> is a function defined in the
                     static context for the <span class="xpath">expression</span>. 
                     To uniquely identify a particular named function, both its name as an expanded QName
                     and its arity are required.
                  </p>
               </dd>
               <dt><a id="GLdt-named-function-ref"></a>named function reference
               </dt>
               <dd>
                  <p>
                     A <b>named function reference</b> is an expression
                     which evaluates to a <a title="named function" href="#dt-named-func">named
                        function</a>.  The name and arity of the returned
                     function are known statically, and correspond to a function
                     signature present in the static context; if the function is
                     context dependent, then the returned function is associated
                     with the static context of the named function reference and
                     the dynamic context in which it is evaluated.
                     
                  </p>
               </dd>
               <dt><a id="GLdt-named-functions"></a>named functions
               </dt>
               <dd>
                  <p>
                     <b>Named functions</b>.
                     This is a mapping from (expanded QName, arity) to 
                     <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.
                     
                  </p>
               </dd>
               <dt><a id="GLdt-namespace-sensitive"></a>namespace-sensitive
               </dt>
               <dd>
                  <p>The <b>namespace-sensitive</b>
                     types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types
                     derived by restriction from <code>xs:QName</code> or
                     <code>xs:NOTATION</code>, list types that have a namespace-sensitive
                     item type, and union types with a namespace-sensitive type in their
                     transitive membership.
                  </p>
               </dd>
               <dt><a id="GLdt-node"></a>node
               </dt>
               <dd>
                  <p>A <b>node</b> is an instance of one of the
                     	  <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section 
                        
                        6 Nodes
                        </a><sup><small>DM31</small></sup>.
                  </p>
               </dd>
               <dt><a id="GLdt-node-test"></a>node test
               </dt>
               <dd>
                  <p>A <b>node test</b> is a condition on the name, kind (element, attribute, text, document, comment,
                     		  or processing instruction), and/or  <a title="type annotation" href="#dt-type-annotation">type annotation</a> of a node. 
                     A node test determines which nodes contained by an axis are selected by a <a title="step" href="#dt-step">step</a>.
                  </p>
               </dd>
               <dt><a id="GLnon-delimiting-token"></a>non-delimiting terminal symbol
               </dt>
               <dd>
                  <p>The
                     <b>non-delimiting terminal symbols</b> are: <a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xpath31-URIQualifiedName">URIQualifiedName</a>, <a href="#prod-xpath31-NCName">NCName</a>, <a href="#prod-xpath31-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xpath31-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath31-QName">QName</a>, "ancestor", "ancestor-or-self", "and", "array", "as", "attribute", "cast", "castable",
                     "child", "comment", "descendant", "descendant-or-self", "div", "document-node", "element",
                     "else", "empty-sequence", "eq", "every", "except", "following", "following-sibling",
                     "for", "function", "ge", "gt", "idiv", "if", "in", "instance", "intersect", "is",
                     "item", "le", "let", "lt", "map", "mod", "namespace", "namespace-node", "ne", "node",
                     "of", "or", "parent", "preceding", "preceding-sibling", "processing-instruction",
                     "return", "satisfies", "schema-attribute", "schema-element", "self", "some", "text",
                     "then", "to", "treat", "union"
                     
                  </p>
               </dd>
               <dt><a id="GLdt-numeric"></a>numeric
               </dt>
               <dd>
                  <p>When referring to a type, the term <b>numeric</b> denotes the types
                     <code>xs:integer</code>, <code>xs:decimal</code>,
                     <code>xs:float</code>, and <code>xs:double</code>
                     <span>which are all member types of the built-in union type <code>xs:numeric</code>
                        </span>.
                  </p>
               </dd>
               <dt><a id="GLdt-operator-function"></a>operator function
               </dt>
               <dd>
                  <p>For each operator and valid combination of operand types, the operator mapping tables
                     specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.
                  </p>
               </dd>
               <dt><a id="GLdt-partial-function-application"></a>partial function application
               </dt>
               <dd>
                  <p>
                     A static or <a title="dynamic function call" href="#dt-dynamic-function-invocation">dynamic</a>
                     function call is a <b>partial function application</b>
                     if one or more arguments is an ArgumentPlaceholder.
                     
                  </p>
               </dd>
               <dt><a id="GLdt-partially-applied-function"></a>partially applied function
               </dt>
               <dd>
                  <p>A <b>partially applied function</b>
                     is a function created by  <a title="partial function application" href="#dt-partial-function-application">partial function application</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-path-expression"></a>path expression
               </dt>
               <dd>
                  <p>A <b>path expression</b> can be used to locate nodes
                     	 within trees. A path expression consists of a series of one or more
                     	 <a title="step" href="#dt-step">steps</a>, separated by "<code>/</code>" or
                     	 "<code>//</code>", and optionally beginning with
                     	 "<code>/</code>" or "<code>//</code>".
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-pattern-separator"></a>pattern-separator
               </dt>
               <dd>
                  <p>
                     <b>pattern-separator</b> is a character used
                     		          to separate positive and negative sub-pictures
                     		          in a picture string; the default value is the semi-colon character (;)
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-per-mille"></a>per-mille
               </dt>
               <dd>
                  <p>
                     <b>per-mille</b>
                     		          is the character used both in the picture string and in the formatted
                     number to indicate that the number is written as a per-thousand fraction; the default
                     		          value is the Unicode per-mille character
                     		          (#x2030)
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-percent"></a>percent
               </dt>
               <dd>
                  <p>
                     <b>percent</b>
                     		          is the character used both in the picture string and in the formatted
                     number to indicate that the number is written as a per-hundred fraction; the default
                     		          value is the percent character (%)
                  </p>
               </dd>
               <dt><a id="GLdt-primary-expression"></a>primary expression
               </dt>
               <dd>
                  <p>
                     <b>Primary expressions</b> are the basic primitives of the
                     	 language. They include literals, variable references,  context item expressions,
                     and function calls. A primary expression may also be created by enclosing any expression
                     in parentheses, which is sometimes helpful in controlling the precedence of operators.
                  </p>
               </dd>
               <dt><a id="GLdt-principal-node-kind"></a>principal node kind
               </dt>
               <dd>
                  <p>Every axis has a <b>principal node kind</b>. If an axis can
                     		  contain elements, then the principal node kind is element; otherwise, it is the
                     		  kind of nodes that the axis can contain.
                  </p>
               </dd>
               <dt><a id="GLdt-pure-union-type"></a>pure union type
               </dt>
               <dd>
                  <p>A <b>pure union type</b> is an XML Schema union type that satisfies the following constraints:
                     (1) <code>{variety}</code> is <code>union</code>, (2) the <code>{facets}</code> property is empty, (3) no type in the transitive membership of the union type has
                     <code>{variety}</code> 
                     <code>list</code>, and (4) no type in the transitive membership of the union type is a type with <code>{variety}</code> 
                     <code>union</code> having a non-empty <code>{facets}</code> property
                  </p>
               </dd>
               <dt><a id="GLdt-resolve-relative-uri"></a>resolve
               </dt>
               <dd>
                  <p>To
                     <b>resolve a relative URI</b> 
                     <code>$rel</code> against a
                     base URI <code>$base</code> is to expand it to an absolute URI,
                     as if by calling the function <code>fn:resolve-uri($rel,
                        $base)</code>.
                  </p>
               </dd>
               <dt><a id="GLdt-reverse-document-order"></a>reverse document order
               </dt>
               <dd>
                  <p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-same-key"></a>same key
               </dt>
               <dd>
                  <p>Two atomic values <code>K1</code> and
                     <code>K2</code> have the <b>same key value</b> if
                     
                     <span>
                        <code>op:same-key(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://www.w3.org/TR/xpath-functions-31/#func-same-key">Section 
                           
                           17.1.1 op:same-key
                           </a><sup><small>FO31</small></sup> 
                        </span>
                     
                  </p>
               </dd>
               <dt><a id="GLdt-schema-type"></a>schema type
               </dt>
               <dd>
                  <p>A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the built-in types).
                  </p>
               </dd>
               <dt><a id="GLdt-sequence"></a>sequence
               </dt>
               <dd>
                  <p>A
                     <b>sequence</b> is an ordered collection of zero or more
                     <a title="item" href="#dt-item">items</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-sequence-type"></a>sequence type
               </dt>
               <dd>
                  <p>A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath31-SequenceType">SequenceType</a>
                     syntax. Sequence types are used whenever it is necessary to refer to a type in an
                     XPath 3.1 expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an XPath 3.1 value, which
                     is always a sequence.
                  </p>
               </dd>
               <dt><a id="GLdt-singleton"></a>singleton
               </dt>
               <dd>
                  <p>A sequence containing exactly one item is called a
                     	 <b>singleton</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-singleton-focus"></a>singleton focus
               </dt>
               <dd>
                  <p>A <b>singleton focus</b> is a focus that refers to a single item; in a singleton focus, context item is set
                     to the item, context position = 1 and context size = 1.
                  </p>
               </dd>
               <dt><a id="GLstable"></a>stable
               </dt>
               <dd>
                  <p>Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing
                     of a given <span class="xpath">expression</span>, even if this order is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-static-analysis"></a>static analysis phase
               </dt>
               <dd>
                  <p>The
                     <b>static analysis phase</b> depends on the expression itself
                     and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does
                     not depend on input data (other than schemas).
                  </p>
               </dd>
               <dt><a id="GLdt-static-context"></a>static context
               </dt>
               <dd>
                  <p>The <b>static context</b> of an expression is
                     		  the information that is available during static analysis of the expression, prior
                     		  to its evaluation.
                  </p>
               </dd>
               <dt><a id="GLdt-static-error"></a>static error
               </dt>
               <dd>
                  <p>
                     An error that can be detected during the static analysis phase, and is not a type
                     error, is a <b>static error</b>.
                  </p>
               </dd>
               <dt><a id="GLdt-static-function-call"></a>static function call
               </dt>
               <dd>
                  <p>A <b>static function call</b> consists of an EQName followed by a
                     		parenthesized list of zero or more arguments.
                  </p>
               </dd>
               <dt><a id="GLdt-static-type"></a>static type
               </dt>
               <dd>
                  <p>The
                     <b>static type</b> of an expression is the best inference that
                     the processor is able to make statically about the type of the result
                     of the expression.
                  </p>
               </dd>
               <dt><a id="GLdt-xpath-static-typing-feature"></a>static typing feature
               </dt>
               <dd>
                  <p>The <b>Static
                        Typing Feature</b> is an optional feature of XPath that provides support for static semantics, and requires
                     implementations to detect and report <a title="type error" href="#dt-type-error">type errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-known-collections"></a>statically known  collections
               </dt>
               <dd>
                  <p>
                     <b>Statically known collections.</b> This is a
                     mapping from strings to types.  The string represents the absolute
                     URI of a resource that is potentially available using the
                     <code>fn:collection</code> function.  The type is the type of the
                     sequence of 
                     <span>items</span> that would result from calling the
                     <code>fn:collection</code> function with this URI as its
                     argument.
                  </p>
               </dd>
               <dt><a id="GLdt-known-docs"></a>statically known  documents
               </dt>
               <dd>
                  <p>
                     <b>Statically known documents.</b> This is a mapping
                     from strings to types.  The string represents the absolute URI of a
                     resource that is potentially available using the <code>fn:doc</code>
                     function.  The type is the <a title="static type" href="#dt-static-type">static type</a> of a call to <code>fn:doc</code>  with the given URI as its
                     literal argument. 
                  </p>
               </dd>
               <dt><a id="GLdt-static-collations"></a>statically known collations
               </dt>
               <dd>
                  <p>
                     <b>Statically known collations.</b> This is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                     mapping from URI to collation. It defines the names of the collations that are available
                     for
                     				use in processing  expressions.
                  </p>
               </dd>
               <dt><a id="GLdt-static-decimal-formats"></a>statically known decimal formats
               </dt>
               <dd>
                  <p>
                     <b>Statically known decimal
                        		      formats.</b> This is a mapping from QNames to decimal formats, with one default format that has
                     no visible name,
                     		      referred to as the unnamed decimal format. Each
                     		      format is available for use when formatting numbers using the <code>fn:format-number</code> function.
                  </p>
               </dd>
               <dt><a id="GLdt-known-default-collection"></a>statically known default collection type
               </dt>
               <dd>
                  <p>
                     <b>Statically known default collection type.</b> This is the type of the sequence of 
                     
                     <span>items</span> that would result from calling the <code>fn:collection</code> function with no arguments.
                  </p>
               </dd>
               <dt><a id="GLdt-known-func-signatures"></a>statically known function signatures
               </dt>
               <dd>
                  <p>
                     <b>Statically known function signatures.</b>
                     This is a mapping from (expanded QName, arity) to 
                     <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function signature</a><sup><small>DM31</small></sup>. 
                     
                  </p>
               </dd>
               <dt><a id="GLdt-static-namespaces"></a>statically known namespaces
               </dt>
               <dd>
                  <p>
                     <b>Statically known namespaces.</b> 
                     This is a mapping from prefix to namespace URI that defines all the namespaces that
                     are known during static processing of a given expression.
                  </p>
               </dd>
               <dt><a id="GLdt-step"></a>step
               </dt>
               <dd>
                  <p>A <b>step</b> is a part of a <a title="path expression" href="#dt-path-expression">path expression</a> that generates a sequence of items
                     		and then filters the sequence by zero or more
                     		<a title="" href="#dt-predicate">predicates</a>. The value of the step
                     		consists of those items that satisfy the
                     		predicates, working from left to right. A step may be either an <a title="axis step" href="#dt-axis-step">axis step</a> or a postfix expression.
                  </p>
               </dd>
               <dt><a id="GLdt-string-value"></a>string value
               </dt>
               <dd>
                  <p>The
                     <b>string value</b> of a node is a string and can be extracted
                     by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 
                        
                        2.3 fn:string
                        </a><sup><small>FO31</small></sup>
                     function to the node.
                  </p>
               </dd>
               <dt><a id="GLdt-substitution-group"></a>substitution group
               </dt>
               <dd>
                  <p>
                     <b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class">Section 
                        
                        2.2.2.2 Element Substitution Group
                        </a><sup><small>XS1-1</small></sup> and 
                     <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class">Section 
                        
                        2.2.2.2 Element Substitution Group
                        </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of  the set of elements that can be substituted for the head element without
                     affecting the outcome of schema validation.
                  </p>
               </dd>
               <dt><a id="GLdt-subtype"></a>subtype
               </dt>
               <dd>
                  <p>A <a title="sequence type" href="#dt-sequence-type">sequence type</a> 
                     <code>A</code> is a <b>subtype</b> of a sequence type <code>B</code>
                     if the judgement <code>subtype(A, B)</code> is true.
                  </p>
               </dd>
               <dt><a id="GLdt-subtype-substitution"></a>subtype substitution
               </dt>
               <dd>
                  <p>The use of a value whose <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> is derived from an
                     		  expected type is known as <b>subtype substitution</b>.
                  </p>
               </dd>
               <dt><a id="GLsymbol"></a>symbol
               </dt>
               <dd>
                  <p>Each rule in the grammar defines one <b>symbol</b>,
                     using the following format: 
                  </p>
                  <div class="exampleInner"><pre>symbol ::= expression</pre></div>
               </dd>
               <dt><a id="GLsymbolseparators"></a>symbol separators
               </dt>
               <dd>
                  <p>
                     <a title="whitespace" href="#Whitespace">Whitespace</a> and <a href="#doc-xpath31-Comment">Comments</a>
                     function as <b>symbol separators</b>. For the most part, they are not mentioned in
                     the grammar, and may occur between any two terminal symbols mentioned in the grammar,
                     except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a>
                     annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version
                        */</a> annotation.
                  </p>
               </dd>
               <dt><a id="GLterminal"></a>terminal
               </dt>
               <dd>
                  <p>A <b>terminal</b> is a symbol or string or
                     pattern that can appear in the right-hand side of a rule, but never appears on the
                     left-hand side in the main grammar, although it may appear on the left-hand side of
                     a rule
                     in the grammar for terminals.
                  </p>
               </dd>
               <dt><a id="GLdt-type-annotation"></a>type annotation
               </dt>
               <dd>
                  <p>Each element node and attribute node in an <a title="XDM instance" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 
                        
                        2.7 Schema Information
                        </a><sup><small>DM31</small></sup>). 
                     The type annotation of a node is a reference to an XML Schema type. 
                     
                  </p>
               </dd>
               <dt><a id="GLdt-type-error"></a>type error
               </dt>
               <dd>
                  <p>A <b>type
                        error</b> may be raised during the static analysis phase or the dynamic evaluation phase.
                     During the static analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
                     when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type
                     of the context in which the expression occurs.
                     During the dynamic evaluation phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
                     when the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of
                     the context in which the value occurs.
                  </p>
               </dd>
               <dt><a id="GLdt-type-promotion"></a>type promotion
               </dt>
               <dd>
                  <p>Under certain circumstances, an atomic value can be promoted from
                     one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>)  and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).
                  </p>
               </dd>
               <dt><a id="GLdt-typed-value"></a>typed value
               </dt>
               <dd>
                  <p>The <b>typed
                        value</b> of a node is a sequence of atomic values and can be
                     extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 
                        
                        2.4 fn:data
                        </a><sup><small>FO31</small></sup> function to the
                     node.
                  </p>
               </dd>
               <dt><a id="GLdt-value"></a>value
               </dt>
               <dd>
                  <p>In the <a title="data model" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" href="#dt-sequence">sequence</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-variable-reference"></a>variable reference
               </dt>
               <dd>
                  <p>A <b>variable reference</b> is an EQName preceded by a $-sign.
                  </p>
               </dd>
               <dt><a id="GLdt-variable-values"></a>variable values
               </dt>
               <dd>
                  <p>
                     <b>Variable values</b>. 
                     This is a mapping from <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> to value. 
                     It contains the
                     				same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the
                     				<a title="static context" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which
                     includes its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-warning"></a>warning
               </dt>
               <dd>
                  <p>In addition to <a title="static error" href="#dt-static-error">static errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" href="#dt-type-error">type
                        errors</a>, an XPath 3.1
                     implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                        phase</a> or the
                     <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
                        phase</a>. The circumstances in which warnings are raised, and
                     the ways in which warnings are handled, are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
                  </p>
               </dd>
               <dt><a id="GLWhitespace"></a>whitespace
               </dt>
               <dd>
                  <p>A <b>whitespace</b> character is any of
                     the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S">
                        [http://www.w3.org/TR/REC-xml/#NT-S]</a>.
                  </p>
               </dd>
               <dt><a id="GLdt-anyAtomicType"></a>xs:anyAtomicType
               </dt>
               <dd>
                  <p>
                     <code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
                     are not atomic). Its base type is
                     <code>xs:anySimpleType</code> from which all simple types, including atomic,
                     list, and union types, are derived. All primitive atomic types, such as
                     <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.
                  </p>
               </dd>
               <dt><a id="GLdt-dayTimeDuration"></a>xs:dayTimeDuration
               </dt>
               <dd>
                  <p>
                     <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
                     is restricted to contain only day, hour, minute, and second
                     components.
                  </p>
               </dd>
               <dt><a id="GLdt-xs-error"></a>xs:error
               </dt>
               <dd>
                  <p>
                     <code>xs:error</code> is a simple type with no value space.  It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error">Section 
                        
                        3.16.7.3 xs:error
                        
                        </a><sup><small>XS11-1</small></sup> and  can be used in the <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a> to raise errors.
                  </p>
               </dd>
               <dt><a id="GLdt-untyped"></a>xs:untyped
               </dt>
               <dd>
                  <p>
                     <code>xs:untyped</code> is  used as the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.
                  </p>
               </dd>
               <dt><a id="GLdt-untypedAtomic"></a>xs:untypedAtomic
               </dt>
               <dd>
                  <p>
                     <code>xs:untypedAtomic</code>
                     is an atomic type that is used to denote untyped atomic data, such as text that has
                     not been assigned a more specific type.
                  </p>
               </dd>
               <dt><a id="GLdt-yearMonthDuration"></a>xs:yearMonthDuration
               </dt>
               <dd>
                  <p>
                     <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
                     restricted to contain only year and month
                     components.
                  </p>
               </dd>
               <dt><a id="GLid-static-decimal-format-zero-digit"></a>zero-digit
               </dt>
               <dd>
                  <p>
                     <b>zero-digit</b>
                     		          is the character used to represent the digit zero; the default
                     		          value is the Western digit zero (#x30). This character must be a digit
                     		          (category Nd in the Unicode property database), and it must have
                     		          the numeric value zero. This property implicitly defines the
                     		          ten Unicode characters that are used to represent the values 0
                     		          to 9: Unicode is organized so that each
                     		          set of decimal digits forms a contiguous block of characters in
                     		          numerical sequence. Within the picture string any of these ten character
                     
                     		          can be used (interchangeably) as a place-holder for a mandatory digit.
                     		          Within the final result string, these ten characters are used to represent
                     		          the digits zero to nine.
                  </p>
               </dd>
            </dl>
         </div>
         <div class="div1">
            
            <h2><a id="id-incompatibilities"></a>H Backwards Compatibility (Non-Normative)
            </h2>
            <div class="div2">
               
               <h3><a id="d2e24209"></a>H.1 Incompatibilities relative to XPath 3.0
               </h3>
               <p>The following names are now reserved, and cannot appear as function names (see <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>):
               </p>
               <ul>
                  <li>
                     <p>
                        <code>map</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>array</code>
                        
                     </p>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="d2e24229"></a>H.2 Incompatibilities relative to XPath <span class="xpath">2.0</span>
                  
               </h3>
               <p>The following names are now reserved, and cannot appear as function names (see <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>):
               </p>
               <ul>
                  <li>
                     <p>
                        <code>function</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>namespace-node</code>
                        
                     </p>
                  </li>
                  <li>
                     <p>
                        <code>switch</code>
                        
                     </p>
                  </li>
               </ul>
               <p>If <code>U</code> is a union type with <code>T</code> as one of its members, and if <code>E</code> is an element with <code>T</code> as its type annotation, the expression <code>E instance of element(*, U)</code> returns <code>true</code> in both XPath 3.0 and 3.1.  In <span class="xpath">XPath 2.0</span>, it returns <code>false</code>.
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This is not an incompatibility with XPath 3.0.  It should be included in XPath 3.0
                     as an incompatibility with <span class="xpath">XPath 2.0</span> but it was discovered after publication.
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-backwards-compatibility"></a>H.3 Incompatibilities relative to XPath 1.0
               </h3>
               <p>This appendix provides a summary of the areas of incompatibility between <span>XPath 3.1</span> and
                  <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>. In each of these cases, an  <span>XPath 3.1</span> processor is compatible with an XPath 2.0 processor <span>or an XPath 3.0 processor</span>.
               </p>
               <p>Three separate cases are considered:</p>
               <ol class="enumar">
                  <li>
                     <p>Incompatibilities that exist when source documents have no schema, and when running
                        with XPath 1.0 compatibility mode set to true. This specification has been designed
                        to reduce the number of incompatibilities in this situation to an absolute minimum,
                        but some differences remain and are listed individually.
                     </p>
                  </li>
                  <li>
                     <p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to false. In
                        this case, the number of expressions where compatibility is lost is rather
                        greater.
                     </p>
                  </li>
                  <li>
                     <p>Incompatibilities that arise when the source document is processed using a schema
                        (whether or not XPath 1.0 compatibility mode is set to true). Processing the
                        document with a schema changes the way that the values of nodes are interpreted, and
                        this can cause an XPath expression to return different results.
                     </p>
                  </li>
               </ol>
               <div class="div3">
                  
                  <h4><a id="id-incompat-in-true-mode"></a>H.3.1 Incompatibilities when Compatibility Mode is true
                  </h4>
                  <p>The list below contains all known areas, within the scope of this specification, where
                     an
                     <span>XPath 3.1</span> processor running with compatibility mode set to true will produce different
                     results from an XPath 1.0 processor evaluating the same expression, assuming that
                     the
                     expression was valid in XPath 1.0, and that the nodes in the source document have
                     no
                     type annotations other than <code>xs:untyped</code> and
                     <code>xs:untypedAtomic</code>.
                  </p>
                  <p>Incompatibilities in the behavior of individual functions are not listed here, but
                     are
                     included in an appendix of <a href="#xpath-functions-31">[XQuery and XPath Functions and Operators 3.1]</a>.
                  </p>
                  <p>Since both XPath 1.0 and <span>XPath 3.1</span> leave some aspects of the specification
                     implementation-defined, there may be incompatibilities in the behavior of a particular
                     implementation that are outside the scope of this specification. Equally, some aspects
                     of the behavior of XPath are defined by the host language.
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were
                           supported in XPath 1.0, but are not permitted by the <span>XPath 3.1</span> grammar. In most
                           cases such comparisons in XPath 1.0 did not have the intuitive meaning, so it is
                           unlikely that they have been widely used in practice. If such a construct is
                           found, an <span>XPath 3.1</span> processor will report a syntax error, and the construct can
                           be rewritten as <code>(A &lt; B) &lt; C</code>
                           
                        </p>
                     </li>
                     <li>
                        <p>When converting strings to numbers (either explicitly when using the
                           <code>number</code> function, or implicitly say on a function call), certain
                           strings that converted to the special value <code>NaN</code> under XPath 1.0
                           will convert to values other than <code>NaN</code> under <span>XPath 3.1</span>. These
                           include any number written with a leading <code>+</code> sign, any number in
                           exponential floating point notation (for example <code>1.0e+9</code>), and the
                           strings <code>INF</code> and <code>-INF</code>.
                        </p>
                        <p>Furthermore, the strings <code>Infinity</code> and <code>-Infinity</code>, which
                           were accepted by XPath 1.0 as representations of the floating-point values
                           positive and negative infinity, are no longer recognized. They are converted to
                           <code>NaN</code> when running under <span>XPath 3.1</span> with compatibility mode set to
                           true, and cause a dynamic error when compatibility mode is set to false.
                        </p>
                     </li>
                     <li>
                        <p>
                           <span>XPath 3.1</span> does not allow a token starting with a letter to follow immediately
                           after a numeric literal, without intervening whitespace. For example,
                           <code>10div 3</code> was permitted in XPath 1.0, but in <span>XPath 3.1</span> must be
                           written as <code>10 div 3</code>.
                        </p>
                     </li>
                     <li>
                        <p>The namespace axis is deprecated as of XPath 2.0. Implementations may support the
                           namespace axis for backward compatibility with XPath 1.0, but they are not
                           required to do so. (XSLT 2.0 requires that if XPath backwards compatibility mode
                           is supported, then the namespace axis must also be supported; but other host
                           languages may define the conformance rules differently.)
                        </p>
                     </li>
                     <li>
                        <p>In XPath 1.0, the expression <code>-x|y</code> parsed as <code>-(x|y)</code>, and
                           returned the negation of the numeric value of the first node in the union of
                           <code>x</code> and <code>y</code>. In <span>XPath 3.1</span>, this expression parses as
                           <code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is true, this will
                           always cause a type error.
                        </p>
                     </li>
                     <li>
                        <p>The rules for converting numbers to strings have changed. These may affect the
                           way numbers are displayed in the output of a stylesheet. For numbers whose
                           absolute value is in the range <code>1E-6</code> to <code>1E+6</code>, the
                           result should be the same, but outside this range, scientific format is used for
                           non-integral <code>xs:float</code> and <code>xs:double</code> values.
                        </p>
                     </li>
                     <li>
                        <p>If one operand in a general comparison is a single atomic value of type
                           <code>xs:boolean</code>, the other operand is converted to
                           <code>xs:boolean</code> when XPath 1.0 compatibility mode is set to true. In
                           XPath 1.0, if neither operand of a comparison operation using the &lt;, &lt;=,
                           &gt; or &gt;= operator was a node set, both operands were converted to numbers.
                           The result of the expression <code>true() &gt; number('0.5')</code> is therefore
                           true in XPath 1.0, but is false in <span>XPath 3.1</span> even when compatibility mode is set
                           to true.
                        </p>
                     </li>
                     <li>
                        <p>In <span>XPath 3.1</span>, a type error is raised if the PITarget specified in a SequenceType
                           of form <code>processing-instruction(PITarget)</code> is not a valid NCName. In
                           XPath 1.0, this condition was not treated as an error.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-incompat-in-false-mode"></a>H.3.2 Incompatibilities when Compatibility Mode is false
                  </h4>
                  <p>Even when the setting of the XPath 1.0 compatibility mode is false, many XPath
                     expressions will still produce the same results under <span>XPath 3.1</span> as under XPath 1.0. The
                     exceptions are described in this section.
                  </p>
                  <p>In all cases it is assumed that the expression in question was valid under XPath 1.0,
                     that XPath 1.0 compatibility mode is false, and that all elements and attributes are
                     annotated with the types <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.
                  </p>
                  <p>In the description below, the terms <em>node-set</em> and <em>number</em> are
                     used with their XPath 1.0 meanings, that is, to describe expressions which according
                     to
                     the rules of XPath 1.0 would have generated a node-set or a number respectively.
                  </p>
                  <ol class="enumar">
                     <li>
                        <p>When a node-set containing more than one node is supplied as an argument to a
                           function or operator that expects a single node or value, the XPath 1.0 rule was
                           that all nodes after the first were discarded. Under <span>XPath 3.1</span>, a type error
                           occurs if there is more than one node. The XPath 1.0 behavior can always be
                           restored by using the predicate <code>[1]</code> to explicitly select the first
                           node in the node-set.
                        </p>
                     </li>
                     <li>
                        <p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when applied
                           to two strings, attempted to convert both the strings to numbers and then made a
                           numeric comparison between the results. In <span>XPath 3.1</span>, these operators perform a
                           string comparison using the default collating sequence. (If either value is
                           numeric, however, the results are compatible with XPath 1.0)
                        </p>
                     </li>
                     <li>
                        <p>When an empty node-set is supplied as an argument to a function or operator that
                           expects a number, the value is no longer converted implicitly to NaN. The XPath
                           1.0 behavior can always be restored by using the <code>number</code> function to
                           perform an explicit conversion.
                        </p>
                     </li>
                     <li>
                        <p>More generally, the supplied arguments to a function or operator are no longer
                           implicitly converted to the required type, except in the case where the supplied
                           argument is of type <code>xs:untypedAtomic</code> (which will commonly be the
                           case when a node in a schemaless document is supplied as the argument). For
                           example, the function call <code>substring-before(10 div 3,
                              ".")</code> raises a type error under <span>XPath 3.1</span>, because the arguments to
                           the <code>substring-before</code> function must be strings rather than numbers.
                           The XPath 1.0 behavior can be restored by performing an explicit conversion to
                           the required type using a constructor function or cast.
                        </p>
                     </li>
                     <li>
                        <p>The rules for comparing a node-set to a boolean have changed. In XPath 1.0, an
                           expression such as <code>$node-set = true()</code> was
                           evaluated by converting the node-set to a boolean and then performing a boolean
                           comparison: so this expression would return <code>true</code> if
                           <code>$node-set</code> was non-empty. In <span>XPath 3.1</span>, this expression is
                           handled in the same way as other comparisons between a sequence and a singleton:
                           it is <code>true</code> if <code>$node-set</code> contains at least one node
                           whose value, after atomization and conversion to a boolean using the casting
                           rules, is <code>true</code>.
                        </p>
                        <p>This means that if <code>$node-set</code> is empty, the result under <span>XPath 3.1</span>
                           will be <code>false</code> regardless of the value of the boolean operand, and
                           regardless of which operator is used. If <code>$node-set</code> is non-empty,
                           then in most cases the comparison with a boolean is likely to fail, giving a
                           dynamic error. But if a node has the value "0", "1", "true", or "false",
                           evaluation of the expression may succeed.
                        </p>
                     </li>
                     <li>
                        <p>Comparisons of a number to a boolean, a number to a string, or a string to a
                           boolean are not allowed in <span>XPath 3.1</span>: they result in a type error. In XPath 1.0
                           such comparisons were allowed, and were handled by converting one of the
                           operands to the type of the other. So for example in XPath 1.0 <code>4 = true()</code> was true; <code>4 =
                              "+4"</code> was false (because the string <code>+4</code> converts to
                           <code>NaN</code>), and <code>false = "false"</code> was false (because the
                           string <code>"false"</code> converts to the boolean <code>true</code>). In XPath
                           3.0 all these comparisons are type errors.
                        </p>
                     </li>
                     <li>
                        <p>Additional numeric types have been introduced, with the effect that arithmetic
                           may now be done as an integer, decimal, or single- or double-precision floating
                           point calculation where previously it was always performed as double-precision
                           floating point. The result of the <code>div</code> operator when dividing two
                           integers is now a value of type decimal rather than double. The expression <code>10 div 0</code> raises an error rather than returning
                           positive infinity.
                        </p>
                     </li>
                     <li>
                        <p>The rules for converting strings to numbers have changed. The implicit conversion
                           that occurs when passing an <code>xs:untypedAtomic</code> value as an argument
                           to a function that expects a number no longer converts unrecognized strings to
                           the value <code>NaN</code>; instead, it reports a dynamic error. This is in
                           addition to the differences that apply when backwards compatibility mode is set
                           to true.
                        </p>
                     </li>
                     <li>
                        <p>Many operations in <span>XPath 3.1</span> produce an empty sequence as their result when one
                           of the arguments or operands is an empty sequence. Where the operation expects a
                           string, an empty sequence is usually considered equivalent to a zero-length
                           string, which is compatible with the XPath 1.0 behavior. Where the operation
                           expects a number, however, the result is not the same. For example, if
                           <code>@width</code> returns an empty sequence, then in XPath 1.0 the result
                           of <code>@width+1</code> was <code>NaN</code>, while with
                           <span>XPath 3.1</span> it is <code>()</code>. This has the effect that a filter expression
                           such as <code>item[@width+1 != 2]</code> will select items
                           having no <code>width</code> attribute under XPath 1.0, and will not select them
                           under <span>XPath 3.1</span>.
                        </p>
                     </li>
                     <li>
                        <p>The typed value of a comment node, processing instruction node, or namespace node
                           under <span>XPath 3.1</span> is of type <code>xs:string</code>, not
                           <code>xs:untypedAtomic</code>. This means that no implicit conversions are
                           applied if the value is used in a context where a number is expected. If a
                           processing-instruction node is used as an operand of an arithmetic operator, for
                           example, XPath 1.0 would attempt to convert the string value of the node to a
                           number (and deliver <code>NaN</code> if unsuccessful), while <span>XPath 3.1</span> will
                           report a type error.
                        </p>
                     </li>
                     <li>
                        <p>In XPath 1.0, it was defined that with an expression of the form <code>A and
                              B</code>, B would not be evaluated if A was false. Similarly in the case of
                           <code>A or B</code>, B would not be evaluated if A was true. This is no
                           longer guaranteed with <span>XPath 3.1</span>: the implementation is free to evaluate the two
                           operands in either order or in parallel. This change has been made to give more
                           scope for optimization in situations where XPath expressions are evaluated
                           against large data collections supported by indexes. Implementations may choose
                           to retain backwards compatibility in this area, but they are not obliged to do
                           so.
                        </p>
                     </li>
                     <li>
                        <p>In XPath 1.0, the expression <code>-x|y</code> parsed as <code>-(x|y)</code>, and
                           returned the negation of the numeric value of the first node in the union of
                           <code>x</code> and <code>y</code>. In <span>XPath 3.1</span>, this expression parses as
                           <code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is false, this will
                           cause a type error, except in the situation where <code>x</code> evaluates to an
                           empty sequence. In that situation, <span>XPath 3.1</span> will return the value of
                           <code>y</code>, whereas XPath 1.0 returned the negation of the numeric value
                           of <code>y</code>.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-incompat-when-using-schema"></a>H.3.3 Incompatibilities when using a Schema
                  </h4>
                  <p>An XPath expression applied to a document that has been processed against a schema
                     will
                     not always give the same results as the same expression applied to the same document
                     in
                     the absence of a schema. Since schema processing had no effect on the result of an
                     XPath
                     1.0 expression, this may give rise to further incompatibilities. This section gives
                     a
                     few examples of the differences that can arise.
                  </p>
                  <p>Suppose that the context node is an element node derived from the following markup:
                     <code>&lt;background color="red green blue"/&gt;</code>. In XPath 1.0, the predicate
                     <code>[@color="blue"]</code> would return <code>false</code>. In <span>XPath 3.1</span>, if the
                     <code>color</code> attribute is defined in a schema to be of type
                     <code>xs:NMTOKENS</code>, the same predicate will return <code>true</code>.
                  </p>
                  <p>Similarly, consider the expression <code>@birth &lt; @death</code>
                     applied to the element <code>&lt;person birth="1901-06-06"
                        death="1991-05-09"/&gt;</code>. With XPath 1.0, this expression would return false,
                     because both attributes are converted to numbers, which returns <code>NaN</code> in each
                     case. With <span>XPath 3.1</span>, in the presence of a schema that annotates these attributes as
                     dates, the expression returns <code>true</code>.
                  </p>
                  <p>Once schema validation is applied, elements and attributes cannot be used as operands
                     and
                     arguments of expressions that expect a different data type. For example, it is no
                     longer
                     possible to apply the <code>substring</code> function to a date to extract the year
                     component, or to a number to extract the integer part. Similarly, if an attribute
                     is
                     annotated as a boolean then it is not possible to compare it with the strings
                     <code>"true"</code> or <code>"false"</code>. All such operations lead to type
                     errors. The remedy when such errors occur is to introduce an explicit conversion,
                     or to
                     do the computation in a different way. For example, <code>substring-after(@temperature, "-")</code> might be rewritten as <code>abs(@temperature)</code>.
                  </p>
                  <p>In the case of an <span>XPath 3.1</span> implementation that provides the static typing feature, many
                     further type errors will be reported in respect of expressions that worked under XPath
                     1.0. For example, an expression such as <code>round(../@price)</code>
                     might lead to a static type error because the processor cannot infer statically that
                     <code>../@price</code> is guaranteed to be numeric.
                  </p>
                  <p>Schema validation will in many cases perform whitespace normalization on the contents
                     of
                     elements (depending on their type). This will change the result of operations such
                     as
                     the <code>string-length</code> function.
                  </p>
                  <p>Schema validation augments the data model by adding default values for omitted attributes
                     and empty elements.
                  </p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="id-revision-log"></a>I Change Log (Non-Normative)
            </h2>
            <p class="xpath">This appendix lists the changes that have been made to this
               specification since the publication of XPath 3.0 Recommendation.
            </p>
            <div class="div2">
               
               <h3><a id="id-changes-since-2CR"></a>I.1 Changes since the Candidate Recommendation of 17 December 2015
               </h3>
               <div class="div3">
                  
                  <h4><a id="d2e24816"></a>I.1.1 Substantive Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>Added switch expressions to list of conditional expressions in <a href="#id-errors-and-opt"><b>2.3.4 Errors and
                                 Optimization</b></a>.  Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29320">Bug 29320</a>.
                        </p>
                     </li>
                     <li>
                        <p>If the <a title="content expression" href="#dt-content-expression">content expression</a> is not provided explicitly, the content expression is <code>()</code>.  Previously, no content expression was provided, but the value of the content was
                           specified.  This caused problems evaluating functions with empty bodies, and failed
                           to provide a host language expression for the function implementation in the data
                           model.
                        </p>
                     </li>
                     <li>
                        <p>Partial function application never returns a map or an array.  If <code>$F</code> is a map or an array, then <code>$F(?)</code> is 
                           a partial function application that returns a function, but the function it returns
                           is not a map nor an array. Resolves action A-640-03.
                        </p>
                     </li>
                     <li>
                        <p>Added <code>xs:anySimpleType</code> to the list of types that have no contructor function.   Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29583">Bug 29583</a>.
                        </p>
                     </li>
                     <li>
                        <p>Added requirement to specify minimum values for some date and time functions.   Resolves
                           <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29576">Bug 29576</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed the rules for atomization in lookup in <a href="#id-lookup"><b>3.11.3 The Lookup Operator ("?") for Maps and Arrays</b></a>.   Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29622">Bug 29622</a>.
                        </p>
                     </li>
                     <li>
                        <p>Allowed more specific typing of maps, arrays, and functions.  Affects <a href="#id-map-test"><b>2.5.5.8 Map Test</b></a>, <a href="#id-array-test"><b>2.5.5.9 Array Test</b></a>, <a href="#id-itemtype-subtype"><b>2.5.6.2 The judgement subtype-itemtype(Ai, Bi) 
                                 </b></a>, <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>, and <a href="#id-inline-func"><b>3.1.7 Inline Function Expressions</b></a>. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29586">Bug 29586</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed <a href="#id-map-lookup"><b>3.11.1.2 Map Lookup using Function Call Syntax</b></a> to define semantics using only <a href="https://www.w3.org/TR/xpath-functions-31/#func-map-get">Section 
                              
                              17.1.6 map:get
                              </a><sup><small>FO31</small></sup>, changed <a href="#id-array-lookup"><b>3.11.2.2 Array Lookup using Function Call Syntax</b></a> to define semantics using only <a href="https://www.w3.org/TR/xpath-functions-31/#func-array-get">Section 
                              
                              17.3.2 array:get
                              </a><sup><small>FO31</small></sup>, thus aligning edge cases and eliminating the possibility of discrepancies creeping
                           in.   Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29683">Bug 29683</a>.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="d2e24900"></a>I.1.2 Editorial Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>Significantly changed the prose in <a href="#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic Function Calls</b></a>.  Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29277">Bug 29277</a>.
                        </p>
                     </li>
                     <li>
                        <p>Created formal definition<span class="xpath">s</span> for <a title="implementation-defined function" href="#dt-implementation-defined-function">implementation-defined function</a>
                           <span class="xpath">
                              and <a title="host language function" href="#dt-host-language-function">host language function</a>
                              </span>.
                        </p>
                     </li>
                     <li>
                        <p>Fixed a problem with conditional text in <a href="#id-itemtype-subtype"><b>2.5.6.2 The judgement subtype-itemtype(Ai, Bi) 
                                 </b></a>:
                           <code>Bi</code> is <code> function(*)</code>,
                           <code>Ai</code> is a <a href="#doc-xpath31-FunctionTest">FunctionTest</a>.
                           Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29414">Bug 29414</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed definition of <a title="same key" href="#dt-same-key">same key</a>, redefining it in terms of  <a href="https://www.w3.org/TR/xpath-functions-31/#func-same-key">Section 
                              
                              17.1.1 op:same-key
                              </a><sup><small>FO31</small></sup>. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29362">Bug 29362</a>.
                        </p>
                     </li>
                     <li>
                        <p>Moved definition of <a title="enclosed expression" href="#dt-enclosed-expression">enclosed expression</a> to prevent it from disappearing in XPath. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29382">Bug 29382</a>.
                        </p>
                     </li>
                     <li>
                        <p>Modified <a href="#id-conformance"><b>4 Conformance</b></a> to be more consistent with RFC2119.  Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29498">Bug 29498</a>.
                        </p>
                     </li>
                     <li>
                        <p>Deleted erroneous note in <a href="#id-unary-lookup"><b>3.11.3.1 Unary Lookup</b></a> that claimed <code>array?*</code> is equivalent to <code>array:flatten</code>. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29487">Bug 29487</a>.
                        </p>
                     </li>
                     <li>
                        <p>Provided definitions of <a title="implementation-defined function" href="#dt-implementation-defined-function">implementation-defined function</a>, moved definition of <a title="external function" href="#dt-external-function">external function</a>
                           <span class="xpath">, added definition of <a title="host language function" href="#dt-host-language-function">host language function</a>
                              </span>.  Eliminated references to "host programming languages". Clarified wording on external
                           function declarations. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29509">Bug 29509</a>.
                        </p>
                     </li>
                     <li>
                        <p>Removed a dangling otherwise clause that belonged to the XQuery specification. Resolves
                           <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29693">Bug 29693</a>.
                        </p>
                     </li>
                     <li>
                        <p>Made EBNF productions in the document body look the same as those in Appendix A (by
                           adding production annotations to the former), thus eliminating the need to specify
                           which is normative.
                        </p>
                     </li>
                     <li>
                        <p>Clarified ambiguous wording about comments in <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit Whitespace Handling</b></a>. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29700">Bug 29700</a>.
                        </p>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="d2e25025"></a>I.2 Changes introduced in the Candidate Recommendation of 17 December 2015
               </h3>
               <div class="div3">
                  
                  <h4><a id="id-changes-2CR-substantive"></a>I.2.1 Substantive Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>Significant rewrite of <a href="#id-xs-error"><b>2.5.7 xs:error</b></a>. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29119">Bug 29119</a>. 
                        </p>
                     </li>
                     <li>
                        <p>Removed non-normative description of casting rules, referring to the normative definition
                           instead. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29192">Bug 29192</a>.
                        </p>
                     </li>
                     <li>
                        <p>To allow streaming, context size may be undefined in an XPath implementation, in which
                           case <code>last()</code> raises an error. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29227">Bug 29227</a>.
                        </p>
                     </li>
                     <li>
                        <p>Clarified semantics of external context item declaration in library modules. Resolves
                           <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29246">Bug 29246</a>.
                        </p>
                     </li>
                     <li>
                        <p>In <a href="#static_context"><b>2.1.1 Static Context</b></a>, clarified that
                           only function signatures that are present in the static context
                           — not actual function implementations. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28175">Bug 28175</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed rules for <a title="same key" href="#dt-same-key">same key
                              value</a> to improve handling of maps in which keys may or
                           may not have timezones.  Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28632">Bug 28632</a>
                           and  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28729">Bug 28729</a>.
                        </p>
                     </li>
                     <li>
                        <p>The precedence of the <a href="#id-arrow-operator"><b>3.16 Arrow operator (=&gt;)</b></a> has changed.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27537">Bug 27537</a>.
                        </p>
                     </li>
                     <li>
                        <p>The error when atomizing a function, map, or array is <code>[err:FOTY0013]</code>, not <code>[err:FOTY0012]</code>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27610">Bug 27610</a>.
                        </p>
                     </li>
                     <li>
                        <p>Collections can now contain any item.  This affects <a title="statically known  collections" href="#dt-known-collections">statically known collections</a>, <a title="statically known  collections" href="#dt-known-collections">statically known collection type</a>, 
                           <a title="available item collections" href="#dt-available-collections">available collections</a> (formerly known as <a title="available item collections" href="#dt-available-collections">available node collections</a>, 
                           <a title="default collection" href="#dt-default-collection">default collection</a> (formerly known as <a title="default collection" href="#dt-default-collection">default node collection</a>, 
                           <a href="#id-consistency-constraints"><b>2.2.4 Consistency Constraints</b></a>, 
                           <a href="#id-input-sources"><b>2.4.4 Input Sources</b></a>.
                        </p>
                     </li>
                     <li>
                        <p>Fixed outdated text that restricted constructor functions to atomic or generalized
                           atomic types.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28915">Bug 28915</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed the semantics of <a href="#id-postfix-lookup"><b>3.11.3.2 Postfix Lookup</b></a> . Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27536">Bug 27536</a>, fixing inadequacies in the earlier resolution.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-changes-PR-editorial"></a>I.2.2 Editorial Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>Refactored the grammar to use <code>EnclosedExpr</code>  consistently.
                        </p>
                     </li>
                     <li>
                        <p>Added a paragraph clarifying the type of an array as a function.   Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29260">Bug 29260</a>.
                        </p>
                     </li>
                     <li>
                        <p>Clarified how function coercion applies to maps and arrays using two examples.  Resolves
                           <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27059">Bug 27059</a>.
                        </p>
                     </li>
                     <li>
                        <p>Removed nine operators from <a href="#mapping"><b>B.2 Operator Mapping</b></a> to eliminate redundant specification. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22456">Bug 22456</a>.
                        </p>
                     </li>
                     <li>
                        <p>Modified <a href="#id-conformance"><b>4 Conformance</b></a> to use the term <a title="must not" href="#mustnot">MUST NOT</a>. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28023">Bug 28023</a>.
                        </p>
                     </li>
                     <li>
                        <p>Added explicit semantics for NCName in <a href="#id-lookup"><b>3.11.3 The Lookup Operator ("?") for Maps and Arrays</b></a>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28701">Bug 28701</a>.
                        </p>
                     </li>
                     <li>
                        <p>Deleted obsolete discussion of named function references and <code>xs:numeric</code>.
                           Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28081">Bug 28081</a>.
                        </p>
                     </li>
                     <li>
                        <p>Removed the unused definition of the initial context item.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28905">Bug 28905</a>.
                        </p>
                     </li>
                     <li>
                        <p>Significantly changed description of names in <a href="#id-basics"><b>2 Basics</b></a>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28241">Bug 28241</a>.
                        </p>
                     </li>
                     <li>
                        <p>Fixed a number of dangling references to XQuery/XPath 3.0 where 3.1 was intended.
                           Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28782">Bug 28782</a>.
                        </p>
                     </li>
                     <li>
                        <p>Clarified the text in <a href="#id-incompatibilities"><b>H Backwards Compatibility</b></a> about SequenceType matching and union types. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28894">Bug 28894</a>.
                        </p>
                     </li>
                     <li>
                        <p>Renamed Available Resource Collections to <a title="available uri collections" href="#dt-available-uri-collections">Available URI Collections</a>, 
                           renamed Available Node Collections to <a title="available item collections" href="#dt-available-collections">Available Collections</a>, 
                           renamed Default Resource Collection to <a title="default URI collection" href="#dt-default-uri-collection">Default URI Collection</a>, 
                           renamed Default Node Collection to <a title="default collection" href="#dt-default-collection">Default Collection</a>.
                           Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28957">Bug 28957</a>.
                        </p>
                     </li>
                     <li>
                        <p>Clarified the definition of <a title="built-in function" href="#dt-built-in-function">built-in functions</a>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28282">Bug 28282</a>.
                        </p>
                     </li>
                     <li>
                        <p>Clarified the text in <a href="#id-arrow-operator"><b>3.16 Arrow operator (=&gt;)</b></a>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29346">Bug 29346</a>.
                        </p>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="d2e25263"></a>I.3 Changes introduced in the Candidate Recommendation of 18 December 2014
               </h3>
               <div class="div3">
                  
                  <h4><a id="id-changes-CR-substantive"></a>I.3.1 Substantive Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>If a value in a map constructor or a member in an array constructor is a map or array,
                           it is copied. If a value in a map
                           constructor or a member in an array constructor is a node, it is not copied. Resolves
                           <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26958">Bug 26958</a>.
                        </p>
                     </li>
                     <li>
                        <p>In the definition of <a title="numeric" href="#dt-numeric">numeric</a>, we now state that all numeric types are member types of <code>xs:numeric</code>.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20631">Bug 20631</a>.
                        </p>
                     </li>
                     <li>
                        <p>Modified rule 14 of <a href="#id-itemtype-subtype"><b>2.5.6.2 The judgement subtype-itemtype(Ai, Bi) 
                                 </b></a>. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27175">Bug 27175</a>.
                        </p>
                     </li>
                     <li>
                        <p>In <a href="#id-unary-lookup"><b>3.11.3.1 Unary Lookup</b></a>, if the context item is not a map or an array, a type error [err:XPTY0004] is raised.
                           If the array index is out of bounds, [err:FOAY0001] is raised. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27382">Bug 27382</a>.
                        </p>
                     </li>
                     <li>
                        <p>Changed the semantics of <a href="#id-postfix-lookup"><b>3.11.3.2 Postfix Lookup</b></a> to <code>for $a in E, $b in S return $a($b)</code>. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27536">Bug 27536</a>.
                        </p>
                     </li>
                     <li>
                        <p>Arrays in element content are flattened, not atomized. Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27463">Bug 27463</a>.
                        </p>
                     </li>
                     <li>
                        <p>
                           <a href="#id-arrow-operator"><b>3.16 Arrow operator (=&gt;)</b></a> is now well defined when the left hand operand is a sequence rather than an item.
                           Partially resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27537">Bug 27537</a>.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-changes-CR-editorial"></a>I.3.2 Editorial Changes
                  </h4>
                  <ol class="enumar">
                     <li>
                        <p>Modified the wording used to describe node identity per <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27048">Bug 27048</a>, comment #2.
                        </p>
                     </li>
                     <li>
                        <p>Fixed specification gaps in unary lookup.  Resolves <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27455">Bug 27455</a>.
                        </p>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-changes-prior-drafts"></a>I.4 Changes introduced in prior Working Drafts
               </h3>
               <ol class="enumar">
                  <li>
                     <p>Added <a href="#id-maps"><b>3.11.1 Maps</b></a> and <a href="#id-arrays"><b>3.11.2 Arrays</b></a>. These are the most important new features in XPath 3.1
                     </p>
                  </li>
                  <li>
                     <p>Clarified error code XQST0134 for XPath implementations that do not support the namespace
                        axis, default axis for namespace-node() in abbreviated syntax. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26788">Bug 26788</a>.
                     </p>
                  </li>
                  <li>
                     <p>Simplified type conversions for value comparisons and orderspecs, eliminating the
                        concept of lowest common supertype. Resolves  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26453">Bug 26453</a>.
                     </p>
                  </li>
                  <li>
                     <p>Modified text of <a href="#id-general-comparisons"><b>3.7.2 General Comparisons</b></a> to clarify that the result of a comparison can be either false or an error. Resolves
                        <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26832">Bug 26832</a>.
                     </p>
                  </li>
                  <li>
                     <p>Added <a href="#id-map-constructors"><b>3.11.1.1 Map Constructors</b></a> and <a href="#id-map-lookup"><b>3.11.1.2 Map Lookup using Function Call Syntax</b></a>.
                     </p>
                  </li>
                  <li>
                     <p>Added <a href="#id-array-constructors"><b>3.11.2.1 Array Constructors</b></a> and <a href="#id-array-lookup"><b>3.11.2.2 Array Lookup using Function Call Syntax</b></a>.
                     </p>
                  </li>
                  <li>
                     <p>Defined <a href="#id-atomization"><b>2.4.2 Atomization</b></a> of an array (atomization of a map is an error).
                     </p>
                  </li>
                  <li>
                     <p>Added <a href="#id-map-test"><b>2.5.5.8 Map Test</b></a> and <a href="#id-array-test"><b>2.5.5.9 Array Test</b></a> to test whether an item is a map or an array respectively.
                     </p>
                  </li>
                  <li>
                     <p>Added <code>exponent-separator</code> to the static context to support <code>fn:format-number()</code>.
                     </p>
                  </li>
                  <li>
                     <p>Eliminated use of to array functions that are no longer in Functions &amp; and Operators,
                        such as <code>fn:seq()</code>. Changed <code>ay:</code> prefix to <code>array:</code> to match current  Functions &amp; and Operators.
                     </p>
                  </li>
                  <li>
                     <p>Added <a href="#id-map-lookup"><b>3.11.1.2 Map Lookup using Function Call Syntax</b></a>, replacing the less general map lookup operator from the previous Working Draft.
                     </p>
                  </li>
                  <li>
                     <p>
                        <a href="#id-array-lookup"><b>3.11.2.2 Array Lookup using Function Call Syntax</b></a> with negative integer arguments are no longer type errors, they are dynamic errors.
                     </p>
                  </li>
                  <li>
                     <p>If the keys in a <a href="#id-map-constructors"><b>3.11.1.1 Map Constructors</b></a>
                        contain both date/time values with a timezone and date/time
                        values with no timezone, a dynamic error is raised. 
                     </p>
                  </li>
                  <li>
                     <p>In maps, keys of type <code>xs:untypedAtomic</code> are no longer converted to <code>xs:string</code>.
                     </p>
                  </li>
               </ol>
            </div>
         </div>
      </div><script src="//www.w3.org/scripts/TR/2016/fixup.js"></script>
      <p role="navigation" id="back-to-top"><a href="#toc"><abbr title="Back to top">↑</abbr></a></p>
      </body>
</html>
