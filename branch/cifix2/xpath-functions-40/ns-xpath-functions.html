<?xml version="1.0" encoding="utf-8"?>
<!--XSLT Processor: Saxonica-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<title>XQuery, XPath, and XSLT Functions and Operators Namespace
Document</title>
<meta name="viewport" content=
"width=device-width, initial-scale=1, shrink-to-fit=no" />
<style type="text/css"></style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/base.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery, XPath, and XSLT
Functions and Operators Namespace Document</h1>
<h2>21 March 2017</h2>
</div>
<nav id="toc">
<h2><a id="contents" name="contents"></a>Table of Contents</h2>
<ol class="toc">
<li><a href="#intro"><span class="secno">1</span> <span class=
"content">Introduction</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#fo-summary"><span class="secno">2</span> <span class=
"content">XQuery and XPath Functions</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#xslt-summary"><span class="secno">3</span>
<span class="content">XSL Transformations (XSLT)
Functions</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#xqupdate-summary"><span class="secno">4</span>
<span class="content">XQuery Update Functions</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#schemas"><span class="secno">5</span> <span class=
"content">XML Schema</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#normrefs"><span class="secno">6</span> <span class=
"content">Normative References</span></a>
<ol class="toc"></ol>
</li>
<li><a href="#nonnormrefs"><span class="secno">7</span>
<span class="content">Non-Normative References</span></a>
<ol class="toc"></ol>
</li>
</ol>
</nav>
<hr />
<div class="body">
<div>
<h2><a id="intro" name="intro"></a>1 Introduction</h2>
<p>This document describes the namespace
<code>http://www.w3.org/2005/xpath-functions</code> defined by the
[XPath and XQuery Functions and Operators 3.1] and [XSLT 3.0]
specifications. This namespace is conventionally identified by the
namespace prefix <code>fn</code>.</p>
<p>In XQuery, the mapping of the prefix <code>fn</code> to this
namespace is predefined.</p>
<p>In XSLT, it is not necessary to use a prefix when invoking
functions in this namespace, because this namespace is always the
default namespace for function calls.</p>
<p>For updated information, please refer to the latest version of
the [XPath and XQuery Functions and Operators 3.1] and [XSLT 3.0]
specifications.</p>
<p>The [XQuery Update 1.0] specification defines one additional
function in this namespace.</p>
<p>Functions are uniquely identified by the combination of
namespace URI, local name, and arity (number of arguments). For the
purpose of this document, functions having a common namespace URI
and local name can be considered to form a function family. A
function family can be uniquely identified with a URI of the form:
“<code>http://www.w3.org/2005/xpath-functions#</code><em>name</em>”
where <em>name</em> is the local name of a function, such as “max”:
<code><a href=
"#max">http://www.w3.org/2005/xpath-functions#max</a></code>.</p>
<p>This document describes the names that are defined in this
namespace at the time of publication. The W3C reserves the right to
define additional names in this namespace in the future. The
specifications listed above are the <em>only</em> specifications
that may amend this namespace.</p>
<p>The specifications referenced in this document are the latest
versions at time of publication. Older versions of these
specifications remain in use, and depending on the context, a name
in this namespace may be referring to an older version of the
specification than the one cited here.</p>
<p>This document contains a directory of links to related
resources, using RDDL (as defined in [Resource Directory
Description Language (RDDL)]).</p>
<p>It is GRDDL-enabled (as defined in [Gleaning Resource
Descriptions from Dialects of Languages (GRDDL)]); that is to say
that a GRDDL-compliant processor can extract useful RDF (as defined
in [Resource Description Framework (RDF): Concepts and Abstract
Syntax]) representations of the information contained herein.</p>
</div>
<div class="resource">
<h2><a id="fo-summary" name="fo-summary"></a>2 XQuery and XPath
Functions</h2>
<p>This section lists all of the functions in this namespace that
are defined in the [XPath and XQuery Functions and Operators 3.1]
specification.</p>
<p>The normative definitions of these functions are in the [XPath
and XQuery Functions and Operators 3.1] specification. For
convenience, a very brief, non-normative summary of each function
is provided. For details, follow the link on the “Summary:”
introductory text below each function.</p>
<h3><a name="abs" id="abs"></a>abs</h3>
<p><strong>abs</strong>(xs:numeric?) as xs:numeric?</p>
<p>Returns the absolute value of <code>$value</code>.</p>
<h3><a name="adjust-dateTime-to-timezone" id=
"adjust-dateTime-to-timezone"></a>adjust-dateTime-to-timezone</h3>
<p><strong>adjust-dateTime-to-timezone</strong>(xs:dateTime?) as
xs:dateTime?</p>
<p><strong>adjust-dateTime-to-timezone</strong>(xs:dateTime?,
xs:dayTimeDuration?) as xs:dateTime?</p>
<p>Adjusts an <code>xs:dateTime</code> value to a specific
timezone, or to no timezone at all.</p>
<h3><a name="adjust-date-to-timezone" id=
"adjust-date-to-timezone"></a>adjust-date-to-timezone</h3>
<p><strong>adjust-date-to-timezone</strong>(xs:date?) as
xs:date?</p>
<p><strong>adjust-date-to-timezone</strong>(xs:date?,
xs:dayTimeDuration?) as xs:date?</p>
<p>Adjusts an <code>xs:date</code> value to a specific timezone, or
to no timezone at all; the result is the date in the target
timezone that contains the starting instant of the supplied
date.</p>
<h3><a name="adjust-time-to-timezone" id=
"adjust-time-to-timezone"></a>adjust-time-to-timezone</h3>
<p><strong>adjust-time-to-timezone</strong>(xs:time?) as
xs:time?</p>
<p><strong>adjust-time-to-timezone</strong>(xs:time?,
xs:dayTimeDuration?) as xs:time?</p>
<p>Adjusts an <code>xs:time</code> value to a specific timezone, or
to no timezone at all.</p>
<h3><a name="all" id="all"></a>all</h3>
<p><strong>all</strong>(item()*, function(item()) as xs:boolean) as
xs:integer*</p>
<p>Returns true if all items in the input sequence match a supplied
predicate.</p>
<h3><a name="analyze-string" id=
"analyze-string"></a>analyze-string</h3>
<p><strong>analyze-string</strong>(xs:string?, xs:string) as
element(fn:analyze-string-result)</p>
<p><strong>analyze-string</strong>(xs:string?, xs:string,
xs:string) as element(fn:analyze-string-result)</p>
<p>Analyzes a string using a regular expression, returning an XML
structure that identifies which parts of the input string matched
or failed to match the regular expression, and in the case of
matched substrings, which substrings matched each capturing group
in the regular expression.</p>
<h3><a name="apply" id="apply"></a>apply</h3>
<p><strong>apply</strong>(function(*), array(*)) as item()*</p>
<p>Makes a dynamic call on a function with an argument list
supplied in the form of an array.</p>
<h3><a name="available-environment-variables" id=
"available-environment-variables"></a>available-environment-variables</h3>
<p><strong>available-environment-variables</strong>() as
xs:string*</p>
<p>Returns a list of environment variable names that are suitable
for passing to <code>fn:environment-variable</code>, as a (possibly
empty) sequence of strings.</p>
<h3><a name="avg" id="avg"></a>avg</h3>
<p><strong>avg</strong>(xs:anyAtomicType*) as xs:anyAtomicType?</p>
<p>Returns the average of the values in the input sequence
<code>$values</code>, that is, the sum of the values divided by the
number of values.</p>
<h3><a name="base-uri" id="base-uri"></a>base-uri</h3>
<p><strong>base-uri</strong>() as xs:anyURI?</p>
<p><strong>base-uri</strong>(node()?) as xs:anyURI?</p>
<p>Returns the base URI of a node.</p>
<h3><a name="boolean" id="boolean"></a>boolean</h3>
<p><strong>boolean</strong>(item()*) as xs:boolean</p>
<p>Computes the effective boolean value of the sequence
<code>$input</code>.</p>
<h3><a name="ceiling" id="ceiling"></a>ceiling</h3>
<p><strong>ceiling</strong>(xs:numeric?) as xs:numeric?</p>
<p>Rounds <code>$value</code> upwards to a whole number.</p>
<h3><a name="characters" id="characters"></a>characters</h3>
<p><strong>characters</strong>(xs:string?) as xs:string*</p>
<p>Splits the supplied string into a sequence of single-character
strings.</p>
<h3><a name="codepoint-equal" id=
"codepoint-equal"></a>codepoint-equal</h3>
<p><strong>codepoint-equal</strong>(xs:string?, xs:string?) as
xs:boolean?</p>
<p>Returns true if two strings are equal, considered
codepoint-by-codepoint.</p>
<h3><a name="codepoints-to-string" id=
"codepoints-to-string"></a>codepoints-to-string</h3>
<p><strong>codepoints-to-string</strong>(xs:integer*) as
xs:string</p>
<p>Returns an <code>xs:string</code> whose characters have supplied
codepoints.</p>
<h3><a name="collation-key" id=
"collation-key"></a>collation-key</h3>
<p><strong>collation-key</strong>(xs:string) as xs:base64Binary</p>
<p><strong>collation-key</strong>(xs:string, xs:string) as
xs:base64Binary</p>
<p>Given a string value and a collation, generates an internal
value called a collation key, with the property that the matching
and ordering of collation keys reflects the matching and ordering
of strings under the specified collation.</p>
<h3><a name="collection" id="collection"></a>collection</h3>
<p><strong>collection</strong>() as item()*</p>
<p><strong>collection</strong>(xs:string?) as item()*</p>
<p>Returns a sequence of items identified by a collection URI; or a
default collection if no URI is supplied.</p>
<h3><a name="compare" id="compare"></a>compare</h3>
<p><strong>compare</strong>(xs:string?, xs:string?) as
xs:integer?</p>
<p><strong>compare</strong>(xs:string?, xs:string?, xs:string) as
xs:integer?</p>
<p>Returns -1, 0, or 1, depending on whether <code>$value1</code>
collates before, equal to, or after <code>$value2</code> according
to the rules of a selected collation.</p>
<h3><a name="concat" id="concat"></a>concat</h3>
<p><strong>concat</strong>(xs:anyAtomicType?, xs:anyAtomicType?,
xs:anyAtomicType?) as xs:string</p>
<p>Returns the concatenation of the string values of the
arguments.</p>
<h3><a name="contains" id="contains"></a>contains</h3>
<p><strong>contains</strong>(xs:string?, xs:string?) as
xs:boolean</p>
<p><strong>contains</strong>(xs:string?, xs:string?, xs:string) as
xs:boolean</p>
<p>Returns true if the string <code>$value</code> contains
<code>$substring</code> as a substring, taking collations into
account.</p>
<h3><a name="contains-token" id=
"contains-token"></a>contains-token</h3>
<p><strong>contains-token</strong>(xs:string*, xs:string) as
xs:boolean</p>
<p><strong>contains-token</strong>(xs:string*, xs:string,
xs:string) as xs:boolean</p>
<p>Determines whether or not any of the supplied strings, when
tokenized at whitespace boundaries, contains the supplied token,
under the rules of the supplied collation.</p>
<h3><a name="count" id="count"></a>count</h3>
<p><strong>count</strong>(item()*) as xs:integer</p>
<p>Returns the number of items in a sequence.</p>
<h3><a name="current-date" id="current-date"></a>current-date</h3>
<p><strong>current-date</strong>() as xs:date</p>
<p>Returns the current date.</p>
<h3><a name="current-dateTime" id=
"current-dateTime"></a>current-dateTime</h3>
<p><strong>current-dateTime</strong>() as xs:dateTimeStamp</p>
<p>Returns the current date and time (with timezone).</p>
<h3><a name="current-time" id="current-time"></a>current-time</h3>
<p><strong>current-time</strong>() as xs:time</p>
<p>Returns the current time.</p>
<h3><a name="data" id="data"></a>data</h3>
<p><strong>data</strong>() as xs:anyAtomicType*</p>
<p><strong>data</strong>(item()*) as xs:anyAtomicType*</p>
<p>Returns the result of atomizing a sequence. This process
flattens arrays, and replaces nodes by their typed values.</p>
<h3><a name="dateTime" id="dateTime"></a>dateTime</h3>
<p><strong>dateTime</strong>(xs:date?, xs:time?) as
xs:dateTime?</p>
<p>Returns an <code>xs:dateTime</code> value created by combining
an <code>xs:date</code> and an <code>xs:time</code>.</p>
<h3><a name="day-from-date" id=
"day-from-date"></a>day-from-date</h3>
<p><strong>day-from-date</strong>(xs:date?) as xs:integer?</p>
<p>Returns the day component of an <code>xs:date</code>.</p>
<h3><a name="day-from-dateTime" id=
"day-from-dateTime"></a>day-from-dateTime</h3>
<p><strong>day-from-dateTime</strong>(xs:dateTime?) as
xs:integer?</p>
<p>Returns the day component of an <code>xs:dateTime</code>.</p>
<h3><a name="days-from-duration" id=
"days-from-duration"></a>days-from-duration</h3>
<p><strong>days-from-duration</strong>(xs:duration?) as
xs:integer?</p>
<p>Returns the number of days in a duration.</p>
<h3><a name="deep-equal" id="deep-equal"></a>deep-equal</h3>
<p><strong>deep-equal</strong>(item()*, item()*) as xs:boolean</p>
<p><strong>deep-equal</strong>(item()*, item()*, xs:string) as
xs:boolean</p>
<p>This function assesses whether two sequences are deep-equal to
each other. To be deep-equal, they must contain items that are
pairwise deep-equal; and for two items to be deep-equal, they must
either be atomic values that compare equal, or nodes of the same
kind, with the same name, whose children are deep-equal<span>, or
maps with matching entries, or arrays with matching
members.</span></p>
<h3><a name="default-collation" id=
"default-collation"></a>default-collation</h3>
<p><strong>default-collation</strong>() as xs:string</p>
<p>Returns the value of the default collation property from the
static context.</p>
<h3><a name="default-language" id=
"default-language"></a>default-language</h3>
<p><strong>default-language</strong>() as xs:language</p>
<p>Returns the value of the default language property from the
dynamic context.</p>
<h3><a name="differences" id="differences"></a>differences</h3>
<p><strong>differences</strong>(item(), item()) as map(*)*</p>
<p><strong>differences</strong>(item(), item(), map(*)) as
map(*)*</p>
<p><strong>differences</strong>(item(), item(), map(*), xs:string)
as map(*)*</p>
<p>This function compares two sequences and returns information
about their differences.</p>
<h3><a name="distinct-values" id=
"distinct-values"></a>distinct-values</h3>
<p><strong>distinct-values</strong>(xs:anyAtomicType*) as
xs:anyAtomicType*</p>
<p><strong>distinct-values</strong>(xs:anyAtomicType*, xs:string)
as xs:anyAtomicType*</p>
<p>Returns the values that appear in a sequence, with duplicates
eliminated.</p>
<h3><a name="doc" id="doc"></a>doc</h3>
<p><strong>doc</strong>(xs:string?) as document-node()?</p>
<p>Retrieves a document using a URI supplied as an
<code>xs:string</code>, and returns the corresponding document
node.</p>
<h3><a name="doc-available" id=
"doc-available"></a>doc-available</h3>
<p><strong>doc-available</strong>(xs:string?) as xs:boolean</p>
<p>The function returns true if and only if the function call
<code>fn:doc($href)</code> would return a document node.</p>
<h3><a name="document-uri" id="document-uri"></a>document-uri</h3>
<p><strong>document-uri</strong>() as xs:anyURI?</p>
<p><strong>document-uri</strong>(node()?) as xs:anyURI?</p>
<p>Returns the URI of a resource where a document can be found, if
available.</p>
<h3><a name="element-with-id" id=
"element-with-id"></a>element-with-id</h3>
<p><strong>element-with-id</strong>(xs:string*) as element()*</p>
<p><strong>element-with-id</strong>(xs:string*, node()) as
element()*</p>
<p>Returns the sequence of element nodes that have an
<code>ID</code> value matching the value of one or more of the
<code>IDREF</code> values supplied in <code>$values</code>.</p>
<h3><a name="empty" id="empty"></a>empty</h3>
<p><strong>empty</strong>(item()*) as xs:boolean</p>
<p>Returns true if the argument is the empty sequence.</p>
<h3><a name="encode-for-uri" id=
"encode-for-uri"></a>encode-for-uri</h3>
<p><strong>encode-for-uri</strong>(xs:string?) as xs:string</p>
<p>Encodes reserved characters in a string that is intended to be
used in the path segment of a URI.</p>
<h3><a name="ends-with" id="ends-with"></a>ends-with</h3>
<p><strong>ends-with</strong>(xs:string?, xs:string?) as
xs:boolean</p>
<p><strong>ends-with</strong>(xs:string?, xs:string?, xs:string) as
xs:boolean</p>
<p>Returns true if the string <code>$value</code> contains
<code>$substring</code> as a trailing substring, taking collations
into account.</p>
<h3><a name="environment-variable" id=
"environment-variable"></a>environment-variable</h3>
<p><strong>environment-variable</strong>(xs:string) as
xs:string?</p>
<p>Returns the value of a system environment variable, if it
exists.</p>
<h3><a name="error" id="error"></a>error</h3>
<p><strong>error</strong>() as none</p>
<p><strong>error</strong>(xs:QName?) as none</p>
<p><strong>error</strong>(xs:QName?, xs:string) as none</p>
<p><strong>error</strong>(xs:QName?, xs:string, item()*) as
none</p>
<p>Calling the <code>fn:error</code> function raises an
application-defined error.</p>
<h3><a name="escape-html-uri" id=
"escape-html-uri"></a>escape-html-uri</h3>
<p><strong>escape-html-uri</strong>(xs:string?) as xs:string</p>
<p>Escapes a URI in the same way that HTML user agents handle
attribute values expected to contain URIs.</p>
<h3><a name="exactly-one" id="exactly-one"></a>exactly-one</h3>
<p><strong>exactly-one</strong>(item()*) as item()</p>
<p>Returns <code>$input</code> if it contains exactly one item.
Otherwise, raises an error.</p>
<h3><a name="exists" id="exists"></a>exists</h3>
<p><strong>exists</strong>(item()*) as xs:boolean</p>
<p>Returns true if the argument is a non-empty sequence.</p>
<h3><a name="false" id="false"></a>false</h3>
<p><strong>false</strong>() as xs:boolean</p>
<p>Returns the <code>xs:boolean</code> value
<code>false</code>.</p>
<h3><a name="filter" id="filter"></a>filter</h3>
<p><strong>filter</strong>(item()*, function(item()) as xs:boolean)
as item()*</p>
<p>Returns those items from the sequence <code>$input</code> for
which the supplied function <code>$predicate</code> returns
true.</p>
<h3><a name="floor" id="floor"></a>floor</h3>
<p><strong>floor</strong>(xs:numeric?) as xs:numeric?</p>
<p>Rounds <code>$value</code> downwards to a whole number.</p>
<h3><a name="fold-left" id="fold-left"></a>fold-left</h3>
<p><strong>fold-left</strong>(item()*, item()*, function(item()*,
item()) as item()*) as item()*</p>
<p>Processes the supplied sequence from left to right, applying the
supplied function repeatedly to each item in turn, together with an
accumulated result value.</p>
<h3><a name="fold-right" id="fold-right"></a>fold-right</h3>
<p><strong>fold-right</strong>(item()*, item()*, function(item(),
item()*) as item()*) as item()*</p>
<p>Processes the supplied sequence from right to left, applying the
supplied function repeatedly to each item in turn, together with an
accumulated result value.</p>
<h3><a name="foot" id="foot"></a>foot</h3>
<p><strong>foot</strong>(item()*) as item()?</p>
<p>Returns the last item in a sequence.</p>
<h3><a name="for-each" id="for-each"></a>for-each</h3>
<p><strong>for-each</strong>(item()*, function(item()) as item()*)
as item()*</p>
<p>Applies the function item <code>$action</code> to every item
from the sequence <var>$input</var> in turn, returning the
concatenation of the resulting sequences in order.</p>
<h3><a name="for-each-pair" id=
"for-each-pair"></a>for-each-pair</h3>
<p><strong>for-each-pair</strong>(item()*, item()*,
function(item(), item()) as item()*) as item()*</p>
<p>Applies the function item <code>$action</code> to successive
pairs of items taken one from <code>$input1</code> and one from
<code>$input2</code>, returning the concatenation of the resulting
sequences in order.</p>
<h3><a name="format-date" id="format-date"></a>format-date</h3>
<p><strong>format-date</strong>(xs:date?, xs:string) as
xs:string?</p>
<p><strong>format-date</strong>(xs:date?, xs:string, xs:string?,
xs:string?, xs:string?) as xs:string?</p>
<p>Returns a string containing an <code>xs:date</code> value
formatted for display.</p>
<h3><a name="format-dateTime" id=
"format-dateTime"></a>format-dateTime</h3>
<p><strong>format-dateTime</strong>(xs:dateTime?, xs:string) as
xs:string?</p>
<p><strong>format-dateTime</strong>(xs:dateTime?, xs:string,
xs:string?, xs:string?, xs:string?) as xs:string?</p>
<p>Returns a string containing an <code>xs:dateTime</code> value
formatted for display.</p>
<h3><a name="format-integer" id=
"format-integer"></a>format-integer</h3>
<p><strong>format-integer</strong>(xs:integer?, xs:string) as
xs:string</p>
<p><strong>format-integer</strong>(xs:integer?, xs:string,
xs:string?) as xs:string</p>
<p>Formats an integer according to a given picture string, using
the conventions of a given natural language if specified.</p>
<h3><a name="format-number" id=
"format-number"></a>format-number</h3>
<p><strong>format-number</strong>(xs:numeric?, xs:string) as
xs:string</p>
<p><strong>format-number</strong>(xs:numeric?, xs:string,
union(xs:string, xs:QName)?) as xs:string</p>
<p>Returns a string containing a number formatted according to a
given picture string, taking account of decimal formats specified
in the static context.</p>
<h3><a name="format-time" id="format-time"></a>format-time</h3>
<p><strong>format-time</strong>(xs:time?, xs:string) as
xs:string?</p>
<p><strong>format-time</strong>(xs:time?, xs:string, xs:string?,
xs:string?, xs:string?) as xs:string?</p>
<p>Returns a string containing an <code>xs:time</code> value
formatted for display.</p>
<h3><a name="function-arity" id=
"function-arity"></a>function-arity</h3>
<p><strong>function-arity</strong>(function(*)) as xs:integer</p>
<p>Returns the arity of the function identified by a function
item.</p>
<h3><a name="function-lookup" id=
"function-lookup"></a>function-lookup</h3>
<p><strong>function-lookup</strong>(xs:QName, xs:integer) as
function(*)?</p>
<p>Returns the function having a given name and arity, if there is
one.</p>
<h3><a name="function-name" id=
"function-name"></a>function-name</h3>
<p><strong>function-name</strong>(function(*)) as xs:QName?</p>
<p>Returns the name of the function identified by a function
item.</p>
<h3><a name="generate-id" id="generate-id"></a>generate-id</h3>
<p><strong>generate-id</strong>() as xs:string</p>
<p><strong>generate-id</strong>(node()?) as xs:string</p>
<p>This function returns a string that uniquely identifies a given
node.</p>
<h3><a name="has-children" id="has-children"></a>has-children</h3>
<p><strong>has-children</strong>() as xs:boolean</p>
<p><strong>has-children</strong>(node()?) as xs:boolean</p>
<p>Returns true if the supplied node has one or more child nodes
(of any kind).</p>
<h3><a name="head" id="head"></a>head</h3>
<p><strong>head</strong>(item()*) as item()?</p>
<p>Returns the first item in a sequence.</p>
<h3><a name="highest" id="highest"></a>highest</h3>
<p><strong>highest</strong>(item()*) as item()*</p>
<p><strong>highest</strong>(item()*, xs:string?) as item()*</p>
<p><strong>highest</strong>(item()*, xs:string?, function(item())
as xs:anyAtomicType*) as item()*</p>
<p>Returns those items from a supplied sequence that have the
highest value of a sort key, where the sort key can be computed
using a caller-supplied function.</p>
<h3><a name="hours-from-dateTime" id=
"hours-from-dateTime"></a>hours-from-dateTime</h3>
<p><strong>hours-from-dateTime</strong>(xs:dateTime?) as
xs:integer?</p>
<p>Returns the hours component of an <code>xs:dateTime</code>.</p>
<h3><a name="hours-from-duration" id=
"hours-from-duration"></a>hours-from-duration</h3>
<p><strong>hours-from-duration</strong>(xs:duration?) as
xs:integer?</p>
<p>Returns the number of hours in a duration.</p>
<h3><a name="hours-from-time" id=
"hours-from-time"></a>hours-from-time</h3>
<p><strong>hours-from-time</strong>(xs:time?) as xs:integer?</p>
<p>Returns the hours component of an <code>xs:time</code>.</p>
<h3><a name="id" id="id"></a>id</h3>
<p><strong>id</strong>(xs:string*) as element()*</p>
<p><strong>id</strong>(xs:string*, node()) as element()*</p>
<p>Returns the sequence of element nodes that have an
<code>ID</code> value matching the value of one or more of the
<code>IDREF</code> values supplied in <code>$values</code>.</p>
<h3><a name="identity" id="identity"></a>identity</h3>
<p><strong>identity</strong>(item()*) as item()*</p>
<p>Returns its argument value.</p>
<h3><a name="idref" id="idref"></a>idref</h3>
<p><strong>idref</strong>(xs:string*) as node()*</p>
<p><strong>idref</strong>(xs:string*, node()) as node()*</p>
<p>Returns the sequence of element or attribute nodes with an
<code>IDREF</code> value matching the value of one or more of the
<code>ID</code> values supplied in <code>$values</code>.</p>
<h3><a name="implicit-timezone" id=
"implicit-timezone"></a>implicit-timezone</h3>
<p><strong>implicit-timezone</strong>() as xs:dayTimeDuration</p>
<p>Returns the value of the implicit timezone property from the
dynamic context.</p>
<h3><a name="index-of" id="index-of"></a>index-of</h3>
<p><strong>index-of</strong>(xs:anyAtomicType*, xs:anyAtomicType)
as xs:integer*</p>
<p><strong>index-of</strong>(xs:anyAtomicType*, xs:anyAtomicType,
xs:string) as xs:integer*</p>
<p>Returns a sequence of positive integers giving the positions
within the sequence <code>$input</code> of items that are equal to
<code>$search</code>.</p>
<h3><a name="index-where" id="index-where"></a>index-where</h3>
<p><strong>index-where</strong>(item()*, function(item()) as
xs:boolean) as xs:integer*</p>
<p>Returns the position in an input sequence of items that match a
supplied predicate.</p>
<h3><a name="innermost" id="innermost"></a>innermost</h3>
<p><strong>innermost</strong>(node()*) as node()*</p>
<p>Returns every node within the input sequence that is not an
ancestor of another member of the input sequence; the nodes are
returned in document order with duplicates eliminated.</p>
<h3><a name="in-scope-namespaces" id=
"in-scope-namespaces"></a>in-scope-namespaces</h3>
<p><strong>in-scope-namespaces</strong>(element()) as
map(union(xs:NCName, enum('')), xs:anyURI)</p>
<p>Returns the in-scope namespaces of an element node, as a
map.</p>
<h3><a name="in-scope-prefixes" id=
"in-scope-prefixes"></a>in-scope-prefixes</h3>
<p><strong>in-scope-prefixes</strong>(element()) as xs:string*</p>
<p>Returns the prefixes of the in-scope namespaces for an element
node.</p>
<h3><a name="insert-before" id=
"insert-before"></a>insert-before</h3>
<p><strong>insert-before</strong>(item()*, xs:integer, item()*) as
item()*</p>
<p>Returns a sequence constructed by inserting an item or a
sequence of items at a given position within an existing
sequence.</p>
<h3><a name="intersperse" id="intersperse"></a>intersperse</h3>
<p><strong>intersperse</strong>(item()*, item()?) as item()*</p>
<p>Inserts a separator between adjacent items in a sequence.</p>
<h3><a name="iri-to-uri" id="iri-to-uri"></a>iri-to-uri</h3>
<p><strong>iri-to-uri</strong>(xs:string?) as xs:string</p>
<p>Converts a string containing an IRI into a URI according to the
rules of [rfc3987].</p>
<h3><a name="is-NaN" id="is-NaN"></a>is-NaN</h3>
<p><strong>is-NaN</strong>(xs:anyAtomicType) as xs:boolean</p>
<p>Returns true if the argument is the <code>xs:float</code> or
<code>xs:double</code> value NaN.</p>
<h3><a name="json" id="json"></a>json</h3>
<p><strong>json</strong>(item()*) as xs:string</p>
<p><strong>json</strong>(xs:string?, map(*)) as xs:string</p>
<p>Creates a JSON representation of an arbitrary XDM value.</p>
<h3><a name="json-doc" id="json-doc"></a>json-doc</h3>
<p><strong>json-doc</strong>(xs:string?) as item()?</p>
<p><strong>json-doc</strong>(xs:string?, map(*)) as item()?</p>
<p>Reads an external resource containing JSON, and returns the
result of parsing the resource as JSON.</p>
<h3><a name="json-to-xml" id="json-to-xml"></a>json-to-xml</h3>
<p><strong>json-to-xml</strong>(xs:string?) as document-node()?</p>
<p><strong>json-to-xml</strong>(xs:string?, map(*)) as
document-node()?</p>
<p>Parses a string supplied in the form of a JSON text, returning
the results in the form of an XML <span>document node</span>.</p>
<h3><a name="lang" id="lang"></a>lang</h3>
<p><strong>lang</strong>(xs:string?) as xs:boolean</p>
<p><strong>lang</strong>(xs:string?, node()) as xs:boolean</p>
<p>This function tests whether the language of <code>$node</code>,
or the context item if the second argument is omitted, as specified
by <code>xml:lang</code> attributes is the same as, or is a
sublanguage of, the language specified by
<code>$language</code>.</p>
<h3><a name="last" id="last"></a>last</h3>
<p><strong>last</strong>() as xs:integer</p>
<p>Returns the context size from the dynamic context.</p>
<h3><a name="load-xquery-module" id=
"load-xquery-module"></a>load-xquery-module</h3>
<p><strong>load-xquery-module</strong>(xs:string) as map(*)</p>
<p><strong>load-xquery-module</strong>(xs:string, map(*)) as
map(*)</p>
<p>Provides access to the public functions and global variables of
a dynamically-loaded XQuery library module.</p>
<h3><a name="local-name" id="local-name"></a>local-name</h3>
<p><strong>local-name</strong>() as xs:string</p>
<p><strong>local-name</strong>(node()?) as xs:string</p>
<p>Returns the local part of the name of <code>$node</code> as an
<code>xs:string</code> that is either the zero-length string, or
has the lexical form of an <code>xs:NCName</code>.</p>
<h3><a name="local-name-from-QName" id=
"local-name-from-QName"></a>local-name-from-QName</h3>
<p><strong>local-name-from-QName</strong>(xs:QName?) as
xs:NCName?</p>
<p>Returns the local part of the supplied QName.</p>
<h3><a name="lower-case" id="lower-case"></a>lower-case</h3>
<p><strong>lower-case</strong>(xs:string?) as xs:string</p>
<p>Converts a string to lower case.</p>
<h3><a name="lowest" id="lowest"></a>lowest</h3>
<p><strong>lowest</strong>(item()*) as item()*</p>
<p><strong>lowest</strong>(item()*, xs:string?) as item()*</p>
<p><strong>lowest</strong>(item()*, xs:string?, function(item()) as
xs:anyAtomicType*) as item()*</p>
<p>Returns those items from a supplied sequence that have the
lowest value of a sort key, where the sort key can be computed
using a caller-supplied function.</p>
<h3><a name="matches" id="matches"></a>matches</h3>
<p><strong>matches</strong>(xs:string?, xs:string) as
xs:boolean</p>
<p><strong>matches</strong>(xs:string?, xs:string, xs:string) as
xs:boolean</p>
<p>Returns true if the supplied string matches a given regular
expression.</p>
<h3><a name="max" id="max"></a>max</h3>
<p><strong>max</strong>(xs:anyAtomicType*) as xs:anyAtomicType?</p>
<p><strong>max</strong>(xs:anyAtomicType*, xs:string) as
xs:anyAtomicType?</p>
<p>Returns a value that is equal to the highest value appearing in
the input sequence.</p>
<h3><a name="min" id="min"></a>min</h3>
<p><strong>min</strong>(xs:anyAtomicType*) as xs:anyAtomicType?</p>
<p><strong>min</strong>(xs:anyAtomicType*, xs:string) as
xs:anyAtomicType?</p>
<p>Returns a value that is equal to the lowest value appearing in
the input sequence.</p>
<h3><a name="minutes-from-dateTime" id=
"minutes-from-dateTime"></a>minutes-from-dateTime</h3>
<p><strong>minutes-from-dateTime</strong>(xs:dateTime?) as
xs:integer?</p>
<p>Returns the minute component of an <code>xs:dateTime</code>.</p>
<h3><a name="minutes-from-duration" id=
"minutes-from-duration"></a>minutes-from-duration</h3>
<p><strong>minutes-from-duration</strong>(xs:duration?) as
xs:integer?</p>
<p>Returns the number of minutes in a duration.</p>
<h3><a name="minutes-from-time" id=
"minutes-from-time"></a>minutes-from-time</h3>
<p><strong>minutes-from-time</strong>(xs:time?) as xs:integer?</p>
<p>Returns the minutes component of an <code>xs:time</code>.</p>
<h3><a name="month-from-date" id=
"month-from-date"></a>month-from-date</h3>
<p><strong>month-from-date</strong>(xs:date?) as xs:integer?</p>
<p>Returns the month component of an <code>xs:date</code>.</p>
<h3><a name="month-from-dateTime" id=
"month-from-dateTime"></a>month-from-dateTime</h3>
<p><strong>month-from-dateTime</strong>(xs:dateTime?) as
xs:integer?</p>
<p>Returns the month component of an <code>xs:dateTime</code>.</p>
<h3><a name="months-from-duration" id=
"months-from-duration"></a>months-from-duration</h3>
<p><strong>months-from-duration</strong>(xs:duration?) as
xs:integer?</p>
<p>Returns the number of months in a duration.</p>
<h3><a name="name" id="name"></a>name</h3>
<p><strong>name</strong>() as xs:string</p>
<p><strong>name</strong>(node()?) as xs:string</p>
<p>Returns the name of a node, as an <code>xs:string</code> that is
either the zero-length string, or has the lexical form of an
<code>xs:QName</code>.</p>
<h3><a name="namespace-uri" id=
"namespace-uri"></a>namespace-uri</h3>
<p><strong>namespace-uri</strong>() as xs:anyURI</p>
<p><strong>namespace-uri</strong>(node()?) as xs:anyURI</p>
<p>Returns the namespace URI part of the name of
<code>$node</code>, as an <code>xs:anyURI</code> value.</p>
<h3><a name="namespace-uri-for-prefix" id=
"namespace-uri-for-prefix"></a>namespace-uri-for-prefix</h3>
<p><strong>namespace-uri-for-prefix</strong>(union(xs:NCName,
enum(''))?, element()) as xs:anyURI?</p>
<p>Returns the namespace URI of one of the in-scope namespaces for
<code>$element</code>, identified by its namespace prefix.</p>
<h3><a name="namespace-uri-from-QName" id=
"namespace-uri-from-QName"></a>namespace-uri-from-QName</h3>
<p><strong>namespace-uri-from-QName</strong>(xs:QName?) as
xs:anyURI?</p>
<p>Returns the namespace URI part of the supplied QName.</p>
<h3><a name="nilled" id="nilled"></a>nilled</h3>
<p><strong>nilled</strong>() as xs:boolean?</p>
<p><strong>nilled</strong>(node()?) as xs:boolean?</p>
<p>Returns true for an element that is <b>nilled</b>.</p>
<h3><a name="node-name" id="node-name"></a>node-name</h3>
<p><strong>node-name</strong>() as xs:QName?</p>
<p><strong>node-name</strong>(node()?) as xs:QName?</p>
<p>Returns the name of a node, as an <code>xs:QName</code>.</p>
<h3><a name="normalize-space" id=
"normalize-space"></a>normalize-space</h3>
<p><strong>normalize-space</strong>() as xs:string</p>
<p><strong>normalize-space</strong>(xs:string?) as xs:string</p>
<p>Returns <code>$value</code> with leading and trailing whitespace
removed, and sequences of internal whitespace reduced to a single
space character.</p>
<h3><a name="normalize-unicode" id=
"normalize-unicode"></a>normalize-unicode</h3>
<p><strong>normalize-unicode</strong>(xs:string?) as xs:string</p>
<p><strong>normalize-unicode</strong>(xs:string?, xs:string) as
xs:string</p>
<p>Returns <code>$value</code> after applying Unicode
normalization.</p>
<h3><a name="not" id="not"></a>not</h3>
<p><strong>not</strong>(item()*) as xs:boolean</p>
<p>Returns <code>true</code> if the effective boolean value of
<code>$input</code> is <code>false</code>, or <code>false</code> if
it is <code>true</code>.</p>
<h3><a name="number" id="number"></a>number</h3>
<p><strong>number</strong>() as xs:double</p>
<p><strong>number</strong>(xs:anyAtomicType?) as xs:double</p>
<p>Returns the value indicated by <code>$value</code> or, if
<code>$value</code> is not specified, the context item after
atomization, converted to an <code>xs:double</code>.</p>
<h3><a name="one-or-more" id="one-or-more"></a>one-or-more</h3>
<p><strong>one-or-more</strong>(item()*) as item()+</p>
<p>Returns <code>$input</code> if it contains one or more items.
Otherwise, raises an error.</p>
<h3><a name="outermost" id="outermost"></a>outermost</h3>
<p><strong>outermost</strong>(node()*) as node()*</p>
<p>Returns every node within the input sequence that has no
ancestor that is itself a member of the input sequence; the nodes
are returned in document order with duplicates eliminated.</p>
<h3><a name="parse-ietf-date" id=
"parse-ietf-date"></a>parse-ietf-date</h3>
<p><strong>parse-ietf-date</strong>(xs:string?) as xs:dateTime?</p>
<p>Parses a string containing the date and time in IETF format,
returning the corresponding <code>xs:dateTime</code> value.</p>
<h3><a name="parse-json" id="parse-json"></a>parse-json</h3>
<p><strong>parse-json</strong>(xs:string?) as item()?</p>
<p><strong>parse-json</strong>(xs:string?, map(*)) as item()?</p>
<p>Parses a string supplied in the form of a JSON text, returning
the results typically in the form of a map or array.</p>
<h3><a name="parse-xml" id="parse-xml"></a>parse-xml</h3>
<p><strong>parse-xml</strong>(xs:string?) as
document-node(element(*))?</p>
<p>This function takes as input an XML document represented as a
string, and returns the document node at the root of an XDM tree
representing the parsed document.</p>
<h3><a name="parse-xml-fragment" id=
"parse-xml-fragment"></a>parse-xml-fragment</h3>
<p><strong>parse-xml-fragment</strong>(xs:string?) as
document-node()?</p>
<p>This function takes as input an XML external entity represented
as a string, and returns the document node at the root of an XDM
tree representing the parsed document fragment.</p>
<h3><a name="parts" id="parts"></a>parts</h3>
<p><strong>parts</strong>() as map(xs:string, item()*)</p>
<p>Returns the components of an atomic value, as a map.</p>
<h3><a name="path" id="path"></a>path</h3>
<p><strong>path</strong>() as xs:string?</p>
<p><strong>path</strong>(node()?) as xs:string?</p>
<p>Returns a path expression that can be used to select the
supplied node relative to the root of its containing document.</p>
<h3><a name="position" id="position"></a>position</h3>
<p><strong>position</strong>() as xs:integer</p>
<p>Returns the context position from the dynamic context.</p>
<h3><a name="prefix-from-QName" id=
"prefix-from-QName"></a>prefix-from-QName</h3>
<p><strong>prefix-from-QName</strong>(xs:QName?) as xs:NCName?</p>
<p>Returns the prefix component of the supplied QName.</p>
<h3><a name="QName" id="QName"></a>QName</h3>
<p><strong>QName</strong>(xs:string?, xs:string) as xs:QName</p>
<p>Returns an <code>xs:QName</code> value formed using a supplied
namespace URI and lexical QName.</p>
<h3><a name="random-number-generator" id=
"random-number-generator"></a>random-number-generator</h3>
<p><strong>random-number-generator</strong>() as item-type(rng)</p>
<p><strong>random-number-generator</strong>(xs:anyAtomicType?) as
item-type(rng)</p>
<p>Returns a random number generator, which can be used to generate
sequences of random numbers.</p>
<h3><a name="range-from" id="range-from"></a>range-from</h3>
<p><strong>range-from</strong>(item()*, (function(item()) as
xs:boolean)) as item()*</p>
<p>Returns a sequence containing items from an input sequence,
starting with the first item that matches a supplied predicate.</p>
<h3><a name="range-to" id="range-to"></a>range-to</h3>
<p><strong>range-to</strong>(item()*, (function(item()) as
xs:boolean)) as item()*</p>
<p>Returns a sequence containing items from an input sequence,
ending with the first item that matches a supplied predicate.</p>
<h3><a name="remove" id="remove"></a>remove</h3>
<p><strong>remove</strong>(item()*, xs:integer) as item()*</p>
<p>Returns a new sequence containing all the items of
<code>$input</code> except the item at position
<code>$position</code>.</p>
<h3><a name="replace" id="replace"></a>replace</h3>
<p><strong>replace</strong>(xs:string?, xs:string, xs:string?,
xs:string?, (function(xs:string, xs:string*) as xs:string?)?) as
xs:string</p>
<p>Returns a string produced from the input string by replacing any
substrings that match a given regular expression with a supplied
replacement string<span>, provided either literally, or by invoking
a supplied function.</span></p>
<h3><a name="replicate" id="replicate"></a>replicate</h3>
<p><strong>replicate</strong>(item()*, xs:nonNegativeInteger) as
item()*</p>
<p>Produces multiple copies of a sequence.</p>
<h3><a name="resolve-QName" id=
"resolve-QName"></a>resolve-QName</h3>
<p><strong>resolve-QName</strong>(xs:string?, element()) as
xs:QName?</p>
<p>Returns an <code>xs:QName</code> value (that is, an
expanded-QName) by taking an <code>xs:string</code> that has the
lexical form of an <code>xs:QName</code> (a string in the form
"prefix:local-name" or "local-name") and resolving it using the
in-scope namespaces for a given element.</p>
<h3><a name="resolve-uri" id="resolve-uri"></a>resolve-uri</h3>
<p><strong>resolve-uri</strong>(xs:string?) as xs:anyURI?</p>
<p><strong>resolve-uri</strong>(xs:string?, xs:string) as
xs:anyURI?</p>
<p>Resolves a relative IRI reference against an absolute IRI.</p>
<h3><a name="reverse" id="reverse"></a>reverse</h3>
<p><strong>reverse</strong>(item()*) as item()*</p>
<p>Reverses the order of items in a sequence.</p>
<h3><a name="root" id="root"></a>root</h3>
<p><strong>root</strong>() as node()</p>
<p><strong>root</strong>(node()?) as node()?</p>
<p>Returns the root of the tree to which <code>$node</code>
belongs. This will usually, but not necessarily, be a document
node.</p>
<h3><a name="round" id="round"></a>round</h3>
<p><strong>round</strong>(xs:numeric?) as xs:numeric?</p>
<p><strong>round</strong>(xs:numeric?, xs:integer) as
xs:numeric?</p>
<p>Rounds a value to a specified number of decimal places, rounding
upwards if two such values are equally near.</p>
<h3><a name="round-half-to-even" id=
"round-half-to-even"></a>round-half-to-even</h3>
<p><strong>round-half-to-even</strong>(xs:numeric?) as
xs:numeric?</p>
<p><strong>round-half-to-even</strong>(xs:numeric?, xs:integer) as
xs:numeric?</p>
<p>Rounds a value to a specified number of decimal places, rounding
to make the last digit even if two such values are equally
near.</p>
<h3><a name="seconds-from-dateTime" id=
"seconds-from-dateTime"></a>seconds-from-dateTime</h3>
<p><strong>seconds-from-dateTime</strong>(xs:dateTime?) as
xs:decimal?</p>
<p>Returns the seconds component of an
<code>xs:dateTime</code>.</p>
<h3><a name="seconds-from-duration" id=
"seconds-from-duration"></a>seconds-from-duration</h3>
<p><strong>seconds-from-duration</strong>(xs:duration?) as
xs:decimal?</p>
<p>Returns the number of seconds in a duration.</p>
<h3><a name="seconds-from-time" id=
"seconds-from-time"></a>seconds-from-time</h3>
<p><strong>seconds-from-time</strong>(xs:time?) as xs:decimal?</p>
<p>Returns the seconds component of an <code>xs:time</code>.</p>
<h3><a name="serialize" id="serialize"></a>serialize</h3>
<p><strong>serialize</strong>(item()*) as xs:string</p>
<p><strong>serialize</strong>(item()*, item()?) as xs:string</p>
<p>This function serializes the supplied input sequence
<code>$input</code> as described in [xslt-xquery-serialization-31],
returning the serialized representation of the sequence as a
string.</p>
<h3><a name="slice" id="slice"></a>slice</h3>
<p><strong>slice</strong>(item()*, xs:integer?, xs:integer?,
xs:integer?) as item()*</p>
<p>Returns a sequence containing selected items from a supplied
input sequence based on their position.</p>
<h3><a name="some" id="some"></a>some</h3>
<p><strong>some</strong>(item()*, function(item()) as xs:boolean)
as xs:integer*</p>
<p>Returns true if at least one item in the input sequence matches
a supplied predicate.</p>
<h3><a name="sort" id="sort"></a>sort</h3>
<p><strong>sort</strong>(item()*) as item()*</p>
<p><strong>sort</strong>(item()*, xs:string?) as item()*</p>
<p><strong>sort</strong>(item()*, xs:string?, function(item()) as
xs:anyAtomicType*) as item()*</p>
<p>Sorts a supplied sequence, based on the value of a sort key
supplied as a function.</p>
<h3><a name="stack-trace" id="stack-trace"></a>stack-trace</h3>
<p><strong>stack-trace</strong>() as xs:string</p>
<p>Returns implementation-dependent information about the current
state of execution.</p>
<h3><a name="starts-with" id="starts-with"></a>starts-with</h3>
<p><strong>starts-with</strong>(xs:string?, xs:string?) as
xs:boolean</p>
<p><strong>starts-with</strong>(xs:string?, xs:string?, xs:string)
as xs:boolean</p>
<p>Returns true if the string <code>$value</code> contains
<code>$substring</code> as a leading substring, taking collations
into account.</p>
<h3><a name="static-base-uri" id=
"static-base-uri"></a>static-base-uri</h3>
<p><strong>static-base-uri</strong>() as xs:anyURI?</p>
<p>This function returns the value of the <b>static base URI</b>
property from the static context.</p>
<h3><a name="string" id="string"></a>string</h3>
<p><strong>string</strong>() as xs:string</p>
<p><strong>string</strong>(item()?) as xs:string</p>
<p>Returns the value of <code>$item</code> represented as an
<code>xs:string</code>.</p>
<h3><a name="string-join" id="string-join"></a>string-join</h3>
<p><strong>string-join</strong>(xs:anyAtomicType*) as xs:string</p>
<p><strong>string-join</strong>(xs:anyAtomicType*, xs:string) as
xs:string</p>
<p>Returns a string created by concatenating the items in a
sequence, with a defined separator between adjacent items.</p>
<h3><a name="string-length" id=
"string-length"></a>string-length</h3>
<p><strong>string-length</strong>() as xs:integer</p>
<p><strong>string-length</strong>(xs:string?) as xs:integer</p>
<p>Returns the number of characters in a string.</p>
<h3><a name="string-to-codepoints" id=
"string-to-codepoints"></a>string-to-codepoints</h3>
<p><strong>string-to-codepoints</strong>(xs:string?) as
xs:integer*</p>
<p>Returns the sequence of codepoints that constitute an
<code>xs:string</code> value.</p>
<h3><a name="subsequence" id="subsequence"></a>subsequence</h3>
<p><strong>subsequence</strong>(item()*, xs:double) as item()*</p>
<p><strong>subsequence</strong>(item()*, xs:double, xs:double) as
item()*</p>
<p>Returns the contiguous sequence of items in <code>$input</code>
beginning at the position indicated by <code>$start</code> and
continuing for the number of items indicated by
<code>$length</code>.</p>
<h3><a name="substring" id="substring"></a>substring</h3>
<p><strong>substring</strong>(xs:string?, xs:double) as
xs:string</p>
<p><strong>substring</strong>(xs:string?, xs:double, xs:double) as
xs:string</p>
<p>Returns the part of <code>$value</code> beginning at the
position indicated by <code>$start</code> and continuing for the
number of characters indicated by <code>$length</code>.</p>
<h3><a name="substring-after" id=
"substring-after"></a>substring-after</h3>
<p><strong>substring-after</strong>(xs:string?, xs:string?) as
xs:string</p>
<p><strong>substring-after</strong>(xs:string?, xs:string?,
xs:string) as xs:string</p>
<p>Returns the part of <code>$value</code> that follows the first
occurrence of <code>$substring</code>, taking collations into
account.</p>
<h3><a name="substring-before" id=
"substring-before"></a>substring-before</h3>
<p><strong>substring-before</strong>(xs:string?, xs:string?) as
xs:string</p>
<p><strong>substring-before</strong>(xs:string?, xs:string?,
xs:string) as xs:string</p>
<p>Returns the part of <code>$value</code> that precedes the first
occurrence of <code>$substring</code>, taking collations into
account.</p>
<h3><a name="sum" id="sum"></a>sum</h3>
<p><strong>sum</strong>(xs:anyAtomicType*) as xs:anyAtomicType</p>
<p><strong>sum</strong>(xs:anyAtomicType*, xs:anyAtomicType?) as
xs:anyAtomicType?</p>
<p>Returns a value obtained by adding together the values in
<code>$values</code>.</p>
<h3><a name="tail" id="tail"></a>tail</h3>
<p><strong>tail</strong>(item()*) as item()*</p>
<p>Returns all but the first item in a sequence.</p>
<h3><a name="timezone-from-date" id=
"timezone-from-date"></a>timezone-from-date</h3>
<p><strong>timezone-from-date</strong>(xs:date?) as
xs:dayTimeDuration?</p>
<p>Returns the timezone component of an <code>xs:date</code>.</p>
<h3><a name="timezone-from-dateTime" id=
"timezone-from-dateTime"></a>timezone-from-dateTime</h3>
<p><strong>timezone-from-dateTime</strong>(xs:dateTime?) as
xs:dayTimeDuration?</p>
<p>Returns the timezone component of an
<code>xs:dateTime</code>.</p>
<h3><a name="timezone-from-time" id=
"timezone-from-time"></a>timezone-from-time</h3>
<p><strong>timezone-from-time</strong>(xs:time?) as
xs:dayTimeDuration?</p>
<p>Returns the timezone component of an <code>xs:time</code>.</p>
<h3><a name="tokenize" id="tokenize"></a>tokenize</h3>
<p><strong>tokenize</strong>(xs:string?) as xs:string*</p>
<p><strong>tokenize</strong>(xs:string?, xs:string) as
xs:string*</p>
<p><strong>tokenize</strong>(xs:string?, xs:string, xs:string) as
xs:string*</p>
<p>Returns a sequence of strings constructed by splitting the input
wherever a separator is found; the separator is any substring that
matches a given regular expression.</p>
<h3><a name="trace" id="trace"></a>trace</h3>
<p><strong>trace</strong>(item()*) as item()*</p>
<p><strong>trace</strong>(item()*, xs:string) as item()*</p>
<p>Provides an execution trace intended to be used in debugging
queries.</p>
<h3><a name="transform" id="transform"></a>transform</h3>
<p><strong>transform</strong>(map(*)) as map(*)</p>
<p>Invokes a transformation using a dynamically-loaded XSLT
stylesheet.</p>
<h3><a name="translate" id="translate"></a>translate</h3>
<p><strong>translate</strong>(xs:string?, xs:string, xs:string) as
xs:string</p>
<p>Returns <code>$value</code> modified by replacing or removing
individual characters.</p>
<h3><a name="true" id="true"></a>true</h3>
<p><strong>true</strong>() as xs:boolean</p>
<p>Returns the <code>xs:boolean</code> value <code>true</code>.</p>
<h3><a name="truncate" id="truncate"></a>truncate</h3>
<p><strong>truncate</strong>(item()*) as item()?</p>
<p>Returns all but the last item in a sequence.</p>
<h3><a name="uniform" id="uniform"></a>uniform</h3>
<p><strong>uniform</strong>(xs:anyAtomicType*) as xs:boolean</p>
<p><strong>uniform</strong>(xs:anyAtomicType*, xs:string) as
xs:boolean</p>
<p>Returns true if all items in a supplied sequence (after
atomization) are equal.</p>
<h3><a name="unique" id="unique"></a>unique</h3>
<p><strong>unique</strong>(xs:anyAtomicType**) as xs:boolean</p>
<p><strong>unique</strong>(xs:anyAtomicType**, xs:string) as
xs:boolean</p>
<p>Returns true if all items in a supplied sequence are
distinct.</p>
<h3><a name="unordered" id="unordered"></a>unordered</h3>
<p><strong>unordered</strong>(item()*) as item()*</p>
<p>Returns the items of <code>$input</code> in an
implementation-dependent order.</p>
<h3><a name="unparsed-text" id=
"unparsed-text"></a>unparsed-text</h3>
<p><strong>unparsed-text</strong>(xs:string?) as xs:string?</p>
<p><strong>unparsed-text</strong>(xs:string?, xs:string) as
xs:string?</p>
<p>The <code>fn:unparsed-text</code> function reads an external
resource (for example, a file) and returns a string representation
of the resource.</p>
<h3><a name="unparsed-text-available" id=
"unparsed-text-available"></a>unparsed-text-available</h3>
<p><strong>unparsed-text-available</strong>(xs:string?) as
xs:boolean</p>
<p><strong>unparsed-text-available</strong>(xs:string?, xs:string)
as xs:boolean</p>
<p>Because errors in evaluating the <code>fn:unparsed-text</code>
function are non-recoverable, these two functions are provided to
allow an application to determine whether a call with particular
arguments would succeed.</p>
<h3><a name="unparsed-text-lines" id=
"unparsed-text-lines"></a>unparsed-text-lines</h3>
<p><strong>unparsed-text-lines</strong>(xs:string?) as
xs:string*</p>
<p><strong>unparsed-text-lines</strong>(xs:string?, xs:string) as
xs:string*</p>
<p>The <code>fn:unparsed-text-lines</code> function reads an
external resource (for example, a file) and returns its contents as
a sequence of strings, one for each line of text in the string
representation of the resource.</p>
<h3><a name="upper-case" id="upper-case"></a>upper-case</h3>
<p><strong>upper-case</strong>(xs:string?) as xs:string</p>
<p>Converts a string to upper case.</p>
<h3><a name="uri-collection" id=
"uri-collection"></a>uri-collection</h3>
<p><strong>uri-collection</strong>() as xs:anyURI*</p>
<p><strong>uri-collection</strong>(xs:string?) as xs:anyURI*</p>
<p>Returns a sequence of <code>xs:anyURI</code> values representing
the URIs in a URI collection.</p>
<h3><a name="xml-to-json" id="xml-to-json"></a>xml-to-json</h3>
<p><strong>xml-to-json</strong>(node()?) as xs:string?</p>
<p><strong>xml-to-json</strong>(node()?, map(*)) as xs:string?</p>
<p>Converts an XML tree, whose format corresponds to the XML
representation of JSON defined in this specification, into a string
conforming to the JSON grammar.</p>
<h3><a name="year-from-date" id=
"year-from-date"></a>year-from-date</h3>
<p><strong>year-from-date</strong>(xs:date?) as xs:integer?</p>
<p>Returns the year component of an <code>xs:date</code>.</p>
<h3><a name="year-from-dateTime" id=
"year-from-dateTime"></a>year-from-dateTime</h3>
<p><strong>year-from-dateTime</strong>(xs:dateTime?) as
xs:integer?</p>
<p>Returns the year component of an <code>xs:dateTime</code>.</p>
<h3><a name="years-from-duration" id=
"years-from-duration"></a>years-from-duration</h3>
<p><strong>years-from-duration</strong>(xs:duration?) as
xs:integer?</p>
<p>Returns the number of years in a duration.</p>
<h3><a name="zero-or-one" id="zero-or-one"></a>zero-or-one</h3>
<p><strong>zero-or-one</strong>(item()*) as item()?</p>
<p>Returns <code>input</code> if it contains zero or one items.
Otherwise, raises an error.</p>
</div>
<div class="resource">
<h2><a id="xslt-summary" name="xslt-summary"></a>3 XSL
Transformations (XSLT) Functions</h2>
<p>This section lists all of the functions in this namespace that
are defined in the [XSLT 3.0] specification.</p>
<p>The normative definitions of these functions are in the [XSLT
3.0] specification. For convenience, a very brief, non-normative
summary of each function is provided. For details, follow the link
on the “Summary:” introductory text below each function.</p>
<p><em>Note that XSLT 3.0, because it is not dependent on XPath
3.1, also reproduces some of the functions specifications that
appear in XPath 3.1. For an XSLT 3.0 processor that works with
XPath 3.0, the normative specification in this case is the one that
appears in the XSLT 3.0 specification.</em></p>
<h3><a name="accumulator-after" id=
"accumulator-after"></a>accumulator-after</h3>
<p><strong>accumulator-after</strong>(union(xs:QName, xs:string))
as item()*</p>
<p>Returns the post-descent value of the selected accumulator at
the context node.</p>
<h3><a name="accumulator-before" id=
"accumulator-before"></a>accumulator-before</h3>
<p><strong>accumulator-before</strong>(union(xs:QName, xs:string))
as item()*</p>
<p>Returns the pre-descent value of the selected accumulator at the
context node.</p>
<h3><a name="available-system-properties" id=
"available-system-properties"></a>available-system-properties</h3>
<p><strong>available-system-properties</strong>() as xs:QName*</p>
<p>Returns a list of system property names that are suitable for
passing to the <code>system-property</code> function, as a sequence
of QNames.</p>
<h3><a name="copy-of" id="copy-of"></a>copy-of</h3>
<p><strong>copy-of</strong>() as item()</p>
<p><strong>copy-of</strong>(item()*) as item()*</p>
<p>Returns a deep copy of the sequence supplied as the
<code>$input</code> argument, or of the context item if the
argument is absent.</p>
<h3><a name="current" id="current"></a>current</h3>
<p><strong>current</strong>() as item()</p>
<p>Returns the item that is the context item for the evaluation of
the containing XPath expression</p>
<h3><a name="current-group" id=
"current-group"></a>current-group</h3>
<p><strong>current-group</strong>() as item()*</p>
<p>Returns the group currently being processed by an
<code>xsl:for-each-group</code> instruction.</p>
<h3><a name="current-grouping-key" id=
"current-grouping-key"></a>current-grouping-key</h3>
<p><strong>current-grouping-key</strong>() as xs:anyAtomicType*</p>
<p>Returns the grouping key of the group currently being processed
using the <code>xsl:for-each-group</code> instruction.</p>
<h3><a name="current-merge-group" id=
"current-merge-group"></a>current-merge-group</h3>
<p><strong>current-merge-group</strong>() as item()*</p>
<p><strong>current-merge-group</strong>(xs:string) as item()*</p>
<p>Returns the group of items currently being processed by an
<code>xsl:merge</code> instruction.</p>
<h3><a name="current-merge-key" id=
"current-merge-key"></a>current-merge-key</h3>
<p><strong>current-merge-key</strong>() as xs:anyAtomicType*</p>
<p>Returns the merge key of the merge group currently being
processed using the <code>xsl:merge</code> instruction.</p>
<h3><a name="current-mode" id="current-mode"></a>current-mode</h3>
<p><strong>current-mode</strong>() as xs:QName?</p>
<p>Returns the value of the .</p>
<h3><a name="current-output-uri" id=
"current-output-uri"></a>current-output-uri</h3>
<p><strong>current-output-uri</strong>() as xs:anyURI?</p>
<p>Returns the value of the .</p>
<h3><a name="document" id="document"></a>document</h3>
<p><strong>document</strong>(item()*) as node()*</p>
<p><strong>document</strong>(item()*, node()) as node()*</p>
<p>Provides access to XML documents identified by a URI.</p>
<h3><a name="element-available" id=
"element-available"></a>element-available</h3>
<p><strong>element-available</strong>(union(xs:QName, xs:string))
as xs:boolean</p>
<p>Determines whether a particular instruction is or is not
available for use. The function is particularly useful for calling
within an <code>[xsl:]use-when</code> attribute (see ) to test
whether a particular is available.</p>
<h3><a name="function-available" id=
"function-available"></a>function-available</h3>
<p><strong>function-available</strong>(union(xs:QName, xs:string))
as xs:boolean</p>
<p><strong>function-available</strong>(union(xs:QName, xs:string),
xs:integer) as xs:boolean</p>
<p>Determines whether a particular function is or is not available
for use. The function is particularly useful for calling within an
<code>[xsl:]use-when</code> attribute (see ) to test whether a
particular is available.</p>
<h3><a name="key" id="key"></a>key</h3>
<p><strong>key</strong>(union(xs:string, xs:QName),
xs:anyAtomicType*) as node()*</p>
<p><strong>key</strong>(union(xs:string, xs:QName),
xs:anyAtomicType*, node()) as node()*</p>
<p>Returns the nodes that match a supplied key value.</p>
<h3><a name="regex-group" id="regex-group"></a>regex-group</h3>
<p><strong>regex-group</strong>(xs:integer) as xs:string</p>
<p>Returns the string captured by a parenthesized subexpression of
the regular expression used during evaluation of the
<code>xsl:analyze-string</code> instruction.</p>
<h3><a name="snapshot" id="snapshot"></a>snapshot</h3>
<p><strong>snapshot</strong>() as item()</p>
<p><strong>snapshot</strong>(item()*) as item()*</p>
<p>Returns a copy of a sequence, retaining copies of the ancestors
and descendants of any node in the input sequence, together with
their attributes and namespaces.</p>
<h3><a name="stream-available" id=
"stream-available"></a>stream-available</h3>
<p><strong>stream-available</strong>(xs:string?) as xs:boolean</p>
<p>Determines, as far as possible, whether a document is available
for streamed processing using <code>xsl:source-document</code>.</p>
<h3><a name="system-property" id=
"system-property"></a>system-property</h3>
<p><strong>system-property</strong>(union(xs:QName, xs:string)) as
xs:string</p>
<p>Returns the value of a system property</p>
<h3><a name="type-available" id=
"type-available"></a>type-available</h3>
<p><strong>type-available</strong>(union(xs:QName, xs:string)) as
xs:boolean</p>
<p>Used to control how a stylesheet behaves if a particular schema
type is or is not available in the static context.</p>
<h3><a name="unparsed-entity-public-id" id=
"unparsed-entity-public-id"></a>unparsed-entity-public-id</h3>
<p><strong>unparsed-entity-public-id</strong>(xs:string) as
xs:string</p>
<p><strong>unparsed-entity-public-id</strong>(xs:string, node()) as
xs:string</p>
<p>Returns the public identifier of an unparsed entity</p>
<h3><a name="unparsed-entity-uri" id=
"unparsed-entity-uri"></a>unparsed-entity-uri</h3>
<p><strong>unparsed-entity-uri</strong>(xs:string) as xs:anyURI</p>
<p><strong>unparsed-entity-uri</strong>(xs:string, node()) as
xs:anyURI</p>
<p>Returns the URI (system identifier) of an unparsed entity</p>
</div>
<div class="resource">
<h2><a id="xqupdate-summary" name="xqupdate-summary"></a>4 XQuery
Update Functions</h2>
<p>This section lists all of the functions in this namespace that
are defined in the [XQuery Update 1.0] specification.</p>
<p>The normative definitions of these functions are in the [XQuery
Update 1.0] specification. For convenience, a very brief,
non-normative summary of each function is provided. For details,
follow the link on the “Summary:” introductory text below each
function.</p>
<h3><a name="put" id="put"></a>put</h3>
<p><strong>put</strong>(node(), xs:string) as empty-sequence()</p>
<p>Stores a document or element to the location specified by
<code>$uri</code>. This function is normally invoked to create a
resource on an external storage system such as a file system or a
database.</p>
<p>The external effects of <code>fn:put</code> are
implementation-defined, since they occur outside the domain of
XQuery. The intent is that, if <code>fn:put</code> is invoked on a
document node and no error is raised, a subsequent query can access
the stored document by invoking <code>fn:doc</code> with the same
URI.</p>
</div>
<div class="resource">
<h2><a id="schemas" name="schemas"></a>5 XML Schema</h2>
<p>Two functions, <code>fn:analyze-string</code> and
<code>fn:json-to-xml</code>, return results that are always valid
according to a defined XSD schema. A third function,
<code>fn:xml-to-json</code>, requires input that is valid according
to this schema.</p>
<p>The target namespace of these schema components is
<code>http://www.w3.org/2005/xpath-functions</code>.</p>
<p>The schema components are defined in a schema document located
at <a href=
"https://www.w3.org/TR/xpath-functions-31/xpath-functions.xsd">https://www.w3.org/TR/xpath-functions-31/xpath-functions.xsd</a>.</p>
</div>
<div>
<h2><a id="normrefs" name="normrefs"></a>6 Normative
References</h2>
<p>These documents describe the names that are defined in this
namespace at the time of publication. The W3C reserves the right to
define additional names in this namespace in the future.</p>
<dl>
<dt class="label"><span><a name="xpath-functions-31" id=
"xpath-functions-31"></a>XPath and XQuery Functions and Operators
3.1</span></dt>
<dd>
<div class="resource">
<p><a href="https://www.w3.org/TR/xpath-functions-31/">XQuery and
XPath Functions and Operators 3.1</a> (21 March 2017 version)</p>
</div>
</dd>
<dt class="label"><span><a name="xslt-30" id="xslt-30"></a>XSLT
3.0</span></dt>
<dd>
<div class="resource">
<p><a href="https://www.w3.org/TR/xslt-30/">XSL Transformations
(XSLT) Version 3.0</a> (7 February 2017 version)</p>
</div>
</dd>
<dt class="label"><span><a name="xquery-update-10" id=
"xquery-update-10"></a>XQuery Update 1.0</span></dt>
<dd>
<div class="resource">
<p><a href="https://www.w3.org/TR/xquery-update-10/">XQuery Update
Facility 1.0</a> (25 January 2011 version)</p>
</div>
</dd>
</dl>
</div>
<div>
<h2><a id="nonnormrefs" name="nonnormrefs"></a>7 Non-Normative
References</h2>
<dl>
<dt class="label"><span><a name="rddl-ref" id=
"rddl-ref"></a>Resource Directory Description Language
(RDDL)</span></dt>
<dd>
<div class="resource">
<p><a href="http://www.rddl.org/">Resource Directory Description
Language (RDDL)</a> (4 July 2007)</p>
</div>
</dd>
<dt class="label"><span><a name="grddl-ref" id=
"grddl-ref"></a>Gleaning Resource Descriptions from Dialects of
Languages (GRDDL)</span></dt>
<dd>
<div class="resource">
<p><a href="http://www.w3.org/TR/grddl/">Gleaning Resource
Descriptions from Dialects of Languages (GRDDL)</a> (Recommendation
of 11 September 2007)</p>
</div>
</dd>
<dt class="label"><span><a name="rdf-ref" id="rdf-ref"></a>Resource
Description Framework (RDF): Concepts and Abstract
Syntax</span></dt>
<dd>
<div class="resource">
<p><a href="http://www.w3.org/TR/rdf-concepts/">Resource
Description Framework (RDF): Concepts and Abstract Syntax</a>
(Recommendation of 10 February 2004)</p>
</div>
</dd>
</dl>
</div>
</div>
<script src="//www.w3.org/scripts/TR/2016/fixup.js"></script>
</body>
</html>
